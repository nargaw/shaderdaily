/*! For license information please see main.22c5af3d.js.LICENSE.txt */
!function(){var n={345:function(n,e){"use strict";function t(n,e){var t=n.length;n.push(e);n:for(;0<t;){var r=t-1>>>1,o=n[r];if(!(0<a(o,e)))break n;n[r]=e,n[t]=o,t=r}}function r(n){return 0===n.length?null:n[0]}function o(n){if(0===n.length)return null;var e=n[0],t=n.pop();if(t!==e){n[0]=t;n:for(var r=0,o=n.length,i=o>>>1;r<i;){var v=2*(r+1)-1,c=n[v],l=v+1,s=n[l];if(0>a(c,t))l<o&&0>a(s,c)?(n[r]=s,n[l]=t,r=l):(n[r]=c,n[v]=t,r=v);else{if(!(l<o&&0>a(s,t)))break n;n[r]=s,n[l]=t,r=l}}}return e}function a(n,e){var t=n.sortIndex-e.sortIndex;return 0!==t?t:n.id-e.id}if("object"===typeof performance&&"function"===typeof performance.now){var i=performance;e.unstable_now=function(){return i.now()}}else{var v=Date,c=v.now();e.unstable_now=function(){return v.now()-c}}var l=[],s=[],u=1,f=null,p=3,d=!1,m=!1,h=!1,x="function"===typeof setTimeout?setTimeout:null,g="function"===typeof clearTimeout?clearTimeout:null,y="undefined"!==typeof setImmediate?setImmediate:null;function b(n){for(var e=r(s);null!==e;){if(null===e.callback)o(s);else{if(!(e.startTime<=n))break;o(s),e.sortIndex=e.expirationTime,t(l,e)}e=r(s)}}function _(n){if(h=!1,b(n),!m)if(null!==r(l))m=!0,j(U);else{var e=r(s);null!==e&&F(_,e.startTime-n)}}function U(n,t){m=!1,h&&(h=!1,g(M),M=-1),d=!0;var a=p;try{for(b(t),f=r(l);null!==f&&(!(f.expirationTime>t)||n&&!T());){var i=f.callback;if("function"===typeof i){f.callback=null,p=f.priorityLevel;var v=i(f.expirationTime<=t);t=e.unstable_now(),"function"===typeof v?f.callback=v:f===r(l)&&o(l),b(t)}else o(l);f=r(l)}if(null!==f)var c=!0;else{var u=r(s);null!==u&&F(_,u.startTime-t),c=!1}return c}finally{f=null,p=a,d=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var w,S=!1,k=null,M=-1,z=5,C=-1;function T(){return!(e.unstable_now()-C<z)}function R(){if(null!==k){var n=e.unstable_now();C=n;var t=!0;try{t=k(!0,n)}finally{t?w():(S=!1,k=null)}}else S=!1}if("function"===typeof y)w=function(){y(R)};else if("undefined"!==typeof MessageChannel){var D=new MessageChannel,P=D.port2;D.port1.onmessage=R,w=function(){P.postMessage(null)}}else w=function(){x(R,0)};function j(n){k=n,S||(S=!0,w())}function F(n,t){M=x((function(){n(e.unstable_now())}),t)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(n){n.callback=null},e.unstable_continueExecution=function(){m||d||(m=!0,j(U))},e.unstable_forceFrameRate=function(n){0>n||125<n?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):z=0<n?Math.floor(1e3/n):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return r(l)},e.unstable_next=function(n){switch(p){case 1:case 2:case 3:var e=3;break;default:e=p}var t=p;p=e;try{return n()}finally{p=t}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(n,e){switch(n){case 1:case 2:case 3:case 4:case 5:break;default:n=3}var t=p;p=n;try{return e()}finally{p=t}},e.unstable_scheduleCallback=function(n,o,a){var i=e.unstable_now();switch("object"===typeof a&&null!==a?a="number"===typeof(a=a.delay)&&0<a?i+a:i:a=i,n){case 1:var v=-1;break;case 2:v=250;break;case 5:v=1073741823;break;case 4:v=1e4;break;default:v=5e3}return n={id:u++,callback:o,priorityLevel:n,startTime:a,expirationTime:v=a+v,sortIndex:-1},a>i?(n.sortIndex=a,t(s,n),null===r(l)&&n===r(s)&&(h?(g(M),M=-1):h=!0,F(_,a-i))):(n.sortIndex=v,t(l,n),m||d||(m=!0,j(U))),n},e.unstable_shouldYield=T,e.unstable_wrapCallback=function(n){var e=p;return function(){var t=p;p=e;try{return n.apply(this,arguments)}finally{p=t}}}},545:function(n,e,t){"use strict";n.exports=t(345)},823:function(n){"use strict";n.exports=function(n,e){if(null===n||"undefined"===typeof n)throw new TypeError("expected first argument to be an object.");if("undefined"===typeof e||"undefined"===typeof Symbol)return n;if("function"!==typeof Object.getOwnPropertySymbols)return n;for(var t=Object.prototype.propertyIsEnumerable,r=Object(n),o=arguments.length,a=0;++a<o;)for(var i=Object(arguments[a]),v=Object.getOwnPropertySymbols(i),c=0;c<v.length;c++){var l=v[c];t.call(i,l)&&(r[l]=i[l])}return r}},998:function(n,e){"use strict";e.Z=function(n,e){if(n&&e){var t=Array.isArray(e)?e:e.split(","),r=n.name||"",o=(n.type||"").toLowerCase(),a=o.replace(/\/.*$/,"");return t.some((function(n){var e=n.trim().toLowerCase();return"."===e.charAt(0)?r.toLowerCase().endsWith(e):e.endsWith("/*")?a===e.replace(/\/.*$/,""):o===e}))}return!0}},494:function(n){function e(n,e,t){var r,o,a,i,v;function c(){var l=Date.now()-i;l<e&&l>=0?r=setTimeout(c,e-l):(r=null,t||(v=n.apply(a,o),a=o=null))}null==e&&(e=100);var l=function(){a=this,o=arguments,i=Date.now();var l=t&&!r;return r||(r=setTimeout(c,e)),l&&(v=n.apply(a,o),a=o=null),v};return l.clear=function(){r&&(clearTimeout(r),r=null)},l.flush=function(){r&&(v=n.apply(a,o),a=o=null,clearTimeout(r),r=null)},l}e.debounce=e,n.exports=e},456:function(n,e,t){"use strict";var r=t(583);function o(n,e){for(var t in e)a(e,t)&&(n[t]=e[t])}function a(n,e){return Object.prototype.hasOwnProperty.call(n,e)}n.exports=function(n){r(n)||(n={});for(var e=arguments.length,t=1;t<e;t++){var a=arguments[t];r(a)&&o(n,a)}return n}},583:function(n){"use strict";n.exports=function(n){return"undefined"!==typeof n&&null!==n&&("object"===typeof n||"function"===typeof n)}},845:function(n){"use strict";n.exports=function(n,e,t){for(var r in n)if(!1===e.call(t,n[r],r,n))break}},944:function(n){function e(n){return n?Array.isArray(n)?n.join("."):n:""}n.exports=function(n,t,r,o,a){if(null===(i=n)||"object"!==typeof i&&"function"!==typeof i||!t)return n;var i;if(t=e(t),r&&(t+="."+e(r)),o&&(t+="."+e(o)),a&&(t+="."+e(a)),t in n)return n[t];for(var v=t.split("."),c=v.length,l=-1;n&&++l<c;){for(var s=v[l];"\\"===s[s.length-1];)s=s.slice(0,-1)+"."+v[++l];n=n[s]}return n}},105:function(n,e,t){"use strict";var r=t(807);n.exports=function(n){return r(n)||"function"===typeof n||Array.isArray(n)}},807:function(n,e,t){"use strict";var r=t(863);function o(n){return!0===r(n)&&"[object Object]"===Object.prototype.toString.call(n)}n.exports=function(n){var e,t;return!1!==o(n)&&("function"===typeof(e=n.constructor)&&(!1!==o(t=e.prototype)&&!1!==t.hasOwnProperty("isPrototypeOf")))}},863:function(n){"use strict";n.exports=function(n){return null!=n&&"object"===typeof n&&!1===Array.isArray(n)}},89:function(n,e,t){"use strict";var r=t(105),o=t(46),a=t(944),i=t(809);n.exports=function(n,e,t){if(!r(n))throw new TypeError("expected an object");if("string"!==typeof e||null==t)return o.apply(null,arguments);if("string"===typeof t)return i(n,e,t),n;var v=a(n,e);return r(t)&&r(v)&&(t=o({},v,t)),i(n,e,t),n}},46:function(n,e,t){"use strict";var r=t(105),o=t(845);function a(n,e){for(var t=arguments.length,r=0;++r<t;){var a=arguments[r];v(a)&&o(a,i,n)}return n}function i(n,e){if(function(n){return"__proto__"!==n&&"constructor"!==n&&"prototype"!==n}(e)){var t=this[e];v(n)&&v(t)?a(t,n):this[e]=n}}function v(n){return r(n)&&!Array.isArray(n)}n.exports=a},888:function(n,e,t){"use strict";var r=t(47);function o(){}function a(){}a.resetWarningCache=o,n.exports=function(){function n(n,e,t,o,a,i){if(i!==r){var v=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw v.name="Invariant Violation",v}}function e(){return n}n.isRequired=n;var t={array:n,bigint:n,bool:n,func:n,number:n,object:n,string:n,symbol:n,any:n,arrayOf:e,element:n,elementType:n,instanceOf:e,node:n,objectOf:e,oneOf:e,oneOfType:e,shape:e,exact:e,checkPropTypes:a,resetWarningCache:o};return t.PropTypes=t,t}},7:function(n,e,t){n.exports=t(888)()},47:function(n){"use strict";n.exports="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"},463:function(n,e,t){"use strict";var r=t(791),o=t(296);function a(n){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+n,t=1;t<arguments.length;t++)e+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+n+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var i=new Set,v={};function c(n,e){l(n,e),l(n+"Capture",e)}function l(n,e){for(v[n]=e,n=0;n<e.length;n++)i.add(e[n])}var s=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),u=Object.prototype.hasOwnProperty,f=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},d={};function m(n,e,t,r,o,a,i){this.acceptsBooleans=2===e||3===e||4===e,this.attributeName=r,this.attributeNamespace=o,this.mustUseProperty=t,this.propertyName=n,this.type=e,this.sanitizeURL=a,this.removeEmptyString=i}var h={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(n){h[n]=new m(n,0,!1,n,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(n){var e=n[0];h[e]=new m(e,1,!1,n[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(n){h[n]=new m(n,2,!1,n.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(n){h[n]=new m(n,2,!1,n,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(n){h[n]=new m(n,3,!1,n.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(n){h[n]=new m(n,3,!0,n,null,!1,!1)})),["capture","download"].forEach((function(n){h[n]=new m(n,4,!1,n,null,!1,!1)})),["cols","rows","size","span"].forEach((function(n){h[n]=new m(n,6,!1,n,null,!1,!1)})),["rowSpan","start"].forEach((function(n){h[n]=new m(n,5,!1,n.toLowerCase(),null,!1,!1)}));var x=/[\-:]([a-z])/g;function g(n){return n[1].toUpperCase()}function y(n,e,t,r){var o=h.hasOwnProperty(e)?h[e]:null;(null!==o?0!==o.type:r||!(2<e.length)||"o"!==e[0]&&"O"!==e[0]||"n"!==e[1]&&"N"!==e[1])&&(function(n,e,t,r){if(null===e||"undefined"===typeof e||function(n,e,t,r){if(null!==t&&0===t.type)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return!r&&(null!==t?!t.acceptsBooleans:"data-"!==(n=n.toLowerCase().slice(0,5))&&"aria-"!==n);default:return!1}}(n,e,t,r))return!0;if(r)return!1;if(null!==t)switch(t.type){case 3:return!e;case 4:return!1===e;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}(e,t,o,r)&&(t=null),r||null===o?function(n){return!!u.call(d,n)||!u.call(p,n)&&(f.test(n)?d[n]=!0:(p[n]=!0,!1))}(e)&&(null===t?n.removeAttribute(e):n.setAttribute(e,""+t)):o.mustUseProperty?n[o.propertyName]=null===t?3!==o.type&&"":t:(e=o.attributeName,r=o.attributeNamespace,null===t?n.removeAttribute(e):(t=3===(o=o.type)||4===o&&!0===t?"":""+t,r?n.setAttributeNS(r,e,t):n.setAttribute(e,t))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(n){var e=n.replace(x,g);h[e]=new m(e,1,!1,n,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(n){var e=n.replace(x,g);h[e]=new m(e,1,!1,n,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(n){var e=n.replace(x,g);h[e]=new m(e,1,!1,n,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(n){h[n]=new m(n,1,!1,n.toLowerCase(),null,!1,!1)})),h.xlinkHref=new m("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(n){h[n]=new m(n,1,!1,n.toLowerCase(),null,!0,!0)}));var b=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,_=Symbol.for("react.element"),U=Symbol.for("react.portal"),w=Symbol.for("react.fragment"),S=Symbol.for("react.strict_mode"),k=Symbol.for("react.profiler"),M=Symbol.for("react.provider"),z=Symbol.for("react.context"),C=Symbol.for("react.forward_ref"),T=Symbol.for("react.suspense"),R=Symbol.for("react.suspense_list"),D=Symbol.for("react.memo"),P=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var j=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var F=Symbol.iterator;function E(n){return null===n||"object"!==typeof n?null:"function"===typeof(n=F&&n[F]||n["@@iterator"])?n:null}var I,O=Object.assign;function L(n){if(void 0===I)try{throw Error()}catch(t){var e=t.stack.trim().match(/\n( *(at )?)/);I=e&&e[1]||""}return"\n"+I+n}var A=!1;function N(n,e){if(!n||A)return"";A=!0;var t=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(e,[])}catch(l){var r=l}Reflect.construct(n,[],e)}else{try{e.call()}catch(l){r=l}n.call(e.prototype)}else{try{throw Error()}catch(l){r=l}n()}}catch(l){if(l&&r&&"string"===typeof l.stack){for(var o=l.stack.split("\n"),a=r.stack.split("\n"),i=o.length-1,v=a.length-1;1<=i&&0<=v&&o[i]!==a[v];)v--;for(;1<=i&&0<=v;i--,v--)if(o[i]!==a[v]){if(1!==i||1!==v)do{if(i--,0>--v||o[i]!==a[v]){var c="\n"+o[i].replace(" at new "," at ");return n.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",n.displayName)),c}}while(1<=i&&0<=v);break}}}finally{A=!1,Error.prepareStackTrace=t}return(n=n?n.displayName||n.name:"")?L(n):""}function G(n){switch(n.tag){case 5:return L(n.type);case 16:return L("Lazy");case 13:return L("Suspense");case 19:return L("SuspenseList");case 0:case 2:case 15:return n=N(n.type,!1);case 11:return n=N(n.type.render,!1);case 1:return n=N(n.type,!0);default:return""}}function B(n){if(null==n)return null;if("function"===typeof n)return n.displayName||n.name||null;if("string"===typeof n)return n;switch(n){case w:return"Fragment";case U:return"Portal";case k:return"Profiler";case S:return"StrictMode";case T:return"Suspense";case R:return"SuspenseList"}if("object"===typeof n)switch(n.$$typeof){case z:return(n.displayName||"Context")+".Consumer";case M:return(n._context.displayName||"Context")+".Provider";case C:var e=n.render;return(n=n.displayName)||(n=""!==(n=e.displayName||e.name||"")?"ForwardRef("+n+")":"ForwardRef"),n;case D:return null!==(e=n.displayName||null)?e:B(n.type)||"Memo";case P:e=n._payload,n=n._init;try{return B(n(e))}catch(t){}}return null}function q(n){var e=n.type;switch(n.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return n=(n=e.render).displayName||n.name||"",e.displayName||(""!==n?"ForwardRef("+n+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return B(e);case 8:return e===S?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e}return null}function V(n){switch(typeof n){case"boolean":case"number":case"string":case"undefined":case"object":return n;default:return""}}function W(n){var e=n.type;return(n=n.nodeName)&&"input"===n.toLowerCase()&&("checkbox"===e||"radio"===e)}function H(n){n._valueTracker||(n._valueTracker=function(n){var e=W(n)?"checked":"value",t=Object.getOwnPropertyDescriptor(n.constructor.prototype,e),r=""+n[e];if(!n.hasOwnProperty(e)&&"undefined"!==typeof t&&"function"===typeof t.get&&"function"===typeof t.set){var o=t.get,a=t.set;return Object.defineProperty(n,e,{configurable:!0,get:function(){return o.call(this)},set:function(n){r=""+n,a.call(this,n)}}),Object.defineProperty(n,e,{enumerable:t.enumerable}),{getValue:function(){return r},setValue:function(n){r=""+n},stopTracking:function(){n._valueTracker=null,delete n[e]}}}}(n))}function X(n){if(!n)return!1;var e=n._valueTracker;if(!e)return!0;var t=e.getValue(),r="";return n&&(r=W(n)?n.checked?"true":"false":n.value),(n=r)!==t&&(e.setValue(n),!0)}function Y(n){if("undefined"===typeof(n=n||("undefined"!==typeof document?document:void 0)))return null;try{return n.activeElement||n.body}catch(e){return n.body}}function $(n,e){var t=e.checked;return O({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=t?t:n._wrapperState.initialChecked})}function Z(n,e){var t=null==e.defaultValue?"":e.defaultValue,r=null!=e.checked?e.checked:e.defaultChecked;t=V(null!=e.value?e.value:t),n._wrapperState={initialChecked:r,initialValue:t,controlled:"checkbox"===e.type||"radio"===e.type?null!=e.checked:null!=e.value}}function K(n,e){null!=(e=e.checked)&&y(n,"checked",e,!1)}function J(n,e){K(n,e);var t=V(e.value),r=e.type;if(null!=t)"number"===r?(0===t&&""===n.value||n.value!=t)&&(n.value=""+t):n.value!==""+t&&(n.value=""+t);else if("submit"===r||"reset"===r)return void n.removeAttribute("value");e.hasOwnProperty("value")?nn(n,e.type,t):e.hasOwnProperty("defaultValue")&&nn(n,e.type,V(e.defaultValue)),null==e.checked&&null!=e.defaultChecked&&(n.defaultChecked=!!e.defaultChecked)}function Q(n,e,t){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var r=e.type;if(!("submit"!==r&&"reset"!==r||void 0!==e.value&&null!==e.value))return;e=""+n._wrapperState.initialValue,t||e===n.value||(n.value=e),n.defaultValue=e}""!==(t=n.name)&&(n.name=""),n.defaultChecked=!!n._wrapperState.initialChecked,""!==t&&(n.name=t)}function nn(n,e,t){"number"===e&&Y(n.ownerDocument)===n||(null==t?n.defaultValue=""+n._wrapperState.initialValue:n.defaultValue!==""+t&&(n.defaultValue=""+t))}var en=Array.isArray;function tn(n,e,t,r){if(n=n.options,e){e={};for(var o=0;o<t.length;o++)e["$"+t[o]]=!0;for(t=0;t<n.length;t++)o=e.hasOwnProperty("$"+n[t].value),n[t].selected!==o&&(n[t].selected=o),o&&r&&(n[t].defaultSelected=!0)}else{for(t=""+V(t),e=null,o=0;o<n.length;o++){if(n[o].value===t)return n[o].selected=!0,void(r&&(n[o].defaultSelected=!0));null!==e||n[o].disabled||(e=n[o])}null!==e&&(e.selected=!0)}}function rn(n,e){if(null!=e.dangerouslySetInnerHTML)throw Error(a(91));return O({},e,{value:void 0,defaultValue:void 0,children:""+n._wrapperState.initialValue})}function on(n,e){var t=e.value;if(null==t){if(t=e.children,e=e.defaultValue,null!=t){if(null!=e)throw Error(a(92));if(en(t)){if(1<t.length)throw Error(a(93));t=t[0]}e=t}null==e&&(e=""),t=e}n._wrapperState={initialValue:V(t)}}function an(n,e){var t=V(e.value),r=V(e.defaultValue);null!=t&&((t=""+t)!==n.value&&(n.value=t),null==e.defaultValue&&n.defaultValue!==t&&(n.defaultValue=t)),null!=r&&(n.defaultValue=""+r)}function vn(n){var e=n.textContent;e===n._wrapperState.initialValue&&""!==e&&null!==e&&(n.value=e)}function cn(n){switch(n){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function ln(n,e){return null==n||"http://www.w3.org/1999/xhtml"===n?cn(e):"http://www.w3.org/2000/svg"===n&&"foreignObject"===e?"http://www.w3.org/1999/xhtml":n}var sn,un=function(n){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,r,o){MSApp.execUnsafeLocalFunction((function(){return n(e,t)}))}:n}((function(n,e){if("http://www.w3.org/2000/svg"!==n.namespaceURI||"innerHTML"in n)n.innerHTML=e;else{for((sn=sn||document.createElement("div")).innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=sn.firstChild;n.firstChild;)n.removeChild(n.firstChild);for(;e.firstChild;)n.appendChild(e.firstChild)}}));function fn(n,e){if(e){var t=n.firstChild;if(t&&t===n.lastChild&&3===t.nodeType)return void(t.nodeValue=e)}n.textContent=e}var pn={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},dn=["Webkit","ms","Moz","O"];function mn(n,e,t){return null==e||"boolean"===typeof e||""===e?"":t||"number"!==typeof e||0===e||pn.hasOwnProperty(n)&&pn[n]?(""+e).trim():e+"px"}function hn(n,e){for(var t in n=n.style,e)if(e.hasOwnProperty(t)){var r=0===t.indexOf("--"),o=mn(t,e[t],r);"float"===t&&(t="cssFloat"),r?n.setProperty(t,o):n[t]=o}}Object.keys(pn).forEach((function(n){dn.forEach((function(e){e=e+n.charAt(0).toUpperCase()+n.substring(1),pn[e]=pn[n]}))}));var xn=O({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function gn(n,e){if(e){if(xn[n]&&(null!=e.children||null!=e.dangerouslySetInnerHTML))throw Error(a(137,n));if(null!=e.dangerouslySetInnerHTML){if(null!=e.children)throw Error(a(60));if("object"!==typeof e.dangerouslySetInnerHTML||!("__html"in e.dangerouslySetInnerHTML))throw Error(a(61))}if(null!=e.style&&"object"!==typeof e.style)throw Error(a(62))}}function yn(n,e){if(-1===n.indexOf("-"))return"string"===typeof e.is;switch(n){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var bn=null;function _n(n){return(n=n.target||n.srcElement||window).correspondingUseElement&&(n=n.correspondingUseElement),3===n.nodeType?n.parentNode:n}var Un=null,wn=null,Sn=null;function kn(n){if(n=ho(n)){if("function"!==typeof Un)throw Error(a(280));var e=n.stateNode;e&&(e=go(e),Un(n.stateNode,n.type,e))}}function Mn(n){wn?Sn?Sn.push(n):Sn=[n]:wn=n}function zn(){if(wn){var n=wn,e=Sn;if(Sn=wn=null,kn(n),e)for(n=0;n<e.length;n++)kn(e[n])}}function Cn(n,e){return n(e)}function Tn(){}var Rn=!1;function Dn(n,e,t){if(Rn)return n(e,t);Rn=!0;try{return Cn(n,e,t)}finally{Rn=!1,(null!==wn||null!==Sn)&&(Tn(),zn())}}function Pn(n,e){var t=n.stateNode;if(null===t)return null;var r=go(t);if(null===r)return null;t=r[e];n:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(n=n.type)||"input"===n||"select"===n||"textarea"===n)),n=!r;break n;default:n=!1}if(n)return null;if(t&&"function"!==typeof t)throw Error(a(231,e,typeof t));return t}var jn=!1;if(s)try{var Fn={};Object.defineProperty(Fn,"passive",{get:function(){jn=!0}}),window.addEventListener("test",Fn,Fn),window.removeEventListener("test",Fn,Fn)}catch(es){jn=!1}function En(n,e,t,r,o,a,i,v,c){var l=Array.prototype.slice.call(arguments,3);try{e.apply(t,l)}catch(s){this.onError(s)}}var In=!1,On=null,Ln=!1,An=null,Nn={onError:function(n){In=!0,On=n}};function Gn(n,e,t,r,o,a,i,v,c){In=!1,On=null,En.apply(Nn,arguments)}function Bn(n){var e=n,t=n;if(n.alternate)for(;e.return;)e=e.return;else{n=e;do{0!==(4098&(e=n).flags)&&(t=e.return),n=e.return}while(n)}return 3===e.tag?t:null}function qn(n){if(13===n.tag){var e=n.memoizedState;if(null===e&&(null!==(n=n.alternate)&&(e=n.memoizedState)),null!==e)return e.dehydrated}return null}function Vn(n){if(Bn(n)!==n)throw Error(a(188))}function Wn(n){return null!==(n=function(n){var e=n.alternate;if(!e){if(null===(e=Bn(n)))throw Error(a(188));return e!==n?null:n}for(var t=n,r=e;;){var o=t.return;if(null===o)break;var i=o.alternate;if(null===i){if(null!==(r=o.return)){t=r;continue}break}if(o.child===i.child){for(i=o.child;i;){if(i===t)return Vn(o),n;if(i===r)return Vn(o),e;i=i.sibling}throw Error(a(188))}if(t.return!==r.return)t=o,r=i;else{for(var v=!1,c=o.child;c;){if(c===t){v=!0,t=o,r=i;break}if(c===r){v=!0,r=o,t=i;break}c=c.sibling}if(!v){for(c=i.child;c;){if(c===t){v=!0,t=i,r=o;break}if(c===r){v=!0,r=i,t=o;break}c=c.sibling}if(!v)throw Error(a(189))}}if(t.alternate!==r)throw Error(a(190))}if(3!==t.tag)throw Error(a(188));return t.stateNode.current===t?n:e}(n))?Hn(n):null}function Hn(n){if(5===n.tag||6===n.tag)return n;for(n=n.child;null!==n;){var e=Hn(n);if(null!==e)return e;n=n.sibling}return null}var Xn=o.unstable_scheduleCallback,Yn=o.unstable_cancelCallback,$n=o.unstable_shouldYield,Zn=o.unstable_requestPaint,Kn=o.unstable_now,Jn=o.unstable_getCurrentPriorityLevel,Qn=o.unstable_ImmediatePriority,ne=o.unstable_UserBlockingPriority,ee=o.unstable_NormalPriority,te=o.unstable_LowPriority,re=o.unstable_IdlePriority,oe=null,ae=null;var ie=Math.clz32?Math.clz32:function(n){return 0===(n>>>=0)?32:31-(ve(n)/ce|0)|0},ve=Math.log,ce=Math.LN2;var le=64,se=4194304;function ue(n){switch(n&-n){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&n;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&n;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return n}}function fe(n,e){var t=n.pendingLanes;if(0===t)return 0;var r=0,o=n.suspendedLanes,a=n.pingedLanes,i=268435455&t;if(0!==i){var v=i&~o;0!==v?r=ue(v):0!==(a&=i)&&(r=ue(a))}else 0!==(i=t&~o)?r=ue(i):0!==a&&(r=ue(a));if(0===r)return 0;if(0!==e&&e!==r&&0===(e&o)&&((o=r&-r)>=(a=e&-e)||16===o&&0!==(4194240&a)))return e;if(0!==(4&r)&&(r|=16&t),0!==(e=n.entangledLanes))for(n=n.entanglements,e&=r;0<e;)o=1<<(t=31-ie(e)),r|=n[t],e&=~o;return r}function pe(n,e){switch(n){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;default:return-1}}function de(n){return 0!==(n=-1073741825&n.pendingLanes)?n:1073741824&n?1073741824:0}function me(){var n=le;return 0===(4194240&(le<<=1))&&(le=64),n}function he(n){for(var e=[],t=0;31>t;t++)e.push(n);return e}function xe(n,e,t){n.pendingLanes|=e,536870912!==e&&(n.suspendedLanes=0,n.pingedLanes=0),(n=n.eventTimes)[e=31-ie(e)]=t}function ge(n,e){var t=n.entangledLanes|=e;for(n=n.entanglements;t;){var r=31-ie(t),o=1<<r;o&e|n[r]&e&&(n[r]|=e),t&=~o}}var ye=0;function be(n){return 1<(n&=-n)?4<n?0!==(268435455&n)?16:536870912:4:1}var _e,Ue,we,Se,ke,Me=!1,ze=[],Ce=null,Te=null,Re=null,De=new Map,Pe=new Map,je=[],Fe="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Ee(n,e){switch(n){case"focusin":case"focusout":Ce=null;break;case"dragenter":case"dragleave":Te=null;break;case"mouseover":case"mouseout":Re=null;break;case"pointerover":case"pointerout":De.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":Pe.delete(e.pointerId)}}function Ie(n,e,t,r,o,a){return null===n||n.nativeEvent!==a?(n={blockedOn:e,domEventName:t,eventSystemFlags:r,nativeEvent:a,targetContainers:[o]},null!==e&&(null!==(e=ho(e))&&Ue(e)),n):(n.eventSystemFlags|=r,e=n.targetContainers,null!==o&&-1===e.indexOf(o)&&e.push(o),n)}function Oe(n){var e=mo(n.target);if(null!==e){var t=Bn(e);if(null!==t)if(13===(e=t.tag)){if(null!==(e=qn(t)))return n.blockedOn=e,void ke(n.priority,(function(){we(t)}))}else if(3===e&&t.stateNode.current.memoizedState.isDehydrated)return void(n.blockedOn=3===t.tag?t.stateNode.containerInfo:null)}n.blockedOn=null}function Le(n){if(null!==n.blockedOn)return!1;for(var e=n.targetContainers;0<e.length;){var t=$e(n.domEventName,n.eventSystemFlags,e[0],n.nativeEvent);if(null!==t)return null!==(e=ho(t))&&Ue(e),n.blockedOn=t,!1;var r=new(t=n.nativeEvent).constructor(t.type,t);bn=r,t.target.dispatchEvent(r),bn=null,e.shift()}return!0}function Ae(n,e,t){Le(n)&&t.delete(e)}function Ne(){Me=!1,null!==Ce&&Le(Ce)&&(Ce=null),null!==Te&&Le(Te)&&(Te=null),null!==Re&&Le(Re)&&(Re=null),De.forEach(Ae),Pe.forEach(Ae)}function Ge(n,e){n.blockedOn===e&&(n.blockedOn=null,Me||(Me=!0,o.unstable_scheduleCallback(o.unstable_NormalPriority,Ne)))}function Be(n){function e(e){return Ge(e,n)}if(0<ze.length){Ge(ze[0],n);for(var t=1;t<ze.length;t++){var r=ze[t];r.blockedOn===n&&(r.blockedOn=null)}}for(null!==Ce&&Ge(Ce,n),null!==Te&&Ge(Te,n),null!==Re&&Ge(Re,n),De.forEach(e),Pe.forEach(e),t=0;t<je.length;t++)(r=je[t]).blockedOn===n&&(r.blockedOn=null);for(;0<je.length&&null===(t=je[0]).blockedOn;)Oe(t),null===t.blockedOn&&je.shift()}var qe=b.ReactCurrentBatchConfig,Ve=!0;function We(n,e,t,r){var o=ye,a=qe.transition;qe.transition=null;try{ye=1,Xe(n,e,t,r)}finally{ye=o,qe.transition=a}}function He(n,e,t,r){var o=ye,a=qe.transition;qe.transition=null;try{ye=4,Xe(n,e,t,r)}finally{ye=o,qe.transition=a}}function Xe(n,e,t,r){if(Ve){var o=$e(n,e,t,r);if(null===o)Nr(n,e,r,Ye,t),Ee(n,r);else if(function(n,e,t,r,o){switch(e){case"focusin":return Ce=Ie(Ce,n,e,t,r,o),!0;case"dragenter":return Te=Ie(Te,n,e,t,r,o),!0;case"mouseover":return Re=Ie(Re,n,e,t,r,o),!0;case"pointerover":var a=o.pointerId;return De.set(a,Ie(De.get(a)||null,n,e,t,r,o)),!0;case"gotpointercapture":return a=o.pointerId,Pe.set(a,Ie(Pe.get(a)||null,n,e,t,r,o)),!0}return!1}(o,n,e,t,r))r.stopPropagation();else if(Ee(n,r),4&e&&-1<Fe.indexOf(n)){for(;null!==o;){var a=ho(o);if(null!==a&&_e(a),null===(a=$e(n,e,t,r))&&Nr(n,e,r,Ye,t),a===o)break;o=a}null!==o&&r.stopPropagation()}else Nr(n,e,r,null,t)}}var Ye=null;function $e(n,e,t,r){if(Ye=null,null!==(n=mo(n=_n(r))))if(null===(e=Bn(n)))n=null;else if(13===(t=e.tag)){if(null!==(n=qn(e)))return n;n=null}else if(3===t){if(e.stateNode.current.memoizedState.isDehydrated)return 3===e.tag?e.stateNode.containerInfo:null;n=null}else e!==n&&(n=null);return Ye=n,null}function Ze(n){switch(n){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Jn()){case Qn:return 1;case ne:return 4;case ee:case te:return 16;case re:return 536870912;default:return 16}default:return 16}}var Ke=null,Je=null,Qe=null;function nt(){if(Qe)return Qe;var n,e,t=Je,r=t.length,o="value"in Ke?Ke.value:Ke.textContent,a=o.length;for(n=0;n<r&&t[n]===o[n];n++);var i=r-n;for(e=1;e<=i&&t[r-e]===o[a-e];e++);return Qe=o.slice(n,1<e?1-e:void 0)}function et(n){var e=n.keyCode;return"charCode"in n?0===(n=n.charCode)&&13===e&&(n=13):n=e,10===n&&(n=13),32<=n||13===n?n:0}function tt(){return!0}function rt(){return!1}function ot(n){function e(e,t,r,o,a){for(var i in this._reactName=e,this._targetInst=r,this.type=t,this.nativeEvent=o,this.target=a,this.currentTarget=null,n)n.hasOwnProperty(i)&&(e=n[i],this[i]=e?e(o):o[i]);return this.isDefaultPrevented=(null!=o.defaultPrevented?o.defaultPrevented:!1===o.returnValue)?tt:rt,this.isPropagationStopped=rt,this}return O(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():"unknown"!==typeof n.returnValue&&(n.returnValue=!1),this.isDefaultPrevented=tt)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():"unknown"!==typeof n.cancelBubble&&(n.cancelBubble=!0),this.isPropagationStopped=tt)},persist:function(){},isPersistent:tt}),e}var at,it,vt,ct={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(n){return n.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},lt=ot(ct),st=O({},ct,{view:0,detail:0}),ut=ot(st),ft=O({},st,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:wt,button:0,buttons:0,relatedTarget:function(n){return void 0===n.relatedTarget?n.fromElement===n.srcElement?n.toElement:n.fromElement:n.relatedTarget},movementX:function(n){return"movementX"in n?n.movementX:(n!==vt&&(vt&&"mousemove"===n.type?(at=n.screenX-vt.screenX,it=n.screenY-vt.screenY):it=at=0,vt=n),at)},movementY:function(n){return"movementY"in n?n.movementY:it}}),pt=ot(ft),dt=ot(O({},ft,{dataTransfer:0})),mt=ot(O({},st,{relatedTarget:0})),ht=ot(O({},ct,{animationName:0,elapsedTime:0,pseudoElement:0})),xt=ot(O({},ct,{clipboardData:function(n){return"clipboardData"in n?n.clipboardData:window.clipboardData}})),gt=ot(O({},ct,{data:0})),yt={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},bt={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},_t={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Ut(n){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(n):!!(n=_t[n])&&!!e[n]}function wt(){return Ut}var St=ot(O({},st,{key:function(n){if(n.key){var e=yt[n.key]||n.key;if("Unidentified"!==e)return e}return"keypress"===n.type?13===(n=et(n))?"Enter":String.fromCharCode(n):"keydown"===n.type||"keyup"===n.type?bt[n.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:wt,charCode:function(n){return"keypress"===n.type?et(n):0},keyCode:function(n){return"keydown"===n.type||"keyup"===n.type?n.keyCode:0},which:function(n){return"keypress"===n.type?et(n):"keydown"===n.type||"keyup"===n.type?n.keyCode:0}})),kt=ot(O({},ft,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Mt=ot(O({},st,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:wt})),zt=ot(O({},ct,{propertyName:0,elapsedTime:0,pseudoElement:0})),Ct=ot(O({},ft,{deltaX:function(n){return"deltaX"in n?n.deltaX:"wheelDeltaX"in n?-n.wheelDeltaX:0},deltaY:function(n){return"deltaY"in n?n.deltaY:"wheelDeltaY"in n?-n.wheelDeltaY:"wheelDelta"in n?-n.wheelDelta:0},deltaZ:0,deltaMode:0})),Tt=[9,13,27,32],Rt=s&&"CompositionEvent"in window,Dt=null;s&&"documentMode"in document&&(Dt=document.documentMode);var Pt=s&&"TextEvent"in window&&!Dt,jt=s&&(!Rt||Dt&&8<Dt&&11>=Dt),Ft=String.fromCharCode(32),Et=!1;function It(n,e){switch(n){case"keyup":return-1!==Tt.indexOf(e.keyCode);case"keydown":return 229!==e.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Ot(n){return"object"===typeof(n=n.detail)&&"data"in n?n.data:null}var Lt=!1;var At={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Nt(n){var e=n&&n.nodeName&&n.nodeName.toLowerCase();return"input"===e?!!At[n.type]:"textarea"===e}function Gt(n,e,t,r){Mn(r),0<(e=Br(e,"onChange")).length&&(t=new lt("onChange","change",null,t,r),n.push({event:t,listeners:e}))}var Bt=null,qt=null;function Vt(n){Fr(n,0)}function Wt(n){if(X(xo(n)))return n}function Ht(n,e){if("change"===n)return e}var Xt=!1;if(s){var Yt;if(s){var $t="oninput"in document;if(!$t){var Zt=document.createElement("div");Zt.setAttribute("oninput","return;"),$t="function"===typeof Zt.oninput}Yt=$t}else Yt=!1;Xt=Yt&&(!document.documentMode||9<document.documentMode)}function Kt(){Bt&&(Bt.detachEvent("onpropertychange",Jt),qt=Bt=null)}function Jt(n){if("value"===n.propertyName&&Wt(qt)){var e=[];Gt(e,qt,n,_n(n)),Dn(Vt,e)}}function Qt(n,e,t){"focusin"===n?(Kt(),qt=t,(Bt=e).attachEvent("onpropertychange",Jt)):"focusout"===n&&Kt()}function nr(n){if("selectionchange"===n||"keyup"===n||"keydown"===n)return Wt(qt)}function er(n,e){if("click"===n)return Wt(e)}function tr(n,e){if("input"===n||"change"===n)return Wt(e)}var rr="function"===typeof Object.is?Object.is:function(n,e){return n===e&&(0!==n||1/n===1/e)||n!==n&&e!==e};function or(n,e){if(rr(n,e))return!0;if("object"!==typeof n||null===n||"object"!==typeof e||null===e)return!1;var t=Object.keys(n),r=Object.keys(e);if(t.length!==r.length)return!1;for(r=0;r<t.length;r++){var o=t[r];if(!u.call(e,o)||!rr(n[o],e[o]))return!1}return!0}function ar(n){for(;n&&n.firstChild;)n=n.firstChild;return n}function ir(n,e){var t,r=ar(n);for(n=0;r;){if(3===r.nodeType){if(t=n+r.textContent.length,n<=e&&t>=e)return{node:r,offset:e-n};n=t}n:{for(;r;){if(r.nextSibling){r=r.nextSibling;break n}r=r.parentNode}r=void 0}r=ar(r)}}function vr(n,e){return!(!n||!e)&&(n===e||(!n||3!==n.nodeType)&&(e&&3===e.nodeType?vr(n,e.parentNode):"contains"in n?n.contains(e):!!n.compareDocumentPosition&&!!(16&n.compareDocumentPosition(e))))}function cr(){for(var n=window,e=Y();e instanceof n.HTMLIFrameElement;){try{var t="string"===typeof e.contentWindow.location.href}catch(r){t=!1}if(!t)break;e=Y((n=e.contentWindow).document)}return e}function lr(n){var e=n&&n.nodeName&&n.nodeName.toLowerCase();return e&&("input"===e&&("text"===n.type||"search"===n.type||"tel"===n.type||"url"===n.type||"password"===n.type)||"textarea"===e||"true"===n.contentEditable)}function sr(n){var e=cr(),t=n.focusedElem,r=n.selectionRange;if(e!==t&&t&&t.ownerDocument&&vr(t.ownerDocument.documentElement,t)){if(null!==r&&lr(t))if(e=r.start,void 0===(n=r.end)&&(n=e),"selectionStart"in t)t.selectionStart=e,t.selectionEnd=Math.min(n,t.value.length);else if((n=(e=t.ownerDocument||document)&&e.defaultView||window).getSelection){n=n.getSelection();var o=t.textContent.length,a=Math.min(r.start,o);r=void 0===r.end?a:Math.min(r.end,o),!n.extend&&a>r&&(o=r,r=a,a=o),o=ir(t,a);var i=ir(t,r);o&&i&&(1!==n.rangeCount||n.anchorNode!==o.node||n.anchorOffset!==o.offset||n.focusNode!==i.node||n.focusOffset!==i.offset)&&((e=e.createRange()).setStart(o.node,o.offset),n.removeAllRanges(),a>r?(n.addRange(e),n.extend(i.node,i.offset)):(e.setEnd(i.node,i.offset),n.addRange(e)))}for(e=[],n=t;n=n.parentNode;)1===n.nodeType&&e.push({element:n,left:n.scrollLeft,top:n.scrollTop});for("function"===typeof t.focus&&t.focus(),t=0;t<e.length;t++)(n=e[t]).element.scrollLeft=n.left,n.element.scrollTop=n.top}}var ur=s&&"documentMode"in document&&11>=document.documentMode,fr=null,pr=null,dr=null,mr=!1;function hr(n,e,t){var r=t.window===t?t.document:9===t.nodeType?t:t.ownerDocument;mr||null==fr||fr!==Y(r)||("selectionStart"in(r=fr)&&lr(r)?r={start:r.selectionStart,end:r.selectionEnd}:r={anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},dr&&or(dr,r)||(dr=r,0<(r=Br(pr,"onSelect")).length&&(e=new lt("onSelect","select",null,e,t),n.push({event:e,listeners:r}),e.target=fr)))}function xr(n,e){var t={};return t[n.toLowerCase()]=e.toLowerCase(),t["Webkit"+n]="webkit"+e,t["Moz"+n]="moz"+e,t}var gr={animationend:xr("Animation","AnimationEnd"),animationiteration:xr("Animation","AnimationIteration"),animationstart:xr("Animation","AnimationStart"),transitionend:xr("Transition","TransitionEnd")},yr={},br={};function _r(n){if(yr[n])return yr[n];if(!gr[n])return n;var e,t=gr[n];for(e in t)if(t.hasOwnProperty(e)&&e in br)return yr[n]=t[e];return n}s&&(br=document.createElement("div").style,"AnimationEvent"in window||(delete gr.animationend.animation,delete gr.animationiteration.animation,delete gr.animationstart.animation),"TransitionEvent"in window||delete gr.transitionend.transition);var Ur=_r("animationend"),wr=_r("animationiteration"),Sr=_r("animationstart"),kr=_r("transitionend"),Mr=new Map,zr="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Cr(n,e){Mr.set(n,e),c(e,[n])}for(var Tr=0;Tr<zr.length;Tr++){var Rr=zr[Tr];Cr(Rr.toLowerCase(),"on"+(Rr[0].toUpperCase()+Rr.slice(1)))}Cr(Ur,"onAnimationEnd"),Cr(wr,"onAnimationIteration"),Cr(Sr,"onAnimationStart"),Cr("dblclick","onDoubleClick"),Cr("focusin","onFocus"),Cr("focusout","onBlur"),Cr(kr,"onTransitionEnd"),l("onMouseEnter",["mouseout","mouseover"]),l("onMouseLeave",["mouseout","mouseover"]),l("onPointerEnter",["pointerout","pointerover"]),l("onPointerLeave",["pointerout","pointerover"]),c("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),c("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),c("onBeforeInput",["compositionend","keypress","textInput","paste"]),c("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Dr="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pr=new Set("cancel close invalid load scroll toggle".split(" ").concat(Dr));function jr(n,e,t){var r=n.type||"unknown-event";n.currentTarget=t,function(n,e,t,r,o,i,v,c,l){if(Gn.apply(this,arguments),In){if(!In)throw Error(a(198));var s=On;In=!1,On=null,Ln||(Ln=!0,An=s)}}(r,e,void 0,n),n.currentTarget=null}function Fr(n,e){e=0!==(4&e);for(var t=0;t<n.length;t++){var r=n[t],o=r.event;r=r.listeners;n:{var a=void 0;if(e)for(var i=r.length-1;0<=i;i--){var v=r[i],c=v.instance,l=v.currentTarget;if(v=v.listener,c!==a&&o.isPropagationStopped())break n;jr(o,v,l),a=c}else for(i=0;i<r.length;i++){if(c=(v=r[i]).instance,l=v.currentTarget,v=v.listener,c!==a&&o.isPropagationStopped())break n;jr(o,v,l),a=c}}}if(Ln)throw n=An,Ln=!1,An=null,n}function Er(n,e){var t=e[uo];void 0===t&&(t=e[uo]=new Set);var r=n+"__bubble";t.has(r)||(Ar(e,n,2,!1),t.add(r))}function Ir(n,e,t){var r=0;e&&(r|=4),Ar(t,n,r,e)}var Or="_reactListening"+Math.random().toString(36).slice(2);function Lr(n){if(!n[Or]){n[Or]=!0,i.forEach((function(e){"selectionchange"!==e&&(Pr.has(e)||Ir(e,!1,n),Ir(e,!0,n))}));var e=9===n.nodeType?n:n.ownerDocument;null===e||e[Or]||(e[Or]=!0,Ir("selectionchange",!1,e))}}function Ar(n,e,t,r){switch(Ze(e)){case 1:var o=We;break;case 4:o=He;break;default:o=Xe}t=o.bind(null,e,t,n),o=void 0,!jn||"touchstart"!==e&&"touchmove"!==e&&"wheel"!==e||(o=!0),r?void 0!==o?n.addEventListener(e,t,{capture:!0,passive:o}):n.addEventListener(e,t,!0):void 0!==o?n.addEventListener(e,t,{passive:o}):n.addEventListener(e,t,!1)}function Nr(n,e,t,r,o){var a=r;if(0===(1&e)&&0===(2&e)&&null!==r)n:for(;;){if(null===r)return;var i=r.tag;if(3===i||4===i){var v=r.stateNode.containerInfo;if(v===o||8===v.nodeType&&v.parentNode===o)break;if(4===i)for(i=r.return;null!==i;){var c=i.tag;if((3===c||4===c)&&((c=i.stateNode.containerInfo)===o||8===c.nodeType&&c.parentNode===o))return;i=i.return}for(;null!==v;){if(null===(i=mo(v)))return;if(5===(c=i.tag)||6===c){r=a=i;continue n}v=v.parentNode}}r=r.return}Dn((function(){var r=a,o=_n(t),i=[];n:{var v=Mr.get(n);if(void 0!==v){var c=lt,l=n;switch(n){case"keypress":if(0===et(t))break n;case"keydown":case"keyup":c=St;break;case"focusin":l="focus",c=mt;break;case"focusout":l="blur",c=mt;break;case"beforeblur":case"afterblur":c=mt;break;case"click":if(2===t.button)break n;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":c=pt;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":c=dt;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":c=Mt;break;case Ur:case wr:case Sr:c=ht;break;case kr:c=zt;break;case"scroll":c=ut;break;case"wheel":c=Ct;break;case"copy":case"cut":case"paste":c=xt;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":c=kt}var s=0!==(4&e),u=!s&&"scroll"===n,f=s?null!==v?v+"Capture":null:v;s=[];for(var p,d=r;null!==d;){var m=(p=d).stateNode;if(5===p.tag&&null!==m&&(p=m,null!==f&&(null!=(m=Pn(d,f))&&s.push(Gr(d,m,p)))),u)break;d=d.return}0<s.length&&(v=new c(v,l,null,t,o),i.push({event:v,listeners:s}))}}if(0===(7&e)){if(c="mouseout"===n||"pointerout"===n,(!(v="mouseover"===n||"pointerover"===n)||t===bn||!(l=t.relatedTarget||t.fromElement)||!mo(l)&&!l[so])&&(c||v)&&(v=o.window===o?o:(v=o.ownerDocument)?v.defaultView||v.parentWindow:window,c?(c=r,null!==(l=(l=t.relatedTarget||t.toElement)?mo(l):null)&&(l!==(u=Bn(l))||5!==l.tag&&6!==l.tag)&&(l=null)):(c=null,l=r),c!==l)){if(s=pt,m="onMouseLeave",f="onMouseEnter",d="mouse","pointerout"!==n&&"pointerover"!==n||(s=kt,m="onPointerLeave",f="onPointerEnter",d="pointer"),u=null==c?v:xo(c),p=null==l?v:xo(l),(v=new s(m,d+"leave",c,t,o)).target=u,v.relatedTarget=p,m=null,mo(o)===r&&((s=new s(f,d+"enter",l,t,o)).target=p,s.relatedTarget=u,m=s),u=m,c&&l)n:{for(f=l,d=0,p=s=c;p;p=qr(p))d++;for(p=0,m=f;m;m=qr(m))p++;for(;0<d-p;)s=qr(s),d--;for(;0<p-d;)f=qr(f),p--;for(;d--;){if(s===f||null!==f&&s===f.alternate)break n;s=qr(s),f=qr(f)}s=null}else s=null;null!==c&&Vr(i,v,c,s,!1),null!==l&&null!==u&&Vr(i,u,l,s,!0)}if("select"===(c=(v=r?xo(r):window).nodeName&&v.nodeName.toLowerCase())||"input"===c&&"file"===v.type)var h=Ht;else if(Nt(v))if(Xt)h=tr;else{h=nr;var x=Qt}else(c=v.nodeName)&&"input"===c.toLowerCase()&&("checkbox"===v.type||"radio"===v.type)&&(h=er);switch(h&&(h=h(n,r))?Gt(i,h,t,o):(x&&x(n,v,r),"focusout"===n&&(x=v._wrapperState)&&x.controlled&&"number"===v.type&&nn(v,"number",v.value)),x=r?xo(r):window,n){case"focusin":(Nt(x)||"true"===x.contentEditable)&&(fr=x,pr=r,dr=null);break;case"focusout":dr=pr=fr=null;break;case"mousedown":mr=!0;break;case"contextmenu":case"mouseup":case"dragend":mr=!1,hr(i,t,o);break;case"selectionchange":if(ur)break;case"keydown":case"keyup":hr(i,t,o)}var g;if(Rt)n:{switch(n){case"compositionstart":var y="onCompositionStart";break n;case"compositionend":y="onCompositionEnd";break n;case"compositionupdate":y="onCompositionUpdate";break n}y=void 0}else Lt?It(n,t)&&(y="onCompositionEnd"):"keydown"===n&&229===t.keyCode&&(y="onCompositionStart");y&&(jt&&"ko"!==t.locale&&(Lt||"onCompositionStart"!==y?"onCompositionEnd"===y&&Lt&&(g=nt()):(Je="value"in(Ke=o)?Ke.value:Ke.textContent,Lt=!0)),0<(x=Br(r,y)).length&&(y=new gt(y,n,null,t,o),i.push({event:y,listeners:x}),g?y.data=g:null!==(g=Ot(t))&&(y.data=g))),(g=Pt?function(n,e){switch(n){case"compositionend":return Ot(e);case"keypress":return 32!==e.which?null:(Et=!0,Ft);case"textInput":return(n=e.data)===Ft&&Et?null:n;default:return null}}(n,t):function(n,e){if(Lt)return"compositionend"===n||!Rt&&It(n,e)?(n=nt(),Qe=Je=Ke=null,Lt=!1,n):null;switch(n){case"paste":default:return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return jt&&"ko"!==e.locale?null:e.data}}(n,t))&&(0<(r=Br(r,"onBeforeInput")).length&&(o=new gt("onBeforeInput","beforeinput",null,t,o),i.push({event:o,listeners:r}),o.data=g))}Fr(i,e)}))}function Gr(n,e,t){return{instance:n,listener:e,currentTarget:t}}function Br(n,e){for(var t=e+"Capture",r=[];null!==n;){var o=n,a=o.stateNode;5===o.tag&&null!==a&&(o=a,null!=(a=Pn(n,t))&&r.unshift(Gr(n,a,o)),null!=(a=Pn(n,e))&&r.push(Gr(n,a,o))),n=n.return}return r}function qr(n){if(null===n)return null;do{n=n.return}while(n&&5!==n.tag);return n||null}function Vr(n,e,t,r,o){for(var a=e._reactName,i=[];null!==t&&t!==r;){var v=t,c=v.alternate,l=v.stateNode;if(null!==c&&c===r)break;5===v.tag&&null!==l&&(v=l,o?null!=(c=Pn(t,a))&&i.unshift(Gr(t,c,v)):o||null!=(c=Pn(t,a))&&i.push(Gr(t,c,v))),t=t.return}0!==i.length&&n.push({event:e,listeners:i})}var Wr=/\r\n?/g,Hr=/\u0000|\uFFFD/g;function Xr(n){return("string"===typeof n?n:""+n).replace(Wr,"\n").replace(Hr,"")}function Yr(n,e,t){if(e=Xr(e),Xr(n)!==e&&t)throw Error(a(425))}function $r(){}var Zr=null,Kr=null;function Jr(n,e){return"textarea"===n||"noscript"===n||"string"===typeof e.children||"number"===typeof e.children||"object"===typeof e.dangerouslySetInnerHTML&&null!==e.dangerouslySetInnerHTML&&null!=e.dangerouslySetInnerHTML.__html}var Qr="function"===typeof setTimeout?setTimeout:void 0,no="function"===typeof clearTimeout?clearTimeout:void 0,eo="function"===typeof Promise?Promise:void 0,to="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof eo?function(n){return eo.resolve(null).then(n).catch(ro)}:Qr;function ro(n){setTimeout((function(){throw n}))}function oo(n,e){var t=e,r=0;do{var o=t.nextSibling;if(n.removeChild(t),o&&8===o.nodeType)if("/$"===(t=o.data)){if(0===r)return n.removeChild(o),void Be(e);r--}else"$"!==t&&"$?"!==t&&"$!"!==t||r++;t=o}while(t);Be(e)}function ao(n){for(;null!=n;n=n.nextSibling){var e=n.nodeType;if(1===e||3===e)break;if(8===e){if("$"===(e=n.data)||"$!"===e||"$?"===e)break;if("/$"===e)return null}}return n}function io(n){n=n.previousSibling;for(var e=0;n;){if(8===n.nodeType){var t=n.data;if("$"===t||"$!"===t||"$?"===t){if(0===e)return n;e--}else"/$"===t&&e++}n=n.previousSibling}return null}var vo=Math.random().toString(36).slice(2),co="__reactFiber$"+vo,lo="__reactProps$"+vo,so="__reactContainer$"+vo,uo="__reactEvents$"+vo,fo="__reactListeners$"+vo,po="__reactHandles$"+vo;function mo(n){var e=n[co];if(e)return e;for(var t=n.parentNode;t;){if(e=t[so]||t[co]){if(t=e.alternate,null!==e.child||null!==t&&null!==t.child)for(n=io(n);null!==n;){if(t=n[co])return t;n=io(n)}return e}t=(n=t).parentNode}return null}function ho(n){return!(n=n[co]||n[so])||5!==n.tag&&6!==n.tag&&13!==n.tag&&3!==n.tag?null:n}function xo(n){if(5===n.tag||6===n.tag)return n.stateNode;throw Error(a(33))}function go(n){return n[lo]||null}var yo=[],bo=-1;function _o(n){return{current:n}}function Uo(n){0>bo||(n.current=yo[bo],yo[bo]=null,bo--)}function wo(n,e){bo++,yo[bo]=n.current,n.current=e}var So={},ko=_o(So),Mo=_o(!1),zo=So;function Co(n,e){var t=n.type.contextTypes;if(!t)return So;var r=n.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===e)return r.__reactInternalMemoizedMaskedChildContext;var o,a={};for(o in t)a[o]=e[o];return r&&((n=n.stateNode).__reactInternalMemoizedUnmaskedChildContext=e,n.__reactInternalMemoizedMaskedChildContext=a),a}function To(n){return null!==(n=n.childContextTypes)&&void 0!==n}function Ro(){Uo(Mo),Uo(ko)}function Do(n,e,t){if(ko.current!==So)throw Error(a(168));wo(ko,e),wo(Mo,t)}function Po(n,e,t){var r=n.stateNode;if(e=e.childContextTypes,"function"!==typeof r.getChildContext)return t;for(var o in r=r.getChildContext())if(!(o in e))throw Error(a(108,q(n)||"Unknown",o));return O({},t,r)}function jo(n){return n=(n=n.stateNode)&&n.__reactInternalMemoizedMergedChildContext||So,zo=ko.current,wo(ko,n),wo(Mo,Mo.current),!0}function Fo(n,e,t){var r=n.stateNode;if(!r)throw Error(a(169));t?(n=Po(n,e,zo),r.__reactInternalMemoizedMergedChildContext=n,Uo(Mo),Uo(ko),wo(ko,n)):Uo(Mo),wo(Mo,t)}var Eo=null,Io=!1,Oo=!1;function Lo(n){null===Eo?Eo=[n]:Eo.push(n)}function Ao(){if(!Oo&&null!==Eo){Oo=!0;var n=0,e=ye;try{var t=Eo;for(ye=1;n<t.length;n++){var r=t[n];do{r=r(!0)}while(null!==r)}Eo=null,Io=!1}catch(o){throw null!==Eo&&(Eo=Eo.slice(n+1)),Xn(Qn,Ao),o}finally{ye=e,Oo=!1}}return null}var No=[],Go=0,Bo=null,qo=0,Vo=[],Wo=0,Ho=null,Xo=1,Yo="";function $o(n,e){No[Go++]=qo,No[Go++]=Bo,Bo=n,qo=e}function Zo(n,e,t){Vo[Wo++]=Xo,Vo[Wo++]=Yo,Vo[Wo++]=Ho,Ho=n;var r=Xo;n=Yo;var o=32-ie(r)-1;r&=~(1<<o),t+=1;var a=32-ie(e)+o;if(30<a){var i=o-o%5;a=(r&(1<<i)-1).toString(32),r>>=i,o-=i,Xo=1<<32-ie(e)+o|t<<o|r,Yo=a+n}else Xo=1<<a|t<<o|r,Yo=n}function Ko(n){null!==n.return&&($o(n,1),Zo(n,1,0))}function Jo(n){for(;n===Bo;)Bo=No[--Go],No[Go]=null,qo=No[--Go],No[Go]=null;for(;n===Ho;)Ho=Vo[--Wo],Vo[Wo]=null,Yo=Vo[--Wo],Vo[Wo]=null,Xo=Vo[--Wo],Vo[Wo]=null}var Qo=null,na=null,ea=!1,ta=null;function ra(n,e){var t=zl(5,null,null,0);t.elementType="DELETED",t.stateNode=e,t.return=n,null===(e=n.deletions)?(n.deletions=[t],n.flags|=16):e.push(t)}function oa(n,e){switch(n.tag){case 5:var t=n.type;return null!==(e=1!==e.nodeType||t.toLowerCase()!==e.nodeName.toLowerCase()?null:e)&&(n.stateNode=e,Qo=n,na=ao(e.firstChild),!0);case 6:return null!==(e=""===n.pendingProps||3!==e.nodeType?null:e)&&(n.stateNode=e,Qo=n,na=null,!0);case 13:return null!==(e=8!==e.nodeType?null:e)&&(t=null!==Ho?{id:Xo,overflow:Yo}:null,n.memoizedState={dehydrated:e,treeContext:t,retryLane:1073741824},(t=zl(18,null,null,0)).stateNode=e,t.return=n,n.child=t,Qo=n,na=null,!0);default:return!1}}function aa(n){return 0!==(1&n.mode)&&0===(128&n.flags)}function ia(n){if(ea){var e=na;if(e){var t=e;if(!oa(n,e)){if(aa(n))throw Error(a(418));e=ao(t.nextSibling);var r=Qo;e&&oa(n,e)?ra(r,t):(n.flags=-4097&n.flags|2,ea=!1,Qo=n)}}else{if(aa(n))throw Error(a(418));n.flags=-4097&n.flags|2,ea=!1,Qo=n}}}function va(n){for(n=n.return;null!==n&&5!==n.tag&&3!==n.tag&&13!==n.tag;)n=n.return;Qo=n}function ca(n){if(n!==Qo)return!1;if(!ea)return va(n),ea=!0,!1;var e;if((e=3!==n.tag)&&!(e=5!==n.tag)&&(e="head"!==(e=n.type)&&"body"!==e&&!Jr(n.type,n.memoizedProps)),e&&(e=na)){if(aa(n))throw la(),Error(a(418));for(;e;)ra(n,e),e=ao(e.nextSibling)}if(va(n),13===n.tag){if(!(n=null!==(n=n.memoizedState)?n.dehydrated:null))throw Error(a(317));n:{for(n=n.nextSibling,e=0;n;){if(8===n.nodeType){var t=n.data;if("/$"===t){if(0===e){na=ao(n.nextSibling);break n}e--}else"$"!==t&&"$!"!==t&&"$?"!==t||e++}n=n.nextSibling}na=null}}else na=Qo?ao(n.stateNode.nextSibling):null;return!0}function la(){for(var n=na;n;)n=ao(n.nextSibling)}function sa(){na=Qo=null,ea=!1}function ua(n){null===ta?ta=[n]:ta.push(n)}var fa=b.ReactCurrentBatchConfig;function pa(n,e){if(n&&n.defaultProps){for(var t in e=O({},e),n=n.defaultProps)void 0===e[t]&&(e[t]=n[t]);return e}return e}var da=_o(null),ma=null,ha=null,xa=null;function ga(){xa=ha=ma=null}function ya(n){var e=da.current;Uo(da),n._currentValue=e}function ba(n,e,t){for(;null!==n;){var r=n.alternate;if((n.childLanes&e)!==e?(n.childLanes|=e,null!==r&&(r.childLanes|=e)):null!==r&&(r.childLanes&e)!==e&&(r.childLanes|=e),n===t)break;n=n.return}}function _a(n,e){ma=n,xa=ha=null,null!==(n=n.dependencies)&&null!==n.firstContext&&(0!==(n.lanes&e)&&(hv=!0),n.firstContext=null)}function Ua(n){var e=n._currentValue;if(xa!==n)if(n={context:n,memoizedValue:e,next:null},null===ha){if(null===ma)throw Error(a(308));ha=n,ma.dependencies={lanes:0,firstContext:n}}else ha=ha.next=n;return e}var wa=null;function Sa(n){null===wa?wa=[n]:wa.push(n)}function ka(n,e,t,r){var o=e.interleaved;return null===o?(t.next=t,Sa(e)):(t.next=o.next,o.next=t),e.interleaved=t,Ma(n,r)}function Ma(n,e){n.lanes|=e;var t=n.alternate;for(null!==t&&(t.lanes|=e),t=n,n=n.return;null!==n;)n.childLanes|=e,null!==(t=n.alternate)&&(t.childLanes|=e),t=n,n=n.return;return 3===t.tag?t.stateNode:null}var za=!1;function Ca(n){n.updateQueue={baseState:n.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Ta(n,e){n=n.updateQueue,e.updateQueue===n&&(e.updateQueue={baseState:n.baseState,firstBaseUpdate:n.firstBaseUpdate,lastBaseUpdate:n.lastBaseUpdate,shared:n.shared,effects:n.effects})}function Ra(n,e){return{eventTime:n,lane:e,tag:0,payload:null,callback:null,next:null}}function Da(n,e,t){var r=n.updateQueue;if(null===r)return null;if(r=r.shared,0!==(2&Sc)){var o=r.pending;return null===o?e.next=e:(e.next=o.next,o.next=e),r.pending=e,Ma(n,t)}return null===(o=r.interleaved)?(e.next=e,Sa(r)):(e.next=o.next,o.next=e),r.interleaved=e,Ma(n,t)}function Pa(n,e,t){if(null!==(e=e.updateQueue)&&(e=e.shared,0!==(4194240&t))){var r=e.lanes;t|=r&=n.pendingLanes,e.lanes=t,ge(n,t)}}function ja(n,e){var t=n.updateQueue,r=n.alternate;if(null!==r&&t===(r=r.updateQueue)){var o=null,a=null;if(null!==(t=t.firstBaseUpdate)){do{var i={eventTime:t.eventTime,lane:t.lane,tag:t.tag,payload:t.payload,callback:t.callback,next:null};null===a?o=a=i:a=a.next=i,t=t.next}while(null!==t);null===a?o=a=e:a=a.next=e}else o=a=e;return t={baseState:r.baseState,firstBaseUpdate:o,lastBaseUpdate:a,shared:r.shared,effects:r.effects},void(n.updateQueue=t)}null===(n=t.lastBaseUpdate)?t.firstBaseUpdate=e:n.next=e,t.lastBaseUpdate=e}function Fa(n,e,t,r){var o=n.updateQueue;za=!1;var a=o.firstBaseUpdate,i=o.lastBaseUpdate,v=o.shared.pending;if(null!==v){o.shared.pending=null;var c=v,l=c.next;c.next=null,null===i?a=l:i.next=l,i=c;var s=n.alternate;null!==s&&((v=(s=s.updateQueue).lastBaseUpdate)!==i&&(null===v?s.firstBaseUpdate=l:v.next=l,s.lastBaseUpdate=c))}if(null!==a){var u=o.baseState;for(i=0,s=l=c=null,v=a;;){var f=v.lane,p=v.eventTime;if((r&f)===f){null!==s&&(s=s.next={eventTime:p,lane:0,tag:v.tag,payload:v.payload,callback:v.callback,next:null});n:{var d=n,m=v;switch(f=e,p=t,m.tag){case 1:if("function"===typeof(d=m.payload)){u=d.call(p,u,f);break n}u=d;break n;case 3:d.flags=-65537&d.flags|128;case 0:if(null===(f="function"===typeof(d=m.payload)?d.call(p,u,f):d)||void 0===f)break n;u=O({},u,f);break n;case 2:za=!0}}null!==v.callback&&0!==v.lane&&(n.flags|=64,null===(f=o.effects)?o.effects=[v]:f.push(v))}else p={eventTime:p,lane:f,tag:v.tag,payload:v.payload,callback:v.callback,next:null},null===s?(l=s=p,c=u):s=s.next=p,i|=f;if(null===(v=v.next)){if(null===(v=o.shared.pending))break;v=(f=v).next,f.next=null,o.lastBaseUpdate=f,o.shared.pending=null}}if(null===s&&(c=u),o.baseState=c,o.firstBaseUpdate=l,o.lastBaseUpdate=s,null!==(e=o.shared.interleaved)){o=e;do{i|=o.lane,o=o.next}while(o!==e)}else null===a&&(o.shared.lanes=0);Pc|=i,n.lanes=i,n.memoizedState=u}}function Ea(n,e,t){if(n=e.effects,e.effects=null,null!==n)for(e=0;e<n.length;e++){var r=n[e],o=r.callback;if(null!==o){if(r.callback=null,r=t,"function"!==typeof o)throw Error(a(191,o));o.call(r)}}}var Ia=(new r.Component).refs;function Oa(n,e,t,r){t=null===(t=t(r,e=n.memoizedState))||void 0===t?e:O({},e,t),n.memoizedState=t,0===n.lanes&&(n.updateQueue.baseState=t)}var La={isMounted:function(n){return!!(n=n._reactInternals)&&Bn(n)===n},enqueueSetState:function(n,e,t){n=n._reactInternals;var r=Zc(),o=Kc(n),a=Ra(r,o);a.payload=e,void 0!==t&&null!==t&&(a.callback=t),null!==(e=Da(n,a,o))&&(Jc(e,n,o,r),Pa(e,n,o))},enqueueReplaceState:function(n,e,t){n=n._reactInternals;var r=Zc(),o=Kc(n),a=Ra(r,o);a.tag=1,a.payload=e,void 0!==t&&null!==t&&(a.callback=t),null!==(e=Da(n,a,o))&&(Jc(e,n,o,r),Pa(e,n,o))},enqueueForceUpdate:function(n,e){n=n._reactInternals;var t=Zc(),r=Kc(n),o=Ra(t,r);o.tag=2,void 0!==e&&null!==e&&(o.callback=e),null!==(e=Da(n,o,r))&&(Jc(e,n,r,t),Pa(e,n,r))}};function Aa(n,e,t,r,o,a,i){return"function"===typeof(n=n.stateNode).shouldComponentUpdate?n.shouldComponentUpdate(r,a,i):!e.prototype||!e.prototype.isPureReactComponent||(!or(t,r)||!or(o,a))}function Na(n,e,t){var r=!1,o=So,a=e.contextType;return"object"===typeof a&&null!==a?a=Ua(a):(o=To(e)?zo:ko.current,a=(r=null!==(r=e.contextTypes)&&void 0!==r)?Co(n,o):So),e=new e(t,a),n.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,e.updater=La,n.stateNode=e,e._reactInternals=n,r&&((n=n.stateNode).__reactInternalMemoizedUnmaskedChildContext=o,n.__reactInternalMemoizedMaskedChildContext=a),e}function Ga(n,e,t,r){n=e.state,"function"===typeof e.componentWillReceiveProps&&e.componentWillReceiveProps(t,r),"function"===typeof e.UNSAFE_componentWillReceiveProps&&e.UNSAFE_componentWillReceiveProps(t,r),e.state!==n&&La.enqueueReplaceState(e,e.state,null)}function Ba(n,e,t,r){var o=n.stateNode;o.props=t,o.state=n.memoizedState,o.refs=Ia,Ca(n);var a=e.contextType;"object"===typeof a&&null!==a?o.context=Ua(a):(a=To(e)?zo:ko.current,o.context=Co(n,a)),o.state=n.memoizedState,"function"===typeof(a=e.getDerivedStateFromProps)&&(Oa(n,e,a,t),o.state=n.memoizedState),"function"===typeof e.getDerivedStateFromProps||"function"===typeof o.getSnapshotBeforeUpdate||"function"!==typeof o.UNSAFE_componentWillMount&&"function"!==typeof o.componentWillMount||(e=o.state,"function"===typeof o.componentWillMount&&o.componentWillMount(),"function"===typeof o.UNSAFE_componentWillMount&&o.UNSAFE_componentWillMount(),e!==o.state&&La.enqueueReplaceState(o,o.state,null),Fa(n,t,o,r),o.state=n.memoizedState),"function"===typeof o.componentDidMount&&(n.flags|=4194308)}function qa(n,e,t){if(null!==(n=t.ref)&&"function"!==typeof n&&"object"!==typeof n){if(t._owner){if(t=t._owner){if(1!==t.tag)throw Error(a(309));var r=t.stateNode}if(!r)throw Error(a(147,n));var o=r,i=""+n;return null!==e&&null!==e.ref&&"function"===typeof e.ref&&e.ref._stringRef===i?e.ref:(e=function(n){var e=o.refs;e===Ia&&(e=o.refs={}),null===n?delete e[i]:e[i]=n},e._stringRef=i,e)}if("string"!==typeof n)throw Error(a(284));if(!t._owner)throw Error(a(290,n))}return n}function Va(n,e){throw n=Object.prototype.toString.call(e),Error(a(31,"[object Object]"===n?"object with keys {"+Object.keys(e).join(", ")+"}":n))}function Wa(n){return(0,n._init)(n._payload)}function Ha(n){function e(e,t){if(n){var r=e.deletions;null===r?(e.deletions=[t],e.flags|=16):r.push(t)}}function t(t,r){if(!n)return null;for(;null!==r;)e(t,r),r=r.sibling;return null}function r(n,e){for(n=new Map;null!==e;)null!==e.key?n.set(e.key,e):n.set(e.index,e),e=e.sibling;return n}function o(n,e){return(n=Tl(n,e)).index=0,n.sibling=null,n}function i(e,t,r){return e.index=r,n?null!==(r=e.alternate)?(r=r.index)<t?(e.flags|=2,t):r:(e.flags|=2,t):(e.flags|=1048576,t)}function v(e){return n&&null===e.alternate&&(e.flags|=2),e}function c(n,e,t,r){return null===e||6!==e.tag?((e=jl(t,n.mode,r)).return=n,e):((e=o(e,t)).return=n,e)}function l(n,e,t,r){var a=t.type;return a===w?u(n,e,t.props.children,r,t.key):null!==e&&(e.elementType===a||"object"===typeof a&&null!==a&&a.$$typeof===P&&Wa(a)===e.type)?((r=o(e,t.props)).ref=qa(n,e,t),r.return=n,r):((r=Rl(t.type,t.key,t.props,null,n.mode,r)).ref=qa(n,e,t),r.return=n,r)}function s(n,e,t,r){return null===e||4!==e.tag||e.stateNode.containerInfo!==t.containerInfo||e.stateNode.implementation!==t.implementation?((e=Fl(t,n.mode,r)).return=n,e):((e=o(e,t.children||[])).return=n,e)}function u(n,e,t,r,a){return null===e||7!==e.tag?((e=Dl(t,n.mode,r,a)).return=n,e):((e=o(e,t)).return=n,e)}function f(n,e,t){if("string"===typeof e&&""!==e||"number"===typeof e)return(e=jl(""+e,n.mode,t)).return=n,e;if("object"===typeof e&&null!==e){switch(e.$$typeof){case _:return(t=Rl(e.type,e.key,e.props,null,n.mode,t)).ref=qa(n,null,e),t.return=n,t;case U:return(e=Fl(e,n.mode,t)).return=n,e;case P:return f(n,(0,e._init)(e._payload),t)}if(en(e)||E(e))return(e=Dl(e,n.mode,t,null)).return=n,e;Va(n,e)}return null}function p(n,e,t,r){var o=null!==e?e.key:null;if("string"===typeof t&&""!==t||"number"===typeof t)return null!==o?null:c(n,e,""+t,r);if("object"===typeof t&&null!==t){switch(t.$$typeof){case _:return t.key===o?l(n,e,t,r):null;case U:return t.key===o?s(n,e,t,r):null;case P:return p(n,e,(o=t._init)(t._payload),r)}if(en(t)||E(t))return null!==o?null:u(n,e,t,r,null);Va(n,t)}return null}function d(n,e,t,r,o){if("string"===typeof r&&""!==r||"number"===typeof r)return c(e,n=n.get(t)||null,""+r,o);if("object"===typeof r&&null!==r){switch(r.$$typeof){case _:return l(e,n=n.get(null===r.key?t:r.key)||null,r,o);case U:return s(e,n=n.get(null===r.key?t:r.key)||null,r,o);case P:return d(n,e,t,(0,r._init)(r._payload),o)}if(en(r)||E(r))return u(e,n=n.get(t)||null,r,o,null);Va(e,r)}return null}function m(o,a,v,c){for(var l=null,s=null,u=a,m=a=0,h=null;null!==u&&m<v.length;m++){u.index>m?(h=u,u=null):h=u.sibling;var x=p(o,u,v[m],c);if(null===x){null===u&&(u=h);break}n&&u&&null===x.alternate&&e(o,u),a=i(x,a,m),null===s?l=x:s.sibling=x,s=x,u=h}if(m===v.length)return t(o,u),ea&&$o(o,m),l;if(null===u){for(;m<v.length;m++)null!==(u=f(o,v[m],c))&&(a=i(u,a,m),null===s?l=u:s.sibling=u,s=u);return ea&&$o(o,m),l}for(u=r(o,u);m<v.length;m++)null!==(h=d(u,o,m,v[m],c))&&(n&&null!==h.alternate&&u.delete(null===h.key?m:h.key),a=i(h,a,m),null===s?l=h:s.sibling=h,s=h);return n&&u.forEach((function(n){return e(o,n)})),ea&&$o(o,m),l}function h(o,v,c,l){var s=E(c);if("function"!==typeof s)throw Error(a(150));if(null==(c=s.call(c)))throw Error(a(151));for(var u=s=null,m=v,h=v=0,x=null,g=c.next();null!==m&&!g.done;h++,g=c.next()){m.index>h?(x=m,m=null):x=m.sibling;var y=p(o,m,g.value,l);if(null===y){null===m&&(m=x);break}n&&m&&null===y.alternate&&e(o,m),v=i(y,v,h),null===u?s=y:u.sibling=y,u=y,m=x}if(g.done)return t(o,m),ea&&$o(o,h),s;if(null===m){for(;!g.done;h++,g=c.next())null!==(g=f(o,g.value,l))&&(v=i(g,v,h),null===u?s=g:u.sibling=g,u=g);return ea&&$o(o,h),s}for(m=r(o,m);!g.done;h++,g=c.next())null!==(g=d(m,o,h,g.value,l))&&(n&&null!==g.alternate&&m.delete(null===g.key?h:g.key),v=i(g,v,h),null===u?s=g:u.sibling=g,u=g);return n&&m.forEach((function(n){return e(o,n)})),ea&&$o(o,h),s}return function n(r,a,i,c){if("object"===typeof i&&null!==i&&i.type===w&&null===i.key&&(i=i.props.children),"object"===typeof i&&null!==i){switch(i.$$typeof){case _:n:{for(var l=i.key,s=a;null!==s;){if(s.key===l){if((l=i.type)===w){if(7===s.tag){t(r,s.sibling),(a=o(s,i.props.children)).return=r,r=a;break n}}else if(s.elementType===l||"object"===typeof l&&null!==l&&l.$$typeof===P&&Wa(l)===s.type){t(r,s.sibling),(a=o(s,i.props)).ref=qa(r,s,i),a.return=r,r=a;break n}t(r,s);break}e(r,s),s=s.sibling}i.type===w?((a=Dl(i.props.children,r.mode,c,i.key)).return=r,r=a):((c=Rl(i.type,i.key,i.props,null,r.mode,c)).ref=qa(r,a,i),c.return=r,r=c)}return v(r);case U:n:{for(s=i.key;null!==a;){if(a.key===s){if(4===a.tag&&a.stateNode.containerInfo===i.containerInfo&&a.stateNode.implementation===i.implementation){t(r,a.sibling),(a=o(a,i.children||[])).return=r,r=a;break n}t(r,a);break}e(r,a),a=a.sibling}(a=Fl(i,r.mode,c)).return=r,r=a}return v(r);case P:return n(r,a,(s=i._init)(i._payload),c)}if(en(i))return m(r,a,i,c);if(E(i))return h(r,a,i,c);Va(r,i)}return"string"===typeof i&&""!==i||"number"===typeof i?(i=""+i,null!==a&&6===a.tag?(t(r,a.sibling),(a=o(a,i)).return=r,r=a):(t(r,a),(a=jl(i,r.mode,c)).return=r,r=a),v(r)):t(r,a)}}var Xa=Ha(!0),Ya=Ha(!1),$a={},Za=_o($a),Ka=_o($a),Ja=_o($a);function Qa(n){if(n===$a)throw Error(a(174));return n}function ni(n,e){switch(wo(Ja,e),wo(Ka,n),wo(Za,$a),n=e.nodeType){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:ln(null,"");break;default:e=ln(e=(n=8===n?e.parentNode:e).namespaceURI||null,n=n.tagName)}Uo(Za),wo(Za,e)}function ei(){Uo(Za),Uo(Ka),Uo(Ja)}function ti(n){Qa(Ja.current);var e=Qa(Za.current),t=ln(e,n.type);e!==t&&(wo(Ka,n),wo(Za,t))}function ri(n){Ka.current===n&&(Uo(Za),Uo(Ka))}var oi=_o(0);function ai(n){for(var e=n;null!==e;){if(13===e.tag){var t=e.memoizedState;if(null!==t&&(null===(t=t.dehydrated)||"$?"===t.data||"$!"===t.data))return e}else if(19===e.tag&&void 0!==e.memoizedProps.revealOrder){if(0!==(128&e.flags))return e}else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===n)break;for(;null===e.sibling;){if(null===e.return||e.return===n)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var ii=[];function vi(){for(var n=0;n<ii.length;n++)ii[n]._workInProgressVersionPrimary=null;ii.length=0}var ci=b.ReactCurrentDispatcher,li=b.ReactCurrentBatchConfig,si=0,ui=null,fi=null,pi=null,di=!1,mi=!1,hi=0,xi=0;function gi(){throw Error(a(321))}function yi(n,e){if(null===e)return!1;for(var t=0;t<e.length&&t<n.length;t++)if(!rr(n[t],e[t]))return!1;return!0}function bi(n,e,t,r,o,i){if(si=i,ui=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,ci.current=null===n||null===n.memoizedState?rv:ov,n=t(r,o),mi){i=0;do{if(mi=!1,hi=0,25<=i)throw Error(a(301));i+=1,pi=fi=null,e.updateQueue=null,ci.current=av,n=t(r,o)}while(mi)}if(ci.current=tv,e=null!==fi&&null!==fi.next,si=0,pi=fi=ui=null,di=!1,e)throw Error(a(300));return n}function _i(){var n=0!==hi;return hi=0,n}function Ui(){var n={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===pi?ui.memoizedState=pi=n:pi=pi.next=n,pi}function wi(){if(null===fi){var n=ui.alternate;n=null!==n?n.memoizedState:null}else n=fi.next;var e=null===pi?ui.memoizedState:pi.next;if(null!==e)pi=e,fi=n;else{if(null===n)throw Error(a(310));n={memoizedState:(fi=n).memoizedState,baseState:fi.baseState,baseQueue:fi.baseQueue,queue:fi.queue,next:null},null===pi?ui.memoizedState=pi=n:pi=pi.next=n}return pi}function Si(n,e){return"function"===typeof e?e(n):e}function ki(n){var e=wi(),t=e.queue;if(null===t)throw Error(a(311));t.lastRenderedReducer=n;var r=fi,o=r.baseQueue,i=t.pending;if(null!==i){if(null!==o){var v=o.next;o.next=i.next,i.next=v}r.baseQueue=o=i,t.pending=null}if(null!==o){i=o.next,r=r.baseState;var c=v=null,l=null,s=i;do{var u=s.lane;if((si&u)===u)null!==l&&(l=l.next={lane:0,action:s.action,hasEagerState:s.hasEagerState,eagerState:s.eagerState,next:null}),r=s.hasEagerState?s.eagerState:n(r,s.action);else{var f={lane:u,action:s.action,hasEagerState:s.hasEagerState,eagerState:s.eagerState,next:null};null===l?(c=l=f,v=r):l=l.next=f,ui.lanes|=u,Pc|=u}s=s.next}while(null!==s&&s!==i);null===l?v=r:l.next=c,rr(r,e.memoizedState)||(hv=!0),e.memoizedState=r,e.baseState=v,e.baseQueue=l,t.lastRenderedState=r}if(null!==(n=t.interleaved)){o=n;do{i=o.lane,ui.lanes|=i,Pc|=i,o=o.next}while(o!==n)}else null===o&&(t.lanes=0);return[e.memoizedState,t.dispatch]}function Mi(n){var e=wi(),t=e.queue;if(null===t)throw Error(a(311));t.lastRenderedReducer=n;var r=t.dispatch,o=t.pending,i=e.memoizedState;if(null!==o){t.pending=null;var v=o=o.next;do{i=n(i,v.action),v=v.next}while(v!==o);rr(i,e.memoizedState)||(hv=!0),e.memoizedState=i,null===e.baseQueue&&(e.baseState=i),t.lastRenderedState=i}return[i,r]}function zi(){}function Ci(n,e){var t=ui,r=wi(),o=e(),i=!rr(r.memoizedState,o);if(i&&(r.memoizedState=o,hv=!0),r=r.queue,Ni(Di.bind(null,t,r,n),[n]),r.getSnapshot!==e||i||null!==pi&&1&pi.memoizedState.tag){if(t.flags|=2048,Ei(9,Ri.bind(null,t,r,o,e),void 0,null),null===kc)throw Error(a(349));0!==(30&si)||Ti(t,e,o)}return o}function Ti(n,e,t){n.flags|=16384,n={getSnapshot:e,value:t},null===(e=ui.updateQueue)?(e={lastEffect:null,stores:null},ui.updateQueue=e,e.stores=[n]):null===(t=e.stores)?e.stores=[n]:t.push(n)}function Ri(n,e,t,r){e.value=t,e.getSnapshot=r,Pi(e)&&ji(n)}function Di(n,e,t){return t((function(){Pi(e)&&ji(n)}))}function Pi(n){var e=n.getSnapshot;n=n.value;try{var t=e();return!rr(n,t)}catch(r){return!0}}function ji(n){var e=Ma(n,1);null!==e&&Jc(e,n,1,-1)}function Fi(n){var e=Ui();return"function"===typeof n&&(n=n()),e.memoizedState=e.baseState=n,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Si,lastRenderedState:n},e.queue=n,n=n.dispatch=Ji.bind(null,ui,n),[e.memoizedState,n]}function Ei(n,e,t,r){return n={tag:n,create:e,destroy:t,deps:r,next:null},null===(e=ui.updateQueue)?(e={lastEffect:null,stores:null},ui.updateQueue=e,e.lastEffect=n.next=n):null===(t=e.lastEffect)?e.lastEffect=n.next=n:(r=t.next,t.next=n,n.next=r,e.lastEffect=n),n}function Ii(){return wi().memoizedState}function Oi(n,e,t,r){var o=Ui();ui.flags|=n,o.memoizedState=Ei(1|e,t,void 0,void 0===r?null:r)}function Li(n,e,t,r){var o=wi();r=void 0===r?null:r;var a=void 0;if(null!==fi){var i=fi.memoizedState;if(a=i.destroy,null!==r&&yi(r,i.deps))return void(o.memoizedState=Ei(e,t,a,r))}ui.flags|=n,o.memoizedState=Ei(1|e,t,a,r)}function Ai(n,e){return Oi(8390656,8,n,e)}function Ni(n,e){return Li(2048,8,n,e)}function Gi(n,e){return Li(4,2,n,e)}function Bi(n,e){return Li(4,4,n,e)}function qi(n,e){return"function"===typeof e?(n=n(),e(n),function(){e(null)}):null!==e&&void 0!==e?(n=n(),e.current=n,function(){e.current=null}):void 0}function Vi(n,e,t){return t=null!==t&&void 0!==t?t.concat([n]):null,Li(4,4,qi.bind(null,e,n),t)}function Wi(){}function Hi(n,e){var t=wi();e=void 0===e?null:e;var r=t.memoizedState;return null!==r&&null!==e&&yi(e,r[1])?r[0]:(t.memoizedState=[n,e],n)}function Xi(n,e){var t=wi();e=void 0===e?null:e;var r=t.memoizedState;return null!==r&&null!==e&&yi(e,r[1])?r[0]:(n=n(),t.memoizedState=[n,e],n)}function Yi(n,e,t){return 0===(21&si)?(n.baseState&&(n.baseState=!1,hv=!0),n.memoizedState=t):(rr(t,e)||(t=me(),ui.lanes|=t,Pc|=t,n.baseState=!0),e)}function $i(n,e){var t=ye;ye=0!==t&&4>t?t:4,n(!0);var r=li.transition;li.transition={};try{n(!1),e()}finally{ye=t,li.transition=r}}function Zi(){return wi().memoizedState}function Ki(n,e,t){var r=Kc(n);if(t={lane:r,action:t,hasEagerState:!1,eagerState:null,next:null},Qi(n))nv(e,t);else if(null!==(t=ka(n,e,t,r))){Jc(t,n,r,Zc()),ev(t,e,r)}}function Ji(n,e,t){var r=Kc(n),o={lane:r,action:t,hasEagerState:!1,eagerState:null,next:null};if(Qi(n))nv(e,o);else{var a=n.alternate;if(0===n.lanes&&(null===a||0===a.lanes)&&null!==(a=e.lastRenderedReducer))try{var i=e.lastRenderedState,v=a(i,t);if(o.hasEagerState=!0,o.eagerState=v,rr(v,i)){var c=e.interleaved;return null===c?(o.next=o,Sa(e)):(o.next=c.next,c.next=o),void(e.interleaved=o)}}catch(l){}null!==(t=ka(n,e,o,r))&&(Jc(t,n,r,o=Zc()),ev(t,e,r))}}function Qi(n){var e=n.alternate;return n===ui||null!==e&&e===ui}function nv(n,e){mi=di=!0;var t=n.pending;null===t?e.next=e:(e.next=t.next,t.next=e),n.pending=e}function ev(n,e,t){if(0!==(4194240&t)){var r=e.lanes;t|=r&=n.pendingLanes,e.lanes=t,ge(n,t)}}var tv={readContext:Ua,useCallback:gi,useContext:gi,useEffect:gi,useImperativeHandle:gi,useInsertionEffect:gi,useLayoutEffect:gi,useMemo:gi,useReducer:gi,useRef:gi,useState:gi,useDebugValue:gi,useDeferredValue:gi,useTransition:gi,useMutableSource:gi,useSyncExternalStore:gi,useId:gi,unstable_isNewReconciler:!1},rv={readContext:Ua,useCallback:function(n,e){return Ui().memoizedState=[n,void 0===e?null:e],n},useContext:Ua,useEffect:Ai,useImperativeHandle:function(n,e,t){return t=null!==t&&void 0!==t?t.concat([n]):null,Oi(4194308,4,qi.bind(null,e,n),t)},useLayoutEffect:function(n,e){return Oi(4194308,4,n,e)},useInsertionEffect:function(n,e){return Oi(4,2,n,e)},useMemo:function(n,e){var t=Ui();return e=void 0===e?null:e,n=n(),t.memoizedState=[n,e],n},useReducer:function(n,e,t){var r=Ui();return e=void 0!==t?t(e):e,r.memoizedState=r.baseState=e,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:n,lastRenderedState:e},r.queue=n,n=n.dispatch=Ki.bind(null,ui,n),[r.memoizedState,n]},useRef:function(n){return n={current:n},Ui().memoizedState=n},useState:Fi,useDebugValue:Wi,useDeferredValue:function(n){return Ui().memoizedState=n},useTransition:function(){var n=Fi(!1),e=n[0];return n=$i.bind(null,n[1]),Ui().memoizedState=n,[e,n]},useMutableSource:function(){},useSyncExternalStore:function(n,e,t){var r=ui,o=Ui();if(ea){if(void 0===t)throw Error(a(407));t=t()}else{if(t=e(),null===kc)throw Error(a(349));0!==(30&si)||Ti(r,e,t)}o.memoizedState=t;var i={value:t,getSnapshot:e};return o.queue=i,Ai(Di.bind(null,r,i,n),[n]),r.flags|=2048,Ei(9,Ri.bind(null,r,i,t,e),void 0,null),t},useId:function(){var n=Ui(),e=kc.identifierPrefix;if(ea){var t=Yo;e=":"+e+"R"+(t=(Xo&~(1<<32-ie(Xo)-1)).toString(32)+t),0<(t=hi++)&&(e+="H"+t.toString(32)),e+=":"}else e=":"+e+"r"+(t=xi++).toString(32)+":";return n.memoizedState=e},unstable_isNewReconciler:!1},ov={readContext:Ua,useCallback:Hi,useContext:Ua,useEffect:Ni,useImperativeHandle:Vi,useInsertionEffect:Gi,useLayoutEffect:Bi,useMemo:Xi,useReducer:ki,useRef:Ii,useState:function(){return ki(Si)},useDebugValue:Wi,useDeferredValue:function(n){return Yi(wi(),fi.memoizedState,n)},useTransition:function(){return[ki(Si)[0],wi().memoizedState]},useMutableSource:zi,useSyncExternalStore:Ci,useId:Zi,unstable_isNewReconciler:!1},av={readContext:Ua,useCallback:Hi,useContext:Ua,useEffect:Ni,useImperativeHandle:Vi,useInsertionEffect:Gi,useLayoutEffect:Bi,useMemo:Xi,useReducer:Mi,useRef:Ii,useState:function(){return Mi(Si)},useDebugValue:Wi,useDeferredValue:function(n){var e=wi();return null===fi?e.memoizedState=n:Yi(e,fi.memoizedState,n)},useTransition:function(){return[Mi(Si)[0],wi().memoizedState]},useMutableSource:zi,useSyncExternalStore:Ci,useId:Zi,unstable_isNewReconciler:!1};function iv(n,e){try{var t="",r=e;do{t+=G(r),r=r.return}while(r);var o=t}catch(a){o="\nError generating stack: "+a.message+"\n"+a.stack}return{value:n,source:e,stack:o,digest:null}}function vv(n,e,t){return{value:n,source:null,stack:null!=t?t:null,digest:null!=e?e:null}}function cv(n,e){try{console.error(e.value)}catch(t){setTimeout((function(){throw t}))}}var lv="function"===typeof WeakMap?WeakMap:Map;function sv(n,e,t){(t=Ra(-1,t)).tag=3,t.payload={element:null};var r=e.value;return t.callback=function(){Nc||(Nc=!0,Gc=r),cv(0,e)},t}function uv(n,e,t){(t=Ra(-1,t)).tag=3;var r=n.type.getDerivedStateFromError;if("function"===typeof r){var o=e.value;t.payload=function(){return r(o)},t.callback=function(){cv(0,e)}}var a=n.stateNode;return null!==a&&"function"===typeof a.componentDidCatch&&(t.callback=function(){cv(0,e),"function"!==typeof r&&(null===Bc?Bc=new Set([this]):Bc.add(this));var n=e.stack;this.componentDidCatch(e.value,{componentStack:null!==n?n:""})}),t}function fv(n,e,t){var r=n.pingCache;if(null===r){r=n.pingCache=new lv;var o=new Set;r.set(e,o)}else void 0===(o=r.get(e))&&(o=new Set,r.set(e,o));o.has(t)||(o.add(t),n=_l.bind(null,n,e,t),e.then(n,n))}function pv(n){do{var e;if((e=13===n.tag)&&(e=null===(e=n.memoizedState)||null!==e.dehydrated),e)return n;n=n.return}while(null!==n);return null}function dv(n,e,t,r,o){return 0===(1&n.mode)?(n===e?n.flags|=65536:(n.flags|=128,t.flags|=131072,t.flags&=-52805,1===t.tag&&(null===t.alternate?t.tag=17:((e=Ra(-1,1)).tag=2,Da(t,e,1))),t.lanes|=1),n):(n.flags|=65536,n.lanes=o,n)}var mv=b.ReactCurrentOwner,hv=!1;function xv(n,e,t,r){e.child=null===n?Ya(e,null,t,r):Xa(e,n.child,t,r)}function gv(n,e,t,r,o){t=t.render;var a=e.ref;return _a(e,o),r=bi(n,e,t,r,a,o),t=_i(),null===n||hv?(ea&&t&&Ko(e),e.flags|=1,xv(n,e,r,o),e.child):(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~o,Nv(n,e,o))}function yv(n,e,t,r,o){if(null===n){var a=t.type;return"function"!==typeof a||Cl(a)||void 0!==a.defaultProps||null!==t.compare||void 0!==t.defaultProps?((n=Rl(t.type,null,r,e,e.mode,o)).ref=e.ref,n.return=e,e.child=n):(e.tag=15,e.type=a,bv(n,e,a,r,o))}if(a=n.child,0===(n.lanes&o)){var i=a.memoizedProps;if((t=null!==(t=t.compare)?t:or)(i,r)&&n.ref===e.ref)return Nv(n,e,o)}return e.flags|=1,(n=Tl(a,r)).ref=e.ref,n.return=e,e.child=n}function bv(n,e,t,r,o){if(null!==n){var a=n.memoizedProps;if(or(a,r)&&n.ref===e.ref){if(hv=!1,e.pendingProps=r=a,0===(n.lanes&o))return e.lanes=n.lanes,Nv(n,e,o);0!==(131072&n.flags)&&(hv=!0)}}return wv(n,e,t,r,o)}function _v(n,e,t){var r=e.pendingProps,o=r.children,a=null!==n?n.memoizedState:null;if("hidden"===r.mode)if(0===(1&e.mode))e.memoizedState={baseLanes:0,cachePool:null,transitions:null},wo(Tc,Cc),Cc|=t;else{if(0===(1073741824&t))return n=null!==a?a.baseLanes|t:t,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:n,cachePool:null,transitions:null},e.updateQueue=null,wo(Tc,Cc),Cc|=n,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=null!==a?a.baseLanes:t,wo(Tc,Cc),Cc|=r}else null!==a?(r=a.baseLanes|t,e.memoizedState=null):r=t,wo(Tc,Cc),Cc|=r;return xv(n,e,o,t),e.child}function Uv(n,e){var t=e.ref;(null===n&&null!==t||null!==n&&n.ref!==t)&&(e.flags|=512,e.flags|=2097152)}function wv(n,e,t,r,o){var a=To(t)?zo:ko.current;return a=Co(e,a),_a(e,o),t=bi(n,e,t,r,a,o),r=_i(),null===n||hv?(ea&&r&&Ko(e),e.flags|=1,xv(n,e,t,o),e.child):(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~o,Nv(n,e,o))}function Sv(n,e,t,r,o){if(To(t)){var a=!0;jo(e)}else a=!1;if(_a(e,o),null===e.stateNode)Av(n,e),Na(e,t,r),Ba(e,t,r,o),r=!0;else if(null===n){var i=e.stateNode,v=e.memoizedProps;i.props=v;var c=i.context,l=t.contextType;"object"===typeof l&&null!==l?l=Ua(l):l=Co(e,l=To(t)?zo:ko.current);var s=t.getDerivedStateFromProps,u="function"===typeof s||"function"===typeof i.getSnapshotBeforeUpdate;u||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(v!==r||c!==l)&&Ga(e,i,r,l),za=!1;var f=e.memoizedState;i.state=f,Fa(e,r,i,o),c=e.memoizedState,v!==r||f!==c||Mo.current||za?("function"===typeof s&&(Oa(e,t,s,r),c=e.memoizedState),(v=za||Aa(e,t,v,r,f,c,l))?(u||"function"!==typeof i.UNSAFE_componentWillMount&&"function"!==typeof i.componentWillMount||("function"===typeof i.componentWillMount&&i.componentWillMount(),"function"===typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount()),"function"===typeof i.componentDidMount&&(e.flags|=4194308)):("function"===typeof i.componentDidMount&&(e.flags|=4194308),e.memoizedProps=r,e.memoizedState=c),i.props=r,i.state=c,i.context=l,r=v):("function"===typeof i.componentDidMount&&(e.flags|=4194308),r=!1)}else{i=e.stateNode,Ta(n,e),v=e.memoizedProps,l=e.type===e.elementType?v:pa(e.type,v),i.props=l,u=e.pendingProps,f=i.context,"object"===typeof(c=t.contextType)&&null!==c?c=Ua(c):c=Co(e,c=To(t)?zo:ko.current);var p=t.getDerivedStateFromProps;(s="function"===typeof p||"function"===typeof i.getSnapshotBeforeUpdate)||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(v!==u||f!==c)&&Ga(e,i,r,c),za=!1,f=e.memoizedState,i.state=f,Fa(e,r,i,o);var d=e.memoizedState;v!==u||f!==d||Mo.current||za?("function"===typeof p&&(Oa(e,t,p,r),d=e.memoizedState),(l=za||Aa(e,t,l,r,f,d,c)||!1)?(s||"function"!==typeof i.UNSAFE_componentWillUpdate&&"function"!==typeof i.componentWillUpdate||("function"===typeof i.componentWillUpdate&&i.componentWillUpdate(r,d,c),"function"===typeof i.UNSAFE_componentWillUpdate&&i.UNSAFE_componentWillUpdate(r,d,c)),"function"===typeof i.componentDidUpdate&&(e.flags|=4),"function"===typeof i.getSnapshotBeforeUpdate&&(e.flags|=1024)):("function"!==typeof i.componentDidUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=1024),e.memoizedProps=r,e.memoizedState=d),i.props=r,i.state=d,i.context=c,r=l):("function"!==typeof i.componentDidUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=1024),r=!1)}return kv(n,e,t,r,a,o)}function kv(n,e,t,r,o,a){Uv(n,e);var i=0!==(128&e.flags);if(!r&&!i)return o&&Fo(e,t,!1),Nv(n,e,a);r=e.stateNode,mv.current=e;var v=i&&"function"!==typeof t.getDerivedStateFromError?null:r.render();return e.flags|=1,null!==n&&i?(e.child=Xa(e,n.child,null,a),e.child=Xa(e,null,v,a)):xv(n,e,v,a),e.memoizedState=r.state,o&&Fo(e,t,!0),e.child}function Mv(n){var e=n.stateNode;e.pendingContext?Do(0,e.pendingContext,e.pendingContext!==e.context):e.context&&Do(0,e.context,!1),ni(n,e.containerInfo)}function zv(n,e,t,r,o){return sa(),ua(o),e.flags|=256,xv(n,e,t,r),e.child}var Cv,Tv,Rv,Dv={dehydrated:null,treeContext:null,retryLane:0};function Pv(n){return{baseLanes:n,cachePool:null,transitions:null}}function jv(n,e,t){var r,o=e.pendingProps,i=oi.current,v=!1,c=0!==(128&e.flags);if((r=c)||(r=(null===n||null!==n.memoizedState)&&0!==(2&i)),r?(v=!0,e.flags&=-129):null!==n&&null===n.memoizedState||(i|=1),wo(oi,1&i),null===n)return ia(e),null!==(n=e.memoizedState)&&null!==(n=n.dehydrated)?(0===(1&e.mode)?e.lanes=1:"$!"===n.data?e.lanes=8:e.lanes=1073741824,null):(c=o.children,n=o.fallback,v?(o=e.mode,v=e.child,c={mode:"hidden",children:c},0===(1&o)&&null!==v?(v.childLanes=0,v.pendingProps=c):v=Pl(c,o,0,null),n=Dl(n,o,t,null),v.return=e,n.return=e,v.sibling=n,e.child=v,e.child.memoizedState=Pv(t),e.memoizedState=Dv,n):Fv(e,c));if(null!==(i=n.memoizedState)&&null!==(r=i.dehydrated))return function(n,e,t,r,o,i,v){if(t)return 256&e.flags?(e.flags&=-257,Ev(n,e,v,r=vv(Error(a(422))))):null!==e.memoizedState?(e.child=n.child,e.flags|=128,null):(i=r.fallback,o=e.mode,r=Pl({mode:"visible",children:r.children},o,0,null),(i=Dl(i,o,v,null)).flags|=2,r.return=e,i.return=e,r.sibling=i,e.child=r,0!==(1&e.mode)&&Xa(e,n.child,null,v),e.child.memoizedState=Pv(v),e.memoizedState=Dv,i);if(0===(1&e.mode))return Ev(n,e,v,null);if("$!"===o.data){if(r=o.nextSibling&&o.nextSibling.dataset)var c=r.dgst;return r=c,Ev(n,e,v,r=vv(i=Error(a(419)),r,void 0))}if(c=0!==(v&n.childLanes),hv||c){if(null!==(r=kc)){switch(v&-v){case 4:o=2;break;case 16:o=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:o=32;break;case 536870912:o=268435456;break;default:o=0}0!==(o=0!==(o&(r.suspendedLanes|v))?0:o)&&o!==i.retryLane&&(i.retryLane=o,Ma(n,o),Jc(r,n,o,-1))}return ul(),Ev(n,e,v,r=vv(Error(a(421))))}return"$?"===o.data?(e.flags|=128,e.child=n.child,e=wl.bind(null,n),o._reactRetry=e,null):(n=i.treeContext,na=ao(o.nextSibling),Qo=e,ea=!0,ta=null,null!==n&&(Vo[Wo++]=Xo,Vo[Wo++]=Yo,Vo[Wo++]=Ho,Xo=n.id,Yo=n.overflow,Ho=e),(e=Fv(e,r.children)).flags|=4096,e)}(n,e,c,o,r,i,t);if(v){v=o.fallback,c=e.mode,r=(i=n.child).sibling;var l={mode:"hidden",children:o.children};return 0===(1&c)&&e.child!==i?((o=e.child).childLanes=0,o.pendingProps=l,e.deletions=null):(o=Tl(i,l)).subtreeFlags=14680064&i.subtreeFlags,null!==r?v=Tl(r,v):(v=Dl(v,c,t,null)).flags|=2,v.return=e,o.return=e,o.sibling=v,e.child=o,o=v,v=e.child,c=null===(c=n.child.memoizedState)?Pv(t):{baseLanes:c.baseLanes|t,cachePool:null,transitions:c.transitions},v.memoizedState=c,v.childLanes=n.childLanes&~t,e.memoizedState=Dv,o}return n=(v=n.child).sibling,o=Tl(v,{mode:"visible",children:o.children}),0===(1&e.mode)&&(o.lanes=t),o.return=e,o.sibling=null,null!==n&&(null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)),e.child=o,e.memoizedState=null,o}function Fv(n,e){return(e=Pl({mode:"visible",children:e},n.mode,0,null)).return=n,n.child=e}function Ev(n,e,t,r){return null!==r&&ua(r),Xa(e,n.child,null,t),(n=Fv(e,e.pendingProps.children)).flags|=2,e.memoizedState=null,n}function Iv(n,e,t){n.lanes|=e;var r=n.alternate;null!==r&&(r.lanes|=e),ba(n.return,e,t)}function Ov(n,e,t,r,o){var a=n.memoizedState;null===a?n.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:r,tail:t,tailMode:o}:(a.isBackwards=e,a.rendering=null,a.renderingStartTime=0,a.last=r,a.tail=t,a.tailMode=o)}function Lv(n,e,t){var r=e.pendingProps,o=r.revealOrder,a=r.tail;if(xv(n,e,r.children,t),0!==(2&(r=oi.current)))r=1&r|2,e.flags|=128;else{if(null!==n&&0!==(128&n.flags))n:for(n=e.child;null!==n;){if(13===n.tag)null!==n.memoizedState&&Iv(n,t,e);else if(19===n.tag)Iv(n,t,e);else if(null!==n.child){n.child.return=n,n=n.child;continue}if(n===e)break n;for(;null===n.sibling;){if(null===n.return||n.return===e)break n;n=n.return}n.sibling.return=n.return,n=n.sibling}r&=1}if(wo(oi,r),0===(1&e.mode))e.memoizedState=null;else switch(o){case"forwards":for(t=e.child,o=null;null!==t;)null!==(n=t.alternate)&&null===ai(n)&&(o=t),t=t.sibling;null===(t=o)?(o=e.child,e.child=null):(o=t.sibling,t.sibling=null),Ov(e,!1,o,t,a);break;case"backwards":for(t=null,o=e.child,e.child=null;null!==o;){if(null!==(n=o.alternate)&&null===ai(n)){e.child=o;break}n=o.sibling,o.sibling=t,t=o,o=n}Ov(e,!0,t,null,a);break;case"together":Ov(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function Av(n,e){0===(1&e.mode)&&null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2)}function Nv(n,e,t){if(null!==n&&(e.dependencies=n.dependencies),Pc|=e.lanes,0===(t&e.childLanes))return null;if(null!==n&&e.child!==n.child)throw Error(a(153));if(null!==e.child){for(t=Tl(n=e.child,n.pendingProps),e.child=t,t.return=e;null!==n.sibling;)n=n.sibling,(t=t.sibling=Tl(n,n.pendingProps)).return=e;t.sibling=null}return e.child}function Gv(n,e){if(!ea)switch(n.tailMode){case"hidden":e=n.tail;for(var t=null;null!==e;)null!==e.alternate&&(t=e),e=e.sibling;null===t?n.tail=null:t.sibling=null;break;case"collapsed":t=n.tail;for(var r=null;null!==t;)null!==t.alternate&&(r=t),t=t.sibling;null===r?e||null===n.tail?n.tail=null:n.tail.sibling=null:r.sibling=null}}function Bv(n){var e=null!==n.alternate&&n.alternate.child===n.child,t=0,r=0;if(e)for(var o=n.child;null!==o;)t|=o.lanes|o.childLanes,r|=14680064&o.subtreeFlags,r|=14680064&o.flags,o.return=n,o=o.sibling;else for(o=n.child;null!==o;)t|=o.lanes|o.childLanes,r|=o.subtreeFlags,r|=o.flags,o.return=n,o=o.sibling;return n.subtreeFlags|=r,n.childLanes=t,e}function qv(n,e,t){var r=e.pendingProps;switch(Jo(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Bv(e),null;case 1:case 17:return To(e.type)&&Ro(),Bv(e),null;case 3:return r=e.stateNode,ei(),Uo(Mo),Uo(ko),vi(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),null!==n&&null!==n.child||(ca(e)?e.flags|=4:null===n||n.memoizedState.isDehydrated&&0===(256&e.flags)||(e.flags|=1024,null!==ta&&(tl(ta),ta=null))),Bv(e),null;case 5:ri(e);var o=Qa(Ja.current);if(t=e.type,null!==n&&null!=e.stateNode)Tv(n,e,t,r),n.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!r){if(null===e.stateNode)throw Error(a(166));return Bv(e),null}if(n=Qa(Za.current),ca(e)){r=e.stateNode,t=e.type;var i=e.memoizedProps;switch(r[co]=e,r[lo]=i,n=0!==(1&e.mode),t){case"dialog":Er("cancel",r),Er("close",r);break;case"iframe":case"object":case"embed":Er("load",r);break;case"video":case"audio":for(o=0;o<Dr.length;o++)Er(Dr[o],r);break;case"source":Er("error",r);break;case"img":case"image":case"link":Er("error",r),Er("load",r);break;case"details":Er("toggle",r);break;case"input":Z(r,i),Er("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!i.multiple},Er("invalid",r);break;case"textarea":on(r,i),Er("invalid",r)}for(var c in gn(t,i),o=null,i)if(i.hasOwnProperty(c)){var l=i[c];"children"===c?"string"===typeof l?r.textContent!==l&&(!0!==i.suppressHydrationWarning&&Yr(r.textContent,l,n),o=["children",l]):"number"===typeof l&&r.textContent!==""+l&&(!0!==i.suppressHydrationWarning&&Yr(r.textContent,l,n),o=["children",""+l]):v.hasOwnProperty(c)&&null!=l&&"onScroll"===c&&Er("scroll",r)}switch(t){case"input":H(r),Q(r,i,!0);break;case"textarea":H(r),vn(r);break;case"select":case"option":break;default:"function"===typeof i.onClick&&(r.onclick=$r)}r=o,e.updateQueue=r,null!==r&&(e.flags|=4)}else{c=9===o.nodeType?o:o.ownerDocument,"http://www.w3.org/1999/xhtml"===n&&(n=cn(t)),"http://www.w3.org/1999/xhtml"===n?"script"===t?((n=c.createElement("div")).innerHTML="<script><\/script>",n=n.removeChild(n.firstChild)):"string"===typeof r.is?n=c.createElement(t,{is:r.is}):(n=c.createElement(t),"select"===t&&(c=n,r.multiple?c.multiple=!0:r.size&&(c.size=r.size))):n=c.createElementNS(n,t),n[co]=e,n[lo]=r,Cv(n,e),e.stateNode=n;n:{switch(c=yn(t,r),t){case"dialog":Er("cancel",n),Er("close",n),o=r;break;case"iframe":case"object":case"embed":Er("load",n),o=r;break;case"video":case"audio":for(o=0;o<Dr.length;o++)Er(Dr[o],n);o=r;break;case"source":Er("error",n),o=r;break;case"img":case"image":case"link":Er("error",n),Er("load",n),o=r;break;case"details":Er("toggle",n),o=r;break;case"input":Z(n,r),o=$(n,r),Er("invalid",n);break;case"option":default:o=r;break;case"select":n._wrapperState={wasMultiple:!!r.multiple},o=O({},r,{value:void 0}),Er("invalid",n);break;case"textarea":on(n,r),o=rn(n,r),Er("invalid",n)}for(i in gn(t,o),l=o)if(l.hasOwnProperty(i)){var s=l[i];"style"===i?hn(n,s):"dangerouslySetInnerHTML"===i?null!=(s=s?s.__html:void 0)&&un(n,s):"children"===i?"string"===typeof s?("textarea"!==t||""!==s)&&fn(n,s):"number"===typeof s&&fn(n,""+s):"suppressContentEditableWarning"!==i&&"suppressHydrationWarning"!==i&&"autoFocus"!==i&&(v.hasOwnProperty(i)?null!=s&&"onScroll"===i&&Er("scroll",n):null!=s&&y(n,i,s,c))}switch(t){case"input":H(n),Q(n,r,!1);break;case"textarea":H(n),vn(n);break;case"option":null!=r.value&&n.setAttribute("value",""+V(r.value));break;case"select":n.multiple=!!r.multiple,null!=(i=r.value)?tn(n,!!r.multiple,i,!1):null!=r.defaultValue&&tn(n,!!r.multiple,r.defaultValue,!0);break;default:"function"===typeof o.onClick&&(n.onclick=$r)}switch(t){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break n;case"img":r=!0;break n;default:r=!1}}r&&(e.flags|=4)}null!==e.ref&&(e.flags|=512,e.flags|=2097152)}return Bv(e),null;case 6:if(n&&null!=e.stateNode)Rv(0,e,n.memoizedProps,r);else{if("string"!==typeof r&&null===e.stateNode)throw Error(a(166));if(t=Qa(Ja.current),Qa(Za.current),ca(e)){if(r=e.stateNode,t=e.memoizedProps,r[co]=e,(i=r.nodeValue!==t)&&null!==(n=Qo))switch(n.tag){case 3:Yr(r.nodeValue,t,0!==(1&n.mode));break;case 5:!0!==n.memoizedProps.suppressHydrationWarning&&Yr(r.nodeValue,t,0!==(1&n.mode))}i&&(e.flags|=4)}else(r=(9===t.nodeType?t:t.ownerDocument).createTextNode(r))[co]=e,e.stateNode=r}return Bv(e),null;case 13:if(Uo(oi),r=e.memoizedState,null===n||null!==n.memoizedState&&null!==n.memoizedState.dehydrated){if(ea&&null!==na&&0!==(1&e.mode)&&0===(128&e.flags))la(),sa(),e.flags|=98560,i=!1;else if(i=ca(e),null!==r&&null!==r.dehydrated){if(null===n){if(!i)throw Error(a(318));if(!(i=null!==(i=e.memoizedState)?i.dehydrated:null))throw Error(a(317));i[co]=e}else sa(),0===(128&e.flags)&&(e.memoizedState=null),e.flags|=4;Bv(e),i=!1}else null!==ta&&(tl(ta),ta=null),i=!0;if(!i)return 65536&e.flags?e:null}return 0!==(128&e.flags)?(e.lanes=t,e):((r=null!==r)!==(null!==n&&null!==n.memoizedState)&&r&&(e.child.flags|=8192,0!==(1&e.mode)&&(null===n||0!==(1&oi.current)?0===Rc&&(Rc=3):ul())),null!==e.updateQueue&&(e.flags|=4),Bv(e),null);case 4:return ei(),null===n&&Lr(e.stateNode.containerInfo),Bv(e),null;case 10:return ya(e.type._context),Bv(e),null;case 19:if(Uo(oi),null===(i=e.memoizedState))return Bv(e),null;if(r=0!==(128&e.flags),null===(c=i.rendering))if(r)Gv(i,!1);else{if(0!==Rc||null!==n&&0!==(128&n.flags))for(n=e.child;null!==n;){if(null!==(c=ai(n))){for(e.flags|=128,Gv(i,!1),null!==(r=c.updateQueue)&&(e.updateQueue=r,e.flags|=4),e.subtreeFlags=0,r=t,t=e.child;null!==t;)n=r,(i=t).flags&=14680066,null===(c=i.alternate)?(i.childLanes=0,i.lanes=n,i.child=null,i.subtreeFlags=0,i.memoizedProps=null,i.memoizedState=null,i.updateQueue=null,i.dependencies=null,i.stateNode=null):(i.childLanes=c.childLanes,i.lanes=c.lanes,i.child=c.child,i.subtreeFlags=0,i.deletions=null,i.memoizedProps=c.memoizedProps,i.memoizedState=c.memoizedState,i.updateQueue=c.updateQueue,i.type=c.type,n=c.dependencies,i.dependencies=null===n?null:{lanes:n.lanes,firstContext:n.firstContext}),t=t.sibling;return wo(oi,1&oi.current|2),e.child}n=n.sibling}null!==i.tail&&Kn()>Lc&&(e.flags|=128,r=!0,Gv(i,!1),e.lanes=4194304)}else{if(!r)if(null!==(n=ai(c))){if(e.flags|=128,r=!0,null!==(t=n.updateQueue)&&(e.updateQueue=t,e.flags|=4),Gv(i,!0),null===i.tail&&"hidden"===i.tailMode&&!c.alternate&&!ea)return Bv(e),null}else 2*Kn()-i.renderingStartTime>Lc&&1073741824!==t&&(e.flags|=128,r=!0,Gv(i,!1),e.lanes=4194304);i.isBackwards?(c.sibling=e.child,e.child=c):(null!==(t=i.last)?t.sibling=c:e.child=c,i.last=c)}return null!==i.tail?(e=i.tail,i.rendering=e,i.tail=e.sibling,i.renderingStartTime=Kn(),e.sibling=null,t=oi.current,wo(oi,r?1&t|2:1&t),e):(Bv(e),null);case 22:case 23:return vl(),r=null!==e.memoizedState,null!==n&&null!==n.memoizedState!==r&&(e.flags|=8192),r&&0!==(1&e.mode)?0!==(1073741824&Cc)&&(Bv(e),6&e.subtreeFlags&&(e.flags|=8192)):Bv(e),null;case 24:case 25:return null}throw Error(a(156,e.tag))}function Vv(n,e){switch(Jo(e),e.tag){case 1:return To(e.type)&&Ro(),65536&(n=e.flags)?(e.flags=-65537&n|128,e):null;case 3:return ei(),Uo(Mo),Uo(ko),vi(),0!==(65536&(n=e.flags))&&0===(128&n)?(e.flags=-65537&n|128,e):null;case 5:return ri(e),null;case 13:if(Uo(oi),null!==(n=e.memoizedState)&&null!==n.dehydrated){if(null===e.alternate)throw Error(a(340));sa()}return 65536&(n=e.flags)?(e.flags=-65537&n|128,e):null;case 19:return Uo(oi),null;case 4:return ei(),null;case 10:return ya(e.type._context),null;case 22:case 23:return vl(),null;default:return null}}Cv=function(n,e){for(var t=e.child;null!==t;){if(5===t.tag||6===t.tag)n.appendChild(t.stateNode);else if(4!==t.tag&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return;t=t.return}t.sibling.return=t.return,t=t.sibling}},Tv=function(n,e,t,r){var o=n.memoizedProps;if(o!==r){n=e.stateNode,Qa(Za.current);var a,i=null;switch(t){case"input":o=$(n,o),r=$(n,r),i=[];break;case"select":o=O({},o,{value:void 0}),r=O({},r,{value:void 0}),i=[];break;case"textarea":o=rn(n,o),r=rn(n,r),i=[];break;default:"function"!==typeof o.onClick&&"function"===typeof r.onClick&&(n.onclick=$r)}for(s in gn(t,r),t=null,o)if(!r.hasOwnProperty(s)&&o.hasOwnProperty(s)&&null!=o[s])if("style"===s){var c=o[s];for(a in c)c.hasOwnProperty(a)&&(t||(t={}),t[a]="")}else"dangerouslySetInnerHTML"!==s&&"children"!==s&&"suppressContentEditableWarning"!==s&&"suppressHydrationWarning"!==s&&"autoFocus"!==s&&(v.hasOwnProperty(s)?i||(i=[]):(i=i||[]).push(s,null));for(s in r){var l=r[s];if(c=null!=o?o[s]:void 0,r.hasOwnProperty(s)&&l!==c&&(null!=l||null!=c))if("style"===s)if(c){for(a in c)!c.hasOwnProperty(a)||l&&l.hasOwnProperty(a)||(t||(t={}),t[a]="");for(a in l)l.hasOwnProperty(a)&&c[a]!==l[a]&&(t||(t={}),t[a]=l[a])}else t||(i||(i=[]),i.push(s,t)),t=l;else"dangerouslySetInnerHTML"===s?(l=l?l.__html:void 0,c=c?c.__html:void 0,null!=l&&c!==l&&(i=i||[]).push(s,l)):"children"===s?"string"!==typeof l&&"number"!==typeof l||(i=i||[]).push(s,""+l):"suppressContentEditableWarning"!==s&&"suppressHydrationWarning"!==s&&(v.hasOwnProperty(s)?(null!=l&&"onScroll"===s&&Er("scroll",n),i||c===l||(i=[])):(i=i||[]).push(s,l))}t&&(i=i||[]).push("style",t);var s=i;(e.updateQueue=s)&&(e.flags|=4)}},Rv=function(n,e,t,r){t!==r&&(e.flags|=4)};var Wv=!1,Hv=!1,Xv="function"===typeof WeakSet?WeakSet:Set,Yv=null;function $v(n,e){var t=n.ref;if(null!==t)if("function"===typeof t)try{t(null)}catch(r){bl(n,e,r)}else t.current=null}function Zv(n,e,t){try{t()}catch(r){bl(n,e,r)}}var Kv=!1;function Jv(n,e,t){var r=e.updateQueue;if(null!==(r=null!==r?r.lastEffect:null)){var o=r=r.next;do{if((o.tag&n)===n){var a=o.destroy;o.destroy=void 0,void 0!==a&&Zv(e,t,a)}o=o.next}while(o!==r)}}function Qv(n,e){if(null!==(e=null!==(e=e.updateQueue)?e.lastEffect:null)){var t=e=e.next;do{if((t.tag&n)===n){var r=t.create;t.destroy=r()}t=t.next}while(t!==e)}}function nc(n){var e=n.ref;if(null!==e){var t=n.stateNode;n.tag,n=t,"function"===typeof e?e(n):e.current=n}}function ec(n){var e=n.alternate;null!==e&&(n.alternate=null,ec(e)),n.child=null,n.deletions=null,n.sibling=null,5===n.tag&&(null!==(e=n.stateNode)&&(delete e[co],delete e[lo],delete e[uo],delete e[fo],delete e[po])),n.stateNode=null,n.return=null,n.dependencies=null,n.memoizedProps=null,n.memoizedState=null,n.pendingProps=null,n.stateNode=null,n.updateQueue=null}function tc(n){return 5===n.tag||3===n.tag||4===n.tag}function rc(n){n:for(;;){for(;null===n.sibling;){if(null===n.return||tc(n.return))return null;n=n.return}for(n.sibling.return=n.return,n=n.sibling;5!==n.tag&&6!==n.tag&&18!==n.tag;){if(2&n.flags)continue n;if(null===n.child||4===n.tag)continue n;n.child.return=n,n=n.child}if(!(2&n.flags))return n.stateNode}}function oc(n,e,t){var r=n.tag;if(5===r||6===r)n=n.stateNode,e?8===t.nodeType?t.parentNode.insertBefore(n,e):t.insertBefore(n,e):(8===t.nodeType?(e=t.parentNode).insertBefore(n,t):(e=t).appendChild(n),null!==(t=t._reactRootContainer)&&void 0!==t||null!==e.onclick||(e.onclick=$r));else if(4!==r&&null!==(n=n.child))for(oc(n,e,t),n=n.sibling;null!==n;)oc(n,e,t),n=n.sibling}function ac(n,e,t){var r=n.tag;if(5===r||6===r)n=n.stateNode,e?t.insertBefore(n,e):t.appendChild(n);else if(4!==r&&null!==(n=n.child))for(ac(n,e,t),n=n.sibling;null!==n;)ac(n,e,t),n=n.sibling}var ic=null,vc=!1;function cc(n,e,t){for(t=t.child;null!==t;)lc(n,e,t),t=t.sibling}function lc(n,e,t){if(ae&&"function"===typeof ae.onCommitFiberUnmount)try{ae.onCommitFiberUnmount(oe,t)}catch(v){}switch(t.tag){case 5:Hv||$v(t,e);case 6:var r=ic,o=vc;ic=null,cc(n,e,t),vc=o,null!==(ic=r)&&(vc?(n=ic,t=t.stateNode,8===n.nodeType?n.parentNode.removeChild(t):n.removeChild(t)):ic.removeChild(t.stateNode));break;case 18:null!==ic&&(vc?(n=ic,t=t.stateNode,8===n.nodeType?oo(n.parentNode,t):1===n.nodeType&&oo(n,t),Be(n)):oo(ic,t.stateNode));break;case 4:r=ic,o=vc,ic=t.stateNode.containerInfo,vc=!0,cc(n,e,t),ic=r,vc=o;break;case 0:case 11:case 14:case 15:if(!Hv&&(null!==(r=t.updateQueue)&&null!==(r=r.lastEffect))){o=r=r.next;do{var a=o,i=a.destroy;a=a.tag,void 0!==i&&(0!==(2&a)||0!==(4&a))&&Zv(t,e,i),o=o.next}while(o!==r)}cc(n,e,t);break;case 1:if(!Hv&&($v(t,e),"function"===typeof(r=t.stateNode).componentWillUnmount))try{r.props=t.memoizedProps,r.state=t.memoizedState,r.componentWillUnmount()}catch(v){bl(t,e,v)}cc(n,e,t);break;case 21:cc(n,e,t);break;case 22:1&t.mode?(Hv=(r=Hv)||null!==t.memoizedState,cc(n,e,t),Hv=r):cc(n,e,t);break;default:cc(n,e,t)}}function sc(n){var e=n.updateQueue;if(null!==e){n.updateQueue=null;var t=n.stateNode;null===t&&(t=n.stateNode=new Xv),e.forEach((function(e){var r=Sl.bind(null,n,e);t.has(e)||(t.add(e),e.then(r,r))}))}}function uc(n,e){var t=e.deletions;if(null!==t)for(var r=0;r<t.length;r++){var o=t[r];try{var i=n,v=e,c=v;n:for(;null!==c;){switch(c.tag){case 5:ic=c.stateNode,vc=!1;break n;case 3:case 4:ic=c.stateNode.containerInfo,vc=!0;break n}c=c.return}if(null===ic)throw Error(a(160));lc(i,v,o),ic=null,vc=!1;var l=o.alternate;null!==l&&(l.return=null),o.return=null}catch(s){bl(o,e,s)}}if(12854&e.subtreeFlags)for(e=e.child;null!==e;)fc(e,n),e=e.sibling}function fc(n,e){var t=n.alternate,r=n.flags;switch(n.tag){case 0:case 11:case 14:case 15:if(uc(e,n),pc(n),4&r){try{Jv(3,n,n.return),Qv(3,n)}catch(h){bl(n,n.return,h)}try{Jv(5,n,n.return)}catch(h){bl(n,n.return,h)}}break;case 1:uc(e,n),pc(n),512&r&&null!==t&&$v(t,t.return);break;case 5:if(uc(e,n),pc(n),512&r&&null!==t&&$v(t,t.return),32&n.flags){var o=n.stateNode;try{fn(o,"")}catch(h){bl(n,n.return,h)}}if(4&r&&null!=(o=n.stateNode)){var i=n.memoizedProps,v=null!==t?t.memoizedProps:i,c=n.type,l=n.updateQueue;if(n.updateQueue=null,null!==l)try{"input"===c&&"radio"===i.type&&null!=i.name&&K(o,i),yn(c,v);var s=yn(c,i);for(v=0;v<l.length;v+=2){var u=l[v],f=l[v+1];"style"===u?hn(o,f):"dangerouslySetInnerHTML"===u?un(o,f):"children"===u?fn(o,f):y(o,u,f,s)}switch(c){case"input":J(o,i);break;case"textarea":an(o,i);break;case"select":var p=o._wrapperState.wasMultiple;o._wrapperState.wasMultiple=!!i.multiple;var d=i.value;null!=d?tn(o,!!i.multiple,d,!1):p!==!!i.multiple&&(null!=i.defaultValue?tn(o,!!i.multiple,i.defaultValue,!0):tn(o,!!i.multiple,i.multiple?[]:"",!1))}o[lo]=i}catch(h){bl(n,n.return,h)}}break;case 6:if(uc(e,n),pc(n),4&r){if(null===n.stateNode)throw Error(a(162));o=n.stateNode,i=n.memoizedProps;try{o.nodeValue=i}catch(h){bl(n,n.return,h)}}break;case 3:if(uc(e,n),pc(n),4&r&&null!==t&&t.memoizedState.isDehydrated)try{Be(e.containerInfo)}catch(h){bl(n,n.return,h)}break;case 4:default:uc(e,n),pc(n);break;case 13:uc(e,n),pc(n),8192&(o=n.child).flags&&(i=null!==o.memoizedState,o.stateNode.isHidden=i,!i||null!==o.alternate&&null!==o.alternate.memoizedState||(Oc=Kn())),4&r&&sc(n);break;case 22:if(u=null!==t&&null!==t.memoizedState,1&n.mode?(Hv=(s=Hv)||u,uc(e,n),Hv=s):uc(e,n),pc(n),8192&r){if(s=null!==n.memoizedState,(n.stateNode.isHidden=s)&&!u&&0!==(1&n.mode))for(Yv=n,u=n.child;null!==u;){for(f=Yv=u;null!==Yv;){switch(d=(p=Yv).child,p.tag){case 0:case 11:case 14:case 15:Jv(4,p,p.return);break;case 1:$v(p,p.return);var m=p.stateNode;if("function"===typeof m.componentWillUnmount){r=p,t=p.return;try{e=r,m.props=e.memoizedProps,m.state=e.memoizedState,m.componentWillUnmount()}catch(h){bl(r,t,h)}}break;case 5:$v(p,p.return);break;case 22:if(null!==p.memoizedState){xc(f);continue}}null!==d?(d.return=p,Yv=d):xc(f)}u=u.sibling}n:for(u=null,f=n;;){if(5===f.tag){if(null===u){u=f;try{o=f.stateNode,s?"function"===typeof(i=o.style).setProperty?i.setProperty("display","none","important"):i.display="none":(c=f.stateNode,v=void 0!==(l=f.memoizedProps.style)&&null!==l&&l.hasOwnProperty("display")?l.display:null,c.style.display=mn("display",v))}catch(h){bl(n,n.return,h)}}}else if(6===f.tag){if(null===u)try{f.stateNode.nodeValue=s?"":f.memoizedProps}catch(h){bl(n,n.return,h)}}else if((22!==f.tag&&23!==f.tag||null===f.memoizedState||f===n)&&null!==f.child){f.child.return=f,f=f.child;continue}if(f===n)break n;for(;null===f.sibling;){if(null===f.return||f.return===n)break n;u===f&&(u=null),f=f.return}u===f&&(u=null),f.sibling.return=f.return,f=f.sibling}}break;case 19:uc(e,n),pc(n),4&r&&sc(n);case 21:}}function pc(n){var e=n.flags;if(2&e){try{n:{for(var t=n.return;null!==t;){if(tc(t)){var r=t;break n}t=t.return}throw Error(a(160))}switch(r.tag){case 5:var o=r.stateNode;32&r.flags&&(fn(o,""),r.flags&=-33),ac(n,rc(n),o);break;case 3:case 4:var i=r.stateNode.containerInfo;oc(n,rc(n),i);break;default:throw Error(a(161))}}catch(v){bl(n,n.return,v)}n.flags&=-3}4096&e&&(n.flags&=-4097)}function dc(n,e,t){Yv=n,mc(n,e,t)}function mc(n,e,t){for(var r=0!==(1&n.mode);null!==Yv;){var o=Yv,a=o.child;if(22===o.tag&&r){var i=null!==o.memoizedState||Wv;if(!i){var v=o.alternate,c=null!==v&&null!==v.memoizedState||Hv;v=Wv;var l=Hv;if(Wv=i,(Hv=c)&&!l)for(Yv=o;null!==Yv;)c=(i=Yv).child,22===i.tag&&null!==i.memoizedState?gc(o):null!==c?(c.return=i,Yv=c):gc(o);for(;null!==a;)Yv=a,mc(a,e,t),a=a.sibling;Yv=o,Wv=v,Hv=l}hc(n)}else 0!==(8772&o.subtreeFlags)&&null!==a?(a.return=o,Yv=a):hc(n)}}function hc(n){for(;null!==Yv;){var e=Yv;if(0!==(8772&e.flags)){var t=e.alternate;try{if(0!==(8772&e.flags))switch(e.tag){case 0:case 11:case 15:Hv||Qv(5,e);break;case 1:var r=e.stateNode;if(4&e.flags&&!Hv)if(null===t)r.componentDidMount();else{var o=e.elementType===e.type?t.memoizedProps:pa(e.type,t.memoizedProps);r.componentDidUpdate(o,t.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var i=e.updateQueue;null!==i&&Ea(e,i,r);break;case 3:var v=e.updateQueue;if(null!==v){if(t=null,null!==e.child)switch(e.child.tag){case 5:case 1:t=e.child.stateNode}Ea(e,v,t)}break;case 5:var c=e.stateNode;if(null===t&&4&e.flags){t=c;var l=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&t.focus();break;case"img":l.src&&(t.src=l.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===e.memoizedState){var s=e.alternate;if(null!==s){var u=s.memoizedState;if(null!==u){var f=u.dehydrated;null!==f&&Be(f)}}}break;default:throw Error(a(163))}Hv||512&e.flags&&nc(e)}catch(p){bl(e,e.return,p)}}if(e===n){Yv=null;break}if(null!==(t=e.sibling)){t.return=e.return,Yv=t;break}Yv=e.return}}function xc(n){for(;null!==Yv;){var e=Yv;if(e===n){Yv=null;break}var t=e.sibling;if(null!==t){t.return=e.return,Yv=t;break}Yv=e.return}}function gc(n){for(;null!==Yv;){var e=Yv;try{switch(e.tag){case 0:case 11:case 15:var t=e.return;try{Qv(4,e)}catch(c){bl(e,t,c)}break;case 1:var r=e.stateNode;if("function"===typeof r.componentDidMount){var o=e.return;try{r.componentDidMount()}catch(c){bl(e,o,c)}}var a=e.return;try{nc(e)}catch(c){bl(e,a,c)}break;case 5:var i=e.return;try{nc(e)}catch(c){bl(e,i,c)}}}catch(c){bl(e,e.return,c)}if(e===n){Yv=null;break}var v=e.sibling;if(null!==v){v.return=e.return,Yv=v;break}Yv=e.return}}var yc,bc=Math.ceil,_c=b.ReactCurrentDispatcher,Uc=b.ReactCurrentOwner,wc=b.ReactCurrentBatchConfig,Sc=0,kc=null,Mc=null,zc=0,Cc=0,Tc=_o(0),Rc=0,Dc=null,Pc=0,jc=0,Fc=0,Ec=null,Ic=null,Oc=0,Lc=1/0,Ac=null,Nc=!1,Gc=null,Bc=null,qc=!1,Vc=null,Wc=0,Hc=0,Xc=null,Yc=-1,$c=0;function Zc(){return 0!==(6&Sc)?Kn():-1!==Yc?Yc:Yc=Kn()}function Kc(n){return 0===(1&n.mode)?1:0!==(2&Sc)&&0!==zc?zc&-zc:null!==fa.transition?(0===$c&&($c=me()),$c):0!==(n=ye)?n:n=void 0===(n=window.event)?16:Ze(n.type)}function Jc(n,e,t,r){if(50<Hc)throw Hc=0,Xc=null,Error(a(185));xe(n,t,r),0!==(2&Sc)&&n===kc||(n===kc&&(0===(2&Sc)&&(jc|=t),4===Rc&&rl(n,zc)),Qc(n,r),1===t&&0===Sc&&0===(1&e.mode)&&(Lc=Kn()+500,Io&&Ao()))}function Qc(n,e){var t=n.callbackNode;!function(n,e){for(var t=n.suspendedLanes,r=n.pingedLanes,o=n.expirationTimes,a=n.pendingLanes;0<a;){var i=31-ie(a),v=1<<i,c=o[i];-1===c?0!==(v&t)&&0===(v&r)||(o[i]=pe(v,e)):c<=e&&(n.expiredLanes|=v),a&=~v}}(n,e);var r=fe(n,n===kc?zc:0);if(0===r)null!==t&&Yn(t),n.callbackNode=null,n.callbackPriority=0;else if(e=r&-r,n.callbackPriority!==e){if(null!=t&&Yn(t),1===e)0===n.tag?function(n){Io=!0,Lo(n)}(ol.bind(null,n)):Lo(ol.bind(null,n)),to((function(){0===(6&Sc)&&Ao()})),t=null;else{switch(be(r)){case 1:t=Qn;break;case 4:t=ne;break;case 16:default:t=ee;break;case 536870912:t=re}t=kl(t,nl.bind(null,n))}n.callbackPriority=e,n.callbackNode=t}}function nl(n,e){if(Yc=-1,$c=0,0!==(6&Sc))throw Error(a(327));var t=n.callbackNode;if(gl()&&n.callbackNode!==t)return null;var r=fe(n,n===kc?zc:0);if(0===r)return null;if(0!==(30&r)||0!==(r&n.expiredLanes)||e)e=fl(n,r);else{e=r;var o=Sc;Sc|=2;var i=sl();for(kc===n&&zc===e||(Ac=null,Lc=Kn()+500,cl(n,e));;)try{dl();break}catch(c){ll(n,c)}ga(),_c.current=i,Sc=o,null!==Mc?e=0:(kc=null,zc=0,e=Rc)}if(0!==e){if(2===e&&(0!==(o=de(n))&&(r=o,e=el(n,o))),1===e)throw t=Dc,cl(n,0),rl(n,r),Qc(n,Kn()),t;if(6===e)rl(n,r);else{if(o=n.current.alternate,0===(30&r)&&!function(n){for(var e=n;;){if(16384&e.flags){var t=e.updateQueue;if(null!==t&&null!==(t=t.stores))for(var r=0;r<t.length;r++){var o=t[r],a=o.getSnapshot;o=o.value;try{if(!rr(a(),o))return!1}catch(v){return!1}}}if(t=e.child,16384&e.subtreeFlags&&null!==t)t.return=e,e=t;else{if(e===n)break;for(;null===e.sibling;){if(null===e.return||e.return===n)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}(o)&&(2===(e=fl(n,r))&&(0!==(i=de(n))&&(r=i,e=el(n,i))),1===e))throw t=Dc,cl(n,0),rl(n,r),Qc(n,Kn()),t;switch(n.finishedWork=o,n.finishedLanes=r,e){case 0:case 1:throw Error(a(345));case 2:case 5:xl(n,Ic,Ac);break;case 3:if(rl(n,r),(130023424&r)===r&&10<(e=Oc+500-Kn())){if(0!==fe(n,0))break;if(((o=n.suspendedLanes)&r)!==r){Zc(),n.pingedLanes|=n.suspendedLanes&o;break}n.timeoutHandle=Qr(xl.bind(null,n,Ic,Ac),e);break}xl(n,Ic,Ac);break;case 4:if(rl(n,r),(4194240&r)===r)break;for(e=n.eventTimes,o=-1;0<r;){var v=31-ie(r);i=1<<v,(v=e[v])>o&&(o=v),r&=~i}if(r=o,10<(r=(120>(r=Kn()-r)?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*bc(r/1960))-r)){n.timeoutHandle=Qr(xl.bind(null,n,Ic,Ac),r);break}xl(n,Ic,Ac);break;default:throw Error(a(329))}}}return Qc(n,Kn()),n.callbackNode===t?nl.bind(null,n):null}function el(n,e){var t=Ec;return n.current.memoizedState.isDehydrated&&(cl(n,e).flags|=256),2!==(n=fl(n,e))&&(e=Ic,Ic=t,null!==e&&tl(e)),n}function tl(n){null===Ic?Ic=n:Ic.push.apply(Ic,n)}function rl(n,e){for(e&=~Fc,e&=~jc,n.suspendedLanes|=e,n.pingedLanes&=~e,n=n.expirationTimes;0<e;){var t=31-ie(e),r=1<<t;n[t]=-1,e&=~r}}function ol(n){if(0!==(6&Sc))throw Error(a(327));gl();var e=fe(n,0);if(0===(1&e))return Qc(n,Kn()),null;var t=fl(n,e);if(0!==n.tag&&2===t){var r=de(n);0!==r&&(e=r,t=el(n,r))}if(1===t)throw t=Dc,cl(n,0),rl(n,e),Qc(n,Kn()),t;if(6===t)throw Error(a(345));return n.finishedWork=n.current.alternate,n.finishedLanes=e,xl(n,Ic,Ac),Qc(n,Kn()),null}function al(n,e){var t=Sc;Sc|=1;try{return n(e)}finally{0===(Sc=t)&&(Lc=Kn()+500,Io&&Ao())}}function il(n){null!==Vc&&0===Vc.tag&&0===(6&Sc)&&gl();var e=Sc;Sc|=1;var t=wc.transition,r=ye;try{if(wc.transition=null,ye=1,n)return n()}finally{ye=r,wc.transition=t,0===(6&(Sc=e))&&Ao()}}function vl(){Cc=Tc.current,Uo(Tc)}function cl(n,e){n.finishedWork=null,n.finishedLanes=0;var t=n.timeoutHandle;if(-1!==t&&(n.timeoutHandle=-1,no(t)),null!==Mc)for(t=Mc.return;null!==t;){var r=t;switch(Jo(r),r.tag){case 1:null!==(r=r.type.childContextTypes)&&void 0!==r&&Ro();break;case 3:ei(),Uo(Mo),Uo(ko),vi();break;case 5:ri(r);break;case 4:ei();break;case 13:case 19:Uo(oi);break;case 10:ya(r.type._context);break;case 22:case 23:vl()}t=t.return}if(kc=n,Mc=n=Tl(n.current,null),zc=Cc=e,Rc=0,Dc=null,Fc=jc=Pc=0,Ic=Ec=null,null!==wa){for(e=0;e<wa.length;e++)if(null!==(r=(t=wa[e]).interleaved)){t.interleaved=null;var o=r.next,a=t.pending;if(null!==a){var i=a.next;a.next=o,r.next=i}t.pending=r}wa=null}return n}function ll(n,e){for(;;){var t=Mc;try{if(ga(),ci.current=tv,di){for(var r=ui.memoizedState;null!==r;){var o=r.queue;null!==o&&(o.pending=null),r=r.next}di=!1}if(si=0,pi=fi=ui=null,mi=!1,hi=0,Uc.current=null,null===t||null===t.return){Rc=1,Dc=e,Mc=null;break}n:{var i=n,v=t.return,c=t,l=e;if(e=zc,c.flags|=32768,null!==l&&"object"===typeof l&&"function"===typeof l.then){var s=l,u=c,f=u.tag;if(0===(1&u.mode)&&(0===f||11===f||15===f)){var p=u.alternate;p?(u.updateQueue=p.updateQueue,u.memoizedState=p.memoizedState,u.lanes=p.lanes):(u.updateQueue=null,u.memoizedState=null)}var d=pv(v);if(null!==d){d.flags&=-257,dv(d,v,c,0,e),1&d.mode&&fv(i,s,e),l=s;var m=(e=d).updateQueue;if(null===m){var h=new Set;h.add(l),e.updateQueue=h}else m.add(l);break n}if(0===(1&e)){fv(i,s,e),ul();break n}l=Error(a(426))}else if(ea&&1&c.mode){var x=pv(v);if(null!==x){0===(65536&x.flags)&&(x.flags|=256),dv(x,v,c,0,e),ua(iv(l,c));break n}}i=l=iv(l,c),4!==Rc&&(Rc=2),null===Ec?Ec=[i]:Ec.push(i),i=v;do{switch(i.tag){case 3:i.flags|=65536,e&=-e,i.lanes|=e,ja(i,sv(0,l,e));break n;case 1:c=l;var g=i.type,y=i.stateNode;if(0===(128&i.flags)&&("function"===typeof g.getDerivedStateFromError||null!==y&&"function"===typeof y.componentDidCatch&&(null===Bc||!Bc.has(y)))){i.flags|=65536,e&=-e,i.lanes|=e,ja(i,uv(i,c,e));break n}}i=i.return}while(null!==i)}hl(t)}catch(b){e=b,Mc===t&&null!==t&&(Mc=t=t.return);continue}break}}function sl(){var n=_c.current;return _c.current=tv,null===n?tv:n}function ul(){0!==Rc&&3!==Rc&&2!==Rc||(Rc=4),null===kc||0===(268435455&Pc)&&0===(268435455&jc)||rl(kc,zc)}function fl(n,e){var t=Sc;Sc|=2;var r=sl();for(kc===n&&zc===e||(Ac=null,cl(n,e));;)try{pl();break}catch(o){ll(n,o)}if(ga(),Sc=t,_c.current=r,null!==Mc)throw Error(a(261));return kc=null,zc=0,Rc}function pl(){for(;null!==Mc;)ml(Mc)}function dl(){for(;null!==Mc&&!$n();)ml(Mc)}function ml(n){var e=yc(n.alternate,n,Cc);n.memoizedProps=n.pendingProps,null===e?hl(n):Mc=e,Uc.current=null}function hl(n){var e=n;do{var t=e.alternate;if(n=e.return,0===(32768&e.flags)){if(null!==(t=qv(t,e,Cc)))return void(Mc=t)}else{if(null!==(t=Vv(t,e)))return t.flags&=32767,void(Mc=t);if(null===n)return Rc=6,void(Mc=null);n.flags|=32768,n.subtreeFlags=0,n.deletions=null}if(null!==(e=e.sibling))return void(Mc=e);Mc=e=n}while(null!==e);0===Rc&&(Rc=5)}function xl(n,e,t){var r=ye,o=wc.transition;try{wc.transition=null,ye=1,function(n,e,t,r){do{gl()}while(null!==Vc);if(0!==(6&Sc))throw Error(a(327));t=n.finishedWork;var o=n.finishedLanes;if(null===t)return null;if(n.finishedWork=null,n.finishedLanes=0,t===n.current)throw Error(a(177));n.callbackNode=null,n.callbackPriority=0;var i=t.lanes|t.childLanes;if(function(n,e){var t=n.pendingLanes&~e;n.pendingLanes=e,n.suspendedLanes=0,n.pingedLanes=0,n.expiredLanes&=e,n.mutableReadLanes&=e,n.entangledLanes&=e,e=n.entanglements;var r=n.eventTimes;for(n=n.expirationTimes;0<t;){var o=31-ie(t),a=1<<o;e[o]=0,r[o]=-1,n[o]=-1,t&=~a}}(n,i),n===kc&&(Mc=kc=null,zc=0),0===(2064&t.subtreeFlags)&&0===(2064&t.flags)||qc||(qc=!0,kl(ee,(function(){return gl(),null}))),i=0!==(15990&t.flags),0!==(15990&t.subtreeFlags)||i){i=wc.transition,wc.transition=null;var v=ye;ye=1;var c=Sc;Sc|=4,Uc.current=null,function(n,e){if(Zr=Ve,lr(n=cr())){if("selectionStart"in n)var t={start:n.selectionStart,end:n.selectionEnd};else n:{var r=(t=(t=n.ownerDocument)&&t.defaultView||window).getSelection&&t.getSelection();if(r&&0!==r.rangeCount){t=r.anchorNode;var o=r.anchorOffset,i=r.focusNode;r=r.focusOffset;try{t.nodeType,i.nodeType}catch(_){t=null;break n}var v=0,c=-1,l=-1,s=0,u=0,f=n,p=null;e:for(;;){for(var d;f!==t||0!==o&&3!==f.nodeType||(c=v+o),f!==i||0!==r&&3!==f.nodeType||(l=v+r),3===f.nodeType&&(v+=f.nodeValue.length),null!==(d=f.firstChild);)p=f,f=d;for(;;){if(f===n)break e;if(p===t&&++s===o&&(c=v),p===i&&++u===r&&(l=v),null!==(d=f.nextSibling))break;p=(f=p).parentNode}f=d}t=-1===c||-1===l?null:{start:c,end:l}}else t=null}t=t||{start:0,end:0}}else t=null;for(Kr={focusedElem:n,selectionRange:t},Ve=!1,Yv=e;null!==Yv;)if(n=(e=Yv).child,0!==(1028&e.subtreeFlags)&&null!==n)n.return=e,Yv=n;else for(;null!==Yv;){e=Yv;try{var m=e.alternate;if(0!==(1024&e.flags))switch(e.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==m){var h=m.memoizedProps,x=m.memoizedState,g=e.stateNode,y=g.getSnapshotBeforeUpdate(e.elementType===e.type?h:pa(e.type,h),x);g.__reactInternalSnapshotBeforeUpdate=y}break;case 3:var b=e.stateNode.containerInfo;1===b.nodeType?b.textContent="":9===b.nodeType&&b.documentElement&&b.removeChild(b.documentElement);break;default:throw Error(a(163))}}catch(_){bl(e,e.return,_)}if(null!==(n=e.sibling)){n.return=e.return,Yv=n;break}Yv=e.return}m=Kv,Kv=!1}(n,t),fc(t,n),sr(Kr),Ve=!!Zr,Kr=Zr=null,n.current=t,dc(t,n,o),Zn(),Sc=c,ye=v,wc.transition=i}else n.current=t;if(qc&&(qc=!1,Vc=n,Wc=o),0===(i=n.pendingLanes)&&(Bc=null),function(n){if(ae&&"function"===typeof ae.onCommitFiberRoot)try{ae.onCommitFiberRoot(oe,n,void 0,128===(128&n.current.flags))}catch(e){}}(t.stateNode),Qc(n,Kn()),null!==e)for(r=n.onRecoverableError,t=0;t<e.length;t++)r((o=e[t]).value,{componentStack:o.stack,digest:o.digest});if(Nc)throw Nc=!1,n=Gc,Gc=null,n;0!==(1&Wc)&&0!==n.tag&&gl(),0!==(1&(i=n.pendingLanes))?n===Xc?Hc++:(Hc=0,Xc=n):Hc=0,Ao()}(n,e,t,r)}finally{wc.transition=o,ye=r}return null}function gl(){if(null!==Vc){var n=be(Wc),e=wc.transition,t=ye;try{if(wc.transition=null,ye=16>n?16:n,null===Vc)var r=!1;else{if(n=Vc,Vc=null,Wc=0,0!==(6&Sc))throw Error(a(331));var o=Sc;for(Sc|=4,Yv=n.current;null!==Yv;){var i=Yv,v=i.child;if(0!==(16&Yv.flags)){var c=i.deletions;if(null!==c){for(var l=0;l<c.length;l++){var s=c[l];for(Yv=s;null!==Yv;){var u=Yv;switch(u.tag){case 0:case 11:case 15:Jv(8,u,i)}var f=u.child;if(null!==f)f.return=u,Yv=f;else for(;null!==Yv;){var p=(u=Yv).sibling,d=u.return;if(ec(u),u===s){Yv=null;break}if(null!==p){p.return=d,Yv=p;break}Yv=d}}}var m=i.alternate;if(null!==m){var h=m.child;if(null!==h){m.child=null;do{var x=h.sibling;h.sibling=null,h=x}while(null!==h)}}Yv=i}}if(0!==(2064&i.subtreeFlags)&&null!==v)v.return=i,Yv=v;else n:for(;null!==Yv;){if(0!==(2048&(i=Yv).flags))switch(i.tag){case 0:case 11:case 15:Jv(9,i,i.return)}var g=i.sibling;if(null!==g){g.return=i.return,Yv=g;break n}Yv=i.return}}var y=n.current;for(Yv=y;null!==Yv;){var b=(v=Yv).child;if(0!==(2064&v.subtreeFlags)&&null!==b)b.return=v,Yv=b;else n:for(v=y;null!==Yv;){if(0!==(2048&(c=Yv).flags))try{switch(c.tag){case 0:case 11:case 15:Qv(9,c)}}catch(U){bl(c,c.return,U)}if(c===v){Yv=null;break n}var _=c.sibling;if(null!==_){_.return=c.return,Yv=_;break n}Yv=c.return}}if(Sc=o,Ao(),ae&&"function"===typeof ae.onPostCommitFiberRoot)try{ae.onPostCommitFiberRoot(oe,n)}catch(U){}r=!0}return r}finally{ye=t,wc.transition=e}}return!1}function yl(n,e,t){n=Da(n,e=sv(0,e=iv(t,e),1),1),e=Zc(),null!==n&&(xe(n,1,e),Qc(n,e))}function bl(n,e,t){if(3===n.tag)yl(n,n,t);else for(;null!==e;){if(3===e.tag){yl(e,n,t);break}if(1===e.tag){var r=e.stateNode;if("function"===typeof e.type.getDerivedStateFromError||"function"===typeof r.componentDidCatch&&(null===Bc||!Bc.has(r))){e=Da(e,n=uv(e,n=iv(t,n),1),1),n=Zc(),null!==e&&(xe(e,1,n),Qc(e,n));break}}e=e.return}}function _l(n,e,t){var r=n.pingCache;null!==r&&r.delete(e),e=Zc(),n.pingedLanes|=n.suspendedLanes&t,kc===n&&(zc&t)===t&&(4===Rc||3===Rc&&(130023424&zc)===zc&&500>Kn()-Oc?cl(n,0):Fc|=t),Qc(n,e)}function Ul(n,e){0===e&&(0===(1&n.mode)?e=1:(e=se,0===(130023424&(se<<=1))&&(se=4194304)));var t=Zc();null!==(n=Ma(n,e))&&(xe(n,e,t),Qc(n,t))}function wl(n){var e=n.memoizedState,t=0;null!==e&&(t=e.retryLane),Ul(n,t)}function Sl(n,e){var t=0;switch(n.tag){case 13:var r=n.stateNode,o=n.memoizedState;null!==o&&(t=o.retryLane);break;case 19:r=n.stateNode;break;default:throw Error(a(314))}null!==r&&r.delete(e),Ul(n,t)}function kl(n,e){return Xn(n,e)}function Ml(n,e,t,r){this.tag=n,this.key=t,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function zl(n,e,t,r){return new Ml(n,e,t,r)}function Cl(n){return!(!(n=n.prototype)||!n.isReactComponent)}function Tl(n,e){var t=n.alternate;return null===t?((t=zl(n.tag,e,n.key,n.mode)).elementType=n.elementType,t.type=n.type,t.stateNode=n.stateNode,t.alternate=n,n.alternate=t):(t.pendingProps=e,t.type=n.type,t.flags=0,t.subtreeFlags=0,t.deletions=null),t.flags=14680064&n.flags,t.childLanes=n.childLanes,t.lanes=n.lanes,t.child=n.child,t.memoizedProps=n.memoizedProps,t.memoizedState=n.memoizedState,t.updateQueue=n.updateQueue,e=n.dependencies,t.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext},t.sibling=n.sibling,t.index=n.index,t.ref=n.ref,t}function Rl(n,e,t,r,o,i){var v=2;if(r=n,"function"===typeof n)Cl(n)&&(v=1);else if("string"===typeof n)v=5;else n:switch(n){case w:return Dl(t.children,o,i,e);case S:v=8,o|=8;break;case k:return(n=zl(12,t,e,2|o)).elementType=k,n.lanes=i,n;case T:return(n=zl(13,t,e,o)).elementType=T,n.lanes=i,n;case R:return(n=zl(19,t,e,o)).elementType=R,n.lanes=i,n;case j:return Pl(t,o,i,e);default:if("object"===typeof n&&null!==n)switch(n.$$typeof){case M:v=10;break n;case z:v=9;break n;case C:v=11;break n;case D:v=14;break n;case P:v=16,r=null;break n}throw Error(a(130,null==n?n:typeof n,""))}return(e=zl(v,t,e,o)).elementType=n,e.type=r,e.lanes=i,e}function Dl(n,e,t,r){return(n=zl(7,n,r,e)).lanes=t,n}function Pl(n,e,t,r){return(n=zl(22,n,r,e)).elementType=j,n.lanes=t,n.stateNode={isHidden:!1},n}function jl(n,e,t){return(n=zl(6,n,null,e)).lanes=t,n}function Fl(n,e,t){return(e=zl(4,null!==n.children?n.children:[],n.key,e)).lanes=t,e.stateNode={containerInfo:n.containerInfo,pendingChildren:null,implementation:n.implementation},e}function El(n,e,t,r,o){this.tag=e,this.containerInfo=n,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=he(0),this.expirationTimes=he(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=he(0),this.identifierPrefix=r,this.onRecoverableError=o,this.mutableSourceEagerHydrationData=null}function Il(n,e,t,r,o,a,i,v,c){return n=new El(n,e,t,v,c),1===e?(e=1,!0===a&&(e|=8)):e=0,a=zl(3,null,null,e),n.current=a,a.stateNode=n,a.memoizedState={element:r,isDehydrated:t,cache:null,transitions:null,pendingSuspenseBoundaries:null},Ca(a),n}function Ol(n,e,t){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:U,key:null==r?null:""+r,children:n,containerInfo:e,implementation:t}}function Ll(n){if(!n)return So;n:{if(Bn(n=n._reactInternals)!==n||1!==n.tag)throw Error(a(170));var e=n;do{switch(e.tag){case 3:e=e.stateNode.context;break n;case 1:if(To(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break n}}e=e.return}while(null!==e);throw Error(a(171))}if(1===n.tag){var t=n.type;if(To(t))return Po(n,t,e)}return e}function Al(n,e,t,r,o,a,i,v,c){return(n=Il(t,r,!0,n,0,a,0,v,c)).context=Ll(null),t=n.current,(a=Ra(r=Zc(),o=Kc(t))).callback=void 0!==e&&null!==e?e:null,Da(t,a,o),n.current.lanes=o,xe(n,o,r),Qc(n,r),n}function Nl(n,e,t,r){var o=e.current,a=Zc(),i=Kc(o);return t=Ll(t),null===e.context?e.context=t:e.pendingContext=t,(e=Ra(a,i)).payload={element:n},null!==(r=void 0===r?null:r)&&(e.callback=r),null!==(n=Da(o,e,i))&&(Jc(n,o,i,a),Pa(n,o,i)),i}function Gl(n){return(n=n.current).child?(n.child.tag,n.child.stateNode):null}function Bl(n,e){if(null!==(n=n.memoizedState)&&null!==n.dehydrated){var t=n.retryLane;n.retryLane=0!==t&&t<e?t:e}}function ql(n,e){Bl(n,e),(n=n.alternate)&&Bl(n,e)}yc=function(n,e,t){if(null!==n)if(n.memoizedProps!==e.pendingProps||Mo.current)hv=!0;else{if(0===(n.lanes&t)&&0===(128&e.flags))return hv=!1,function(n,e,t){switch(e.tag){case 3:Mv(e),sa();break;case 5:ti(e);break;case 1:To(e.type)&&jo(e);break;case 4:ni(e,e.stateNode.containerInfo);break;case 10:var r=e.type._context,o=e.memoizedProps.value;wo(da,r._currentValue),r._currentValue=o;break;case 13:if(null!==(r=e.memoizedState))return null!==r.dehydrated?(wo(oi,1&oi.current),e.flags|=128,null):0!==(t&e.child.childLanes)?jv(n,e,t):(wo(oi,1&oi.current),null!==(n=Nv(n,e,t))?n.sibling:null);wo(oi,1&oi.current);break;case 19:if(r=0!==(t&e.childLanes),0!==(128&n.flags)){if(r)return Lv(n,e,t);e.flags|=128}if(null!==(o=e.memoizedState)&&(o.rendering=null,o.tail=null,o.lastEffect=null),wo(oi,oi.current),r)break;return null;case 22:case 23:return e.lanes=0,_v(n,e,t)}return Nv(n,e,t)}(n,e,t);hv=0!==(131072&n.flags)}else hv=!1,ea&&0!==(1048576&e.flags)&&Zo(e,qo,e.index);switch(e.lanes=0,e.tag){case 2:var r=e.type;Av(n,e),n=e.pendingProps;var o=Co(e,ko.current);_a(e,t),o=bi(null,e,r,n,o,t);var i=_i();return e.flags|=1,"object"===typeof o&&null!==o&&"function"===typeof o.render&&void 0===o.$$typeof?(e.tag=1,e.memoizedState=null,e.updateQueue=null,To(r)?(i=!0,jo(e)):i=!1,e.memoizedState=null!==o.state&&void 0!==o.state?o.state:null,Ca(e),o.updater=La,e.stateNode=o,o._reactInternals=e,Ba(e,r,n,t),e=kv(null,e,r,!0,i,t)):(e.tag=0,ea&&i&&Ko(e),xv(null,e,o,t),e=e.child),e;case 16:r=e.elementType;n:{switch(Av(n,e),n=e.pendingProps,r=(o=r._init)(r._payload),e.type=r,o=e.tag=function(n){if("function"===typeof n)return Cl(n)?1:0;if(void 0!==n&&null!==n){if((n=n.$$typeof)===C)return 11;if(n===D)return 14}return 2}(r),n=pa(r,n),o){case 0:e=wv(null,e,r,n,t);break n;case 1:e=Sv(null,e,r,n,t);break n;case 11:e=gv(null,e,r,n,t);break n;case 14:e=yv(null,e,r,pa(r.type,n),t);break n}throw Error(a(306,r,""))}return e;case 0:return r=e.type,o=e.pendingProps,wv(n,e,r,o=e.elementType===r?o:pa(r,o),t);case 1:return r=e.type,o=e.pendingProps,Sv(n,e,r,o=e.elementType===r?o:pa(r,o),t);case 3:n:{if(Mv(e),null===n)throw Error(a(387));r=e.pendingProps,o=(i=e.memoizedState).element,Ta(n,e),Fa(e,r,null,t);var v=e.memoizedState;if(r=v.element,i.isDehydrated){if(i={element:r,isDehydrated:!1,cache:v.cache,pendingSuspenseBoundaries:v.pendingSuspenseBoundaries,transitions:v.transitions},e.updateQueue.baseState=i,e.memoizedState=i,256&e.flags){e=zv(n,e,r,t,o=iv(Error(a(423)),e));break n}if(r!==o){e=zv(n,e,r,t,o=iv(Error(a(424)),e));break n}for(na=ao(e.stateNode.containerInfo.firstChild),Qo=e,ea=!0,ta=null,t=Ya(e,null,r,t),e.child=t;t;)t.flags=-3&t.flags|4096,t=t.sibling}else{if(sa(),r===o){e=Nv(n,e,t);break n}xv(n,e,r,t)}e=e.child}return e;case 5:return ti(e),null===n&&ia(e),r=e.type,o=e.pendingProps,i=null!==n?n.memoizedProps:null,v=o.children,Jr(r,o)?v=null:null!==i&&Jr(r,i)&&(e.flags|=32),Uv(n,e),xv(n,e,v,t),e.child;case 6:return null===n&&ia(e),null;case 13:return jv(n,e,t);case 4:return ni(e,e.stateNode.containerInfo),r=e.pendingProps,null===n?e.child=Xa(e,null,r,t):xv(n,e,r,t),e.child;case 11:return r=e.type,o=e.pendingProps,gv(n,e,r,o=e.elementType===r?o:pa(r,o),t);case 7:return xv(n,e,e.pendingProps,t),e.child;case 8:case 12:return xv(n,e,e.pendingProps.children,t),e.child;case 10:n:{if(r=e.type._context,o=e.pendingProps,i=e.memoizedProps,v=o.value,wo(da,r._currentValue),r._currentValue=v,null!==i)if(rr(i.value,v)){if(i.children===o.children&&!Mo.current){e=Nv(n,e,t);break n}}else for(null!==(i=e.child)&&(i.return=e);null!==i;){var c=i.dependencies;if(null!==c){v=i.child;for(var l=c.firstContext;null!==l;){if(l.context===r){if(1===i.tag){(l=Ra(-1,t&-t)).tag=2;var s=i.updateQueue;if(null!==s){var u=(s=s.shared).pending;null===u?l.next=l:(l.next=u.next,u.next=l),s.pending=l}}i.lanes|=t,null!==(l=i.alternate)&&(l.lanes|=t),ba(i.return,t,e),c.lanes|=t;break}l=l.next}}else if(10===i.tag)v=i.type===e.type?null:i.child;else if(18===i.tag){if(null===(v=i.return))throw Error(a(341));v.lanes|=t,null!==(c=v.alternate)&&(c.lanes|=t),ba(v,t,e),v=i.sibling}else v=i.child;if(null!==v)v.return=i;else for(v=i;null!==v;){if(v===e){v=null;break}if(null!==(i=v.sibling)){i.return=v.return,v=i;break}v=v.return}i=v}xv(n,e,o.children,t),e=e.child}return e;case 9:return o=e.type,r=e.pendingProps.children,_a(e,t),r=r(o=Ua(o)),e.flags|=1,xv(n,e,r,t),e.child;case 14:return o=pa(r=e.type,e.pendingProps),yv(n,e,r,o=pa(r.type,o),t);case 15:return bv(n,e,e.type,e.pendingProps,t);case 17:return r=e.type,o=e.pendingProps,o=e.elementType===r?o:pa(r,o),Av(n,e),e.tag=1,To(r)?(n=!0,jo(e)):n=!1,_a(e,t),Na(e,r,o),Ba(e,r,o,t),kv(null,e,r,!0,n,t);case 19:return Lv(n,e,t);case 22:return _v(n,e,t)}throw Error(a(156,e.tag))};var Vl="function"===typeof reportError?reportError:function(n){console.error(n)};function Wl(n){this._internalRoot=n}function Hl(n){this._internalRoot=n}function Xl(n){return!(!n||1!==n.nodeType&&9!==n.nodeType&&11!==n.nodeType)}function Yl(n){return!(!n||1!==n.nodeType&&9!==n.nodeType&&11!==n.nodeType&&(8!==n.nodeType||" react-mount-point-unstable "!==n.nodeValue))}function $l(){}function Zl(n,e,t,r,o){var a=t._reactRootContainer;if(a){var i=a;if("function"===typeof o){var v=o;o=function(){var n=Gl(i);v.call(n)}}Nl(e,i,n,o)}else i=function(n,e,t,r,o){if(o){if("function"===typeof r){var a=r;r=function(){var n=Gl(i);a.call(n)}}var i=Al(e,r,n,0,null,!1,0,"",$l);return n._reactRootContainer=i,n[so]=i.current,Lr(8===n.nodeType?n.parentNode:n),il(),i}for(;o=n.lastChild;)n.removeChild(o);if("function"===typeof r){var v=r;r=function(){var n=Gl(c);v.call(n)}}var c=Il(n,0,!1,null,0,!1,0,"",$l);return n._reactRootContainer=c,n[so]=c.current,Lr(8===n.nodeType?n.parentNode:n),il((function(){Nl(e,c,t,r)})),c}(t,e,n,o,r);return Gl(i)}Hl.prototype.render=Wl.prototype.render=function(n){var e=this._internalRoot;if(null===e)throw Error(a(409));Nl(n,e,null,null)},Hl.prototype.unmount=Wl.prototype.unmount=function(){var n=this._internalRoot;if(null!==n){this._internalRoot=null;var e=n.containerInfo;il((function(){Nl(null,n,null,null)})),e[so]=null}},Hl.prototype.unstable_scheduleHydration=function(n){if(n){var e=Se();n={blockedOn:null,target:n,priority:e};for(var t=0;t<je.length&&0!==e&&e<je[t].priority;t++);je.splice(t,0,n),0===t&&Oe(n)}},_e=function(n){switch(n.tag){case 3:var e=n.stateNode;if(e.current.memoizedState.isDehydrated){var t=ue(e.pendingLanes);0!==t&&(ge(e,1|t),Qc(e,Kn()),0===(6&Sc)&&(Lc=Kn()+500,Ao()))}break;case 13:il((function(){var e=Ma(n,1);if(null!==e){var t=Zc();Jc(e,n,1,t)}})),ql(n,1)}},Ue=function(n){if(13===n.tag){var e=Ma(n,134217728);if(null!==e)Jc(e,n,134217728,Zc());ql(n,134217728)}},we=function(n){if(13===n.tag){var e=Kc(n),t=Ma(n,e);if(null!==t)Jc(t,n,e,Zc());ql(n,e)}},Se=function(){return ye},ke=function(n,e){var t=ye;try{return ye=n,e()}finally{ye=t}},Un=function(n,e,t){switch(e){case"input":if(J(n,t),e=t.name,"radio"===t.type&&null!=e){for(t=n;t.parentNode;)t=t.parentNode;for(t=t.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<t.length;e++){var r=t[e];if(r!==n&&r.form===n.form){var o=go(r);if(!o)throw Error(a(90));X(r),J(r,o)}}}break;case"textarea":an(n,t);break;case"select":null!=(e=t.value)&&tn(n,!!t.multiple,e,!1)}},Cn=al,Tn=il;var Kl={usingClientEntryPoint:!1,Events:[ho,xo,go,Mn,zn,al]},Jl={findFiberByHostInstance:mo,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},Ql={bundleType:Jl.bundleType,version:Jl.version,rendererPackageName:Jl.rendererPackageName,rendererConfig:Jl.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:b.ReactCurrentDispatcher,findHostInstanceByFiber:function(n){return null===(n=Wn(n))?null:n.stateNode},findFiberByHostInstance:Jl.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var ns=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!ns.isDisabled&&ns.supportsFiber)try{oe=ns.inject(Ql),ae=ns}catch(es){}}e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Kl,e.createPortal=function(n,e){var t=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Xl(e))throw Error(a(200));return Ol(n,e,null,t)},e.createRoot=function(n,e){if(!Xl(n))throw Error(a(299));var t=!1,r="",o=Vl;return null!==e&&void 0!==e&&(!0===e.unstable_strictMode&&(t=!0),void 0!==e.identifierPrefix&&(r=e.identifierPrefix),void 0!==e.onRecoverableError&&(o=e.onRecoverableError)),e=Il(n,1,!1,null,0,t,0,r,o),n[so]=e.current,Lr(8===n.nodeType?n.parentNode:n),new Wl(e)},e.findDOMNode=function(n){if(null==n)return null;if(1===n.nodeType)return n;var e=n._reactInternals;if(void 0===e){if("function"===typeof n.render)throw Error(a(188));throw n=Object.keys(n).join(","),Error(a(268,n))}return n=null===(n=Wn(e))?null:n.stateNode},e.flushSync=function(n){return il(n)},e.hydrate=function(n,e,t){if(!Yl(e))throw Error(a(200));return Zl(null,n,e,!0,t)},e.hydrateRoot=function(n,e,t){if(!Xl(n))throw Error(a(405));var r=null!=t&&t.hydratedSources||null,o=!1,i="",v=Vl;if(null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(o=!0),void 0!==t.identifierPrefix&&(i=t.identifierPrefix),void 0!==t.onRecoverableError&&(v=t.onRecoverableError)),e=Al(e,null,n,1,null!=t?t:null,o,0,i,v),n[so]=e.current,Lr(n),r)for(n=0;n<r.length;n++)o=(o=(t=r[n])._getVersion)(t._source),null==e.mutableSourceEagerHydrationData?e.mutableSourceEagerHydrationData=[t,o]:e.mutableSourceEagerHydrationData.push(t,o);return new Hl(e)},e.render=function(n,e,t){if(!Yl(e))throw Error(a(200));return Zl(null,n,e,!1,t)},e.unmountComponentAtNode=function(n){if(!Yl(n))throw Error(a(40));return!!n._reactRootContainer&&(il((function(){Zl(null,null,n,!1,(function(){n._reactRootContainer=null,n[so]=null}))})),!0)},e.unstable_batchedUpdates=al,e.unstable_renderSubtreeIntoContainer=function(n,e,t,r){if(!Yl(t))throw Error(a(200));if(null==n||void 0===n._reactInternals)throw Error(a(38));return Zl(n,e,t,!1,r)},e.version="18.2.0-next-9e3b772b8-20220608"},250:function(n,e,t){"use strict";var r=t(164);e.s=r.createRoot,r.hydrateRoot},164:function(n,e,t){"use strict";!function n(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}(),n.exports=t(463)},976:function(n,e){"use strict";e.ConcurrentRoot=1,e.ContinuousEventPriority=4,e.DefaultEventPriority=16,e.DiscreteEventPriority=1},721:function(n,e,t){n.exports=function(n){var e={},r=t(791),o=t(100),a=Object.assign;function i(n){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+n,t=1;t<arguments.length;t++)e+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+n+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var v=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,c=Symbol.for("react.element"),l=Symbol.for("react.portal"),s=Symbol.for("react.fragment"),u=Symbol.for("react.strict_mode"),f=Symbol.for("react.profiler"),p=Symbol.for("react.provider"),d=Symbol.for("react.context"),m=Symbol.for("react.forward_ref"),h=Symbol.for("react.suspense"),x=Symbol.for("react.suspense_list"),g=Symbol.for("react.memo"),y=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var b=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var _=Symbol.iterator;function U(n){return null===n||"object"!==typeof n?null:"function"===typeof(n=_&&n[_]||n["@@iterator"])?n:null}function w(n){if(null==n)return null;if("function"===typeof n)return n.displayName||n.name||null;if("string"===typeof n)return n;switch(n){case s:return"Fragment";case l:return"Portal";case f:return"Profiler";case u:return"StrictMode";case h:return"Suspense";case x:return"SuspenseList"}if("object"===typeof n)switch(n.$$typeof){case d:return(n.displayName||"Context")+".Consumer";case p:return(n._context.displayName||"Context")+".Provider";case m:var e=n.render;return(n=n.displayName)||(n=""!==(n=e.displayName||e.name||"")?"ForwardRef("+n+")":"ForwardRef"),n;case g:return null!==(e=n.displayName||null)?e:w(n.type)||"Memo";case y:e=n._payload,n=n._init;try{return w(n(e))}catch(t){}}return null}function S(n){var e=n.type;switch(n.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return n=(n=e.render).displayName||n.name||"",e.displayName||(""!==n?"ForwardRef("+n+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return w(e);case 8:return e===u?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e}return null}function k(n){var e=n,t=n;if(n.alternate)for(;e.return;)e=e.return;else{n=e;do{0!==(4098&(e=n).flags)&&(t=e.return),n=e.return}while(n)}return 3===e.tag?t:null}function M(n){if(k(n)!==n)throw Error(i(188))}function z(n){var e=n.alternate;if(!e){if(null===(e=k(n)))throw Error(i(188));return e!==n?null:n}for(var t=n,r=e;;){var o=t.return;if(null===o)break;var a=o.alternate;if(null===a){if(null!==(r=o.return)){t=r;continue}break}if(o.child===a.child){for(a=o.child;a;){if(a===t)return M(o),n;if(a===r)return M(o),e;a=a.sibling}throw Error(i(188))}if(t.return!==r.return)t=o,r=a;else{for(var v=!1,c=o.child;c;){if(c===t){v=!0,t=o,r=a;break}if(c===r){v=!0,r=o,t=a;break}c=c.sibling}if(!v){for(c=a.child;c;){if(c===t){v=!0,t=a,r=o;break}if(c===r){v=!0,r=a,t=o;break}c=c.sibling}if(!v)throw Error(i(189))}}if(t.alternate!==r)throw Error(i(190))}if(3!==t.tag)throw Error(i(188));return t.stateNode.current===t?n:e}function C(n){return null!==(n=z(n))?T(n):null}function T(n){if(5===n.tag||6===n.tag)return n;for(n=n.child;null!==n;){var e=T(n);if(null!==e)return e;n=n.sibling}return null}function R(n){if(5===n.tag||6===n.tag)return n;for(n=n.child;null!==n;){if(4!==n.tag){var e=R(n);if(null!==e)return e}n=n.sibling}return null}var D,P=Array.isArray,j=n.getPublicInstance,F=n.getRootHostContext,E=n.getChildHostContext,I=n.prepareForCommit,O=n.resetAfterCommit,L=n.createInstance,A=n.appendInitialChild,N=n.finalizeInitialChildren,G=n.prepareUpdate,B=n.shouldSetTextContent,q=n.createTextInstance,V=n.scheduleTimeout,W=n.cancelTimeout,H=n.noTimeout,X=n.isPrimaryRenderer,Y=n.supportsMutation,$=n.supportsPersistence,Z=n.supportsHydration,K=n.getInstanceFromNode,J=n.preparePortalMount,Q=n.getCurrentEventPriority,nn=n.detachDeletedInstance,en=n.supportsMicrotasks,tn=n.scheduleMicrotask,rn=n.supportsTestSelectors,on=n.findFiberRoot,an=n.getBoundingRect,vn=n.getTextContent,cn=n.isHiddenSubtree,ln=n.matchAccessibilityRole,sn=n.setFocusIfFocusable,un=n.setupIntersectionObserver,fn=n.appendChild,pn=n.appendChildToContainer,dn=n.commitTextUpdate,mn=n.commitMount,hn=n.commitUpdate,xn=n.insertBefore,gn=n.insertInContainerBefore,yn=n.removeChild,bn=n.removeChildFromContainer,_n=n.resetTextContent,Un=n.hideInstance,wn=n.hideTextInstance,Sn=n.unhideInstance,kn=n.unhideTextInstance,Mn=n.clearContainer,zn=n.cloneInstance,Cn=n.createContainerChildSet,Tn=n.appendChildToContainerChildSet,Rn=n.finalizeContainerChildren,Dn=n.replaceContainerChildren,Pn=n.cloneHiddenInstance,jn=n.cloneHiddenTextInstance,Fn=n.canHydrateInstance,En=n.canHydrateTextInstance,In=n.canHydrateSuspenseInstance,On=n.isSuspenseInstancePending,Ln=n.isSuspenseInstanceFallback,An=n.registerSuspenseInstanceRetry,Nn=n.getNextHydratableSibling,Gn=n.getFirstHydratableChild,Bn=n.getFirstHydratableChildWithinContainer,qn=n.getFirstHydratableChildWithinSuspenseInstance,Vn=n.hydrateInstance,Wn=n.hydrateTextInstance,Hn=n.hydrateSuspenseInstance,Xn=n.getNextHydratableInstanceAfterSuspenseInstance,Yn=n.commitHydratedContainer,$n=n.commitHydratedSuspenseInstance,Zn=n.clearSuspenseBoundary,Kn=n.clearSuspenseBoundaryFromContainer,Jn=n.shouldDeleteUnhydratedTailInstances,Qn=n.didNotMatchHydratedContainerTextInstance,ne=n.didNotMatchHydratedTextInstance;function ee(n){if(void 0===D)try{throw Error()}catch(t){var e=t.stack.trim().match(/\n( *(at )?)/);D=e&&e[1]||""}return"\n"+D+n}var te=!1;function re(n,e){if(!n||te)return"";te=!0;var t=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(e,[])}catch(l){var r=l}Reflect.construct(n,[],e)}else{try{e.call()}catch(l){r=l}n.call(e.prototype)}else{try{throw Error()}catch(l){r=l}n()}}catch(l){if(l&&r&&"string"===typeof l.stack){for(var o=l.stack.split("\n"),a=r.stack.split("\n"),i=o.length-1,v=a.length-1;1<=i&&0<=v&&o[i]!==a[v];)v--;for(;1<=i&&0<=v;i--,v--)if(o[i]!==a[v]){if(1!==i||1!==v)do{if(i--,0>--v||o[i]!==a[v]){var c="\n"+o[i].replace(" at new "," at ");return n.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",n.displayName)),c}}while(1<=i&&0<=v);break}}}finally{te=!1,Error.prepareStackTrace=t}return(n=n?n.displayName||n.name:"")?ee(n):""}var oe=Object.prototype.hasOwnProperty,ae=[],ie=-1;function ve(n){return{current:n}}function ce(n){0>ie||(n.current=ae[ie],ae[ie]=null,ie--)}function le(n,e){ie++,ae[ie]=n.current,n.current=e}var se={},ue=ve(se),fe=ve(!1),pe=se;function de(n,e){var t=n.type.contextTypes;if(!t)return se;var r=n.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===e)return r.__reactInternalMemoizedMaskedChildContext;var o,a={};for(o in t)a[o]=e[o];return r&&((n=n.stateNode).__reactInternalMemoizedUnmaskedChildContext=e,n.__reactInternalMemoizedMaskedChildContext=a),a}function me(n){return null!==(n=n.childContextTypes)&&void 0!==n}function he(){ce(fe),ce(ue)}function xe(n,e,t){if(ue.current!==se)throw Error(i(168));le(ue,e),le(fe,t)}function ge(n,e,t){var r=n.stateNode;if(e=e.childContextTypes,"function"!==typeof r.getChildContext)return t;for(var o in r=r.getChildContext())if(!(o in e))throw Error(i(108,S(n)||"Unknown",o));return a({},t,r)}function ye(n){return n=(n=n.stateNode)&&n.__reactInternalMemoizedMergedChildContext||se,pe=ue.current,le(ue,n),le(fe,fe.current),!0}function be(n,e,t){var r=n.stateNode;if(!r)throw Error(i(169));t?(n=ge(n,e,pe),r.__reactInternalMemoizedMergedChildContext=n,ce(fe),ce(ue),le(ue,n)):ce(fe),le(fe,t)}var _e=Math.clz32?Math.clz32:function(n){return 0===(n>>>=0)?32:31-(Ue(n)/we|0)|0},Ue=Math.log,we=Math.LN2;var Se=64,ke=4194304;function Me(n){switch(n&-n){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&n;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&n;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return n}}function ze(n,e){var t=n.pendingLanes;if(0===t)return 0;var r=0,o=n.suspendedLanes,a=n.pingedLanes,i=268435455&t;if(0!==i){var v=i&~o;0!==v?r=Me(v):0!==(a&=i)&&(r=Me(a))}else 0!==(i=t&~o)?r=Me(i):0!==a&&(r=Me(a));if(0===r)return 0;if(0!==e&&e!==r&&0===(e&o)&&((o=r&-r)>=(a=e&-e)||16===o&&0!==(4194240&a)))return e;if(0!==(4&r)&&(r|=16&t),0!==(e=n.entangledLanes))for(n=n.entanglements,e&=r;0<e;)o=1<<(t=31-_e(e)),r|=n[t],e&=~o;return r}function Ce(n,e){switch(n){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;default:return-1}}function Te(n){return 0!==(n=-1073741825&n.pendingLanes)?n:1073741824&n?1073741824:0}function Re(n){for(var e=[],t=0;31>t;t++)e.push(n);return e}function De(n,e,t){n.pendingLanes|=e,536870912!==e&&(n.suspendedLanes=0,n.pingedLanes=0),(n=n.eventTimes)[e=31-_e(e)]=t}function Pe(n,e){var t=n.entangledLanes|=e;for(n=n.entanglements;t;){var r=31-_e(t),o=1<<r;o&e|n[r]&e&&(n[r]|=e),t&=~o}}var je=0;function Fe(n){return 1<(n&=-n)?4<n?0!==(268435455&n)?16:536870912:4:1}var Ee=o.unstable_scheduleCallback,Ie=o.unstable_cancelCallback,Oe=o.unstable_shouldYield,Le=o.unstable_requestPaint,Ae=o.unstable_now,Ne=o.unstable_ImmediatePriority,Ge=o.unstable_UserBlockingPriority,Be=o.unstable_NormalPriority,qe=o.unstable_IdlePriority,Ve=null,We=null;var He="function"===typeof Object.is?Object.is:function(n,e){return n===e&&(0!==n||1/n===1/e)||n!==n&&e!==e},Xe=null,Ye=!1,$e=!1;function Ze(n){null===Xe?Xe=[n]:Xe.push(n)}function Ke(){if(!$e&&null!==Xe){$e=!0;var n=0,e=je;try{var t=Xe;for(je=1;n<t.length;n++){var r=t[n];do{r=r(!0)}while(null!==r)}Xe=null,Ye=!1}catch(o){throw null!==Xe&&(Xe=Xe.slice(n+1)),Ee(Ne,Ke),o}finally{je=e,$e=!1}}return null}var Je=v.ReactCurrentBatchConfig;function Qe(n,e){if(He(n,e))return!0;if("object"!==typeof n||null===n||"object"!==typeof e||null===e)return!1;var t=Object.keys(n),r=Object.keys(e);if(t.length!==r.length)return!1;for(r=0;r<t.length;r++){var o=t[r];if(!oe.call(e,o)||!He(n[o],e[o]))return!1}return!0}function nt(n){switch(n.tag){case 5:return ee(n.type);case 16:return ee("Lazy");case 13:return ee("Suspense");case 19:return ee("SuspenseList");case 0:case 2:case 15:return n=re(n.type,!1);case 11:return n=re(n.type.render,!1);case 1:return n=re(n.type,!0);default:return""}}function et(n,e){if(n&&n.defaultProps){for(var t in e=a({},e),n=n.defaultProps)void 0===e[t]&&(e[t]=n[t]);return e}return e}var tt=ve(null),rt=null,ot=null,at=null;function it(){at=ot=rt=null}function vt(n,e,t){X?(le(tt,e._currentValue),e._currentValue=t):(le(tt,e._currentValue2),e._currentValue2=t)}function ct(n){var e=tt.current;ce(tt),X?n._currentValue=e:n._currentValue2=e}function lt(n,e,t){for(;null!==n;){var r=n.alternate;if((n.childLanes&e)!==e?(n.childLanes|=e,null!==r&&(r.childLanes|=e)):null!==r&&(r.childLanes&e)!==e&&(r.childLanes|=e),n===t)break;n=n.return}}function st(n,e){rt=n,at=ot=null,null!==(n=n.dependencies)&&null!==n.firstContext&&(0!==(n.lanes&e)&&(Oo=!0),n.firstContext=null)}function ut(n){var e=X?n._currentValue:n._currentValue2;if(at!==n)if(n={context:n,memoizedValue:e,next:null},null===ot){if(null===rt)throw Error(i(308));ot=n,rt.dependencies={lanes:0,firstContext:n}}else ot=ot.next=n;return e}var ft=null,pt=!1;function dt(n){n.updateQueue={baseState:n.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function mt(n,e){n=n.updateQueue,e.updateQueue===n&&(e.updateQueue={baseState:n.baseState,firstBaseUpdate:n.firstBaseUpdate,lastBaseUpdate:n.lastBaseUpdate,shared:n.shared,effects:n.effects})}function ht(n,e){return{eventTime:n,lane:e,tag:0,payload:null,callback:null,next:null}}function xt(n,e){var t=n.updateQueue;null!==t&&(t=t.shared,null!==$a&&0!==(1&n.mode)&&0===(2&Ya)?(null===(n=t.interleaved)?(e.next=e,null===ft?ft=[t]:ft.push(t)):(e.next=n.next,n.next=e),t.interleaved=e):(null===(n=t.pending)?e.next=e:(e.next=n.next,n.next=e),t.pending=e))}function gt(n,e,t){if(null!==(e=e.updateQueue)&&(e=e.shared,0!==(4194240&t))){var r=e.lanes;t|=r&=n.pendingLanes,e.lanes=t,Pe(n,t)}}function yt(n,e){var t=n.updateQueue,r=n.alternate;if(null!==r&&t===(r=r.updateQueue)){var o=null,a=null;if(null!==(t=t.firstBaseUpdate)){do{var i={eventTime:t.eventTime,lane:t.lane,tag:t.tag,payload:t.payload,callback:t.callback,next:null};null===a?o=a=i:a=a.next=i,t=t.next}while(null!==t);null===a?o=a=e:a=a.next=e}else o=a=e;return t={baseState:r.baseState,firstBaseUpdate:o,lastBaseUpdate:a,shared:r.shared,effects:r.effects},void(n.updateQueue=t)}null===(n=t.lastBaseUpdate)?t.firstBaseUpdate=e:n.next=e,t.lastBaseUpdate=e}function bt(n,e,t,r){var o=n.updateQueue;pt=!1;var i=o.firstBaseUpdate,v=o.lastBaseUpdate,c=o.shared.pending;if(null!==c){o.shared.pending=null;var l=c,s=l.next;l.next=null,null===v?i=s:v.next=s,v=l;var u=n.alternate;null!==u&&((c=(u=u.updateQueue).lastBaseUpdate)!==v&&(null===c?u.firstBaseUpdate=s:c.next=s,u.lastBaseUpdate=l))}if(null!==i){var f=o.baseState;for(v=0,u=s=l=null,c=i;;){var p=c.lane,d=c.eventTime;if((r&p)===p){null!==u&&(u=u.next={eventTime:d,lane:0,tag:c.tag,payload:c.payload,callback:c.callback,next:null});n:{var m=n,h=c;switch(p=e,d=t,h.tag){case 1:if("function"===typeof(m=h.payload)){f=m.call(d,f,p);break n}f=m;break n;case 3:m.flags=-65537&m.flags|128;case 0:if(null===(p="function"===typeof(m=h.payload)?m.call(d,f,p):m)||void 0===p)break n;f=a({},f,p);break n;case 2:pt=!0}}null!==c.callback&&0!==c.lane&&(n.flags|=64,null===(p=o.effects)?o.effects=[c]:p.push(c))}else d={eventTime:d,lane:p,tag:c.tag,payload:c.payload,callback:c.callback,next:null},null===u?(s=u=d,l=f):u=u.next=d,v|=p;if(null===(c=c.next)){if(null===(c=o.shared.pending))break;c=(p=c).next,p.next=null,o.lastBaseUpdate=p,o.shared.pending=null}}if(null===u&&(l=f),o.baseState=l,o.firstBaseUpdate=s,o.lastBaseUpdate=u,null!==(e=o.shared.interleaved)){o=e;do{v|=o.lane,o=o.next}while(o!==e)}else null===i&&(o.shared.lanes=0);ti|=v,n.lanes=v,n.memoizedState=f}}function _t(n,e,t){if(n=e.effects,e.effects=null,null!==n)for(e=0;e<n.length;e++){var r=n[e],o=r.callback;if(null!==o){if(r.callback=null,r=t,"function"!==typeof o)throw Error(i(191,o));o.call(r)}}}var Ut=(new r.Component).refs;function wt(n,e,t,r){t=null===(t=t(r,e=n.memoizedState))||void 0===t?e:a({},e,t),n.memoizedState=t,0===n.lanes&&(n.updateQueue.baseState=t)}var St={isMounted:function(n){return!!(n=n._reactInternals)&&k(n)===n},enqueueSetState:function(n,e,t){n=n._reactInternals;var r=_i(),o=Ui(n),a=ht(r,o);a.payload=e,void 0!==t&&null!==t&&(a.callback=t),xt(n,a),null!==(e=wi(n,o,r))&&gt(e,n,o)},enqueueReplaceState:function(n,e,t){n=n._reactInternals;var r=_i(),o=Ui(n),a=ht(r,o);a.tag=1,a.payload=e,void 0!==t&&null!==t&&(a.callback=t),xt(n,a),null!==(e=wi(n,o,r))&&gt(e,n,o)},enqueueForceUpdate:function(n,e){n=n._reactInternals;var t=_i(),r=Ui(n),o=ht(t,r);o.tag=2,void 0!==e&&null!==e&&(o.callback=e),xt(n,o),null!==(e=wi(n,r,t))&&gt(e,n,r)}};function kt(n,e,t,r,o,a,i){return"function"===typeof(n=n.stateNode).shouldComponentUpdate?n.shouldComponentUpdate(r,a,i):!e.prototype||!e.prototype.isPureReactComponent||(!Qe(t,r)||!Qe(o,a))}function Mt(n,e,t){var r=!1,o=se,a=e.contextType;return"object"===typeof a&&null!==a?a=ut(a):(o=me(e)?pe:ue.current,a=(r=null!==(r=e.contextTypes)&&void 0!==r)?de(n,o):se),e=new e(t,a),n.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,e.updater=St,n.stateNode=e,e._reactInternals=n,r&&((n=n.stateNode).__reactInternalMemoizedUnmaskedChildContext=o,n.__reactInternalMemoizedMaskedChildContext=a),e}function zt(n,e,t,r){n=e.state,"function"===typeof e.componentWillReceiveProps&&e.componentWillReceiveProps(t,r),"function"===typeof e.UNSAFE_componentWillReceiveProps&&e.UNSAFE_componentWillReceiveProps(t,r),e.state!==n&&St.enqueueReplaceState(e,e.state,null)}function Ct(n,e,t,r){var o=n.stateNode;o.props=t,o.state=n.memoizedState,o.refs=Ut,dt(n);var a=e.contextType;"object"===typeof a&&null!==a?o.context=ut(a):(a=me(e)?pe:ue.current,o.context=de(n,a)),o.state=n.memoizedState,"function"===typeof(a=e.getDerivedStateFromProps)&&(wt(n,e,a,t),o.state=n.memoizedState),"function"===typeof e.getDerivedStateFromProps||"function"===typeof o.getSnapshotBeforeUpdate||"function"!==typeof o.UNSAFE_componentWillMount&&"function"!==typeof o.componentWillMount||(e=o.state,"function"===typeof o.componentWillMount&&o.componentWillMount(),"function"===typeof o.UNSAFE_componentWillMount&&o.UNSAFE_componentWillMount(),e!==o.state&&St.enqueueReplaceState(o,o.state,null),bt(n,t,o,r),o.state=n.memoizedState),"function"===typeof o.componentDidMount&&(n.flags|=4194308)}var Tt=[],Rt=0,Dt=null,Pt=0,jt=[],Ft=0,Et=null,It=1,Ot="";function Lt(n,e){Tt[Rt++]=Pt,Tt[Rt++]=Dt,Dt=n,Pt=e}function At(n,e,t){jt[Ft++]=It,jt[Ft++]=Ot,jt[Ft++]=Et,Et=n;var r=It;n=Ot;var o=32-_e(r)-1;r&=~(1<<o),t+=1;var a=32-_e(e)+o;if(30<a){var i=o-o%5;a=(r&(1<<i)-1).toString(32),r>>=i,o-=i,It=1<<32-_e(e)+o|t<<o|r,Ot=a+n}else It=1<<a|t<<o|r,Ot=n}function Nt(n){null!==n.return&&(Lt(n,1),At(n,1,0))}function Gt(n){for(;n===Dt;)Dt=Tt[--Rt],Tt[Rt]=null,Pt=Tt[--Rt],Tt[Rt]=null;for(;n===Et;)Et=jt[--Ft],jt[Ft]=null,Ot=jt[--Ft],jt[Ft]=null,It=jt[--Ft],jt[Ft]=null}var Bt=null,qt=null,Vt=!1,Wt=!1,Ht=null;function Xt(n,e){var t=Ji(5,null,null,0);t.elementType="DELETED",t.stateNode=e,t.return=n,null===(e=n.deletions)?(n.deletions=[t],n.flags|=16):e.push(t)}function Yt(n,e){switch(n.tag){case 5:return null!==(e=Fn(e,n.type,n.pendingProps))&&(n.stateNode=e,Bt=n,qt=Gn(e),!0);case 6:return null!==(e=En(e,n.pendingProps))&&(n.stateNode=e,Bt=n,qt=null,!0);case 13:if(null!==(e=In(e))){var t=null!==Et?{id:It,overflow:Ot}:null;return n.memoizedState={dehydrated:e,treeContext:t,retryLane:1073741824},(t=Ji(18,null,null,0)).stateNode=e,t.return=n,n.child=t,Bt=n,qt=null,!0}return!1;default:return!1}}function $t(n){return 0!==(1&n.mode)&&0===(128&n.flags)}function Zt(n){if(Vt){var e=qt;if(e){var t=e;if(!Yt(n,e)){if($t(n))throw Error(i(418));e=Nn(t);var r=Bt;e&&Yt(n,e)?Xt(r,t):(n.flags=-4097&n.flags|2,Vt=!1,Bt=n)}}else{if($t(n))throw Error(i(418));n.flags=-4097&n.flags|2,Vt=!1,Bt=n}}}function Kt(n){for(n=n.return;null!==n&&5!==n.tag&&3!==n.tag&&13!==n.tag;)n=n.return;Bt=n}function Jt(n){if(!Z||n!==Bt)return!1;if(!Vt)return Kt(n),Vt=!0,!1;if(3!==n.tag&&(5!==n.tag||Jn(n.type)&&!B(n.type,n.memoizedProps))){var e=qt;if(e){if($t(n)){for(n=qt;n;)n=Nn(n);throw Error(i(418))}for(;e;)Xt(n,e),e=Nn(e)}}if(Kt(n),13===n.tag){if(!Z)throw Error(i(316));if(!(n=null!==(n=n.memoizedState)?n.dehydrated:null))throw Error(i(317));qt=Xn(n)}else qt=Bt?Nn(n.stateNode):null;return!0}function Qt(){Z&&(qt=Bt=null,Wt=Vt=!1)}function nr(n){null===Ht?Ht=[n]:Ht.push(n)}function er(n,e,t){if(null!==(n=t.ref)&&"function"!==typeof n&&"object"!==typeof n){if(t._owner){if(t=t._owner){if(1!==t.tag)throw Error(i(309));var r=t.stateNode}if(!r)throw Error(i(147,n));var o=r,a=""+n;return null!==e&&null!==e.ref&&"function"===typeof e.ref&&e.ref._stringRef===a?e.ref:(e=function(n){var e=o.refs;e===Ut&&(e=o.refs={}),null===n?delete e[a]:e[a]=n},e._stringRef=a,e)}if("string"!==typeof n)throw Error(i(284));if(!t._owner)throw Error(i(290,n))}return n}function tr(n,e){throw n=Object.prototype.toString.call(e),Error(i(31,"[object Object]"===n?"object with keys {"+Object.keys(e).join(", ")+"}":n))}function rr(n){return(0,n._init)(n._payload)}function or(n){function e(e,t){if(n){var r=e.deletions;null===r?(e.deletions=[t],e.flags|=16):r.push(t)}}function t(t,r){if(!n)return null;for(;null!==r;)e(t,r),r=r.sibling;return null}function r(n,e){for(n=new Map;null!==e;)null!==e.key?n.set(e.key,e):n.set(e.index,e),e=e.sibling;return n}function o(n,e){return(n=nv(n,e)).index=0,n.sibling=null,n}function a(e,t,r){return e.index=r,n?null!==(r=e.alternate)?(r=r.index)<t?(e.flags|=2,t):r:(e.flags|=2,t):(e.flags|=1048576,t)}function v(e){return n&&null===e.alternate&&(e.flags|=2),e}function u(n,e,t,r){return null===e||6!==e.tag?((e=ov(t,n.mode,r)).return=n,e):((e=o(e,t)).return=n,e)}function f(n,e,t,r){var a=t.type;return a===s?d(n,e,t.props.children,r,t.key):null!==e&&(e.elementType===a||"object"===typeof a&&null!==a&&a.$$typeof===y&&rr(a)===e.type)?((r=o(e,t.props)).ref=er(n,e,t),r.return=n,r):((r=ev(t.type,t.key,t.props,null,n.mode,r)).ref=er(n,e,t),r.return=n,r)}function p(n,e,t,r){return null===e||4!==e.tag||e.stateNode.containerInfo!==t.containerInfo||e.stateNode.implementation!==t.implementation?((e=av(t,n.mode,r)).return=n,e):((e=o(e,t.children||[])).return=n,e)}function d(n,e,t,r,a){return null===e||7!==e.tag?((e=tv(t,n.mode,r,a)).return=n,e):((e=o(e,t)).return=n,e)}function m(n,e,t){if("string"===typeof e&&""!==e||"number"===typeof e)return(e=ov(""+e,n.mode,t)).return=n,e;if("object"===typeof e&&null!==e){switch(e.$$typeof){case c:return(t=ev(e.type,e.key,e.props,null,n.mode,t)).ref=er(n,null,e),t.return=n,t;case l:return(e=av(e,n.mode,t)).return=n,e;case y:return m(n,(0,e._init)(e._payload),t)}if(P(e)||U(e))return(e=tv(e,n.mode,t,null)).return=n,e;tr(n,e)}return null}function h(n,e,t,r){var o=null!==e?e.key:null;if("string"===typeof t&&""!==t||"number"===typeof t)return null!==o?null:u(n,e,""+t,r);if("object"===typeof t&&null!==t){switch(t.$$typeof){case c:return t.key===o?f(n,e,t,r):null;case l:return t.key===o?p(n,e,t,r):null;case y:return h(n,e,(o=t._init)(t._payload),r)}if(P(t)||U(t))return null!==o?null:d(n,e,t,r,null);tr(n,t)}return null}function x(n,e,t,r,o){if("string"===typeof r&&""!==r||"number"===typeof r)return u(e,n=n.get(t)||null,""+r,o);if("object"===typeof r&&null!==r){switch(r.$$typeof){case c:return f(e,n=n.get(null===r.key?t:r.key)||null,r,o);case l:return p(e,n=n.get(null===r.key?t:r.key)||null,r,o);case y:return x(n,e,t,(0,r._init)(r._payload),o)}if(P(r)||U(r))return d(e,n=n.get(t)||null,r,o,null);tr(e,r)}return null}function g(o,i,v,c){for(var l=null,s=null,u=i,f=i=0,p=null;null!==u&&f<v.length;f++){u.index>f?(p=u,u=null):p=u.sibling;var d=h(o,u,v[f],c);if(null===d){null===u&&(u=p);break}n&&u&&null===d.alternate&&e(o,u),i=a(d,i,f),null===s?l=d:s.sibling=d,s=d,u=p}if(f===v.length)return t(o,u),Vt&&Lt(o,f),l;if(null===u){for(;f<v.length;f++)null!==(u=m(o,v[f],c))&&(i=a(u,i,f),null===s?l=u:s.sibling=u,s=u);return Vt&&Lt(o,f),l}for(u=r(o,u);f<v.length;f++)null!==(p=x(u,o,f,v[f],c))&&(n&&null!==p.alternate&&u.delete(null===p.key?f:p.key),i=a(p,i,f),null===s?l=p:s.sibling=p,s=p);return n&&u.forEach((function(n){return e(o,n)})),Vt&&Lt(o,f),l}function b(o,v,c,l){var s=U(c);if("function"!==typeof s)throw Error(i(150));if(null==(c=s.call(c)))throw Error(i(151));for(var u=s=null,f=v,p=v=0,d=null,g=c.next();null!==f&&!g.done;p++,g=c.next()){f.index>p?(d=f,f=null):d=f.sibling;var y=h(o,f,g.value,l);if(null===y){null===f&&(f=d);break}n&&f&&null===y.alternate&&e(o,f),v=a(y,v,p),null===u?s=y:u.sibling=y,u=y,f=d}if(g.done)return t(o,f),Vt&&Lt(o,p),s;if(null===f){for(;!g.done;p++,g=c.next())null!==(g=m(o,g.value,l))&&(v=a(g,v,p),null===u?s=g:u.sibling=g,u=g);return Vt&&Lt(o,p),s}for(f=r(o,f);!g.done;p++,g=c.next())null!==(g=x(f,o,p,g.value,l))&&(n&&null!==g.alternate&&f.delete(null===g.key?p:g.key),v=a(g,v,p),null===u?s=g:u.sibling=g,u=g);return n&&f.forEach((function(n){return e(o,n)})),Vt&&Lt(o,p),s}return function n(r,a,i,u){if("object"===typeof i&&null!==i&&i.type===s&&null===i.key&&(i=i.props.children),"object"===typeof i&&null!==i){switch(i.$$typeof){case c:n:{for(var f=i.key,p=a;null!==p;){if(p.key===f){if((f=i.type)===s){if(7===p.tag){t(r,p.sibling),(a=o(p,i.props.children)).return=r,r=a;break n}}else if(p.elementType===f||"object"===typeof f&&null!==f&&f.$$typeof===y&&rr(f)===p.type){t(r,p.sibling),(a=o(p,i.props)).ref=er(r,p,i),a.return=r,r=a;break n}t(r,p);break}e(r,p),p=p.sibling}i.type===s?((a=tv(i.props.children,r.mode,u,i.key)).return=r,r=a):((u=ev(i.type,i.key,i.props,null,r.mode,u)).ref=er(r,a,i),u.return=r,r=u)}return v(r);case l:n:{for(p=i.key;null!==a;){if(a.key===p){if(4===a.tag&&a.stateNode.containerInfo===i.containerInfo&&a.stateNode.implementation===i.implementation){t(r,a.sibling),(a=o(a,i.children||[])).return=r,r=a;break n}t(r,a);break}e(r,a),a=a.sibling}(a=av(i,r.mode,u)).return=r,r=a}return v(r);case y:return n(r,a,(p=i._init)(i._payload),u)}if(P(i))return g(r,a,i,u);if(U(i))return b(r,a,i,u);tr(r,i)}return"string"===typeof i&&""!==i||"number"===typeof i?(i=""+i,null!==a&&6===a.tag?(t(r,a.sibling),(a=o(a,i)).return=r,r=a):(t(r,a),(a=ov(i,r.mode,u)).return=r,r=a),v(r)):t(r,a)}}var ar=or(!0),ir=or(!1),vr={},cr=ve(vr),lr=ve(vr),sr=ve(vr);function ur(n){if(n===vr)throw Error(i(174));return n}function fr(n,e){le(sr,e),le(lr,n),le(cr,vr),n=F(e),ce(cr),le(cr,n)}function pr(){ce(cr),ce(lr),ce(sr)}function dr(n){var e=ur(sr.current),t=ur(cr.current);t!==(e=E(t,n.type,e))&&(le(lr,n),le(cr,e))}function mr(n){lr.current===n&&(ce(cr),ce(lr))}var hr=ve(0);function xr(n){for(var e=n;null!==e;){if(13===e.tag){var t=e.memoizedState;if(null!==t&&(null===(t=t.dehydrated)||On(t)||Ln(t)))return e}else if(19===e.tag&&void 0!==e.memoizedProps.revealOrder){if(0!==(128&e.flags))return e}else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===n)break;for(;null===e.sibling;){if(null===e.return||e.return===n)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var gr=[];function yr(){for(var n=0;n<gr.length;n++){var e=gr[n];X?e._workInProgressVersionPrimary=null:e._workInProgressVersionSecondary=null}gr.length=0}var br=v.ReactCurrentDispatcher,_r=v.ReactCurrentBatchConfig,Ur=0,wr=null,Sr=null,kr=null,Mr=!1,zr=!1,Cr=0,Tr=0;function Rr(){throw Error(i(321))}function Dr(n,e){if(null===e)return!1;for(var t=0;t<e.length&&t<n.length;t++)if(!He(n[t],e[t]))return!1;return!0}function Pr(n,e,t,r,o,a){if(Ur=a,wr=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,br.current=null===n||null===n.memoizedState?mo:ho,n=t(r,o),zr){a=0;do{if(zr=!1,Cr=0,25<=a)throw Error(i(301));a+=1,kr=Sr=null,e.updateQueue=null,br.current=xo,n=t(r,o)}while(zr)}if(br.current=po,e=null!==Sr&&null!==Sr.next,Ur=0,kr=Sr=wr=null,Mr=!1,e)throw Error(i(300));return n}function jr(){var n=0!==Cr;return Cr=0,n}function Fr(){var n={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===kr?wr.memoizedState=kr=n:kr=kr.next=n,kr}function Er(){if(null===Sr){var n=wr.alternate;n=null!==n?n.memoizedState:null}else n=Sr.next;var e=null===kr?wr.memoizedState:kr.next;if(null!==e)kr=e,Sr=n;else{if(null===n)throw Error(i(310));n={memoizedState:(Sr=n).memoizedState,baseState:Sr.baseState,baseQueue:Sr.baseQueue,queue:Sr.queue,next:null},null===kr?wr.memoizedState=kr=n:kr=kr.next=n}return kr}function Ir(n,e){return"function"===typeof e?e(n):e}function Or(n){var e=Er(),t=e.queue;if(null===t)throw Error(i(311));t.lastRenderedReducer=n;var r=Sr,o=r.baseQueue,a=t.pending;if(null!==a){if(null!==o){var v=o.next;o.next=a.next,a.next=v}r.baseQueue=o=a,t.pending=null}if(null!==o){a=o.next,r=r.baseState;var c=v=null,l=null,s=a;do{var u=s.lane;if((Ur&u)===u)null!==l&&(l=l.next={lane:0,action:s.action,hasEagerState:s.hasEagerState,eagerState:s.eagerState,next:null}),r=s.hasEagerState?s.eagerState:n(r,s.action);else{var f={lane:u,action:s.action,hasEagerState:s.hasEagerState,eagerState:s.eagerState,next:null};null===l?(c=l=f,v=r):l=l.next=f,wr.lanes|=u,ti|=u}s=s.next}while(null!==s&&s!==a);null===l?v=r:l.next=c,He(r,e.memoizedState)||(Oo=!0),e.memoizedState=r,e.baseState=v,e.baseQueue=l,t.lastRenderedState=r}if(null!==(n=t.interleaved)){o=n;do{a=o.lane,wr.lanes|=a,ti|=a,o=o.next}while(o!==n)}else null===o&&(t.lanes=0);return[e.memoizedState,t.dispatch]}function Lr(n){var e=Er(),t=e.queue;if(null===t)throw Error(i(311));t.lastRenderedReducer=n;var r=t.dispatch,o=t.pending,a=e.memoizedState;if(null!==o){t.pending=null;var v=o=o.next;do{a=n(a,v.action),v=v.next}while(v!==o);He(a,e.memoizedState)||(Oo=!0),e.memoizedState=a,null===e.baseQueue&&(e.baseState=a),t.lastRenderedState=a}return[a,r]}function Ar(){}function Nr(n,e){var t=wr,r=Er(),o=e(),a=!He(r.memoizedState,o);if(a&&(r.memoizedState=o,Oo=!0),r=r.queue,Kr(qr.bind(null,t,r,n),[n]),r.getSnapshot!==e||a||null!==kr&&1&kr.memoizedState.tag){if(t.flags|=2048,Hr(9,Br.bind(null,t,r,o,e),void 0,null),null===$a)throw Error(i(349));0!==(30&Ur)||Gr(t,e,o)}return o}function Gr(n,e,t){n.flags|=16384,n={getSnapshot:e,value:t},null===(e=wr.updateQueue)?(e={lastEffect:null,stores:null},wr.updateQueue=e,e.stores=[n]):null===(t=e.stores)?e.stores=[n]:t.push(n)}function Br(n,e,t,r){e.value=t,e.getSnapshot=r,Vr(e)&&wi(n,1,-1)}function qr(n,e,t){return t((function(){Vr(e)&&wi(n,1,-1)}))}function Vr(n){var e=n.getSnapshot;n=n.value;try{var t=e();return!He(n,t)}catch(r){return!0}}function Wr(n){var e=Fr();return"function"===typeof n&&(n=n()),e.memoizedState=e.baseState=n,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Ir,lastRenderedState:n},e.queue=n,n=n.dispatch=co.bind(null,wr,n),[e.memoizedState,n]}function Hr(n,e,t,r){return n={tag:n,create:e,destroy:t,deps:r,next:null},null===(e=wr.updateQueue)?(e={lastEffect:null,stores:null},wr.updateQueue=e,e.lastEffect=n.next=n):null===(t=e.lastEffect)?e.lastEffect=n.next=n:(r=t.next,t.next=n,n.next=r,e.lastEffect=n),n}function Xr(){return Er().memoizedState}function Yr(n,e,t,r){var o=Fr();wr.flags|=n,o.memoizedState=Hr(1|e,t,void 0,void 0===r?null:r)}function $r(n,e,t,r){var o=Er();r=void 0===r?null:r;var a=void 0;if(null!==Sr){var i=Sr.memoizedState;if(a=i.destroy,null!==r&&Dr(r,i.deps))return void(o.memoizedState=Hr(e,t,a,r))}wr.flags|=n,o.memoizedState=Hr(1|e,t,a,r)}function Zr(n,e){return Yr(8390656,8,n,e)}function Kr(n,e){return $r(2048,8,n,e)}function Jr(n,e){return $r(4,2,n,e)}function Qr(n,e){return $r(4,4,n,e)}function no(n,e){return"function"===typeof e?(n=n(),e(n),function(){e(null)}):null!==e&&void 0!==e?(n=n(),e.current=n,function(){e.current=null}):void 0}function eo(n,e,t){return t=null!==t&&void 0!==t?t.concat([n]):null,$r(4,4,no.bind(null,e,n),t)}function to(){}function ro(n,e){var t=Er();e=void 0===e?null:e;var r=t.memoizedState;return null!==r&&null!==e&&Dr(e,r[1])?r[0]:(t.memoizedState=[n,e],n)}function oo(n,e){var t=Er();e=void 0===e?null:e;var r=t.memoizedState;return null!==r&&null!==e&&Dr(e,r[1])?r[0]:(n=n(),t.memoizedState=[n,e],n)}function ao(n,e){var t=je;je=0!==t&&4>t?t:4,n(!0);var r=_r.transition;_r.transition={};try{n(!1),e()}finally{je=t,_r.transition=r}}function io(){return Er().memoizedState}function vo(n,e,t){var r=Ui(n);t={lane:r,action:t,hasEagerState:!1,eagerState:null,next:null},lo(n)?so(e,t):(uo(n,e,t),null!==(n=wi(n,r,t=_i()))&&fo(n,e,r))}function co(n,e,t){var r=Ui(n),o={lane:r,action:t,hasEagerState:!1,eagerState:null,next:null};if(lo(n))so(e,o);else{uo(n,e,o);var a=n.alternate;if(0===n.lanes&&(null===a||0===a.lanes)&&null!==(a=e.lastRenderedReducer))try{var i=e.lastRenderedState,v=a(i,t);if(o.hasEagerState=!0,o.eagerState=v,He(v,i))return}catch(c){}null!==(n=wi(n,r,t=_i()))&&fo(n,e,r)}}function lo(n){var e=n.alternate;return n===wr||null!==e&&e===wr}function so(n,e){zr=Mr=!0;var t=n.pending;null===t?e.next=e:(e.next=t.next,t.next=e),n.pending=e}function uo(n,e,t){null!==$a&&0!==(1&n.mode)&&0===(2&Ya)?(null===(n=e.interleaved)?(t.next=t,null===ft?ft=[e]:ft.push(e)):(t.next=n.next,n.next=t),e.interleaved=t):(null===(n=e.pending)?t.next=t:(t.next=n.next,n.next=t),e.pending=t)}function fo(n,e,t){if(0!==(4194240&t)){var r=e.lanes;t|=r&=n.pendingLanes,e.lanes=t,Pe(n,t)}}var po={readContext:ut,useCallback:Rr,useContext:Rr,useEffect:Rr,useImperativeHandle:Rr,useInsertionEffect:Rr,useLayoutEffect:Rr,useMemo:Rr,useReducer:Rr,useRef:Rr,useState:Rr,useDebugValue:Rr,useDeferredValue:Rr,useTransition:Rr,useMutableSource:Rr,useSyncExternalStore:Rr,useId:Rr,unstable_isNewReconciler:!1},mo={readContext:ut,useCallback:function(n,e){return Fr().memoizedState=[n,void 0===e?null:e],n},useContext:ut,useEffect:Zr,useImperativeHandle:function(n,e,t){return t=null!==t&&void 0!==t?t.concat([n]):null,Yr(4194308,4,no.bind(null,e,n),t)},useLayoutEffect:function(n,e){return Yr(4194308,4,n,e)},useInsertionEffect:function(n,e){return Yr(4,2,n,e)},useMemo:function(n,e){var t=Fr();return e=void 0===e?null:e,n=n(),t.memoizedState=[n,e],n},useReducer:function(n,e,t){var r=Fr();return e=void 0!==t?t(e):e,r.memoizedState=r.baseState=e,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:n,lastRenderedState:e},r.queue=n,n=n.dispatch=vo.bind(null,wr,n),[r.memoizedState,n]},useRef:function(n){return n={current:n},Fr().memoizedState=n},useState:Wr,useDebugValue:to,useDeferredValue:function(n){var e=Wr(n),t=e[0],r=e[1];return Zr((function(){var e=_r.transition;_r.transition={};try{r(n)}finally{_r.transition=e}}),[n]),t},useTransition:function(){var n=Wr(!1),e=n[0];return n=ao.bind(null,n[1]),Fr().memoizedState=n,[e,n]},useMutableSource:function(){},useSyncExternalStore:function(n,e,t){var r=wr,o=Fr();if(Vt){if(void 0===t)throw Error(i(407));t=t()}else{if(t=e(),null===$a)throw Error(i(349));0!==(30&Ur)||Gr(r,e,t)}o.memoizedState=t;var a={value:t,getSnapshot:e};return o.queue=a,Zr(qr.bind(null,r,a,n),[n]),r.flags|=2048,Hr(9,Br.bind(null,r,a,t,e),void 0,null),t},useId:function(){var n=Fr(),e=$a.identifierPrefix;if(Vt){var t=Ot;e=":"+e+"R"+(t=(It&~(1<<32-_e(It)-1)).toString(32)+t),0<(t=Cr++)&&(e+="H"+t.toString(32)),e+=":"}else e=":"+e+"r"+(t=Tr++).toString(32)+":";return n.memoizedState=e},unstable_isNewReconciler:!1},ho={readContext:ut,useCallback:ro,useContext:ut,useEffect:Kr,useImperativeHandle:eo,useInsertionEffect:Jr,useLayoutEffect:Qr,useMemo:oo,useReducer:Or,useRef:Xr,useState:function(){return Or(Ir)},useDebugValue:to,useDeferredValue:function(n){var e=Or(Ir),t=e[0],r=e[1];return Kr((function(){var e=_r.transition;_r.transition={};try{r(n)}finally{_r.transition=e}}),[n]),t},useTransition:function(){return[Or(Ir)[0],Er().memoizedState]},useMutableSource:Ar,useSyncExternalStore:Nr,useId:io,unstable_isNewReconciler:!1},xo={readContext:ut,useCallback:ro,useContext:ut,useEffect:Kr,useImperativeHandle:eo,useInsertionEffect:Jr,useLayoutEffect:Qr,useMemo:oo,useReducer:Lr,useRef:Xr,useState:function(){return Lr(Ir)},useDebugValue:to,useDeferredValue:function(n){var e=Lr(Ir),t=e[0],r=e[1];return Kr((function(){var e=_r.transition;_r.transition={};try{r(n)}finally{_r.transition=e}}),[n]),t},useTransition:function(){return[Lr(Ir)[0],Er().memoizedState]},useMutableSource:Ar,useSyncExternalStore:Nr,useId:io,unstable_isNewReconciler:!1};function go(n,e){try{var t="",r=e;do{t+=nt(r),r=r.return}while(r);var o=t}catch(a){o="\nError generating stack: "+a.message+"\n"+a.stack}return{value:n,source:e,stack:o}}function yo(n,e){try{console.error(e.value)}catch(t){setTimeout((function(){throw t}))}}var bo,_o,Uo,wo,So="function"===typeof WeakMap?WeakMap:Map;function ko(n,e,t){(t=ht(-1,t)).tag=3,t.payload={element:null};var r=e.value;return t.callback=function(){ui||(ui=!0,fi=r),yo(0,e)},t}function Mo(n,e,t){(t=ht(-1,t)).tag=3;var r=n.type.getDerivedStateFromError;if("function"===typeof r){var o=e.value;t.payload=function(){return r(o)},t.callback=function(){yo(0,e)}}var a=n.stateNode;return null!==a&&"function"===typeof a.componentDidCatch&&(t.callback=function(){yo(0,e),"function"!==typeof r&&(null===pi?pi=new Set([this]):pi.add(this));var n=e.stack;this.componentDidCatch(e.value,{componentStack:null!==n?n:""})}),t}function zo(n,e,t){var r=n.pingCache;if(null===r){r=n.pingCache=new So;var o=new Set;r.set(e,o)}else void 0===(o=r.get(e))&&(o=new Set,r.set(e,o));o.has(t)||(o.add(t),n=Hi.bind(null,n,e,t),e.then(n,n))}function Co(n){do{var e;if((e=13===n.tag)&&(e=null===(e=n.memoizedState)||null!==e.dehydrated),e)return n;n=n.return}while(null!==n);return null}function To(n,e,t,r,o){return 0===(1&n.mode)?(n===e?n.flags|=65536:(n.flags|=128,t.flags|=131072,t.flags&=-52805,1===t.tag&&(null===t.alternate?t.tag=17:((e=ht(-1,1)).tag=2,xt(t,e))),t.lanes|=1),n):(n.flags|=65536,n.lanes=o,n)}function Ro(n){n.flags|=4}function Do(n,e){if(null!==n&&n.child===e.child)return!0;if(0!==(16&e.flags))return!1;for(n=e.child;null!==n;){if(0!==(12854&n.flags)||0!==(12854&n.subtreeFlags))return!1;n=n.sibling}return!0}if(Y)bo=function(n,e){for(var t=e.child;null!==t;){if(5===t.tag||6===t.tag)A(n,t.stateNode);else if(4!==t.tag&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return;t=t.return}t.sibling.return=t.return,t=t.sibling}},_o=function(){},Uo=function(n,e,t,r,o){if((n=n.memoizedProps)!==r){var a=e.stateNode,i=ur(cr.current);t=G(a,t,n,r,o,i),(e.updateQueue=t)&&Ro(e)}},wo=function(n,e,t,r){t!==r&&Ro(e)};else if($){bo=function(n,e,t,r){for(var o=e.child;null!==o;){if(5===o.tag){var a=o.stateNode;t&&r&&(a=Pn(a,o.type,o.memoizedProps,o)),A(n,a)}else if(6===o.tag)a=o.stateNode,t&&r&&(a=jn(a,o.memoizedProps,o)),A(n,a);else if(4!==o.tag)if(22===o.tag&&null!==o.memoizedState)null!==(a=o.child)&&(a.return=o),bo(n,o,!0,!0);else if(null!==o.child){o.child.return=o,o=o.child;continue}if(o===e)break;for(;null===o.sibling;){if(null===o.return||o.return===e)return;o=o.return}o.sibling.return=o.return,o=o.sibling}};var Po=function n(e,t,r,o){for(var a=t.child;null!==a;){if(5===a.tag){var i=a.stateNode;r&&o&&(i=Pn(i,a.type,a.memoizedProps,a)),Tn(e,i)}else if(6===a.tag)i=a.stateNode,r&&o&&(i=jn(i,a.memoizedProps,a)),Tn(e,i);else if(4!==a.tag)if(22===a.tag&&null!==a.memoizedState)null!==(i=a.child)&&(i.return=a),n(e,a,!0,!0);else if(null!==a.child){a.child.return=a,a=a.child;continue}if(a===t)break;for(;null===a.sibling;){if(null===a.return||a.return===t)return;a=a.return}a.sibling.return=a.return,a=a.sibling}};_o=function(n,e){var t=e.stateNode;if(!Do(n,e)){n=t.containerInfo;var r=Cn(n);Po(r,e,!1,!1),t.pendingChildren=r,Ro(e),Rn(n,r)}},Uo=function(n,e,t,r,o){var a=n.stateNode,i=n.memoizedProps;if((n=Do(n,e))&&i===r)e.stateNode=a;else{var v=e.stateNode,c=ur(cr.current),l=null;i!==r&&(l=G(v,t,i,r,o,c)),n&&null===l?e.stateNode=a:(a=zn(a,l,t,i,r,e,n,v),N(a,t,r,o,c)&&Ro(e),e.stateNode=a,n?Ro(e):bo(a,e,!1,!1))}},wo=function(n,e,t,r){t!==r?(n=ur(sr.current),t=ur(cr.current),e.stateNode=q(r,n,t,e),Ro(e)):e.stateNode=n.stateNode}}else _o=function(){},Uo=function(){},wo=function(){};function jo(n,e){if(!Vt)switch(n.tailMode){case"hidden":e=n.tail;for(var t=null;null!==e;)null!==e.alternate&&(t=e),e=e.sibling;null===t?n.tail=null:t.sibling=null;break;case"collapsed":t=n.tail;for(var r=null;null!==t;)null!==t.alternate&&(r=t),t=t.sibling;null===r?e||null===n.tail?n.tail=null:n.tail.sibling=null:r.sibling=null}}function Fo(n){var e=null!==n.alternate&&n.alternate.child===n.child,t=0,r=0;if(e)for(var o=n.child;null!==o;)t|=o.lanes|o.childLanes,r|=14680064&o.subtreeFlags,r|=14680064&o.flags,o.return=n,o=o.sibling;else for(o=n.child;null!==o;)t|=o.lanes|o.childLanes,r|=o.subtreeFlags,r|=o.flags,o.return=n,o=o.sibling;return n.subtreeFlags|=r,n.childLanes=t,e}function Eo(n,e,t){var r=e.pendingProps;switch(Gt(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Fo(e),null;case 1:case 17:return me(e.type)&&he(),Fo(e),null;case 3:return r=e.stateNode,pr(),ce(fe),ce(ue),yr(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),null!==n&&null!==n.child||(Jt(e)?Ro(e):null===n||n.memoizedState.isDehydrated&&0===(256&e.flags)||(e.flags|=1024,null!==Ht&&(Ci(Ht),Ht=null))),_o(n,e),Fo(e),null;case 5:mr(e),t=ur(sr.current);var o=e.type;if(null!==n&&null!=e.stateNode)Uo(n,e,o,r,t),n.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!r){if(null===e.stateNode)throw Error(i(166));return Fo(e),null}if(n=ur(cr.current),Jt(e)){if(!Z)throw Error(i(175));n=Vn(e.stateNode,e.type,e.memoizedProps,t,n,e,!Wt),e.updateQueue=n,null!==n&&Ro(e)}else{var a=L(o,r,t,n,e);bo(a,e,!1,!1),e.stateNode=a,N(a,o,r,t,n)&&Ro(e)}null!==e.ref&&(e.flags|=512,e.flags|=2097152)}return Fo(e),null;case 6:if(n&&null!=e.stateNode)wo(n,e,n.memoizedProps,r);else{if("string"!==typeof r&&null===e.stateNode)throw Error(i(166));if(n=ur(sr.current),t=ur(cr.current),Jt(e)){if(!Z)throw Error(i(176));if(n=e.stateNode,r=e.memoizedProps,(t=Wn(n,r,e,!Wt))&&null!==(o=Bt))switch(a=0!==(1&o.mode),o.tag){case 3:Qn(o.stateNode.containerInfo,n,r,a);break;case 5:ne(o.type,o.memoizedProps,o.stateNode,n,r,a)}t&&Ro(e)}else e.stateNode=q(r,n,t,e)}return Fo(e),null;case 13:if(ce(hr),r=e.memoizedState,Vt&&null!==qt&&0!==(1&e.mode)&&0===(128&e.flags)){for(n=qt;n;)n=Nn(n);return Qt(),e.flags|=98560,e}if(null!==r&&null!==r.dehydrated){if(r=Jt(e),null===n){if(!r)throw Error(i(318));if(!Z)throw Error(i(344));if(!(n=null!==(n=e.memoizedState)?n.dehydrated:null))throw Error(i(317));Hn(n,e)}else Qt(),0===(128&e.flags)&&(e.memoizedState=null),e.flags|=4;return Fo(e),null}return null!==Ht&&(Ci(Ht),Ht=null),0!==(128&e.flags)?(e.lanes=t,e):(r=null!==r,t=!1,null===n?Jt(e):t=null!==n.memoizedState,r&&!t&&(e.child.flags|=8192,0!==(1&e.mode)&&(null===n||0!==(1&hr.current)?0===ni&&(ni=3):Ii())),null!==e.updateQueue&&(e.flags|=4),Fo(e),null);case 4:return pr(),_o(n,e),null===n&&J(e.stateNode.containerInfo),Fo(e),null;case 10:return ct(e.type._context),Fo(e),null;case 19:if(ce(hr),null===(o=e.memoizedState))return Fo(e),null;if(r=0!==(128&e.flags),null===(a=o.rendering))if(r)jo(o,!1);else{if(0!==ni||null!==n&&0!==(128&n.flags))for(n=e.child;null!==n;){if(null!==(a=xr(n))){for(e.flags|=128,jo(o,!1),null!==(n=a.updateQueue)&&(e.updateQueue=n,e.flags|=4),e.subtreeFlags=0,n=t,r=e.child;null!==r;)o=n,(t=r).flags&=14680066,null===(a=t.alternate)?(t.childLanes=0,t.lanes=o,t.child=null,t.subtreeFlags=0,t.memoizedProps=null,t.memoizedState=null,t.updateQueue=null,t.dependencies=null,t.stateNode=null):(t.childLanes=a.childLanes,t.lanes=a.lanes,t.child=a.child,t.subtreeFlags=0,t.deletions=null,t.memoizedProps=a.memoizedProps,t.memoizedState=a.memoizedState,t.updateQueue=a.updateQueue,t.type=a.type,o=a.dependencies,t.dependencies=null===o?null:{lanes:o.lanes,firstContext:o.firstContext}),r=r.sibling;return le(hr,1&hr.current|2),e.child}n=n.sibling}null!==o.tail&&Ae()>ci&&(e.flags|=128,r=!0,jo(o,!1),e.lanes=4194304)}else{if(!r)if(null!==(n=xr(a))){if(e.flags|=128,r=!0,null!==(n=n.updateQueue)&&(e.updateQueue=n,e.flags|=4),jo(o,!0),null===o.tail&&"hidden"===o.tailMode&&!a.alternate&&!Vt)return Fo(e),null}else 2*Ae()-o.renderingStartTime>ci&&1073741824!==t&&(e.flags|=128,r=!0,jo(o,!1),e.lanes=4194304);o.isBackwards?(a.sibling=e.child,e.child=a):(null!==(n=o.last)?n.sibling=a:e.child=a,o.last=a)}return null!==o.tail?(e=o.tail,o.rendering=e,o.tail=e.sibling,o.renderingStartTime=Ae(),e.sibling=null,n=hr.current,le(hr,r?1&n|2:1&n),e):(Fo(e),null);case 22:case 23:return Pi(),r=null!==e.memoizedState,null!==n&&null!==n.memoizedState!==r&&(e.flags|=8192),r&&0!==(1&e.mode)?0!==(1073741824&Ja)&&(Fo(e),Y&&6&e.subtreeFlags&&(e.flags|=8192)):Fo(e),null;case 24:case 25:return null}throw Error(i(156,e.tag))}var Io=v.ReactCurrentOwner,Oo=!1;function Lo(n,e,t,r){e.child=null===n?ir(e,null,t,r):ar(e,n.child,t,r)}function Ao(n,e,t,r,o){t=t.render;var a=e.ref;return st(e,o),r=Pr(n,e,t,r,a,o),t=jr(),null===n||Oo?(Vt&&t&&Nt(e),e.flags|=1,Lo(n,e,r,o),e.child):(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~o,aa(n,e,o))}function No(n,e,t,r,o){if(null===n){var a=t.type;return"function"!==typeof a||Qi(a)||void 0!==a.defaultProps||null!==t.compare||void 0!==t.defaultProps?((n=ev(t.type,null,r,e,e.mode,o)).ref=e.ref,n.return=e,e.child=n):(e.tag=15,e.type=a,Go(n,e,a,r,o))}if(a=n.child,0===(n.lanes&o)){var i=a.memoizedProps;if((t=null!==(t=t.compare)?t:Qe)(i,r)&&n.ref===e.ref)return aa(n,e,o)}return e.flags|=1,(n=nv(a,r)).ref=e.ref,n.return=e,e.child=n}function Go(n,e,t,r,o){if(null!==n&&Qe(n.memoizedProps,r)&&n.ref===e.ref){if(Oo=!1,0===(n.lanes&o))return e.lanes=n.lanes,aa(n,e,o);0!==(131072&n.flags)&&(Oo=!0)}return Vo(n,e,t,r,o)}function Bo(n,e,t){var r=e.pendingProps,o=r.children,a=null!==n?n.memoizedState:null;if("hidden"===r.mode)if(0===(1&e.mode))e.memoizedState={baseLanes:0,cachePool:null},le(Qa,Ja),Ja|=t;else{if(0===(1073741824&t))return n=null!==a?a.baseLanes|t:t,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:n,cachePool:null},e.updateQueue=null,le(Qa,Ja),Ja|=n,null;e.memoizedState={baseLanes:0,cachePool:null},r=null!==a?a.baseLanes:t,le(Qa,Ja),Ja|=r}else null!==a?(r=a.baseLanes|t,e.memoizedState=null):r=t,le(Qa,Ja),Ja|=r;return Lo(n,e,o,t),e.child}function qo(n,e){var t=e.ref;(null===n&&null!==t||null!==n&&n.ref!==t)&&(e.flags|=512,e.flags|=2097152)}function Vo(n,e,t,r,o){var a=me(t)?pe:ue.current;return a=de(e,a),st(e,o),t=Pr(n,e,t,r,a,o),r=jr(),null===n||Oo?(Vt&&r&&Nt(e),e.flags|=1,Lo(n,e,t,o),e.child):(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~o,aa(n,e,o))}function Wo(n,e,t,r,o){if(me(t)){var a=!0;ye(e)}else a=!1;if(st(e,o),null===e.stateNode)null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2),Mt(e,t,r),Ct(e,t,r,o),r=!0;else if(null===n){var i=e.stateNode,v=e.memoizedProps;i.props=v;var c=i.context,l=t.contextType;"object"===typeof l&&null!==l?l=ut(l):l=de(e,l=me(t)?pe:ue.current);var s=t.getDerivedStateFromProps,u="function"===typeof s||"function"===typeof i.getSnapshotBeforeUpdate;u||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(v!==r||c!==l)&&zt(e,i,r,l),pt=!1;var f=e.memoizedState;i.state=f,bt(e,r,i,o),c=e.memoizedState,v!==r||f!==c||fe.current||pt?("function"===typeof s&&(wt(e,t,s,r),c=e.memoizedState),(v=pt||kt(e,t,v,r,f,c,l))?(u||"function"!==typeof i.UNSAFE_componentWillMount&&"function"!==typeof i.componentWillMount||("function"===typeof i.componentWillMount&&i.componentWillMount(),"function"===typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount()),"function"===typeof i.componentDidMount&&(e.flags|=4194308)):("function"===typeof i.componentDidMount&&(e.flags|=4194308),e.memoizedProps=r,e.memoizedState=c),i.props=r,i.state=c,i.context=l,r=v):("function"===typeof i.componentDidMount&&(e.flags|=4194308),r=!1)}else{i=e.stateNode,mt(n,e),v=e.memoizedProps,l=e.type===e.elementType?v:et(e.type,v),i.props=l,u=e.pendingProps,f=i.context,"object"===typeof(c=t.contextType)&&null!==c?c=ut(c):c=de(e,c=me(t)?pe:ue.current);var p=t.getDerivedStateFromProps;(s="function"===typeof p||"function"===typeof i.getSnapshotBeforeUpdate)||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(v!==u||f!==c)&&zt(e,i,r,c),pt=!1,f=e.memoizedState,i.state=f,bt(e,r,i,o);var d=e.memoizedState;v!==u||f!==d||fe.current||pt?("function"===typeof p&&(wt(e,t,p,r),d=e.memoizedState),(l=pt||kt(e,t,l,r,f,d,c)||!1)?(s||"function"!==typeof i.UNSAFE_componentWillUpdate&&"function"!==typeof i.componentWillUpdate||("function"===typeof i.componentWillUpdate&&i.componentWillUpdate(r,d,c),"function"===typeof i.UNSAFE_componentWillUpdate&&i.UNSAFE_componentWillUpdate(r,d,c)),"function"===typeof i.componentDidUpdate&&(e.flags|=4),"function"===typeof i.getSnapshotBeforeUpdate&&(e.flags|=1024)):("function"!==typeof i.componentDidUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=1024),e.memoizedProps=r,e.memoizedState=d),i.props=r,i.state=d,i.context=c,r=l):("function"!==typeof i.componentDidUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=1024),r=!1)}return Ho(n,e,t,r,a,o)}function Ho(n,e,t,r,o,a){qo(n,e);var i=0!==(128&e.flags);if(!r&&!i)return o&&be(e,t,!1),aa(n,e,a);r=e.stateNode,Io.current=e;var v=i&&"function"!==typeof t.getDerivedStateFromError?null:r.render();return e.flags|=1,null!==n&&i?(e.child=ar(e,n.child,null,a),e.child=ar(e,null,v,a)):Lo(n,e,v,a),e.memoizedState=r.state,o&&be(e,t,!0),e.child}function Xo(n){var e=n.stateNode;e.pendingContext?xe(0,e.pendingContext,e.pendingContext!==e.context):e.context&&xe(0,e.context,!1),fr(n,e.containerInfo)}function Yo(n,e,t,r,o){return Qt(),nr(o),e.flags|=256,Lo(n,e,t,r),e.child}var $o={dehydrated:null,treeContext:null,retryLane:0};function Zo(n){return{baseLanes:n,cachePool:null}}function Ko(n,e,t){var r,o=e.pendingProps,a=hr.current,v=!1,c=0!==(128&e.flags);if((r=c)||(r=(null===n||null!==n.memoizedState)&&0!==(2&a)),r?(v=!0,e.flags&=-129):null!==n&&null===n.memoizedState||(a|=1),le(hr,1&a),null===n)return Zt(e),null!==(n=e.memoizedState)&&null!==(n=n.dehydrated)?(0===(1&e.mode)?e.lanes=1:Ln(n)?e.lanes=8:e.lanes=1073741824,null):(a=o.children,n=o.fallback,v?(o=e.mode,v=e.child,a={mode:"hidden",children:a},0===(1&o)&&null!==v?(v.childLanes=0,v.pendingProps=a):v=rv(a,o,0,null),n=tv(n,o,t,null),v.return=e,n.return=e,v.sibling=n,e.child=v,e.child.memoizedState=Zo(t),e.memoizedState=$o,n):Jo(e,a));if(null!==(a=n.memoizedState)){if(null!==(r=a.dehydrated)){if(c)return 256&e.flags?(e.flags&=-257,ea(n,e,t,Error(i(422)))):null!==e.memoizedState?(e.child=n.child,e.flags|=128,null):(v=o.fallback,a=e.mode,o=rv({mode:"visible",children:o.children},a,0,null),(v=tv(v,a,t,null)).flags|=2,o.return=e,v.return=e,o.sibling=v,e.child=o,0!==(1&e.mode)&&ar(e,n.child,null,t),e.child.memoizedState=Zo(t),e.memoizedState=$o,v);if(0===(1&e.mode))e=ea(n,e,t,null);else if(Ln(r))e=ea(n,e,t,Error(i(419)));else if(o=0!==(t&n.childLanes),Oo||o){if(null!==(o=$a)){switch(t&-t){case 4:v=2;break;case 16:v=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:v=32;break;case 536870912:v=268435456;break;default:v=0}0!==(o=0!==(v&(o.suspendedLanes|t))?0:v)&&o!==a.retryLane&&(a.retryLane=o,wi(n,o,-1))}Ii(),e=ea(n,e,t,Error(i(421)))}else On(r)?(e.flags|=128,e.child=n.child,e=Yi.bind(null,n),An(r,e),e=null):(t=a.treeContext,Z&&(qt=qn(r),Bt=e,Vt=!0,Ht=null,Wt=!1,null!==t&&(jt[Ft++]=It,jt[Ft++]=Ot,jt[Ft++]=Et,It=t.id,Ot=t.overflow,Et=e)),(e=Jo(e,e.pendingProps.children)).flags|=4096);return e}return v?(o=na(n,e,o.children,o.fallback,t),v=e.child,a=n.child.memoizedState,v.memoizedState=null===a?Zo(t):{baseLanes:a.baseLanes|t,cachePool:null},v.childLanes=n.childLanes&~t,e.memoizedState=$o,o):(t=Qo(n,e,o.children,t),e.memoizedState=null,t)}return v?(o=na(n,e,o.children,o.fallback,t),v=e.child,a=n.child.memoizedState,v.memoizedState=null===a?Zo(t):{baseLanes:a.baseLanes|t,cachePool:null},v.childLanes=n.childLanes&~t,e.memoizedState=$o,o):(t=Qo(n,e,o.children,t),e.memoizedState=null,t)}function Jo(n,e){return(e=rv({mode:"visible",children:e},n.mode,0,null)).return=n,n.child=e}function Qo(n,e,t,r){var o=n.child;return n=o.sibling,t=nv(o,{mode:"visible",children:t}),0===(1&e.mode)&&(t.lanes=r),t.return=e,t.sibling=null,null!==n&&(null===(r=e.deletions)?(e.deletions=[n],e.flags|=16):r.push(n)),e.child=t}function na(n,e,t,r,o){var a=e.mode,i=(n=n.child).sibling,v={mode:"hidden",children:t};return 0===(1&a)&&e.child!==n?((t=e.child).childLanes=0,t.pendingProps=v,e.deletions=null):(t=nv(n,v)).subtreeFlags=14680064&n.subtreeFlags,null!==i?r=nv(i,r):(r=tv(r,a,o,null)).flags|=2,r.return=e,t.return=e,t.sibling=r,e.child=t,r}function ea(n,e,t,r){return null!==r&&nr(r),ar(e,n.child,null,t),(n=Jo(e,e.pendingProps.children)).flags|=2,e.memoizedState=null,n}function ta(n,e,t){n.lanes|=e;var r=n.alternate;null!==r&&(r.lanes|=e),lt(n.return,e,t)}function ra(n,e,t,r,o){var a=n.memoizedState;null===a?n.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:r,tail:t,tailMode:o}:(a.isBackwards=e,a.rendering=null,a.renderingStartTime=0,a.last=r,a.tail=t,a.tailMode=o)}function oa(n,e,t){var r=e.pendingProps,o=r.revealOrder,a=r.tail;if(Lo(n,e,r.children,t),0!==(2&(r=hr.current)))r=1&r|2,e.flags|=128;else{if(null!==n&&0!==(128&n.flags))n:for(n=e.child;null!==n;){if(13===n.tag)null!==n.memoizedState&&ta(n,t,e);else if(19===n.tag)ta(n,t,e);else if(null!==n.child){n.child.return=n,n=n.child;continue}if(n===e)break n;for(;null===n.sibling;){if(null===n.return||n.return===e)break n;n=n.return}n.sibling.return=n.return,n=n.sibling}r&=1}if(le(hr,r),0===(1&e.mode))e.memoizedState=null;else switch(o){case"forwards":for(t=e.child,o=null;null!==t;)null!==(n=t.alternate)&&null===xr(n)&&(o=t),t=t.sibling;null===(t=o)?(o=e.child,e.child=null):(o=t.sibling,t.sibling=null),ra(e,!1,o,t,a);break;case"backwards":for(t=null,o=e.child,e.child=null;null!==o;){if(null!==(n=o.alternate)&&null===xr(n)){e.child=o;break}n=o.sibling,o.sibling=t,t=o,o=n}ra(e,!0,t,null,a);break;case"together":ra(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function aa(n,e,t){if(null!==n&&(e.dependencies=n.dependencies),ti|=e.lanes,0===(t&e.childLanes))return null;if(null!==n&&e.child!==n.child)throw Error(i(153));if(null!==e.child){for(t=nv(n=e.child,n.pendingProps),e.child=t,t.return=e;null!==n.sibling;)n=n.sibling,(t=t.sibling=nv(n,n.pendingProps)).return=e;t.sibling=null}return e.child}function ia(n,e){switch(Gt(e),e.tag){case 1:return me(e.type)&&he(),65536&(n=e.flags)?(e.flags=-65537&n|128,e):null;case 3:return pr(),ce(fe),ce(ue),yr(),0!==(65536&(n=e.flags))&&0===(128&n)?(e.flags=-65537&n|128,e):null;case 5:return mr(e),null;case 13:if(ce(hr),null!==(n=e.memoizedState)&&null!==n.dehydrated){if(null===e.alternate)throw Error(i(340));Qt()}return 65536&(n=e.flags)?(e.flags=-65537&n|128,e):null;case 19:return ce(hr),null;case 4:return pr(),null;case 10:return ct(e.type._context),null;case 22:case 23:return Pi(),null;default:return null}}var va=!1,ca=!1,la="function"===typeof WeakSet?WeakSet:Set,sa=null;function ua(n,e){var t=n.ref;if(null!==t)if("function"===typeof t)try{t(null)}catch(r){Wi(n,e,r)}else t.current=null}function fa(n,e,t){try{t()}catch(r){Wi(n,e,r)}}var pa=!1;function da(n,e,t){var r=e.updateQueue;if(null!==(r=null!==r?r.lastEffect:null)){var o=r=r.next;do{if((o.tag&n)===n){var a=o.destroy;o.destroy=void 0,void 0!==a&&fa(e,t,a)}o=o.next}while(o!==r)}}function ma(n,e){if(null!==(e=null!==(e=e.updateQueue)?e.lastEffect:null)){var t=e=e.next;do{if((t.tag&n)===n){var r=t.create;t.destroy=r()}t=t.next}while(t!==e)}}function ha(n){var e=n.ref;if(null!==e){var t=n.stateNode;if(5===n.tag)n=j(t);else n=t;"function"===typeof e?e(n):e.current=n}}function xa(n,e,t){if(We&&"function"===typeof We.onCommitFiberUnmount)try{We.onCommitFiberUnmount(Ve,e)}catch(i){}switch(e.tag){case 0:case 11:case 14:case 15:if(null!==(n=e.updateQueue)&&null!==(n=n.lastEffect)){var r=n=n.next;do{var o=r,a=o.destroy;o=o.tag,void 0!==a&&(0!==(2&o)||0!==(4&o))&&fa(e,t,a),r=r.next}while(r!==n)}break;case 1:if(ua(e,t),"function"===typeof(n=e.stateNode).componentWillUnmount)try{n.props=e.memoizedProps,n.state=e.memoizedState,n.componentWillUnmount()}catch(i){Wi(e,t,i)}break;case 5:ua(e,t);break;case 4:Y?ka(n,e,t):$&&$&&(e=e.stateNode.containerInfo,t=Cn(e),Dn(e,t))}}function ga(n,e,t){for(var r=e;;)if(xa(n,r,t),null===r.child||Y&&4===r.tag){if(r===e)break;for(;null===r.sibling;){if(null===r.return||r.return===e)return;r=r.return}r.sibling.return=r.return,r=r.sibling}else r.child.return=r,r=r.child}function ya(n){var e=n.alternate;null!==e&&(n.alternate=null,ya(e)),n.child=null,n.deletions=null,n.sibling=null,5===n.tag&&(null!==(e=n.stateNode)&&nn(e)),n.stateNode=null,n.return=null,n.dependencies=null,n.memoizedProps=null,n.memoizedState=null,n.pendingProps=null,n.stateNode=null,n.updateQueue=null}function ba(n){return 5===n.tag||3===n.tag||4===n.tag}function _a(n){n:for(;;){for(;null===n.sibling;){if(null===n.return||ba(n.return))return null;n=n.return}for(n.sibling.return=n.return,n=n.sibling;5!==n.tag&&6!==n.tag&&18!==n.tag;){if(2&n.flags)continue n;if(null===n.child||4===n.tag)continue n;n.child.return=n,n=n.child}if(!(2&n.flags))return n.stateNode}}function Ua(n){if(Y){n:{for(var e=n.return;null!==e;){if(ba(e))break n;e=e.return}throw Error(i(160))}var t=e;switch(t.tag){case 5:e=t.stateNode,32&t.flags&&(_n(e),t.flags&=-33),Sa(n,t=_a(n),e);break;case 3:case 4:e=t.stateNode.containerInfo,wa(n,t=_a(n),e);break;default:throw Error(i(161))}}}function wa(n,e,t){var r=n.tag;if(5===r||6===r)n=n.stateNode,e?gn(t,n,e):pn(t,n);else if(4!==r&&null!==(n=n.child))for(wa(n,e,t),n=n.sibling;null!==n;)wa(n,e,t),n=n.sibling}function Sa(n,e,t){var r=n.tag;if(5===r||6===r)n=n.stateNode,e?xn(t,n,e):fn(t,n);else if(4!==r&&null!==(n=n.child))for(Sa(n,e,t),n=n.sibling;null!==n;)Sa(n,e,t),n=n.sibling}function ka(n,e,t){for(var r,o,a=e,v=!1;;){if(!v){v=a.return;n:for(;;){if(null===v)throw Error(i(160));switch(r=v.stateNode,v.tag){case 5:o=!1;break n;case 3:case 4:r=r.containerInfo,o=!0;break n}v=v.return}v=!0}if(5===a.tag||6===a.tag)ga(n,a,t),o?bn(r,a.stateNode):yn(r,a.stateNode);else if(18===a.tag)o?Kn(r,a.stateNode):Zn(r,a.stateNode);else if(4===a.tag){if(null!==a.child){r=a.stateNode.containerInfo,o=!0,a.child.return=a,a=a.child;continue}}else if(xa(n,a,t),null!==a.child){a.child.return=a,a=a.child;continue}if(a===e)break;for(;null===a.sibling;){if(null===a.return||a.return===e)return;4===(a=a.return).tag&&(v=!1)}a.sibling.return=a.return,a=a.sibling}}function Ma(n,e){if(Y){switch(e.tag){case 0:case 11:case 14:case 15:return da(3,e,e.return),ma(3,e),void da(5,e,e.return);case 1:case 12:case 17:return;case 5:var t=e.stateNode;if(null!=t){var r=e.memoizedProps;n=null!==n?n.memoizedProps:r;var o=e.type,a=e.updateQueue;e.updateQueue=null,null!==a&&hn(t,a,o,n,r,e)}return;case 6:if(null===e.stateNode)throw Error(i(162));return t=e.memoizedProps,void dn(e.stateNode,null!==n?n.memoizedProps:t,t);case 3:return void(Z&&null!==n&&n.memoizedState.isDehydrated&&Yn(e.stateNode.containerInfo));case 13:case 19:return void za(e)}throw Error(i(163))}switch(e.tag){case 0:case 11:case 14:case 15:return da(3,e,e.return),ma(3,e),void da(5,e,e.return);case 12:case 22:case 23:return;case 13:case 19:return void za(e);case 3:Z&&null!==n&&n.memoizedState.isDehydrated&&Yn(e.stateNode.containerInfo)}n:if($){switch(e.tag){case 1:case 5:case 6:break n;case 3:case 4:e=e.stateNode,Dn(e.containerInfo,e.pendingChildren);break n}throw Error(i(163))}}function za(n){var e=n.updateQueue;if(null!==e){n.updateQueue=null;var t=n.stateNode;null===t&&(t=n.stateNode=new la),e.forEach((function(e){var r=$i.bind(null,n,e);t.has(e)||(t.add(e),e.then(r,r))}))}}function Ca(n,e,t){sa=n,Ta(n,e,t)}function Ta(n,e,t){for(var r=0!==(1&n.mode);null!==sa;){var o=sa,a=o.child;if(22===o.tag&&r){var i=null!==o.memoizedState||va;if(!i){var v=o.alternate,c=null!==v&&null!==v.memoizedState||ca;v=va;var l=ca;if(va=i,(ca=c)&&!l)for(sa=o;null!==sa;)c=(i=sa).child,22===i.tag&&null!==i.memoizedState?Pa(o):null!==c?(c.return=i,sa=c):Pa(o);for(;null!==a;)sa=a,Ta(a,e,t),a=a.sibling;sa=o,va=v,ca=l}Ra(n)}else 0!==(8772&o.subtreeFlags)&&null!==a?(a.return=o,sa=a):Ra(n)}}function Ra(n){for(;null!==sa;){var e=sa;if(0!==(8772&e.flags)){var t=e.alternate;try{if(0!==(8772&e.flags))switch(e.tag){case 0:case 11:case 15:ca||ma(5,e);break;case 1:var r=e.stateNode;if(4&e.flags&&!ca)if(null===t)r.componentDidMount();else{var o=e.elementType===e.type?t.memoizedProps:et(e.type,t.memoizedProps);r.componentDidUpdate(o,t.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var a=e.updateQueue;null!==a&&_t(e,a,r);break;case 3:var v=e.updateQueue;if(null!==v){if(t=null,null!==e.child)switch(e.child.tag){case 5:t=j(e.child.stateNode);break;case 1:t=e.child.stateNode}_t(e,v,t)}break;case 5:var c=e.stateNode;null===t&&4&e.flags&&mn(c,e.type,e.memoizedProps,e);break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:break;case 13:if(Z&&null===e.memoizedState){var l=e.alternate;if(null!==l){var s=l.memoizedState;if(null!==s){var u=s.dehydrated;null!==u&&$n(u)}}}break;default:throw Error(i(163))}ca||512&e.flags&&ha(e)}catch(f){Wi(e,e.return,f)}}if(e===n){sa=null;break}if(null!==(t=e.sibling)){t.return=e.return,sa=t;break}sa=e.return}}function Da(n){for(;null!==sa;){var e=sa;if(e===n){sa=null;break}var t=e.sibling;if(null!==t){t.return=e.return,sa=t;break}sa=e.return}}function Pa(n){for(;null!==sa;){var e=sa;try{switch(e.tag){case 0:case 11:case 15:var t=e.return;try{ma(4,e)}catch(c){Wi(e,t,c)}break;case 1:var r=e.stateNode;if("function"===typeof r.componentDidMount){var o=e.return;try{r.componentDidMount()}catch(c){Wi(e,o,c)}}var a=e.return;try{ha(e)}catch(c){Wi(e,a,c)}break;case 5:var i=e.return;try{ha(e)}catch(c){Wi(e,i,c)}}}catch(c){Wi(e,e.return,c)}if(e===n){sa=null;break}var v=e.sibling;if(null!==v){v.return=e.return,sa=v;break}sa=e.return}}var ja=0,Fa=1,Ea=2,Ia=3,Oa=4;if("function"===typeof Symbol&&Symbol.for){var La=Symbol.for;ja=La("selector.component"),Fa=La("selector.has_pseudo_class"),Ea=La("selector.role"),Ia=La("selector.test_id"),Oa=La("selector.text")}function Aa(n){var e=K(n);if(null!=e){if("string"!==typeof e.memoizedProps["data-testname"])throw Error(i(364));return e}if(null===(n=on(n)))throw Error(i(362));return n.stateNode.current}function Na(n,e){switch(e.$$typeof){case ja:if(n.type===e.value)return!0;break;case Fa:n:{e=e.value,n=[n,0];for(var t=0;t<n.length;){var r=n[t++],o=n[t++],a=e[o];if(5!==r.tag||!cn(r)){for(;null!=a&&Na(r,a);)a=e[++o];if(o===e.length){e=!0;break n}for(r=r.child;null!==r;)n.push(r,o),r=r.sibling}}e=!1}return e;case Ea:if(5===n.tag&&ln(n.stateNode,e.value))return!0;break;case Oa:if((5===n.tag||6===n.tag)&&(null!==(n=vn(n))&&0<=n.indexOf(e.value)))return!0;break;case Ia:if(5===n.tag&&("string"===typeof(n=n.memoizedProps["data-testname"])&&n.toLowerCase()===e.value.toLowerCase()))return!0;break;default:throw Error(i(365))}return!1}function Ga(n){switch(n.$$typeof){case ja:return"<"+(w(n.value)||"Unknown")+">";case Fa:return":has("+(Ga(n)||"")+")";case Ea:return'[role="'+n.value+'"]';case Oa:return'"'+n.value+'"';case Ia:return'[data-testname="'+n.value+'"]';default:throw Error(i(365))}}function Ba(n,e){var t=[];n=[n,0];for(var r=0;r<n.length;){var o=n[r++],a=n[r++],i=e[a];if(5!==o.tag||!cn(o)){for(;null!=i&&Na(o,i);)i=e[++a];if(a===e.length)t.push(o);else for(o=o.child;null!==o;)n.push(o,a),o=o.sibling}}return t}function qa(n,e){if(!rn)throw Error(i(363));n=Ba(n=Aa(n),e),e=[],n=Array.from(n);for(var t=0;t<n.length;){var r=n[t++];if(5===r.tag)cn(r)||e.push(r.stateNode);else for(r=r.child;null!==r;)n.push(r),r=r.sibling}return e}var Va=Math.ceil,Wa=v.ReactCurrentDispatcher,Ha=v.ReactCurrentOwner,Xa=v.ReactCurrentBatchConfig,Ya=0,$a=null,Za=null,Ka=0,Ja=0,Qa=ve(0),ni=0,ei=null,ti=0,ri=0,oi=0,ai=null,ii=null,vi=0,ci=1/0;function li(){ci=Ae()+500}var si,ui=!1,fi=null,pi=null,di=!1,mi=null,hi=0,xi=0,gi=null,yi=-1,bi=0;function _i(){return 0!==(6&Ya)?Ae():-1!==yi?yi:yi=Ae()}function Ui(n){return 0===(1&n.mode)?1:0!==(2&Ya)&&0!==Ka?Ka&-Ka:null!==Je.transition?(0===bi&&(n=Se,0===(4194240&(Se<<=1))&&(Se=64),bi=n),bi):0!==(n=je)?n:Q()}function wi(n,e,t){if(50<xi)throw xi=0,gi=null,Error(i(185));var r=Si(n,e);return null===r?null:(De(r,e,t),0!==(2&Ya)&&r===$a||(r===$a&&(0===(2&Ya)&&(ri|=e),4===ni&&Ti(r,Ka)),ki(r,t),1===e&&0===Ya&&0===(1&n.mode)&&(li(),Ye&&Ke())),r)}function Si(n,e){n.lanes|=e;var t=n.alternate;for(null!==t&&(t.lanes|=e),t=n,n=n.return;null!==n;)n.childLanes|=e,null!==(t=n.alternate)&&(t.childLanes|=e),t=n,n=n.return;return 3===t.tag?t.stateNode:null}function ki(n,e){var t=n.callbackNode;!function(n,e){for(var t=n.suspendedLanes,r=n.pingedLanes,o=n.expirationTimes,a=n.pendingLanes;0<a;){var i=31-_e(a),v=1<<i,c=o[i];-1===c?0!==(v&t)&&0===(v&r)||(o[i]=Ce(v,e)):c<=e&&(n.expiredLanes|=v),a&=~v}}(n,e);var r=ze(n,n===$a?Ka:0);if(0===r)null!==t&&Ie(t),n.callbackNode=null,n.callbackPriority=0;else if(e=r&-r,n.callbackPriority!==e){if(null!=t&&Ie(t),1===e)0===n.tag?function(n){Ye=!0,Ze(n)}(Ri.bind(null,n)):Ze(Ri.bind(null,n)),en?tn((function(){0===Ya&&Ke()})):Ee(Ne,Ke),t=null;else{switch(Fe(r)){case 1:t=Ne;break;case 4:t=Ge;break;case 16:default:t=Be;break;case 536870912:t=qe}t=Zi(t,Mi.bind(null,n))}n.callbackPriority=e,n.callbackNode=t}}function Mi(n,e){if(yi=-1,bi=0,0!==(6&Ya))throw Error(i(327));var t=n.callbackNode;if(qi()&&n.callbackNode!==t)return null;var r=ze(n,n===$a?Ka:0);if(0===r)return null;if(0!==(30&r)||0!==(r&n.expiredLanes)||e)e=Oi(n,r);else{e=r;var o=Ya;Ya|=2;var a=Ei();for($a===n&&Ka===e||(li(),ji(n,e));;)try{Ai();break}catch(c){Fi(n,c)}it(),Wa.current=a,Ya=o,null!==Za?e=0:($a=null,Ka=0,e=ni)}if(0!==e){if(2===e&&(0!==(o=Te(n))&&(r=o,e=zi(n,o))),1===e)throw t=ei,ji(n,0),Ti(n,r),ki(n,Ae()),t;if(6===e)Ti(n,r);else{if(o=n.current.alternate,0===(30&r)&&!function(n){for(var e=n;;){if(16384&e.flags){var t=e.updateQueue;if(null!==t&&null!==(t=t.stores))for(var r=0;r<t.length;r++){var o=t[r],a=o.getSnapshot;o=o.value;try{if(!He(a(),o))return!1}catch(v){return!1}}}if(t=e.child,16384&e.subtreeFlags&&null!==t)t.return=e,e=t;else{if(e===n)break;for(;null===e.sibling;){if(null===e.return||e.return===n)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}(o)&&(2===(e=Oi(n,r))&&(0!==(a=Te(n))&&(r=a,e=zi(n,a))),1===e))throw t=ei,ji(n,0),Ti(n,r),ki(n,Ae()),t;switch(n.finishedWork=o,n.finishedLanes=r,e){case 0:case 1:throw Error(i(345));case 2:case 5:Bi(n,ii);break;case 3:if(Ti(n,r),(130023424&r)===r&&10<(e=vi+500-Ae())){if(0!==ze(n,0))break;if(((o=n.suspendedLanes)&r)!==r){_i(),n.pingedLanes|=n.suspendedLanes&o;break}n.timeoutHandle=V(Bi.bind(null,n,ii),e);break}Bi(n,ii);break;case 4:if(Ti(n,r),(4194240&r)===r)break;for(e=n.eventTimes,o=-1;0<r;){var v=31-_e(r);a=1<<v,(v=e[v])>o&&(o=v),r&=~a}if(r=o,10<(r=(120>(r=Ae()-r)?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*Va(r/1960))-r)){n.timeoutHandle=V(Bi.bind(null,n,ii),r);break}Bi(n,ii);break;default:throw Error(i(329))}}}return ki(n,Ae()),n.callbackNode===t?Mi.bind(null,n):null}function zi(n,e){var t=ai;return n.current.memoizedState.isDehydrated&&(ji(n,e).flags|=256),2!==(n=Oi(n,e))&&(e=ii,ii=t,null!==e&&Ci(e)),n}function Ci(n){null===ii?ii=n:ii.push.apply(ii,n)}function Ti(n,e){for(e&=~oi,e&=~ri,n.suspendedLanes|=e,n.pingedLanes&=~e,n=n.expirationTimes;0<e;){var t=31-_e(e),r=1<<t;n[t]=-1,e&=~r}}function Ri(n){if(0!==(6&Ya))throw Error(i(327));qi();var e=ze(n,0);if(0===(1&e))return ki(n,Ae()),null;var t=Oi(n,e);if(0!==n.tag&&2===t){var r=Te(n);0!==r&&(e=r,t=zi(n,r))}if(1===t)throw t=ei,ji(n,0),Ti(n,e),ki(n,Ae()),t;if(6===t)throw Error(i(345));return n.finishedWork=n.current.alternate,n.finishedLanes=e,Bi(n,ii),ki(n,Ae()),null}function Di(n){null!==mi&&0===mi.tag&&0===(6&Ya)&&qi();var e=Ya;Ya|=1;var t=Xa.transition,r=je;try{if(Xa.transition=null,je=1,n)return n()}finally{je=r,Xa.transition=t,0===(6&(Ya=e))&&Ke()}}function Pi(){Ja=Qa.current,ce(Qa)}function ji(n,e){n.finishedWork=null,n.finishedLanes=0;var t=n.timeoutHandle;if(t!==H&&(n.timeoutHandle=H,W(t)),null!==Za)for(t=Za.return;null!==t;){var r=t;switch(Gt(r),r.tag){case 1:null!==(r=r.type.childContextTypes)&&void 0!==r&&he();break;case 3:pr(),ce(fe),ce(ue),yr();break;case 5:mr(r);break;case 4:pr();break;case 13:case 19:ce(hr);break;case 10:ct(r.type._context);break;case 22:case 23:Pi()}t=t.return}if($a=n,Za=n=nv(n.current,null),Ka=Ja=e,ni=0,ei=null,oi=ri=ti=0,ii=ai=null,null!==ft){for(e=0;e<ft.length;e++)if(null!==(r=(t=ft[e]).interleaved)){t.interleaved=null;var o=r.next,a=t.pending;if(null!==a){var i=a.next;a.next=o,r.next=i}t.pending=r}ft=null}return n}function Fi(n,e){for(;;){var t=Za;try{if(it(),br.current=po,Mr){for(var r=wr.memoizedState;null!==r;){var o=r.queue;null!==o&&(o.pending=null),r=r.next}Mr=!1}if(Ur=0,kr=Sr=wr=null,zr=!1,Cr=0,Ha.current=null,null===t||null===t.return){ni=1,ei=e,Za=null;break}n:{var a=n,v=t.return,c=t,l=e;if(e=Ka,c.flags|=32768,null!==l&&"object"===typeof l&&"function"===typeof l.then){var s=l,u=c,f=u.tag;if(0===(1&u.mode)&&(0===f||11===f||15===f)){var p=u.alternate;p?(u.updateQueue=p.updateQueue,u.memoizedState=p.memoizedState,u.lanes=p.lanes):(u.updateQueue=null,u.memoizedState=null)}var d=Co(v);if(null!==d){d.flags&=-257,To(d,v,c,0,e),1&d.mode&&zo(a,s,e),l=s;var m=(e=d).updateQueue;if(null===m){var h=new Set;h.add(l),e.updateQueue=h}else m.add(l);break n}if(0===(1&e)){zo(a,s,e),Ii();break n}l=Error(i(426))}else if(Vt&&1&c.mode){var x=Co(v);if(null!==x){0===(65536&x.flags)&&(x.flags|=256),To(x,v,c,0,e),nr(l);break n}}a=l,4!==ni&&(ni=2),null===ai?ai=[a]:ai.push(a),l=go(l,c),c=v;do{switch(c.tag){case 3:c.flags|=65536,e&=-e,c.lanes|=e,yt(c,ko(0,l,e));break n;case 1:a=l;var g=c.type,y=c.stateNode;if(0===(128&c.flags)&&("function"===typeof g.getDerivedStateFromError||null!==y&&"function"===typeof y.componentDidCatch&&(null===pi||!pi.has(y)))){c.flags|=65536,e&=-e,c.lanes|=e,yt(c,Mo(c,a,e));break n}}c=c.return}while(null!==c)}Gi(t)}catch(b){e=b,Za===t&&null!==t&&(Za=t=t.return);continue}break}}function Ei(){var n=Wa.current;return Wa.current=po,null===n?po:n}function Ii(){0!==ni&&3!==ni&&2!==ni||(ni=4),null===$a||0===(268435455&ti)&&0===(268435455&ri)||Ti($a,Ka)}function Oi(n,e){var t=Ya;Ya|=2;var r=Ei();for($a===n&&Ka===e||ji(n,e);;)try{Li();break}catch(o){Fi(n,o)}if(it(),Ya=t,Wa.current=r,null!==Za)throw Error(i(261));return $a=null,Ka=0,ni}function Li(){for(;null!==Za;)Ni(Za)}function Ai(){for(;null!==Za&&!Oe();)Ni(Za)}function Ni(n){var e=si(n.alternate,n,Ja);n.memoizedProps=n.pendingProps,null===e?Gi(n):Za=e,Ha.current=null}function Gi(n){var e=n;do{var t=e.alternate;if(n=e.return,0===(32768&e.flags)){if(null!==(t=Eo(t,e,Ja)))return void(Za=t)}else{if(null!==(t=ia(t,e)))return t.flags&=32767,void(Za=t);if(null===n)return ni=6,void(Za=null);n.flags|=32768,n.subtreeFlags=0,n.deletions=null}if(null!==(e=e.sibling))return void(Za=e);Za=e=n}while(null!==e);0===ni&&(ni=5)}function Bi(n,e){var t=je,r=Xa.transition;try{Xa.transition=null,je=1,function(n,e,t){do{qi()}while(null!==mi);if(0!==(6&Ya))throw Error(i(327));var r=n.finishedWork,o=n.finishedLanes;if(null===r)return null;if(n.finishedWork=null,n.finishedLanes=0,r===n.current)throw Error(i(177));n.callbackNode=null,n.callbackPriority=0;var a=r.lanes|r.childLanes;if(function(n,e){var t=n.pendingLanes&~e;n.pendingLanes=e,n.suspendedLanes=0,n.pingedLanes=0,n.expiredLanes&=e,n.mutableReadLanes&=e,n.entangledLanes&=e,e=n.entanglements;var r=n.eventTimes;for(n=n.expirationTimes;0<t;){var o=31-_e(t),a=1<<o;e[o]=0,r[o]=-1,n[o]=-1,t&=~a}}(n,a),n===$a&&(Za=$a=null,Ka=0),0===(2064&r.subtreeFlags)&&0===(2064&r.flags)||di||(di=!0,Zi(Be,(function(){return qi(),null}))),a=0!==(15990&r.flags),0!==(15990&r.subtreeFlags)||a){a=Xa.transition,Xa.transition=null;var v=je;je=1;var c=Ya;Ya|=4,Ha.current=null,function(n,e){for(I(n.containerInfo),sa=e;null!==sa;)if(e=(n=sa).child,0!==(1028&n.subtreeFlags)&&null!==e)e.return=n,sa=e;else for(;null!==sa;){n=sa;try{var t=n.alternate;if(0!==(1024&n.flags))switch(n.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==t){var r=t.memoizedProps,o=t.memoizedState,a=n.stateNode,v=a.getSnapshotBeforeUpdate(n.elementType===n.type?r:et(n.type,r),o);a.__reactInternalSnapshotBeforeUpdate=v}break;case 3:Y&&Mn(n.stateNode.containerInfo);break;default:throw Error(i(163))}}catch(c){Wi(n,n.return,c)}if(null!==(e=n.sibling)){e.return=n.return,sa=e;break}sa=n.return}t=pa,pa=!1}(n,r),function(n,e){for(sa=e;null!==sa;){var t=(e=sa).deletions;if(null!==t)for(var r=0;r<t.length;r++){var o=t[r];try{var a=n;Y?ka(a,o,e):ga(a,o,e);var i=o.alternate;null!==i&&(i.return=null),o.return=null}catch(_){Wi(o,e,_)}}if(t=e.child,0!==(12854&e.subtreeFlags)&&null!==t)t.return=e,sa=t;else for(;null!==sa;){e=sa;try{var v=e.flags;if(32&v&&Y&&_n(e.stateNode),512&v){var c=e.alternate;if(null!==c){var l=c.ref;null!==l&&("function"===typeof l?l(null):l.current=null)}}if(8192&v)switch(e.tag){case 13:if(null!==e.memoizedState){var s=e.alternate;null!==s&&null!==s.memoizedState||(vi=Ae())}break;case 22:var u=null!==e.memoizedState,f=e.alternate,p=null!==f&&null!==f.memoizedState;if(t=e,Y)n:if(r=t,o=u,a=null,Y)for(var d=r;;){if(5===d.tag){if(null===a){a=d;var m=d.stateNode;o?Un(m):Sn(d.stateNode,d.memoizedProps)}}else if(6===d.tag){if(null===a){var h=d.stateNode;o?wn(h):kn(h,d.memoizedProps)}}else if((22!==d.tag&&23!==d.tag||null===d.memoizedState||d===r)&&null!==d.child){d.child.return=d,d=d.child;continue}if(d===r)break;for(;null===d.sibling;){if(null===d.return||d.return===r)break n;a===d&&(a=null),d=d.return}a===d&&(a=null),d.sibling.return=d.return,d=d.sibling}if(u&&!p&&0!==(1&t.mode)){sa=t;for(var x=t.child;null!==x;){for(t=sa=x;null!==sa;){var g=(r=sa).child;switch(r.tag){case 0:case 11:case 14:case 15:da(4,r,r.return);break;case 1:ua(r,r.return);var y=r.stateNode;if("function"===typeof y.componentWillUnmount){var b=r.return;try{y.props=r.memoizedProps,y.state=r.memoizedState,y.componentWillUnmount()}catch(_){Wi(r,b,_)}}break;case 5:ua(r,r.return);break;case 22:if(null!==r.memoizedState){Da(t);continue}}null!==g?(g.return=r,sa=g):Da(t)}x=x.sibling}}}switch(4102&v){case 2:Ua(e),e.flags&=-3;break;case 6:Ua(e),e.flags&=-3,Ma(e.alternate,e);break;case 4096:e.flags&=-4097;break;case 4100:e.flags&=-4097,Ma(e.alternate,e);break;case 4:Ma(e.alternate,e)}}catch(_){Wi(e,e.return,_)}if(null!==(t=e.sibling)){t.return=e.return,sa=t;break}sa=e.return}}}(n,r),O(n.containerInfo),n.current=r,Ca(r,n,o),Le(),Ya=c,je=v,Xa.transition=a}else n.current=r;if(di&&(di=!1,mi=n,hi=o),0===(a=n.pendingLanes)&&(pi=null),function(n){if(We&&"function"===typeof We.onCommitFiberRoot)try{We.onCommitFiberRoot(Ve,n,void 0,128===(128&n.current.flags))}catch(e){}}(r.stateNode),ki(n,Ae()),null!==e)for(t=n.onRecoverableError,r=0;r<e.length;r++)t(e[r]);if(ui)throw ui=!1,n=fi,fi=null,n;0!==(1&hi)&&0!==n.tag&&qi(),0!==(1&(a=n.pendingLanes))?n===gi?xi++:(xi=0,gi=n):xi=0,Ke()}(n,e,t)}finally{Xa.transition=r,je=t}return null}function qi(){if(null!==mi){var n=Fe(hi),e=Xa.transition,t=je;try{if(Xa.transition=null,je=16>n?16:n,null===mi)var r=!1;else{if(n=mi,mi=null,hi=0,0!==(6&Ya))throw Error(i(331));var o=Ya;for(Ya|=4,sa=n.current;null!==sa;){var a=sa,v=a.child;if(0!==(16&sa.flags)){var c=a.deletions;if(null!==c){for(var l=0;l<c.length;l++){var s=c[l];for(sa=s;null!==sa;){var u=sa;switch(u.tag){case 0:case 11:case 15:da(8,u,a)}var f=u.child;if(null!==f)f.return=u,sa=f;else for(;null!==sa;){var p=(u=sa).sibling,d=u.return;if(ya(u),u===s){sa=null;break}if(null!==p){p.return=d,sa=p;break}sa=d}}}var m=a.alternate;if(null!==m){var h=m.child;if(null!==h){m.child=null;do{var x=h.sibling;h.sibling=null,h=x}while(null!==h)}}sa=a}}if(0!==(2064&a.subtreeFlags)&&null!==v)v.return=a,sa=v;else n:for(;null!==sa;){if(0!==(2048&(a=sa).flags))switch(a.tag){case 0:case 11:case 15:da(9,a,a.return)}var g=a.sibling;if(null!==g){g.return=a.return,sa=g;break n}sa=a.return}}var y=n.current;for(sa=y;null!==sa;){var b=(v=sa).child;if(0!==(2064&v.subtreeFlags)&&null!==b)b.return=v,sa=b;else n:for(v=y;null!==sa;){if(0!==(2048&(c=sa).flags))try{switch(c.tag){case 0:case 11:case 15:ma(9,c)}}catch(U){Wi(c,c.return,U)}if(c===v){sa=null;break n}var _=c.sibling;if(null!==_){_.return=c.return,sa=_;break n}sa=c.return}}if(Ya=o,Ke(),We&&"function"===typeof We.onPostCommitFiberRoot)try{We.onPostCommitFiberRoot(Ve,n)}catch(U){}r=!0}return r}finally{je=t,Xa.transition=e}}return!1}function Vi(n,e,t){xt(n,e=ko(0,e=go(t,e),1)),e=_i(),null!==(n=Si(n,1))&&(De(n,1,e),ki(n,e))}function Wi(n,e,t){if(3===n.tag)Vi(n,n,t);else for(;null!==e;){if(3===e.tag){Vi(e,n,t);break}if(1===e.tag){var r=e.stateNode;if("function"===typeof e.type.getDerivedStateFromError||"function"===typeof r.componentDidCatch&&(null===pi||!pi.has(r))){xt(e,n=Mo(e,n=go(t,n),1)),n=_i(),null!==(e=Si(e,1))&&(De(e,1,n),ki(e,n));break}}e=e.return}}function Hi(n,e,t){var r=n.pingCache;null!==r&&r.delete(e),e=_i(),n.pingedLanes|=n.suspendedLanes&t,$a===n&&(Ka&t)===t&&(4===ni||3===ni&&(130023424&Ka)===Ka&&500>Ae()-vi?ji(n,0):oi|=t),ki(n,e)}function Xi(n,e){0===e&&(0===(1&n.mode)?e=1:(e=ke,0===(130023424&(ke<<=1))&&(ke=4194304)));var t=_i();null!==(n=Si(n,e))&&(De(n,e,t),ki(n,t))}function Yi(n){var e=n.memoizedState,t=0;null!==e&&(t=e.retryLane),Xi(n,t)}function $i(n,e){var t=0;switch(n.tag){case 13:var r=n.stateNode,o=n.memoizedState;null!==o&&(t=o.retryLane);break;case 19:r=n.stateNode;break;default:throw Error(i(314))}null!==r&&r.delete(e),Xi(n,t)}function Zi(n,e){return Ee(n,e)}function Ki(n,e,t,r){this.tag=n,this.key=t,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ji(n,e,t,r){return new Ki(n,e,t,r)}function Qi(n){return!(!(n=n.prototype)||!n.isReactComponent)}function nv(n,e){var t=n.alternate;return null===t?((t=Ji(n.tag,e,n.key,n.mode)).elementType=n.elementType,t.type=n.type,t.stateNode=n.stateNode,t.alternate=n,n.alternate=t):(t.pendingProps=e,t.type=n.type,t.flags=0,t.subtreeFlags=0,t.deletions=null),t.flags=14680064&n.flags,t.childLanes=n.childLanes,t.lanes=n.lanes,t.child=n.child,t.memoizedProps=n.memoizedProps,t.memoizedState=n.memoizedState,t.updateQueue=n.updateQueue,e=n.dependencies,t.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext},t.sibling=n.sibling,t.index=n.index,t.ref=n.ref,t}function ev(n,e,t,r,o,a){var v=2;if(r=n,"function"===typeof n)Qi(n)&&(v=1);else if("string"===typeof n)v=5;else n:switch(n){case s:return tv(t.children,o,a,e);case u:v=8,o|=8;break;case f:return(n=Ji(12,t,e,2|o)).elementType=f,n.lanes=a,n;case h:return(n=Ji(13,t,e,o)).elementType=h,n.lanes=a,n;case x:return(n=Ji(19,t,e,o)).elementType=x,n.lanes=a,n;case b:return rv(t,o,a,e);default:if("object"===typeof n&&null!==n)switch(n.$$typeof){case p:v=10;break n;case d:v=9;break n;case m:v=11;break n;case g:v=14;break n;case y:v=16,r=null;break n}throw Error(i(130,null==n?n:typeof n,""))}return(e=Ji(v,t,e,o)).elementType=n,e.type=r,e.lanes=a,e}function tv(n,e,t,r){return(n=Ji(7,n,r,e)).lanes=t,n}function rv(n,e,t,r){return(n=Ji(22,n,r,e)).elementType=b,n.lanes=t,n.stateNode={},n}function ov(n,e,t){return(n=Ji(6,n,null,e)).lanes=t,n}function av(n,e,t){return(e=Ji(4,null!==n.children?n.children:[],n.key,e)).lanes=t,e.stateNode={containerInfo:n.containerInfo,pendingChildren:null,implementation:n.implementation},e}function iv(n,e,t,r,o){this.tag=e,this.containerInfo=n,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=H,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Re(0),this.expirationTimes=Re(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Re(0),this.identifierPrefix=r,this.onRecoverableError=o,Z&&(this.mutableSourceEagerHydrationData=null)}function vv(n,e,t,r,o,a,i,v,c){return n=new iv(n,e,t,v,c),1===e?(e=1,!0===a&&(e|=8)):e=0,a=Ji(3,null,null,e),n.current=a,a.stateNode=n,a.memoizedState={element:r,isDehydrated:t,cache:null,transitions:null},dt(a),n}function cv(n){if(!n)return se;n:{if(k(n=n._reactInternals)!==n||1!==n.tag)throw Error(i(170));var e=n;do{switch(e.tag){case 3:e=e.stateNode.context;break n;case 1:if(me(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break n}}e=e.return}while(null!==e);throw Error(i(171))}if(1===n.tag){var t=n.type;if(me(t))return ge(n,t,e)}return e}function lv(n){var e=n._reactInternals;if(void 0===e){if("function"===typeof n.render)throw Error(i(188));throw n=Object.keys(n).join(","),Error(i(268,n))}return null===(n=C(e))?null:n.stateNode}function sv(n,e){if(null!==(n=n.memoizedState)&&null!==n.dehydrated){var t=n.retryLane;n.retryLane=0!==t&&t<e?t:e}}function uv(n,e){sv(n,e),(n=n.alternate)&&sv(n,e)}function fv(n){return null===(n=C(n))?null:n.stateNode}function pv(){return null}return si=function(n,e,t){if(null!==n)if(n.memoizedProps!==e.pendingProps||fe.current)Oo=!0;else{if(0===(n.lanes&t)&&0===(128&e.flags))return Oo=!1,function(n,e,t){switch(e.tag){case 3:Xo(e),Qt();break;case 5:dr(e);break;case 1:me(e.type)&&ye(e);break;case 4:fr(e,e.stateNode.containerInfo);break;case 10:vt(0,e.type._context,e.memoizedProps.value);break;case 13:var r=e.memoizedState;if(null!==r)return null!==r.dehydrated?(le(hr,1&hr.current),e.flags|=128,null):0!==(t&e.child.childLanes)?Ko(n,e,t):(le(hr,1&hr.current),null!==(n=aa(n,e,t))?n.sibling:null);le(hr,1&hr.current);break;case 19:if(r=0!==(t&e.childLanes),0!==(128&n.flags)){if(r)return oa(n,e,t);e.flags|=128}var o=e.memoizedState;if(null!==o&&(o.rendering=null,o.tail=null,o.lastEffect=null),le(hr,hr.current),r)break;return null;case 22:case 23:return e.lanes=0,Bo(n,e,t)}return aa(n,e,t)}(n,e,t);Oo=0!==(131072&n.flags)}else Oo=!1,Vt&&0!==(1048576&e.flags)&&At(e,Pt,e.index);switch(e.lanes=0,e.tag){case 2:var r=e.type;null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2),n=e.pendingProps;var o=de(e,ue.current);st(e,t),o=Pr(null,e,r,n,o,t);var a=jr();return e.flags|=1,"object"===typeof o&&null!==o&&"function"===typeof o.render&&void 0===o.$$typeof?(e.tag=1,e.memoizedState=null,e.updateQueue=null,me(r)?(a=!0,ye(e)):a=!1,e.memoizedState=null!==o.state&&void 0!==o.state?o.state:null,dt(e),o.updater=St,e.stateNode=o,o._reactInternals=e,Ct(e,r,n,t),e=Ho(null,e,r,!0,a,t)):(e.tag=0,Vt&&a&&Nt(e),Lo(null,e,o,t),e=e.child),e;case 16:r=e.elementType;n:{switch(null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2),n=e.pendingProps,r=(o=r._init)(r._payload),e.type=r,o=e.tag=function(n){if("function"===typeof n)return Qi(n)?1:0;if(void 0!==n&&null!==n){if((n=n.$$typeof)===m)return 11;if(n===g)return 14}return 2}(r),n=et(r,n),o){case 0:e=Vo(null,e,r,n,t);break n;case 1:e=Wo(null,e,r,n,t);break n;case 11:e=Ao(null,e,r,n,t);break n;case 14:e=No(null,e,r,et(r.type,n),t);break n}throw Error(i(306,r,""))}return e;case 0:return r=e.type,o=e.pendingProps,Vo(n,e,r,o=e.elementType===r?o:et(r,o),t);case 1:return r=e.type,o=e.pendingProps,Wo(n,e,r,o=e.elementType===r?o:et(r,o),t);case 3:n:{if(Xo(e),null===n)throw Error(i(387));r=e.pendingProps,o=(a=e.memoizedState).element,mt(n,e),bt(e,r,null,t);var v=e.memoizedState;if(r=v.element,Z&&a.isDehydrated){if(a={element:r,isDehydrated:!1,cache:v.cache,transitions:v.transitions},e.updateQueue.baseState=a,e.memoizedState=a,256&e.flags){e=Yo(n,e,r,t,o=Error(i(423)));break n}if(r!==o){e=Yo(n,e,r,t,o=Error(i(424)));break n}for(Z&&(qt=Bn(e.stateNode.containerInfo),Bt=e,Vt=!0,Ht=null,Wt=!1),t=ir(e,null,r,t),e.child=t;t;)t.flags=-3&t.flags|4096,t=t.sibling}else{if(Qt(),r===o){e=aa(n,e,t);break n}Lo(n,e,r,t)}e=e.child}return e;case 5:return dr(e),null===n&&Zt(e),r=e.type,o=e.pendingProps,a=null!==n?n.memoizedProps:null,v=o.children,B(r,o)?v=null:null!==a&&B(r,a)&&(e.flags|=32),qo(n,e),Lo(n,e,v,t),e.child;case 6:return null===n&&Zt(e),null;case 13:return Ko(n,e,t);case 4:return fr(e,e.stateNode.containerInfo),r=e.pendingProps,null===n?e.child=ar(e,null,r,t):Lo(n,e,r,t),e.child;case 11:return r=e.type,o=e.pendingProps,Ao(n,e,r,o=e.elementType===r?o:et(r,o),t);case 7:return Lo(n,e,e.pendingProps,t),e.child;case 8:case 12:return Lo(n,e,e.pendingProps.children,t),e.child;case 10:n:{if(r=e.type._context,o=e.pendingProps,a=e.memoizedProps,vt(0,r,v=o.value),null!==a)if(He(a.value,v)){if(a.children===o.children&&!fe.current){e=aa(n,e,t);break n}}else for(null!==(a=e.child)&&(a.return=e);null!==a;){var c=a.dependencies;if(null!==c){v=a.child;for(var l=c.firstContext;null!==l;){if(l.context===r){if(1===a.tag){(l=ht(-1,t&-t)).tag=2;var s=a.updateQueue;if(null!==s){var u=(s=s.shared).pending;null===u?l.next=l:(l.next=u.next,u.next=l),s.pending=l}}a.lanes|=t,null!==(l=a.alternate)&&(l.lanes|=t),lt(a.return,t,e),c.lanes|=t;break}l=l.next}}else if(10===a.tag)v=a.type===e.type?null:a.child;else if(18===a.tag){if(null===(v=a.return))throw Error(i(341));v.lanes|=t,null!==(c=v.alternate)&&(c.lanes|=t),lt(v,t,e),v=a.sibling}else v=a.child;if(null!==v)v.return=a;else for(v=a;null!==v;){if(v===e){v=null;break}if(null!==(a=v.sibling)){a.return=v.return,v=a;break}v=v.return}a=v}Lo(n,e,o.children,t),e=e.child}return e;case 9:return o=e.type,r=e.pendingProps.children,st(e,t),r=r(o=ut(o)),e.flags|=1,Lo(n,e,r,t),e.child;case 14:return o=et(r=e.type,e.pendingProps),No(n,e,r,o=et(r.type,o),t);case 15:return Go(n,e,e.type,e.pendingProps,t);case 17:return r=e.type,o=e.pendingProps,o=e.elementType===r?o:et(r,o),null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2),e.tag=1,me(r)?(n=!0,ye(e)):n=!1,st(e,t),Mt(e,r,o),Ct(e,r,o,t),Ho(null,e,r,!0,n,t);case 19:return oa(n,e,t);case 22:return Bo(n,e,t)}throw Error(i(156,e.tag))},e.attemptContinuousHydration=function(n){13===n.tag&&(wi(n,134217728,_i()),uv(n,134217728))},e.attemptHydrationAtCurrentPriority=function(n){if(13===n.tag){var e=_i(),t=Ui(n);wi(n,t,e),uv(n,t)}},e.attemptSynchronousHydration=function(n){switch(n.tag){case 3:var e=n.stateNode;if(e.current.memoizedState.isDehydrated){var t=Me(e.pendingLanes);0!==t&&(Pe(e,1|t),ki(e,Ae()),0===(6&Ya)&&(li(),Ke()))}break;case 13:var r=_i();Di((function(){return wi(n,1,r)})),uv(n,1)}},e.batchedUpdates=function(n,e){var t=Ya;Ya|=1;try{return n(e)}finally{0===(Ya=t)&&(li(),Ye&&Ke())}},e.createComponentSelector=function(n){return{$$typeof:ja,value:n}},e.createContainer=function(n,e,t,r,o,a,i){return vv(n,e,!1,null,0,r,0,a,i)},e.createHasPseudoClassSelector=function(n){return{$$typeof:Fa,value:n}},e.createHydrationContainer=function(n,e,t,r,o,a,i,v,c){return(n=vv(t,r,!0,n,0,a,0,v,c)).context=cv(null),t=n.current,(a=ht(r=_i(),o=Ui(t))).callback=void 0!==e&&null!==e?e:null,xt(t,a),n.current.lanes=o,De(n,o,r),ki(n,r),n},e.createPortal=function(n,e,t){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:l,key:null==r?null:""+r,children:n,containerInfo:e,implementation:t}},e.createRoleSelector=function(n){return{$$typeof:Ea,value:n}},e.createTestNameSelector=function(n){return{$$typeof:Ia,value:n}},e.createTextSelector=function(n){return{$$typeof:Oa,value:n}},e.deferredUpdates=function(n){var e=je,t=Xa.transition;try{return Xa.transition=null,je=16,n()}finally{je=e,Xa.transition=t}},e.discreteUpdates=function(n,e,t,r,o){var a=je,i=Xa.transition;try{return Xa.transition=null,je=1,n(e,t,r,o)}finally{je=a,Xa.transition=i,0===Ya&&li()}},e.findAllNodes=qa,e.findBoundingRects=function(n,e){if(!rn)throw Error(i(363));e=qa(n,e),n=[];for(var t=0;t<e.length;t++)n.push(an(e[t]));for(e=n.length-1;0<e;e--)for(var r=(t=n[e]).x,o=r+t.width,a=t.y,v=a+t.height,c=e-1;0<=c;c--)if(e!==c){var l=n[c],s=l.x,u=s+l.width,f=l.y,p=f+l.height;if(r>=s&&a>=f&&o<=u&&v<=p){n.splice(e,1);break}if(!(r!==s||t.width!==l.width||p<a||f>v)){f>a&&(l.height+=f-a,l.y=a),p<v&&(l.height=v-f),n.splice(e,1);break}if(!(a!==f||t.height!==l.height||u<r||s>o)){s>r&&(l.width+=s-r,l.x=r),u<o&&(l.width=o-s),n.splice(e,1);break}}return n},e.findHostInstance=lv,e.findHostInstanceWithNoPortals=function(n){return null===(n=null!==(n=z(n))?R(n):null)?null:n.stateNode},e.findHostInstanceWithWarning=function(n){return lv(n)},e.flushControlled=function(n){var e=Ya;Ya|=1;var t=Xa.transition,r=je;try{Xa.transition=null,je=1,n()}finally{je=r,Xa.transition=t,0===(Ya=e)&&(li(),Ke())}},e.flushPassiveEffects=qi,e.flushSync=Di,e.focusWithin=function(n,e){if(!rn)throw Error(i(363));for(e=Ba(n=Aa(n),e),e=Array.from(e),n=0;n<e.length;){var t=e[n++];if(!cn(t)){if(5===t.tag&&sn(t.stateNode))return!0;for(t=t.child;null!==t;)e.push(t),t=t.sibling}}return!1},e.getCurrentUpdatePriority=function(){return je},e.getFindAllNodesFailureDescription=function(n,e){if(!rn)throw Error(i(363));var t=0,r=[];n=[Aa(n),0];for(var o=0;o<n.length;){var a=n[o++],v=n[o++],c=e[v];if((5!==a.tag||!cn(a))&&(Na(a,c)&&(r.push(Ga(c)),++v>t&&(t=v)),v<e.length))for(a=a.child;null!==a;)n.push(a,v),a=a.sibling}if(t<e.length){for(n=[];t<e.length;t++)n.push(Ga(e[t]));return"findAllNodes was able to match part of the selector:\n  "+r.join(" > ")+"\n\nNo matching component was found for:\n  "+n.join(" > ")}return null},e.getPublicRootInstance=function(n){return(n=n.current).child?5===n.child.tag?j(n.child.stateNode):n.child.stateNode:null},e.injectIntoDevTools=function(n){if(n={bundleType:n.bundleType,version:n.version,rendererPackageName:n.rendererPackageName,rendererConfig:n.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:v.ReactCurrentDispatcher,findHostInstanceByFiber:fv,findFiberByHostInstance:n.findFiberByHostInstance||pv,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.0.0-fc46dba67-20220329"},"undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)n=!1;else{var e=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(e.isDisabled||!e.supportsFiber)n=!0;else{try{Ve=e.inject(n),We=e}catch(t){}n=!!e.checkDCE}}return n},e.isAlreadyRendering=function(){return!1},e.observeVisibleRects=function(n,e,t,r){if(!rn)throw Error(i(363));n=qa(n,e);var o=un(n,t,r).disconnect;return{disconnect:function(){o()}}},e.registerMutableSourceForHydration=function(n,e){var t=e._getVersion;t=t(e._source),null==n.mutableSourceEagerHydrationData?n.mutableSourceEagerHydrationData=[e,t]:n.mutableSourceEagerHydrationData.push(e,t)},e.runWithPriority=function(n,e){var t=je;try{return je=n,e()}finally{je=t}},e.shouldError=function(){return null},e.shouldSuspend=function(){return!1},e.updateContainer=function(n,e,t,r){var o=e.current,a=_i(),i=Ui(o);return t=cv(t),null===e.context?e.context=t:e.pendingContext=t,(e=ht(a,i)).payload={element:n},null!==(r=void 0===r?null:r)&&(e.callback=r),xt(o,e),null!==(n=wi(o,i,a))&&gt(n,o,i),i},e}},585:function(n,e,t){"use strict";n.exports=t(976)},258:function(n,e,t){"use strict";n.exports=t(721)},783:function(n,e){"use strict";function t(n,e){var t=n.length;n.push(e);n:for(;0<t;){var r=t-1>>>1,o=n[r];if(!(0<a(o,e)))break n;n[r]=e,n[t]=o,t=r}}function r(n){return 0===n.length?null:n[0]}function o(n){if(0===n.length)return null;var e=n[0],t=n.pop();if(t!==e){n[0]=t;n:for(var r=0,o=n.length,i=o>>>1;r<i;){var v=2*(r+1)-1,c=n[v],l=v+1,s=n[l];if(0>a(c,t))l<o&&0>a(s,c)?(n[r]=s,n[l]=t,r=l):(n[r]=c,n[v]=t,r=v);else{if(!(l<o&&0>a(s,t)))break n;n[r]=s,n[l]=t,r=l}}}return e}function a(n,e){var t=n.sortIndex-e.sortIndex;return 0!==t?t:n.id-e.id}if("object"===typeof performance&&"function"===typeof performance.now){var i=performance;e.unstable_now=function(){return i.now()}}else{var v=Date,c=v.now();e.unstable_now=function(){return v.now()-c}}var l=[],s=[],u=1,f=null,p=3,d=!1,m=!1,h=!1,x="function"===typeof setTimeout?setTimeout:null,g="function"===typeof clearTimeout?clearTimeout:null,y="undefined"!==typeof setImmediate?setImmediate:null;function b(n){for(var e=r(s);null!==e;){if(null===e.callback)o(s);else{if(!(e.startTime<=n))break;o(s),e.sortIndex=e.expirationTime,t(l,e)}e=r(s)}}function _(n){if(h=!1,b(n),!m)if(null!==r(l))m=!0,j(U);else{var e=r(s);null!==e&&F(_,e.startTime-n)}}function U(n,t){m=!1,h&&(h=!1,g(M),M=-1),d=!0;var a=p;try{for(b(t),f=r(l);null!==f&&(!(f.expirationTime>t)||n&&!T());){var i=f.callback;if("function"===typeof i){f.callback=null,p=f.priorityLevel;var v=i(f.expirationTime<=t);t=e.unstable_now(),"function"===typeof v?f.callback=v:f===r(l)&&o(l),b(t)}else o(l);f=r(l)}if(null!==f)var c=!0;else{var u=r(s);null!==u&&F(_,u.startTime-t),c=!1}return c}finally{f=null,p=a,d=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var w,S=!1,k=null,M=-1,z=5,C=-1;function T(){return!(e.unstable_now()-C<z)}function R(){if(null!==k){var n=e.unstable_now();C=n;var t=!0;try{t=k(!0,n)}finally{t?w():(S=!1,k=null)}}else S=!1}if("function"===typeof y)w=function(){y(R)};else if("undefined"!==typeof MessageChannel){var D=new MessageChannel,P=D.port2;D.port1.onmessage=R,w=function(){P.postMessage(null)}}else w=function(){x(R,0)};function j(n){k=n,S||(S=!0,w())}function F(n,t){M=x((function(){n(e.unstable_now())}),t)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(n){n.callback=null},e.unstable_continueExecution=function(){m||d||(m=!0,j(U))},e.unstable_forceFrameRate=function(n){0>n||125<n?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):z=0<n?Math.floor(1e3/n):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return r(l)},e.unstable_next=function(n){switch(p){case 1:case 2:case 3:var e=3;break;default:e=p}var t=p;p=e;try{return n()}finally{p=t}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(n,e){switch(n){case 1:case 2:case 3:case 4:case 5:break;default:n=3}var t=p;p=n;try{return e()}finally{p=t}},e.unstable_scheduleCallback=function(n,o,a){var i=e.unstable_now();switch("object"===typeof a&&null!==a?a="number"===typeof(a=a.delay)&&0<a?i+a:i:a=i,n){case 1:var v=-1;break;case 2:v=250;break;case 5:v=1073741823;break;case 4:v=1e4;break;default:v=5e3}return n={id:u++,callback:o,priorityLevel:n,startTime:a,expirationTime:v=a+v,sortIndex:-1},a>i?(n.sortIndex=a,t(s,n),null===r(l)&&n===r(s)&&(h?(g(M),M=-1):h=!0,F(_,a-i))):(n.sortIndex=v,t(l,n),m||d||(m=!0,j(U))),n},e.unstable_shouldYield=T,e.unstable_wrapCallback=function(n){var e=p;return function(){var t=p;p=e;try{return n.apply(this,arguments)}finally{p=t}}}},100:function(n,e,t){"use strict";n.exports=t(783)},374:function(n,e,t){"use strict";var r=t(791),o=Symbol.for("react.element"),a=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,v=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function l(n,e,t){var r,a={},l=null,s=null;for(r in void 0!==t&&(l=""+t),void 0!==e.key&&(l=""+e.key),void 0!==e.ref&&(s=e.ref),e)i.call(e,r)&&!c.hasOwnProperty(r)&&(a[r]=e[r]);if(n&&n.defaultProps)for(r in e=n.defaultProps)void 0===a[r]&&(a[r]=e[r]);return{$$typeof:o,type:n,key:l,ref:s,props:a,_owner:v.current}}e.Fragment=a,e.jsx=l,e.jsxs=l},117:function(n,e){"use strict";var t=Symbol.for("react.element"),r=Symbol.for("react.portal"),o=Symbol.for("react.fragment"),a=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),v=Symbol.for("react.provider"),c=Symbol.for("react.context"),l=Symbol.for("react.forward_ref"),s=Symbol.for("react.suspense"),u=Symbol.for("react.memo"),f=Symbol.for("react.lazy"),p=Symbol.iterator;var d={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,h={};function x(n,e,t){this.props=n,this.context=e,this.refs=h,this.updater=t||d}function g(){}function y(n,e,t){this.props=n,this.context=e,this.refs=h,this.updater=t||d}x.prototype.isReactComponent={},x.prototype.setState=function(n,e){if("object"!==typeof n&&"function"!==typeof n&&null!=n)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,n,e,"setState")},x.prototype.forceUpdate=function(n){this.updater.enqueueForceUpdate(this,n,"forceUpdate")},g.prototype=x.prototype;var b=y.prototype=new g;b.constructor=y,m(b,x.prototype),b.isPureReactComponent=!0;var _=Array.isArray,U=Object.prototype.hasOwnProperty,w={current:null},S={key:!0,ref:!0,__self:!0,__source:!0};function k(n,e,r){var o,a={},i=null,v=null;if(null!=e)for(o in void 0!==e.ref&&(v=e.ref),void 0!==e.key&&(i=""+e.key),e)U.call(e,o)&&!S.hasOwnProperty(o)&&(a[o]=e[o]);var c=arguments.length-2;if(1===c)a.children=r;else if(1<c){for(var l=Array(c),s=0;s<c;s++)l[s]=arguments[s+2];a.children=l}if(n&&n.defaultProps)for(o in c=n.defaultProps)void 0===a[o]&&(a[o]=c[o]);return{$$typeof:t,type:n,key:i,ref:v,props:a,_owner:w.current}}function M(n){return"object"===typeof n&&null!==n&&n.$$typeof===t}var z=/\/+/g;function C(n,e){return"object"===typeof n&&null!==n&&null!=n.key?function(n){var e={"=":"=0",":":"=2"};return"$"+n.replace(/[=:]/g,(function(n){return e[n]}))}(""+n.key):e.toString(36)}function T(n,e,o,a,i){var v=typeof n;"undefined"!==v&&"boolean"!==v||(n=null);var c=!1;if(null===n)c=!0;else switch(v){case"string":case"number":c=!0;break;case"object":switch(n.$$typeof){case t:case r:c=!0}}if(c)return i=i(c=n),n=""===a?"."+C(c,0):a,_(i)?(o="",null!=n&&(o=n.replace(z,"$&/")+"/"),T(i,e,o,"",(function(n){return n}))):null!=i&&(M(i)&&(i=function(n,e){return{$$typeof:t,type:n.type,key:e,ref:n.ref,props:n.props,_owner:n._owner}}(i,o+(!i.key||c&&c.key===i.key?"":(""+i.key).replace(z,"$&/")+"/")+n)),e.push(i)),1;if(c=0,a=""===a?".":a+":",_(n))for(var l=0;l<n.length;l++){var s=a+C(v=n[l],l);c+=T(v,e,o,s,i)}else if(s=function(n){return null===n||"object"!==typeof n?null:"function"===typeof(n=p&&n[p]||n["@@iterator"])?n:null}(n),"function"===typeof s)for(n=s.call(n),l=0;!(v=n.next()).done;)c+=T(v=v.value,e,o,s=a+C(v,l++),i);else if("object"===v)throw e=String(n),Error("Objects are not valid as a React child (found: "+("[object Object]"===e?"object with keys {"+Object.keys(n).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return c}function R(n,e,t){if(null==n)return n;var r=[],o=0;return T(n,r,"","",(function(n){return e.call(t,n,o++)})),r}function D(n){if(-1===n._status){var e=n._result;(e=e()).then((function(e){0!==n._status&&-1!==n._status||(n._status=1,n._result=e)}),(function(e){0!==n._status&&-1!==n._status||(n._status=2,n._result=e)})),-1===n._status&&(n._status=0,n._result=e)}if(1===n._status)return n._result.default;throw n._result}var P={current:null},j={transition:null},F={ReactCurrentDispatcher:P,ReactCurrentBatchConfig:j,ReactCurrentOwner:w};e.Children={map:R,forEach:function(n,e,t){R(n,(function(){e.apply(this,arguments)}),t)},count:function(n){var e=0;return R(n,(function(){e++})),e},toArray:function(n){return R(n,(function(n){return n}))||[]},only:function(n){if(!M(n))throw Error("React.Children.only expected to receive a single React element child.");return n}},e.Component=x,e.Fragment=o,e.Profiler=i,e.PureComponent=y,e.StrictMode=a,e.Suspense=s,e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=F,e.cloneElement=function(n,e,r){if(null===n||void 0===n)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+n+".");var o=m({},n.props),a=n.key,i=n.ref,v=n._owner;if(null!=e){if(void 0!==e.ref&&(i=e.ref,v=w.current),void 0!==e.key&&(a=""+e.key),n.type&&n.type.defaultProps)var c=n.type.defaultProps;for(l in e)U.call(e,l)&&!S.hasOwnProperty(l)&&(o[l]=void 0===e[l]&&void 0!==c?c[l]:e[l])}var l=arguments.length-2;if(1===l)o.children=r;else if(1<l){c=Array(l);for(var s=0;s<l;s++)c[s]=arguments[s+2];o.children=c}return{$$typeof:t,type:n.type,key:a,ref:i,props:o,_owner:v}},e.createContext=function(n){return(n={$$typeof:c,_currentValue:n,_currentValue2:n,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:v,_context:n},n.Consumer=n},e.createElement=k,e.createFactory=function(n){var e=k.bind(null,n);return e.type=n,e},e.createRef=function(){return{current:null}},e.forwardRef=function(n){return{$$typeof:l,render:n}},e.isValidElement=M,e.lazy=function(n){return{$$typeof:f,_payload:{_status:-1,_result:n},_init:D}},e.memo=function(n,e){return{$$typeof:u,type:n,compare:void 0===e?null:e}},e.startTransition=function(n){var e=j.transition;j.transition={};try{n()}finally{j.transition=e}},e.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")},e.useCallback=function(n,e){return P.current.useCallback(n,e)},e.useContext=function(n){return P.current.useContext(n)},e.useDebugValue=function(){},e.useDeferredValue=function(n){return P.current.useDeferredValue(n)},e.useEffect=function(n,e){return P.current.useEffect(n,e)},e.useId=function(){return P.current.useId()},e.useImperativeHandle=function(n,e,t){return P.current.useImperativeHandle(n,e,t)},e.useInsertionEffect=function(n,e){return P.current.useInsertionEffect(n,e)},e.useLayoutEffect=function(n,e){return P.current.useLayoutEffect(n,e)},e.useMemo=function(n,e){return P.current.useMemo(n,e)},e.useReducer=function(n,e,t){return P.current.useReducer(n,e,t)},e.useRef=function(n){return P.current.useRef(n)},e.useState=function(n){return P.current.useState(n)},e.useSyncExternalStore=function(n,e,t){return P.current.useSyncExternalStore(n,e,t)},e.useTransition=function(){return P.current.useTransition()},e.version="18.2.0"},791:function(n,e,t){"use strict";n.exports=t(117)},184:function(n,e,t){"use strict";n.exports=t(374)},813:function(n,e){"use strict";function t(n,e){var t=n.length;n.push(e);n:for(;0<t;){var r=t-1>>>1,o=n[r];if(!(0<a(o,e)))break n;n[r]=e,n[t]=o,t=r}}function r(n){return 0===n.length?null:n[0]}function o(n){if(0===n.length)return null;var e=n[0],t=n.pop();if(t!==e){n[0]=t;n:for(var r=0,o=n.length,i=o>>>1;r<i;){var v=2*(r+1)-1,c=n[v],l=v+1,s=n[l];if(0>a(c,t))l<o&&0>a(s,c)?(n[r]=s,n[l]=t,r=l):(n[r]=c,n[v]=t,r=v);else{if(!(l<o&&0>a(s,t)))break n;n[r]=s,n[l]=t,r=l}}}return e}function a(n,e){var t=n.sortIndex-e.sortIndex;return 0!==t?t:n.id-e.id}if("object"===typeof performance&&"function"===typeof performance.now){var i=performance;e.unstable_now=function(){return i.now()}}else{var v=Date,c=v.now();e.unstable_now=function(){return v.now()-c}}var l=[],s=[],u=1,f=null,p=3,d=!1,m=!1,h=!1,x="function"===typeof setTimeout?setTimeout:null,g="function"===typeof clearTimeout?clearTimeout:null,y="undefined"!==typeof setImmediate?setImmediate:null;function b(n){for(var e=r(s);null!==e;){if(null===e.callback)o(s);else{if(!(e.startTime<=n))break;o(s),e.sortIndex=e.expirationTime,t(l,e)}e=r(s)}}function _(n){if(h=!1,b(n),!m)if(null!==r(l))m=!0,j(U);else{var e=r(s);null!==e&&F(_,e.startTime-n)}}function U(n,t){m=!1,h&&(h=!1,g(M),M=-1),d=!0;var a=p;try{for(b(t),f=r(l);null!==f&&(!(f.expirationTime>t)||n&&!T());){var i=f.callback;if("function"===typeof i){f.callback=null,p=f.priorityLevel;var v=i(f.expirationTime<=t);t=e.unstable_now(),"function"===typeof v?f.callback=v:f===r(l)&&o(l),b(t)}else o(l);f=r(l)}if(null!==f)var c=!0;else{var u=r(s);null!==u&&F(_,u.startTime-t),c=!1}return c}finally{f=null,p=a,d=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var w,S=!1,k=null,M=-1,z=5,C=-1;function T(){return!(e.unstable_now()-C<z)}function R(){if(null!==k){var n=e.unstable_now();C=n;var t=!0;try{t=k(!0,n)}finally{t?w():(S=!1,k=null)}}else S=!1}if("function"===typeof y)w=function(){y(R)};else if("undefined"!==typeof MessageChannel){var D=new MessageChannel,P=D.port2;D.port1.onmessage=R,w=function(){P.postMessage(null)}}else w=function(){x(R,0)};function j(n){k=n,S||(S=!0,w())}function F(n,t){M=x((function(){n(e.unstable_now())}),t)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(n){n.callback=null},e.unstable_continueExecution=function(){m||d||(m=!0,j(U))},e.unstable_forceFrameRate=function(n){0>n||125<n?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):z=0<n?Math.floor(1e3/n):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return r(l)},e.unstable_next=function(n){switch(p){case 1:case 2:case 3:var e=3;break;default:e=p}var t=p;p=e;try{return n()}finally{p=t}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(n,e){switch(n){case 1:case 2:case 3:case 4:case 5:break;default:n=3}var t=p;p=n;try{return e()}finally{p=t}},e.unstable_scheduleCallback=function(n,o,a){var i=e.unstable_now();switch("object"===typeof a&&null!==a?a="number"===typeof(a=a.delay)&&0<a?i+a:i:a=i,n){case 1:var v=-1;break;case 2:v=250;break;case 5:v=1073741823;break;case 4:v=1e4;break;default:v=5e3}return n={id:u++,callback:o,priorityLevel:n,startTime:a,expirationTime:v=a+v,sortIndex:-1},a>i?(n.sortIndex=a,t(s,n),null===r(l)&&n===r(s)&&(h?(g(M),M=-1):h=!0,F(_,a-i))):(n.sortIndex=v,t(l,n),m||d||(m=!0,j(U))),n},e.unstable_shouldYield=T,e.unstable_wrapCallback=function(n){var e=p;return function(){var t=p;p=e;try{return n.apply(this,arguments)}finally{p=t}}}},296:function(n,e,t){"use strict";n.exports=t(813)},809:function(n,e,t){"use strict";var r=t(18),o=t(456),a=t(807),i=t(240);function v(n){return"__proto__"!==n&&"constructor"!==n&&"prototype"!==n}n.exports=function(n,e,t){if(!i(n))return n;if(Array.isArray(e)&&(e=[].concat.apply([],e).join(".")),"string"!==typeof e)return n;for(var c=r(e,{sep:".",brackets:!0}).filter(v),l=c.length,s=-1,u=n;++s<l;){var f=c[s];s===l-1?a(u[f])&&a(t)?u[f]=o({},u[f],t):u[f]=t:(i(u[f])||(u[f]={}),u=u[f])}return n}},240:function(n){"use strict";n.exports=function(n){return"undefined"!==typeof n&&null!==n&&("object"===typeof n||"function"===typeof n)}},18:function(n,e,t){"use strict";var r=t(955);function o(n,e,t,r){var a=n.indexOf(e,t);return"\\"===n.charAt(a-1)?o(n,e,a+1):a}function a(n,e){return!0===e.keepDoubleQuotes&&'"'===n||(!0===e.keepSingleQuotes&&"'"===n||e.keepQuotes)}function i(n,e,t){return"function"===typeof n.keepEscaping?n.keepEscaping(e,t):!0===n.keepEscaping||"\\"===e[t+1]}n.exports=function(n,e,t){if("string"!==typeof n)throw new TypeError("expected a string");"function"===typeof e&&(t=e,e=null),"string"===typeof e&&(e={sep:e});var v,c=r({sep:"."},e),l=c.quotes||['"',"'","`"];!0===c.brackets?v={"<":">","(":")","[":"]","{":"}"}:c.brackets&&(v=c.brackets);var s,u=[],f=[],p=[""],d=c.sep,m=n.length,h=-1;function x(){if(v&&f.length)return v[f[f.length-1]]}for(;++h<m;){var g=n[h],y=n[h+1],b={val:g,idx:h,arr:p,str:n};if(u.push(b),"\\"!==g){if(v&&v[g]){f.push(g);var _=x(),U=h+1;if(-1!==n.indexOf(_,U+1))for(;f.length&&U<m;){var w=n[++U];if("\\"!==w)if(-1===l.indexOf(w)){if(_=x(),f.length&&-1===n.indexOf(_,U+1))break;v[w]?f.push(w):_===w&&f.pop()}else U=o(n,w,U+1);else w++}if(-1===(s=U)){p[p.length-1]+=g;continue}g=n.slice(h,s+1),b.val=g,b.idx=h=s}if(-1!==l.indexOf(g)){if(-1===(s=o(n,g,h+1))){p[p.length-1]+=g;continue}g=!0===a(g,c)?n.slice(h,s+1):n.slice(h+1,s),b.val=g,b.idx=h=s}"function"===typeof t&&(t(b,u),g=b.val,h=b.idx),b.val!==d||!1===b.split?p[p.length-1]+=b.val:p.push("")}else b.val=!0===i(c,n,h)?g+y:y,b.escaped=!0,"function"===typeof t&&t(b),p[p.length-1]+=b.val,h++}return p}},955:function(n,e,t){"use strict";var r=t(105),o=t(823);function a(n,e){for(var t in e)l(e,t)&&(n[t]=e[t])}function i(n){return n&&"string"===typeof n}function v(n){var e={};for(var t in n)e[t]=n[t];return e}function c(n){return n&&"object"===typeof n||r(n)}function l(n,e){return Object.prototype.hasOwnProperty.call(n,e)}n.exports=Object.assign||function(n){if(null===n||"undefined"===typeof n)throw new TypeError("Cannot convert undefined or null to object");c(n)||(n={});for(var e=1;e<arguments.length;e++){var t=arguments[e];i(t)&&(t=v(t)),c(t)&&(a(n,t),o(n,t))}return n}},561:function(n,e,t){"use strict";var r=t(791);var o="function"===typeof Object.is?Object.is:function(n,e){return n===e&&(0!==n||1/n===1/e)||n!==n&&e!==e},a=r.useState,i=r.useEffect,v=r.useLayoutEffect,c=r.useDebugValue;function l(n){var e=n.getSnapshot;n=n.value;try{var t=e();return!o(n,t)}catch(r){return!0}}var s="undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement?function(n,e){return e()}:function(n,e){var t=e(),r=a({inst:{value:t,getSnapshot:e}}),o=r[0].inst,s=r[1];return v((function(){o.value=t,o.getSnapshot=e,l(o)&&s({inst:o})}),[n,t,e]),i((function(){return l(o)&&s({inst:o}),n((function(){l(o)&&s({inst:o})}))}),[n]),c(t),t};e.useSyncExternalStore=void 0!==r.useSyncExternalStore?r.useSyncExternalStore:s},595:function(n,e,t){"use strict";var r=t(791),o=t(248);var a="function"===typeof Object.is?Object.is:function(n,e){return n===e&&(0!==n||1/n===1/e)||n!==n&&e!==e},i=o.useSyncExternalStore,v=r.useRef,c=r.useEffect,l=r.useMemo,s=r.useDebugValue;e.useSyncExternalStoreWithSelector=function(n,e,t,r,o){var u=v(null);if(null===u.current){var f={hasValue:!1,value:null};u.current=f}else f=u.current;u=l((function(){function n(n){if(!c){if(c=!0,i=n,n=r(n),void 0!==o&&f.hasValue){var e=f.value;if(o(e,n))return v=e}return v=n}if(e=v,a(i,n))return e;var t=r(n);return void 0!==o&&o(e,t)?e:(i=n,v=t)}var i,v,c=!1,l=void 0===t?null:t;return[function(){return n(e())},null===l?void 0:function(){return n(l())}]}),[e,t,r,o]);var p=i(n,u[0],u[1]);return c((function(){f.hasValue=!0,f.value=p}),[p]),s(p),p}},248:function(n,e,t){"use strict";n.exports=t(561)},327:function(n,e,t){"use strict";n.exports=t(595)}},e={};function t(r){var o=e[r];if(void 0!==o)return o.exports;var a=e[r]={exports:{}};return n[r](a,a.exports,t),a.exports}t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,{a:e}),e},function(){var n,e=Object.getPrototypeOf?function(n){return Object.getPrototypeOf(n)}:function(n){return n.__proto__};t.t=function(r,o){if(1&o&&(r=this(r)),8&o)return r;if("object"===typeof r&&r){if(4&o&&r.__esModule)return r;if(16&o&&"function"===typeof r.then)return r}var a=Object.create(null);t.r(a);var i={};n=n||[null,e({}),e([]),e(e)];for(var v=2&o&&r;"object"==typeof v&&!~n.indexOf(v);v=e(v))Object.getOwnPropertyNames(v).forEach((function(n){i[n]=function(){return r[n]}}));return i.default=function(){return r},t.d(a,i),a}}(),t.d=function(n,e){for(var r in e)t.o(e,r)&&!t.o(n,r)&&Object.defineProperty(n,r,{enumerable:!0,get:e[r]})},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.r=function(n){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.nc=void 0,function(){"use strict";var n,e={};function r(n,e){if(null==n)return{};var t,r,o=function(n,e){if(null==n)return{};var t,r,o={},a=Object.keys(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||(o[t]=n[t]);return o}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(o[t]=n[t])}return o}function o(n){if(Array.isArray(n))return n}function a(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}function i(n,e){if(n){if("string"===typeof n)return a(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?a(n,e):void 0}}function v(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function c(n,e){return o(n)||function(n,e){var t=null==n?null:"undefined"!==typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var r,o,a=[],i=!0,v=!1;try{for(t=t.call(n);!(i=(r=t.next()).done)&&(a.push(r.value),!e||a.length!==e);i=!0);}catch(c){v=!0,o=c}finally{try{i||null==t.return||t.return()}finally{if(v)throw o}}return a}}(n,e)||i(n,e)||v()}function l(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function s(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function u(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?s(Object(t),!0).forEach((function(e){l(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function f(n,e){var t="undefined"!==typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(!t){if(Array.isArray(n)||(t=i(n))||e&&n&&"number"===typeof n.length){t&&(n=t);var r=0,o=function(){};return{s:o,n:function(){return r>=n.length?{done:!0}:{done:!1,value:n[r++]}},e:function(n){throw n},f:o}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,v=!0,c=!1;return{s:function(){t=t.call(n)},n:function(){var n=t.next();return v=n.done,n},e:function(n){c=!0,a=n},f:function(){try{v||null==t.return||t.return()}finally{if(c)throw a}}}}function p(n,e){return p=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(n,e){return n.__proto__=e,n},p(n,e)}function d(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}function m(n,e,t){return m=d()?Reflect.construct.bind():function(n,e,t){var r=[null];r.push.apply(r,e);var o=new(Function.bind.apply(n,r));return t&&p(o,t.prototype),o},m.apply(null,arguments)}function h(n){if("undefined"!==typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}function x(n){return function(n){if(Array.isArray(n))return a(n)}(n)||h(n)||i(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function g(n){return o(n)||h(n)||i(n)||v()}function y(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function b(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function _(n,e,t){return e&&b(n.prototype,e),t&&b(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}function U(n,e){if("function"!==typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),e&&p(n,e)}function w(n){return w=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(n){return n.__proto__||Object.getPrototypeOf(n)},w(n)}function S(n){return S="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},S(n)}function k(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}function M(n,e){if(e&&("object"===S(e)||"function"===typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return k(n)}function z(n){var e=d();return function(){var t,r=w(n);if(e){var o=w(this).constructor;t=Reflect.construct(r,arguments,o)}else t=r.apply(this,arguments);return M(this,t)}}function C(n){var e="function"===typeof Map?new Map:void 0;return C=function(n){if(null===n||(t=n,-1===Function.toString.call(t).indexOf("[native code]")))return n;var t;if("function"!==typeof n)throw new TypeError("Super expression must either be null or a function");if("undefined"!==typeof e){if(e.has(n))return e.get(n);e.set(n,r)}function r(){return m(n,arguments,w(this).constructor)}return r.prototype=Object.create(n.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),p(r,n)},C(n)}function T(n,e,t,r,o,a,i){try{var v=n[a](i),c=v.value}catch(l){return void t(l)}v.done?e(c):Promise.resolve(c).then(r,o)}function R(n){return function(){var e=this,t=arguments;return new Promise((function(r,o){var a=n.apply(e,t);function i(n){T(a,r,o,i,v,"next",n)}function v(n){T(a,r,o,i,v,"throw",n)}i(void 0)}))}}function D(n,e){for(;!Object.prototype.hasOwnProperty.call(n,e)&&null!==(n=w(n)););return n}function P(){return P="undefined"!==typeof Reflect&&Reflect.get?Reflect.get.bind():function(n,e,t){var r=D(n,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(arguments.length<3?n:t):o.value}},P.apply(this,arguments)}function j(){j=function(){return n};var n={},e=Object.prototype,t=e.hasOwnProperty,r=Object.defineProperty||function(n,e,t){n[e]=t.value},o="function"==typeof Symbol?Symbol:{},a=o.iterator||"@@iterator",i=o.asyncIterator||"@@asyncIterator",v=o.toStringTag||"@@toStringTag";function c(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{c({},"")}catch(T){c=function(n,e,t){return n[e]=t}}function l(n,e,t,o){var a=e&&e.prototype instanceof f?e:f,i=Object.create(a.prototype),v=new M(o||[]);return r(i,"_invoke",{value:_(n,t,v)}),i}function s(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(T){return{type:"throw",arg:T}}}n.wrap=l;var u={};function f(){}function p(){}function d(){}var m={};c(m,a,(function(){return this}));var h=Object.getPrototypeOf,x=h&&h(h(z([])));x&&x!==e&&t.call(x,a)&&(m=x);var g=d.prototype=f.prototype=Object.create(m);function y(n){["next","throw","return"].forEach((function(e){c(n,e,(function(n){return this._invoke(e,n)}))}))}function b(n,e){function o(r,a,i,v){var c=s(n[r],n,a);if("throw"!==c.type){var l=c.arg,u=l.value;return u&&"object"==S(u)&&t.call(u,"__await")?e.resolve(u.__await).then((function(n){o("next",n,i,v)}),(function(n){o("throw",n,i,v)})):e.resolve(u).then((function(n){l.value=n,i(l)}),(function(n){return o("throw",n,i,v)}))}v(c.arg)}var a;r(this,"_invoke",{value:function(n,t){function r(){return new e((function(e,r){o(n,t,e,r)}))}return a=a?a.then(r,r):r()}})}function _(n,e,t){var r="suspendedStart";return function(o,a){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===o)throw a;return C()}for(t.method=o,t.arg=a;;){var i=t.delegate;if(i){var v=U(i,t);if(v){if(v===u)continue;return v}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===r)throw r="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);r="executing";var c=s(n,e,t);if("normal"===c.type){if(r=t.done?"completed":"suspendedYield",c.arg===u)continue;return{value:c.arg,done:t.done}}"throw"===c.type&&(r="completed",t.method="throw",t.arg=c.arg)}}}function U(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,U(n,e),"throw"===e.method))return u;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return u}var r=s(t,n.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,u;var o=r.arg;return o?o.done?(e[n.resultName]=o.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,u):o:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,u)}function w(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function k(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function M(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(w,this),this.reset(!0)}function z(n){if(n){var e=n[a];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,o=function e(){for(;++r<n.length;)if(t.call(n,r))return e.value=n[r],e.done=!1,e;return e.value=void 0,e.done=!0,e};return o.next=o}}return{next:C}}function C(){return{value:void 0,done:!0}}return p.prototype=d,r(g,"constructor",{value:d,configurable:!0}),r(d,"constructor",{value:p,configurable:!0}),p.displayName=c(d,v,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===p||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,d):(n.__proto__=d,c(n,v,"GeneratorFunction")),n.prototype=Object.create(g),n},n.awrap=function(n){return{__await:n}},y(b.prototype),c(b.prototype,i,(function(){return this})),n.AsyncIterator=b,n.async=function(e,t,r,o,a){void 0===a&&(a=Promise);var i=new b(l(e,t,r,o),a);return n.isGeneratorFunction(t)?i:i.next().then((function(n){return n.done?n.value:i.next()}))},y(g),c(g,v,"Generator"),c(g,a,(function(){return this})),c(g,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var e=Object(n),t=[];for(var r in e)t.push(r);return t.reverse(),function n(){for(;t.length;){var r=t.pop();if(r in e)return n.value=r,n.done=!1,n}return n.done=!0,n}},n.values=z,M.prototype={constructor:M,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(k),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function r(t,r){return i.type="throw",i.arg=n,e.next=t,r&&(e.method="next",e.arg=void 0),!!r}for(var o=this.tryEntries.length-1;o>=0;--o){var a=this.tryEntries[o],i=a.completion;if("root"===a.tryLoc)return r("end");if(a.tryLoc<=this.prev){var v=t.call(a,"catchLoc"),c=t.call(a,"finallyLoc");if(v&&c){if(this.prev<a.catchLoc)return r(a.catchLoc,!0);if(this.prev<a.finallyLoc)return r(a.finallyLoc)}else if(v){if(this.prev<a.catchLoc)return r(a.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return r(a.finallyLoc)}}}},abrupt:function(n,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&t.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var a=o;break}}a&&("break"===n||"continue"===n)&&a.tryLoc<=e&&e<=a.finallyLoc&&(a=null);var i=a?a.completion:{};return i.type=n,i.arg=e,a?(this.method="next",this.next=a.finallyLoc,u):this.complete(i)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),u},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),k(t),u}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var r=t.completion;if("throw"===r.type){var o=r.arg;k(t)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:z(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),u}},n}t.r(e),t.d(e,{ACESFilmicToneMapping:function(){return Pn},AddEquation:function(){return nn},AddOperation:function(){return zn},AdditiveAnimationBlendMode:function(){return ot},AdditiveBlending:function(){return Z},AlphaFormat:function(){return se},AlwaysDepth:function(){return gn},AlwaysStencilFunc:function(){return Pt},AmbientLight:function(){return Mf},AmbientLightProbe:function(){return Bf},AnimationClip:function(){return Yu},AnimationLoader:function(){return of},AnimationMixer:function(){return yp},AnimationObjectGroup:function(){return hp},AnimationUtils:function(){return Eu},ArcCurve:function(){return Kl},ArrayCamera:function(){return Mc},ArrowHelper:function(){return sd},Audio:function(){return np},AudioAnalyser:function(){return ip},AudioContext:function(){return Af},AudioListener:function(){return Qf},AudioLoader:function(){return Nf},AxesHelper:function(){return ud},BackSide:function(){return H},BasicDepthPacking:function(){return st},BasicShadowMap:function(){return G},Bone:function(){return dl},BooleanKeyframeTrack:function(){return Gu},Box2:function(){return Dp},Box3:function(){return Nr},Box3Helper:function(){return vd},BoxBufferGeometry:function(){return bd},BoxGeometry:function(){return Na},BoxHelper:function(){return id},BufferAttribute:function(){return ta},BufferGeometry:function(){return ba},BufferGeometryLoader:function(){return jf},ByteType:function(){return ne},Cache:function(){return Ku},Camera:function(){return Wa},CameraHelper:function(){return ed},CanvasTexture:function(){return Yl},CapsuleBufferGeometry:function(){return _d},CapsuleGeometry:function(){return gs},CatmullRomCurve3:function(){return rs},CineonToneMapping:function(){return Dn},CircleBufferGeometry:function(){return Ud},CircleGeometry:function(){return ys},ClampToEdgeWrapping:function(){return Gn},Clock:function(){return Xf},Color:function(){return wr},ColorKeyframeTrack:function(){return Bu},ColorManagement:function(){return mr},CompressedArrayTexture:function(){return Xl},CompressedTexture:function(){return Hl},CompressedTextureLoader:function(){return af},ConeBufferGeometry:function(){return wd},ConeGeometry:function(){return _s},CubeCamera:function(){return Ya},CubeReflectionMapping:function(){return En},CubeRefractionMapping:function(){return In},CubeTexture:function(){return $a},CubeTextureLoader:function(){return cf},CubeUVReflectionMapping:function(){return An},CubicBezierCurve:function(){return vs},CubicBezierCurve3:function(){return cs},CubicInterpolant:function(){return Ou},CullFaceBack:function(){return L},CullFaceFront:function(){return A},CullFaceFrontBack:function(){return N},CullFaceNone:function(){return O},Curve:function(){return $l},CurvePath:function(){return ms},CustomBlending:function(){return Q},CustomToneMapping:function(){return jn},CylinderBufferGeometry:function(){return Sd},CylinderGeometry:function(){return bs},Cylindrical:function(){return Tp},Data3DTexture:function(){return jr},DataArrayTexture:function(){return Dr},DataTexture:function(){return ml},DataTexture2DArray:function(){return gd},DataTexture3D:function(){return yd},DataTextureLoader:function(){return lf},DataUtils:function(){return md},DecrementStencilOp:function(){return _t},DecrementWrapStencilOp:function(){return wt},DefaultLoadingManager:function(){return Qu},DepthFormat:function(){return me},DepthStencilFormat:function(){return he},DepthTexture:function(){return Rc},DirectionalLight:function(){return kf},DirectionalLightHelper:function(){return Jp},DiscreteInterpolant:function(){return Au},DodecahedronBufferGeometry:function(){return kd},DodecahedronGeometry:function(){return ws},DoubleSide:function(){return X},DstAlphaFactor:function(){return fn},DstColorFactor:function(){return dn},DynamicCopyUsage:function(){return Nt},DynamicDrawUsage:function(){return Ft},DynamicReadUsage:function(){return Ot},EdgesGeometry:function(){return Cs},EllipseCurve:function(){return Zl},EqualDepth:function(){return _n},EqualStencilFunc:function(){return zt},EquirectangularReflectionMapping:function(){return On},EquirectangularRefractionMapping:function(){return Ln},Euler:function(){return So},EventDispatcher:function(){return Wt},ExtrudeBufferGeometry:function(){return Md},ExtrudeGeometry:function(){return au},FileLoader:function(){return rf},Float16BufferAttribute:function(){return sa},Float32BufferAttribute:function(){return ua},Float64BufferAttribute:function(){return fa},FloatType:function(){return ae},Fog:function(){return Ac},FogExp2:function(){return Lc},FramebufferTexture:function(){return Wl},FrontSide:function(){return W},Frustum:function(){return ri},GLBufferAttribute:function(){return Sp},GLSL1:function(){return Bt},GLSL3:function(){return qt},GreaterDepth:function(){return wn},GreaterEqualDepth:function(){return Un},GreaterEqualStencilFunc:function(){return Dt},GreaterStencilFunc:function(){return Tt},GridHelper:function(){return Xp},Group:function(){return zc},HalfFloatType:function(){return ie},HemisphereLight:function(){return ff},HemisphereLightHelper:function(){return Hp},HemisphereLightProbe:function(){return Gf},IcosahedronBufferGeometry:function(){return zd},IcosahedronGeometry:function(){return vu},ImageBitmapLoader:function(){return Lf},ImageLoader:function(){return vf},ImageUtils:function(){return Sr},ImmediateRenderObject:function(){return hd},IncrementStencilOp:function(){return bt},IncrementWrapStencilOp:function(){return Ut},InstancedBufferAttribute:function(){return yl},InstancedBufferGeometry:function(){return Pf},InstancedInterleavedBuffer:function(){return wp},InstancedMesh:function(){return kl},Int16BufferAttribute:function(){return ia},Int32BufferAttribute:function(){return ca},Int8BufferAttribute:function(){return ra},IntType:function(){return re},InterleavedBuffer:function(){return Gc},InterleavedBufferAttribute:function(){return qc},Interpolant:function(){return Iu},InterpolateDiscrete:function(){return Ke},InterpolateLinear:function(){return Je},InterpolateSmooth:function(){return Qe},InvertStencilOp:function(){return St},KeepStencilOp:function(){return gt},KeyframeTrack:function(){return Nu},LOD:function(){return vl},LatheBufferGeometry:function(){return Cd},LatheGeometry:function(){return xs},Layers:function(){return ko},LessDepth:function(){return yn},LessEqualDepth:function(){return bn},LessEqualStencilFunc:function(){return Ct},LessStencilFunc:function(){return Mt},Light:function(){return uf},LightProbe:function(){return Tf},Line:function(){return Pl},Line3:function(){return Fp},LineBasicMaterial:function(){return Ml},LineCurve:function(){return ls},LineCurve3:function(){return ss},LineDashedMaterial:function(){return Cu},LineLoop:function(){return Il},LineSegments:function(){return El},LinearEncoding:function(){return ct},LinearFilter:function(){return Yn},LinearInterpolant:function(){return Lu},LinearMipMapLinearFilter:function(){return Jn},LinearMipMapNearestFilter:function(){return Zn},LinearMipmapLinearFilter:function(){return Kn},LinearMipmapNearestFilter:function(){return $n},LinearSRGBColorSpace:function(){return ht},LinearToneMapping:function(){return Tn},Loader:function(){return nf},LoaderUtils:function(){return Df},LoadingManager:function(){return Ju},LoopOnce:function(){return Ye},LoopPingPong:function(){return Ze},LoopRepeat:function(){return $e},LuminanceAlphaFormat:function(){return de},LuminanceFormat:function(){return pe},MOUSE:function(){return E},Material:function(){return Jo},MaterialLoader:function(){return Rf},MathUtils:function(){return ar},Matrix3:function(){return vr},Matrix4:function(){return po},MaxEquation:function(){return on},Mesh:function(){return La},MeshBasicMaterial:function(){return Qo},MeshDepthMaterial:function(){return bc},MeshDistanceMaterial:function(){return _c},MeshLambertMaterial:function(){return Mu},MeshMatcapMaterial:function(){return zu},MeshNormalMaterial:function(){return ku},MeshPhongMaterial:function(){return wu},MeshPhysicalMaterial:function(){return Uu},MeshStandardMaterial:function(){return _u},MeshToonMaterial:function(){return Su},MinEquation:function(){return rn},MirroredRepeatWrapping:function(){return Bn},MixOperation:function(){return Mn},MultiplyBlending:function(){return J},MultiplyOperation:function(){return kn},NearestFilter:function(){return qn},NearestMipMapLinearFilter:function(){return Xn},NearestMipMapNearestFilter:function(){return Wn},NearestMipmapLinearFilter:function(){return Hn},NearestMipmapNearestFilter:function(){return Vn},NeverDepth:function(){return xn},NeverStencilFunc:function(){return kt},NoBlending:function(){return Y},NoColorSpace:function(){return dt},NoToneMapping:function(){return Cn},NormalAnimationBlendMode:function(){return rt},NormalBlending:function(){return $},NotEqualDepth:function(){return Sn},NotEqualStencilFunc:function(){return Rt},NumberKeyframeTrack:function(){return qu},Object3D:function(){return Ao},ObjectLoader:function(){return Ff},ObjectSpaceNormalMap:function(){return pt},OctahedronBufferGeometry:function(){return Td},OctahedronGeometry:function(){return cu},OneFactor:function(){return vn},OneMinusDstAlphaFactor:function(){return pn},OneMinusDstColorFactor:function(){return mn},OneMinusSrcAlphaFactor:function(){return un},OneMinusSrcColorFactor:function(){return ln},OrthographicCamera:function(){return hi},PCFShadowMap:function(){return B},PCFSoftShadowMap:function(){return q},PMREMGenerator:function(){return ki},Path:function(){return hs},PerspectiveCamera:function(){return Ha},Plane:function(){return ni},PlaneBufferGeometry:function(){return Rd},PlaneGeometry:function(){return ii},PlaneHelper:function(){return cd},PointLight:function(){return wf},PointLightHelper:function(){return Bp},Points:function(){return Bl},PointsMaterial:function(){return Ol},PolarGridHelper:function(){return Yp},PolyhedronBufferGeometry:function(){return Dd},PolyhedronGeometry:function(){return Us},PositionalAudio:function(){return ap},PropertyBinding:function(){return mp},PropertyMixer:function(){return vp},QuadraticBezierCurve:function(){return us},QuadraticBezierCurve3:function(){return fs},Quaternion:function(){return Ir},QuaternionKeyframeTrack:function(){return Wu},QuaternionLinearInterpolant:function(){return Vu},REVISION:function(){return F},RGBADepthPacking:function(){return ut},RGBAFormat:function(){return fe},RGBAIntegerFormat:function(){return _e},RGBA_ASTC_10x10_Format:function(){return Ve},RGBA_ASTC_10x5_Format:function(){return Ge},RGBA_ASTC_10x6_Format:function(){return Be},RGBA_ASTC_10x8_Format:function(){return qe},RGBA_ASTC_12x10_Format:function(){return We},RGBA_ASTC_12x12_Format:function(){return He},RGBA_ASTC_4x4_Format:function(){return je},RGBA_ASTC_5x4_Format:function(){return Fe},RGBA_ASTC_5x5_Format:function(){return Ee},RGBA_ASTC_6x5_Format:function(){return Ie},RGBA_ASTC_6x6_Format:function(){return Oe},RGBA_ASTC_8x5_Format:function(){return Le},RGBA_ASTC_8x6_Format:function(){return Ae},RGBA_ASTC_8x8_Format:function(){return Ne},RGBA_BPTC_Format:function(){return Xe},RGBA_ETC2_EAC_Format:function(){return Pe},RGBA_PVRTC_2BPPV1_Format:function(){return Te},RGBA_PVRTC_4BPPV1_Format:function(){return Ce},RGBA_S3TC_DXT1_Format:function(){return we},RGBA_S3TC_DXT3_Format:function(){return Se},RGBA_S3TC_DXT5_Format:function(){return ke},RGBFormat:function(){return ue},RGB_ETC1_Format:function(){return Re},RGB_ETC2_Format:function(){return De},RGB_PVRTC_2BPPV1_Format:function(){return ze},RGB_PVRTC_4BPPV1_Format:function(){return Me},RGB_S3TC_DXT1_Format:function(){return Ue},RGFormat:function(){return ye},RGIntegerFormat:function(){return be},RawShaderMaterial:function(){return bu},Ray:function(){return fo},Raycaster:function(){return kp},RectAreaLight:function(){return zf},RedFormat:function(){return xe},RedIntegerFormat:function(){return ge},ReinhardToneMapping:function(){return Rn},RepeatWrapping:function(){return Nn},ReplaceStencilOp:function(){return yt},ReverseSubtractEquation:function(){return tn},RingBufferGeometry:function(){return Pd},RingGeometry:function(){return lu},SRGBColorSpace:function(){return mt},Scene:function(){return Nc},ShaderChunk:function(){return vi},ShaderLib:function(){return li},ShaderMaterial:function(){return Va},ShadowMaterial:function(){return yu},Shape:function(){return Ts},ShapeBufferGeometry:function(){return jd},ShapeGeometry:function(){return su},ShapePath:function(){return fd},ShapeUtils:function(){return tu},ShortType:function(){return ee},Skeleton:function(){return gl},SkeletonHelper:function(){return Np},SkinnedMesh:function(){return pl},Source:function(){return kr},Sphere:function(){return oo},SphereBufferGeometry:function(){return Fd},SphereGeometry:function(){return uu},Spherical:function(){return Cp},SphericalHarmonics3:function(){return Cf},SplineCurve:function(){return ps},SpotLight:function(){return gf},SpotLightHelper:function(){return Ip},Sprite:function(){return rl},SpriteMaterial:function(){return Vc},SrcAlphaFactor:function(){return sn},SrcAlphaSaturateFactor:function(){return hn},SrcColorFactor:function(){return cn},StaticCopyUsage:function(){return At},StaticDrawUsage:function(){return jt},StaticReadUsage:function(){return It},StereoCamera:function(){return Hf},StreamCopyUsage:function(){return Gt},StreamDrawUsage:function(){return Et},StreamReadUsage:function(){return Lt},StringKeyframeTrack:function(){return Hu},SubtractEquation:function(){return en},SubtractiveBlending:function(){return K},TOUCH:function(){return I},TangentSpaceNormalMap:function(){return ft},TetrahedronBufferGeometry:function(){return Ed},TetrahedronGeometry:function(){return fu},Texture:function(){return Cr},TextureLoader:function(){return sf},TorusBufferGeometry:function(){return Id},TorusGeometry:function(){return pu},TorusKnotBufferGeometry:function(){return Od},TorusKnotGeometry:function(){return du},Triangle:function(){return Zo},TriangleFanDrawMode:function(){return vt},TriangleStripDrawMode:function(){return it},TrianglesDrawMode:function(){return at},TubeBufferGeometry:function(){return Ld},TubeGeometry:function(){return mu},UVMapping:function(){return Fn},Uint16BufferAttribute:function(){return va},Uint32BufferAttribute:function(){return la},Uint8BufferAttribute:function(){return oa},Uint8ClampedBufferAttribute:function(){return aa},Uniform:function(){return bp},UniformsGroup:function(){return Up},UniformsLib:function(){return ci},UniformsUtils:function(){return qa},UnsignedByteType:function(){return Qn},UnsignedInt248Type:function(){return le},UnsignedIntType:function(){return oe},UnsignedShort4444Type:function(){return ve},UnsignedShort5551Type:function(){return ce},UnsignedShortType:function(){return te},VSMShadowMap:function(){return V},Vector2:function(){return ir},Vector3:function(){return Or},Vector4:function(){return Tr},VectorKeyframeTrack:function(){return Xu},VideoTexture:function(){return Vl},WebGL1Renderer:function(){return Ic},WebGL3DRenderTarget:function(){return Fr},WebGLArrayRenderTarget:function(){return Pr},WebGLCubeRenderTarget:function(){return Za},WebGLMultipleRenderTargets:function(){return Er},WebGLMultisampleRenderTarget:function(){return xd},WebGLRenderTarget:function(){return Rr},WebGLRenderer:function(){return Ec},WebGLUtils:function(){return kc},WireframeGeometry:function(){return hu},WrapAroundEnding:function(){return tt},ZeroCurvatureEnding:function(){return nt},ZeroFactor:function(){return an},ZeroSlopeEnding:function(){return et},ZeroStencilOp:function(){return xt},_SRGBAFormat:function(){return Vt},sRGBEncoding:function(){return lt}});var F="146",E={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},I={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},O=0,L=1,A=2,N=3,G=0,B=1,q=2,V=3,W=0,H=1,X=2,Y=0,$=1,Z=2,K=3,J=4,Q=5,nn=100,en=101,tn=102,rn=103,on=104,an=200,vn=201,cn=202,ln=203,sn=204,un=205,fn=206,pn=207,dn=208,mn=209,hn=210,xn=0,gn=1,yn=2,bn=3,_n=4,Un=5,wn=6,Sn=7,kn=0,Mn=1,zn=2,Cn=0,Tn=1,Rn=2,Dn=3,Pn=4,jn=5,Fn=300,En=301,In=302,On=303,Ln=304,An=306,Nn=1e3,Gn=1001,Bn=1002,qn=1003,Vn=1004,Wn=1004,Hn=1005,Xn=1005,Yn=1006,$n=1007,Zn=1007,Kn=1008,Jn=1008,Qn=1009,ne=1010,ee=1011,te=1012,re=1013,oe=1014,ae=1015,ie=1016,ve=1017,ce=1018,le=1020,se=1021,ue=1022,fe=1023,pe=1024,de=1025,me=1026,he=1027,xe=1028,ge=1029,ye=1030,be=1031,_e=1033,Ue=33776,we=33777,Se=33778,ke=33779,Me=35840,ze=35841,Ce=35842,Te=35843,Re=36196,De=37492,Pe=37496,je=37808,Fe=37809,Ee=37810,Ie=37811,Oe=37812,Le=37813,Ae=37814,Ne=37815,Ge=37816,Be=37817,qe=37818,Ve=37819,We=37820,He=37821,Xe=36492,Ye=2200,$e=2201,Ze=2202,Ke=2300,Je=2301,Qe=2302,nt=2400,et=2401,tt=2402,rt=2500,ot=2501,at=0,it=1,vt=2,ct=3e3,lt=3001,st=3200,ut=3201,ft=0,pt=1,dt="",mt="srgb",ht="srgb-linear",xt=0,gt=7680,yt=7681,bt=7682,_t=7683,Ut=34055,wt=34056,St=5386,kt=512,Mt=513,zt=514,Ct=515,Tt=516,Rt=517,Dt=518,Pt=519,jt=35044,Ft=35048,Et=35040,It=35045,Ot=35049,Lt=35041,At=35046,Nt=35050,Gt=35042,Bt="100",qt="300 es",Vt=1035,Wt=function(){function n(){y(this,n)}return _(n,[{key:"addEventListener",value:function(n,e){void 0===this._listeners&&(this._listeners={});var t=this._listeners;void 0===t[n]&&(t[n]=[]),-1===t[n].indexOf(e)&&t[n].push(e)}},{key:"hasEventListener",value:function(n,e){if(void 0===this._listeners)return!1;var t=this._listeners;return void 0!==t[n]&&-1!==t[n].indexOf(e)}},{key:"removeEventListener",value:function(n,e){if(void 0!==this._listeners){var t=this._listeners[n];if(void 0!==t){var r=t.indexOf(e);-1!==r&&t.splice(r,1)}}}},{key:"dispatchEvent",value:function(n){if(void 0!==this._listeners){var e=this._listeners[n.type];if(void 0!==e){n.target=this;for(var t=e.slice(0),r=0,o=t.length;r<o;r++)t[r].call(this,n);n.target=null}}}}]),n}(),Ht=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"],Xt=1234567,Yt=Math.PI/180,$t=180/Math.PI;function Zt(){var n=4294967295*Math.random()|0,e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(Ht[255&n]+Ht[n>>8&255]+Ht[n>>16&255]+Ht[n>>24&255]+"-"+Ht[255&e]+Ht[e>>8&255]+"-"+Ht[e>>16&15|64]+Ht[e>>24&255]+"-"+Ht[63&t|128]+Ht[t>>8&255]+"-"+Ht[t>>16&255]+Ht[t>>24&255]+Ht[255&r]+Ht[r>>8&255]+Ht[r>>16&255]+Ht[r>>24&255]).toLowerCase()}function Kt(n,e,t){return Math.max(e,Math.min(t,n))}function Jt(n,e){return(n%e+e)%e}function Qt(n,e,t){return(1-t)*n+t*e}function nr(n){return 0===(n&n-1)&&0!==n}function er(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function tr(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function rr(n,e){switch(e.constructor){case Float32Array:return n;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function or(n,e){switch(e.constructor){case Float32Array:return n;case Uint16Array:return Math.round(65535*n);case Uint8Array:return Math.round(255*n);case Int16Array:return Math.round(32767*n);case Int8Array:return Math.round(127*n);default:throw new Error("Invalid component type.")}}var ar=Object.freeze({__proto__:null,DEG2RAD:Yt,RAD2DEG:$t,generateUUID:Zt,clamp:Kt,euclideanModulo:Jt,mapLinear:function(n,e,t,r,o){return r+(n-e)*(o-r)/(t-e)},inverseLerp:function(n,e,t){return n!==e?(t-n)/(e-n):0},lerp:Qt,damp:function(n,e,t,r){return Qt(n,e,1-Math.exp(-t*r))},pingpong:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return e-Math.abs(Jt(n,2*e)-e)},smoothstep:function(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e))*n*(3-2*n)},smootherstep:function(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e))*n*n*(n*(6*n-15)+10)},randInt:function(n,e){return n+Math.floor(Math.random()*(e-n+1))},randFloat:function(n,e){return n+Math.random()*(e-n)},randFloatSpread:function(n){return n*(.5-Math.random())},seededRandom:function(n){void 0!==n&&(Xt=n);var e=Xt+=1831565813;return e=Math.imul(e^e>>>15,1|e),(((e^=e+Math.imul(e^e>>>7,61|e))^e>>>14)>>>0)/4294967296},degToRad:function(n){return n*Yt},radToDeg:function(n){return n*$t},isPowerOfTwo:nr,ceilPowerOfTwo:er,floorPowerOfTwo:tr,setQuaternionFromProperEuler:function(n,e,t,r,o){var a=Math.cos,i=Math.sin,v=a(t/2),c=i(t/2),l=a((e+r)/2),s=i((e+r)/2),u=a((e-r)/2),f=i((e-r)/2),p=a((r-e)/2),d=i((r-e)/2);switch(o){case"XYX":n.set(v*s,c*u,c*f,v*l);break;case"YZY":n.set(c*f,v*s,c*u,v*l);break;case"ZXZ":n.set(c*u,c*f,v*s,v*l);break;case"XZX":n.set(v*s,c*d,c*p,v*l);break;case"YXY":n.set(c*p,v*s,c*d,v*l);break;case"ZYZ":n.set(c*d,c*p,v*s,v*l);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+o)}},normalize:or,denormalize:rr}),ir=function(n){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;y(this,e),e.prototype.isVector2=!0,this.x=n,this.y=t}return _(e,[{key:"width",get:function(){return this.x},set:function(n){this.x=n}},{key:"height",get:function(){return this.y},set:function(n){this.y=n}},{key:"set",value:function(n,e){return this.x=n,this.y=e,this}},{key:"setScalar",value:function(n){return this.x=n,this.y=n,this}},{key:"setX",value:function(n){return this.x=n,this}},{key:"setY",value:function(n){return this.y=n,this}},{key:"setComponent",value:function(n,e){switch(n){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+n)}return this}},{key:"getComponent",value:function(n){switch(n){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+n)}}},{key:"clone",value:function(){return new this.constructor(this.x,this.y)}},{key:"copy",value:function(n){return this.x=n.x,this.y=n.y,this}},{key:"add",value:function(n){return this.x+=n.x,this.y+=n.y,this}},{key:"addScalar",value:function(n){return this.x+=n,this.y+=n,this}},{key:"addVectors",value:function(n,e){return this.x=n.x+e.x,this.y=n.y+e.y,this}},{key:"addScaledVector",value:function(n,e){return this.x+=n.x*e,this.y+=n.y*e,this}},{key:"sub",value:function(n){return this.x-=n.x,this.y-=n.y,this}},{key:"subScalar",value:function(n){return this.x-=n,this.y-=n,this}},{key:"subVectors",value:function(n,e){return this.x=n.x-e.x,this.y=n.y-e.y,this}},{key:"multiply",value:function(n){return this.x*=n.x,this.y*=n.y,this}},{key:"multiplyScalar",value:function(n){return this.x*=n,this.y*=n,this}},{key:"divide",value:function(n){return this.x/=n.x,this.y/=n.y,this}},{key:"divideScalar",value:function(n){return this.multiplyScalar(1/n)}},{key:"applyMatrix3",value:function(n){var e=this.x,t=this.y,r=n.elements;return this.x=r[0]*e+r[3]*t+r[6],this.y=r[1]*e+r[4]*t+r[7],this}},{key:"min",value:function(n){return this.x=Math.min(this.x,n.x),this.y=Math.min(this.y,n.y),this}},{key:"max",value:function(n){return this.x=Math.max(this.x,n.x),this.y=Math.max(this.y,n.y),this}},{key:"clamp",value:function(n,e){return this.x=Math.max(n.x,Math.min(e.x,this.x)),this.y=Math.max(n.y,Math.min(e.y,this.y)),this}},{key:"clampScalar",value:function(n,e){return this.x=Math.max(n,Math.min(e,this.x)),this.y=Math.max(n,Math.min(e,this.y)),this}},{key:"clampLength",value:function(n,e){var t=this.length();return this.divideScalar(t||1).multiplyScalar(Math.max(n,Math.min(e,t)))}},{key:"floor",value:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}},{key:"ceil",value:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}},{key:"round",value:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}},{key:"roundToZero",value:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}},{key:"negate",value:function(){return this.x=-this.x,this.y=-this.y,this}},{key:"dot",value:function(n){return this.x*n.x+this.y*n.y}},{key:"cross",value:function(n){return this.x*n.y-this.y*n.x}},{key:"lengthSq",value:function(){return this.x*this.x+this.y*this.y}},{key:"length",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y)}},{key:"manhattanLength",value:function(){return Math.abs(this.x)+Math.abs(this.y)}},{key:"normalize",value:function(){return this.divideScalar(this.length()||1)}},{key:"angle",value:function(){var n=Math.atan2(-this.y,-this.x)+Math.PI;return n}},{key:"distanceTo",value:function(n){return Math.sqrt(this.distanceToSquared(n))}},{key:"distanceToSquared",value:function(n){var e=this.x-n.x,t=this.y-n.y;return e*e+t*t}},{key:"manhattanDistanceTo",value:function(n){return Math.abs(this.x-n.x)+Math.abs(this.y-n.y)}},{key:"setLength",value:function(n){return this.normalize().multiplyScalar(n)}},{key:"lerp",value:function(n,e){return this.x+=(n.x-this.x)*e,this.y+=(n.y-this.y)*e,this}},{key:"lerpVectors",value:function(n,e,t){return this.x=n.x+(e.x-n.x)*t,this.y=n.y+(e.y-n.y)*t,this}},{key:"equals",value:function(n){return n.x===this.x&&n.y===this.y}},{key:"fromArray",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=n[e],this.y=n[e+1],this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this.x,n[e+1]=this.y,n}},{key:"fromBufferAttribute",value:function(n,e){return this.x=n.getX(e),this.y=n.getY(e),this}},{key:"rotateAround",value:function(n,e){var t=Math.cos(e),r=Math.sin(e),o=this.x-n.x,a=this.y-n.y;return this.x=o*t-a*r+n.x,this.y=o*r+a*t+n.y,this}},{key:"random",value:function(){return this.x=Math.random(),this.y=Math.random(),this}},{key:Symbol.iterator,value:j().mark((function n(){return j().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this.x;case 2:return n.next=4,this.y;case 4:case"end":return n.stop()}}),n,this)}))}]),e}(),vr=function(){function n(){y(this,n),n.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}return _(n,[{key:"set",value:function(n,e,t,r,o,a,i,v,c){var l=this.elements;return l[0]=n,l[1]=r,l[2]=i,l[3]=e,l[4]=o,l[5]=v,l[6]=t,l[7]=a,l[8]=c,this}},{key:"identity",value:function(){return this.set(1,0,0,0,1,0,0,0,1),this}},{key:"copy",value:function(n){var e=this.elements,t=n.elements;return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],this}},{key:"extractBasis",value:function(n,e,t){return n.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),t.setFromMatrix3Column(this,2),this}},{key:"setFromMatrix4",value:function(n){var e=n.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}},{key:"multiply",value:function(n){return this.multiplyMatrices(this,n)}},{key:"premultiply",value:function(n){return this.multiplyMatrices(n,this)}},{key:"multiplyMatrices",value:function(n,e){var t=n.elements,r=e.elements,o=this.elements,a=t[0],i=t[3],v=t[6],c=t[1],l=t[4],s=t[7],u=t[2],f=t[5],p=t[8],d=r[0],m=r[3],h=r[6],x=r[1],g=r[4],y=r[7],b=r[2],_=r[5],U=r[8];return o[0]=a*d+i*x+v*b,o[3]=a*m+i*g+v*_,o[6]=a*h+i*y+v*U,o[1]=c*d+l*x+s*b,o[4]=c*m+l*g+s*_,o[7]=c*h+l*y+s*U,o[2]=u*d+f*x+p*b,o[5]=u*m+f*g+p*_,o[8]=u*h+f*y+p*U,this}},{key:"multiplyScalar",value:function(n){var e=this.elements;return e[0]*=n,e[3]*=n,e[6]*=n,e[1]*=n,e[4]*=n,e[7]*=n,e[2]*=n,e[5]*=n,e[8]*=n,this}},{key:"determinant",value:function(){var n=this.elements,e=n[0],t=n[1],r=n[2],o=n[3],a=n[4],i=n[5],v=n[6],c=n[7],l=n[8];return e*a*l-e*i*c-t*o*l+t*i*v+r*o*c-r*a*v}},{key:"invert",value:function(){var n=this.elements,e=n[0],t=n[1],r=n[2],o=n[3],a=n[4],i=n[5],v=n[6],c=n[7],l=n[8],s=l*a-i*c,u=i*v-l*o,f=c*o-a*v,p=e*s+t*u+r*f;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);var d=1/p;return n[0]=s*d,n[1]=(r*c-l*t)*d,n[2]=(i*t-r*a)*d,n[3]=u*d,n[4]=(l*e-r*v)*d,n[5]=(r*o-i*e)*d,n[6]=f*d,n[7]=(t*v-c*e)*d,n[8]=(a*e-t*o)*d,this}},{key:"transpose",value:function(){var n,e=this.elements;return n=e[1],e[1]=e[3],e[3]=n,n=e[2],e[2]=e[6],e[6]=n,n=e[5],e[5]=e[7],e[7]=n,this}},{key:"getNormalMatrix",value:function(n){return this.setFromMatrix4(n).invert().transpose()}},{key:"transposeIntoArray",value:function(n){var e=this.elements;return n[0]=e[0],n[1]=e[3],n[2]=e[6],n[3]=e[1],n[4]=e[4],n[5]=e[7],n[6]=e[2],n[7]=e[5],n[8]=e[8],this}},{key:"setUvTransform",value:function(n,e,t,r,o,a,i){var v=Math.cos(o),c=Math.sin(o);return this.set(t*v,t*c,-t*(v*a+c*i)+a+n,-r*c,r*v,-r*(-c*a+v*i)+i+e,0,0,1),this}},{key:"scale",value:function(n,e){var t=this.elements;return t[0]*=n,t[3]*=n,t[6]*=n,t[1]*=e,t[4]*=e,t[7]*=e,this}},{key:"rotate",value:function(n){var e=Math.cos(n),t=Math.sin(n),r=this.elements,o=r[0],a=r[3],i=r[6],v=r[1],c=r[4],l=r[7];return r[0]=e*o+t*v,r[3]=e*a+t*c,r[6]=e*i+t*l,r[1]=-t*o+e*v,r[4]=-t*a+e*c,r[7]=-t*i+e*l,this}},{key:"translate",value:function(n,e){var t=this.elements;return t[0]+=n*t[2],t[3]+=n*t[5],t[6]+=n*t[8],t[1]+=e*t[2],t[4]+=e*t[5],t[7]+=e*t[8],this}},{key:"equals",value:function(n){for(var e=this.elements,t=n.elements,r=0;r<9;r++)if(e[r]!==t[r])return!1;return!0}},{key:"fromArray",value:function(n){for(var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=0;t<9;t++)this.elements[t]=n[t+e];return this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=this.elements;return n[e]=t[0],n[e+1]=t[1],n[e+2]=t[2],n[e+3]=t[3],n[e+4]=t[4],n[e+5]=t[5],n[e+6]=t[6],n[e+7]=t[7],n[e+8]=t[8],n}},{key:"clone",value:function(){return(new this.constructor).fromArray(this.elements)}}]),n}();function cr(n){for(var e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}var lr={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function sr(n,e){return new lr[n](e)}function ur(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function fr(n){return n<.04045?.0773993808*n:Math.pow(.9478672986*n+.0521327014,2.4)}function pr(n){return n<.0031308?12.92*n:1.055*Math.pow(n,.41666)-.055}var dr=(l(n={},mt,l({},ht,fr)),l(n,ht,l({},mt,pr)),n),mr={legacyMode:!0,get workingColorSpace(){return ht},set workingColorSpace(n){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(n,e,t){if(this.legacyMode||e===t||!e||!t)return n;if(dr[e]&&void 0!==dr[e][t]){var r=dr[e][t];return n.r=r(n.r),n.g=r(n.g),n.b=r(n.b),n}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(n,e){return this.convert(n,this.workingColorSpace,e)},toWorkingColorSpace:function(n,e){return this.convert(n,e,this.workingColorSpace)}},hr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},xr={r:0,g:0,b:0},gr={h:0,s:0,l:0},yr={h:0,s:0,l:0};function br(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+6*(e-n)*t:t<.5?e:t<2/3?n+6*(e-n)*(2/3-t):n}function _r(n,e){return e.r=n.r,e.g=n.g,e.b=n.b,e}var Ur,wr=function(n){function e(n,t,r){return y(this,e),this.isColor=!0,this.r=1,this.g=1,this.b=1,void 0===t&&void 0===r?this.set(n):this.setRGB(n,t,r)}return _(e,[{key:"set",value:function(n){return n&&n.isColor?this.copy(n):"number"===typeof n?this.setHex(n):"string"===typeof n&&this.setStyle(n),this}},{key:"setScalar",value:function(n){return this.r=n,this.g=n,this.b=n,this}},{key:"setHex",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:mt;return n=Math.floor(n),this.r=(n>>16&255)/255,this.g=(n>>8&255)/255,this.b=(255&n)/255,mr.toWorkingColorSpace(this,e),this}},{key:"setRGB",value:function(n,e,t){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:ht;return this.r=n,this.g=e,this.b=t,mr.toWorkingColorSpace(this,r),this}},{key:"setHSL",value:function(n,e,t){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:ht;if(n=Jt(n,1),e=Kt(e,0,1),t=Kt(t,0,1),0===e)this.r=this.g=this.b=t;else{var o=t<=.5?t*(1+e):t+e-t*e,a=2*t-o;this.r=br(a,o,n+1/3),this.g=br(a,o,n),this.b=br(a,o,n-1/3)}return mr.toWorkingColorSpace(this,r),this}},{key:"setStyle",value:function(n){var e,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:mt;function r(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+n+" will be ignored.")}if(e=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(n)){var o,a=e[1],i=e[2];switch(a){case"rgb":case"rgba":if(o=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))return this.r=Math.min(255,parseInt(o[1],10))/255,this.g=Math.min(255,parseInt(o[2],10))/255,this.b=Math.min(255,parseInt(o[3],10))/255,mr.toWorkingColorSpace(this,t),r(o[4]),this;if(o=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))return this.r=Math.min(100,parseInt(o[1],10))/100,this.g=Math.min(100,parseInt(o[2],10))/100,this.b=Math.min(100,parseInt(o[3],10))/100,mr.toWorkingColorSpace(this,t),r(o[4]),this;break;case"hsl":case"hsla":if(o=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)){var v=parseFloat(o[1])/360,c=parseFloat(o[2])/100,l=parseFloat(o[3])/100;return r(o[4]),this.setHSL(v,c,l,t)}}}else if(e=/^\#([A-Fa-f\d]+)$/.exec(n)){var s=e[1],u=s.length;if(3===u)return this.r=parseInt(s.charAt(0)+s.charAt(0),16)/255,this.g=parseInt(s.charAt(1)+s.charAt(1),16)/255,this.b=parseInt(s.charAt(2)+s.charAt(2),16)/255,mr.toWorkingColorSpace(this,t),this;if(6===u)return this.r=parseInt(s.charAt(0)+s.charAt(1),16)/255,this.g=parseInt(s.charAt(2)+s.charAt(3),16)/255,this.b=parseInt(s.charAt(4)+s.charAt(5),16)/255,mr.toWorkingColorSpace(this,t),this}return n&&n.length>0?this.setColorName(n,t):this}},{key:"setColorName",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:mt,t=hr[n.toLowerCase()];return void 0!==t?this.setHex(t,e):console.warn("THREE.Color: Unknown color "+n),this}},{key:"clone",value:function(){return new this.constructor(this.r,this.g,this.b)}},{key:"copy",value:function(n){return this.r=n.r,this.g=n.g,this.b=n.b,this}},{key:"copySRGBToLinear",value:function(n){return this.r=fr(n.r),this.g=fr(n.g),this.b=fr(n.b),this}},{key:"copyLinearToSRGB",value:function(n){return this.r=pr(n.r),this.g=pr(n.g),this.b=pr(n.b),this}},{key:"convertSRGBToLinear",value:function(){return this.copySRGBToLinear(this),this}},{key:"convertLinearToSRGB",value:function(){return this.copyLinearToSRGB(this),this}},{key:"getHex",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:mt;return mr.fromWorkingColorSpace(_r(this,xr),n),Kt(255*xr.r,0,255)<<16^Kt(255*xr.g,0,255)<<8^Kt(255*xr.b,0,255)<<0}},{key:"getHexString",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:mt;return("000000"+this.getHex(n).toString(16)).slice(-6)}},{key:"getHSL",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ht;mr.fromWorkingColorSpace(_r(this,xr),e);var t,r,o=xr.r,a=xr.g,i=xr.b,v=Math.max(o,a,i),c=Math.min(o,a,i),l=(c+v)/2;if(c===v)t=0,r=0;else{var s=v-c;switch(r=l<=.5?s/(v+c):s/(2-v-c),v){case o:t=(a-i)/s+(a<i?6:0);break;case a:t=(i-o)/s+2;break;case i:t=(o-a)/s+4}t/=6}return n.h=t,n.s=r,n.l=l,n}},{key:"getRGB",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ht;return mr.fromWorkingColorSpace(_r(this,xr),e),n.r=xr.r,n.g=xr.g,n.b=xr.b,n}},{key:"getStyle",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:mt;return mr.fromWorkingColorSpace(_r(this,xr),n),n!==mt?"color(".concat(n," ").concat(xr.r," ").concat(xr.g," ").concat(xr.b,")"):"rgb(".concat(255*xr.r|0,",").concat(255*xr.g|0,",").concat(255*xr.b|0,")")}},{key:"offsetHSL",value:function(n,e,t){return this.getHSL(gr),gr.h+=n,gr.s+=e,gr.l+=t,this.setHSL(gr.h,gr.s,gr.l),this}},{key:"add",value:function(n){return this.r+=n.r,this.g+=n.g,this.b+=n.b,this}},{key:"addColors",value:function(n,e){return this.r=n.r+e.r,this.g=n.g+e.g,this.b=n.b+e.b,this}},{key:"addScalar",value:function(n){return this.r+=n,this.g+=n,this.b+=n,this}},{key:"sub",value:function(n){return this.r=Math.max(0,this.r-n.r),this.g=Math.max(0,this.g-n.g),this.b=Math.max(0,this.b-n.b),this}},{key:"multiply",value:function(n){return this.r*=n.r,this.g*=n.g,this.b*=n.b,this}},{key:"multiplyScalar",value:function(n){return this.r*=n,this.g*=n,this.b*=n,this}},{key:"lerp",value:function(n,e){return this.r+=(n.r-this.r)*e,this.g+=(n.g-this.g)*e,this.b+=(n.b-this.b)*e,this}},{key:"lerpColors",value:function(n,e,t){return this.r=n.r+(e.r-n.r)*t,this.g=n.g+(e.g-n.g)*t,this.b=n.b+(e.b-n.b)*t,this}},{key:"lerpHSL",value:function(n,e){this.getHSL(gr),n.getHSL(yr);var t=Qt(gr.h,yr.h,e),r=Qt(gr.s,yr.s,e),o=Qt(gr.l,yr.l,e);return this.setHSL(t,r,o),this}},{key:"equals",value:function(n){return n.r===this.r&&n.g===this.g&&n.b===this.b}},{key:"fromArray",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=n[e],this.g=n[e+1],this.b=n[e+2],this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this.r,n[e+1]=this.g,n[e+2]=this.b,n}},{key:"fromBufferAttribute",value:function(n,e){return this.r=n.getX(e),this.g=n.getY(e),this.b=n.getZ(e),this}},{key:"toJSON",value:function(){return this.getHex()}},{key:Symbol.iterator,value:j().mark((function n(){return j().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this.r;case 2:return n.next=4,this.g;case 4:return n.next=6,this.b;case 6:case"end":return n.stop()}}),n,this)}))}]),e}();wr.NAMES=hr;var Sr=function(){function n(){y(this,n)}return _(n,null,[{key:"getDataURL",value:function(n){if(/^data:/i.test(n.src))return n.src;if("undefined"==typeof HTMLCanvasElement)return n.src;var e;if(n instanceof HTMLCanvasElement)e=n;else{void 0===Ur&&(Ur=ur("canvas")),Ur.width=n.width,Ur.height=n.height;var t=Ur.getContext("2d");n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0,n.width,n.height),e=Ur}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",n),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}},{key:"sRGBToLinear",value:function(n){if("undefined"!==typeof HTMLImageElement&&n instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&n instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&n instanceof ImageBitmap){var e=ur("canvas");e.width=n.width,e.height=n.height;var t=e.getContext("2d");t.drawImage(n,0,0,n.width,n.height);for(var r=t.getImageData(0,0,n.width,n.height),o=r.data,a=0;a<o.length;a++)o[a]=255*fr(o[a]/255);return t.putImageData(r,0,0),e}if(n.data){for(var i=n.data.slice(0),v=0;v<i.length;v++)i instanceof Uint8Array||i instanceof Uint8ClampedArray?i[v]=Math.floor(255*fr(i[v]/255)):i[v]=fr(i[v]);return{data:i,width:n.width,height:n.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),n}}]),n}(),kr=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;y(this,n),this.isSource=!0,this.uuid=Zt(),this.data=e,this.version=0}return _(n,[{key:"needsUpdate",set:function(n){!0===n&&this.version++}},{key:"toJSON",value:function(n){var e=void 0===n||"string"===typeof n;if(!e&&void 0!==n.images[this.uuid])return n.images[this.uuid];var t={uuid:this.uuid,url:""},r=this.data;if(null!==r){var o;if(Array.isArray(r)){o=[];for(var a=0,i=r.length;a<i;a++)r[a].isDataTexture?o.push(Mr(r[a].image)):o.push(Mr(r[a]))}else o=Mr(r);t.url=o}return e||(n.images[this.uuid]=t),t}}]),n}();function Mr(n){return"undefined"!==typeof HTMLImageElement&&n instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&n instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&n instanceof ImageBitmap?Sr.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}var zr=0,Cr=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.DEFAULT_IMAGE,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.DEFAULT_MAPPING,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Gn,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Gn,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Yn,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:Kn,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:fe,s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:Qn,u=arguments.length>8&&void 0!==arguments[8]?arguments[8]:1,f=arguments.length>9&&void 0!==arguments[9]?arguments[9]:ct;return y(this,t),(n=e.call(this)).isTexture=!0,Object.defineProperty(k(n),"id",{value:zr++}),n.uuid=Zt(),n.name="",n.source=new kr(r),n.mipmaps=[],n.mapping=o,n.wrapS=a,n.wrapT=i,n.magFilter=v,n.minFilter=c,n.anisotropy=u,n.format=l,n.internalFormat=null,n.type=s,n.offset=new ir(0,0),n.repeat=new ir(1,1),n.center=new ir(0,0),n.rotation=0,n.matrixAutoUpdate=!0,n.matrix=new vr,n.generateMipmaps=!0,n.premultiplyAlpha=!1,n.flipY=!0,n.unpackAlignment=4,n.encoding=f,n.userData={},n.version=0,n.onUpdate=null,n.isRenderTargetTexture=!1,n.needsPMREMUpdate=!1,n}return _(t,[{key:"image",get:function(){return this.source.data},set:function(n){this.source.data=n}},{key:"updateMatrix",value:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){return this.name=n.name,this.source=n.source,this.mipmaps=n.mipmaps.slice(0),this.mapping=n.mapping,this.wrapS=n.wrapS,this.wrapT=n.wrapT,this.magFilter=n.magFilter,this.minFilter=n.minFilter,this.anisotropy=n.anisotropy,this.format=n.format,this.internalFormat=n.internalFormat,this.type=n.type,this.offset.copy(n.offset),this.repeat.copy(n.repeat),this.center.copy(n.center),this.rotation=n.rotation,this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrix.copy(n.matrix),this.generateMipmaps=n.generateMipmaps,this.premultiplyAlpha=n.premultiplyAlpha,this.flipY=n.flipY,this.unpackAlignment=n.unpackAlignment,this.encoding=n.encoding,this.userData=JSON.parse(JSON.stringify(n.userData)),this.needsUpdate=!0,this}},{key:"toJSON",value:function(n){var e=void 0===n||"string"===typeof n;if(!e&&void 0!==n.textures[this.uuid])return n.textures[this.uuid];var t={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(n).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return"{}"!==JSON.stringify(this.userData)&&(t.userData=this.userData),e||(n.textures[this.uuid]=t),t}},{key:"dispose",value:function(){this.dispatchEvent({type:"dispose"})}},{key:"transformUv",value:function(n){if(this.mapping!==Fn)return n;if(n.applyMatrix3(this.matrix),n.x<0||n.x>1)switch(this.wrapS){case Nn:n.x=n.x-Math.floor(n.x);break;case Gn:n.x=n.x<0?0:1;break;case Bn:1===Math.abs(Math.floor(n.x)%2)?n.x=Math.ceil(n.x)-n.x:n.x=n.x-Math.floor(n.x)}if(n.y<0||n.y>1)switch(this.wrapT){case Nn:n.y=n.y-Math.floor(n.y);break;case Gn:n.y=n.y<0?0:1;break;case Bn:1===Math.abs(Math.floor(n.y)%2)?n.y=Math.ceil(n.y)-n.y:n.y=n.y-Math.floor(n.y)}return this.flipY&&(n.y=1-n.y),n}},{key:"needsUpdate",set:function(n){!0===n&&(this.version++,this.source.needsUpdate=!0)}}]),t}(Wt);Cr.DEFAULT_IMAGE=null,Cr.DEFAULT_MAPPING=Fn;var Tr=function(n){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;y(this,e),e.prototype.isVector4=!0,this.x=n,this.y=t,this.z=r,this.w=o}return _(e,[{key:"width",get:function(){return this.z},set:function(n){this.z=n}},{key:"height",get:function(){return this.w},set:function(n){this.w=n}},{key:"set",value:function(n,e,t,r){return this.x=n,this.y=e,this.z=t,this.w=r,this}},{key:"setScalar",value:function(n){return this.x=n,this.y=n,this.z=n,this.w=n,this}},{key:"setX",value:function(n){return this.x=n,this}},{key:"setY",value:function(n){return this.y=n,this}},{key:"setZ",value:function(n){return this.z=n,this}},{key:"setW",value:function(n){return this.w=n,this}},{key:"setComponent",value:function(n,e){switch(n){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+n)}return this}},{key:"getComponent",value:function(n){switch(n){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+n)}}},{key:"clone",value:function(){return new this.constructor(this.x,this.y,this.z,this.w)}},{key:"copy",value:function(n){return this.x=n.x,this.y=n.y,this.z=n.z,this.w=void 0!==n.w?n.w:1,this}},{key:"add",value:function(n){return this.x+=n.x,this.y+=n.y,this.z+=n.z,this.w+=n.w,this}},{key:"addScalar",value:function(n){return this.x+=n,this.y+=n,this.z+=n,this.w+=n,this}},{key:"addVectors",value:function(n,e){return this.x=n.x+e.x,this.y=n.y+e.y,this.z=n.z+e.z,this.w=n.w+e.w,this}},{key:"addScaledVector",value:function(n,e){return this.x+=n.x*e,this.y+=n.y*e,this.z+=n.z*e,this.w+=n.w*e,this}},{key:"sub",value:function(n){return this.x-=n.x,this.y-=n.y,this.z-=n.z,this.w-=n.w,this}},{key:"subScalar",value:function(n){return this.x-=n,this.y-=n,this.z-=n,this.w-=n,this}},{key:"subVectors",value:function(n,e){return this.x=n.x-e.x,this.y=n.y-e.y,this.z=n.z-e.z,this.w=n.w-e.w,this}},{key:"multiply",value:function(n){return this.x*=n.x,this.y*=n.y,this.z*=n.z,this.w*=n.w,this}},{key:"multiplyScalar",value:function(n){return this.x*=n,this.y*=n,this.z*=n,this.w*=n,this}},{key:"applyMatrix4",value:function(n){var e=this.x,t=this.y,r=this.z,o=this.w,a=n.elements;return this.x=a[0]*e+a[4]*t+a[8]*r+a[12]*o,this.y=a[1]*e+a[5]*t+a[9]*r+a[13]*o,this.z=a[2]*e+a[6]*t+a[10]*r+a[14]*o,this.w=a[3]*e+a[7]*t+a[11]*r+a[15]*o,this}},{key:"divideScalar",value:function(n){return this.multiplyScalar(1/n)}},{key:"setAxisAngleFromQuaternion",value:function(n){this.w=2*Math.acos(n.w);var e=Math.sqrt(1-n.w*n.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=n.x/e,this.y=n.y/e,this.z=n.z/e),this}},{key:"setAxisAngleFromRotationMatrix",value:function(n){var e,t,r,o,a=.01,i=.1,v=n.elements,c=v[0],l=v[4],s=v[8],u=v[1],f=v[5],p=v[9],d=v[2],m=v[6],h=v[10];if(Math.abs(l-u)<a&&Math.abs(s-d)<a&&Math.abs(p-m)<a){if(Math.abs(l+u)<i&&Math.abs(s+d)<i&&Math.abs(p+m)<i&&Math.abs(c+f+h-3)<i)return this.set(1,0,0,0),this;e=Math.PI;var x=(c+1)/2,g=(f+1)/2,y=(h+1)/2,b=(l+u)/4,_=(s+d)/4,U=(p+m)/4;return x>g&&x>y?x<a?(t=0,r=.707106781,o=.707106781):(r=b/(t=Math.sqrt(x)),o=_/t):g>y?g<a?(t=.707106781,r=0,o=.707106781):(t=b/(r=Math.sqrt(g)),o=U/r):y<a?(t=.707106781,r=.707106781,o=0):(t=_/(o=Math.sqrt(y)),r=U/o),this.set(t,r,o,e),this}var w=Math.sqrt((m-p)*(m-p)+(s-d)*(s-d)+(u-l)*(u-l));return Math.abs(w)<.001&&(w=1),this.x=(m-p)/w,this.y=(s-d)/w,this.z=(u-l)/w,this.w=Math.acos((c+f+h-1)/2),this}},{key:"min",value:function(n){return this.x=Math.min(this.x,n.x),this.y=Math.min(this.y,n.y),this.z=Math.min(this.z,n.z),this.w=Math.min(this.w,n.w),this}},{key:"max",value:function(n){return this.x=Math.max(this.x,n.x),this.y=Math.max(this.y,n.y),this.z=Math.max(this.z,n.z),this.w=Math.max(this.w,n.w),this}},{key:"clamp",value:function(n,e){return this.x=Math.max(n.x,Math.min(e.x,this.x)),this.y=Math.max(n.y,Math.min(e.y,this.y)),this.z=Math.max(n.z,Math.min(e.z,this.z)),this.w=Math.max(n.w,Math.min(e.w,this.w)),this}},{key:"clampScalar",value:function(n,e){return this.x=Math.max(n,Math.min(e,this.x)),this.y=Math.max(n,Math.min(e,this.y)),this.z=Math.max(n,Math.min(e,this.z)),this.w=Math.max(n,Math.min(e,this.w)),this}},{key:"clampLength",value:function(n,e){var t=this.length();return this.divideScalar(t||1).multiplyScalar(Math.max(n,Math.min(e,t)))}},{key:"floor",value:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}},{key:"ceil",value:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}},{key:"round",value:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}},{key:"roundToZero",value:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}},{key:"negate",value:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}},{key:"dot",value:function(n){return this.x*n.x+this.y*n.y+this.z*n.z+this.w*n.w}},{key:"lengthSq",value:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}},{key:"length",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}},{key:"manhattanLength",value:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}},{key:"normalize",value:function(){return this.divideScalar(this.length()||1)}},{key:"setLength",value:function(n){return this.normalize().multiplyScalar(n)}},{key:"lerp",value:function(n,e){return this.x+=(n.x-this.x)*e,this.y+=(n.y-this.y)*e,this.z+=(n.z-this.z)*e,this.w+=(n.w-this.w)*e,this}},{key:"lerpVectors",value:function(n,e,t){return this.x=n.x+(e.x-n.x)*t,this.y=n.y+(e.y-n.y)*t,this.z=n.z+(e.z-n.z)*t,this.w=n.w+(e.w-n.w)*t,this}},{key:"equals",value:function(n){return n.x===this.x&&n.y===this.y&&n.z===this.z&&n.w===this.w}},{key:"fromArray",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=n[e],this.y=n[e+1],this.z=n[e+2],this.w=n[e+3],this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this.x,n[e+1]=this.y,n[e+2]=this.z,n[e+3]=this.w,n}},{key:"fromBufferAttribute",value:function(n,e){return this.x=n.getX(e),this.y=n.getY(e),this.z=n.getZ(e),this.w=n.getW(e),this}},{key:"random",value:function(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}},{key:Symbol.iterator,value:j().mark((function n(){return j().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this.x;case 2:return n.next=4,this.y;case 4:return n.next=6,this.z;case 6:return n.next=8,this.w;case 8:case"end":return n.stop()}}),n,this)}))}]),e}(),Rr=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};y(this,t),(n=e.call(this)).isWebGLRenderTarget=!0,n.width=r,n.height=o,n.depth=1,n.scissor=new Tr(0,0,r,o),n.scissorTest=!1,n.viewport=new Tr(0,0,r,o);var i={width:r,height:o,depth:1};return n.texture=new Cr(i,a.mapping,a.wrapS,a.wrapT,a.magFilter,a.minFilter,a.format,a.type,a.anisotropy,a.encoding),n.texture.isRenderTargetTexture=!0,n.texture.flipY=!1,n.texture.generateMipmaps=void 0!==a.generateMipmaps&&a.generateMipmaps,n.texture.internalFormat=void 0!==a.internalFormat?a.internalFormat:null,n.texture.minFilter=void 0!==a.minFilter?a.minFilter:Yn,n.depthBuffer=void 0===a.depthBuffer||a.depthBuffer,n.stencilBuffer=void 0!==a.stencilBuffer&&a.stencilBuffer,n.depthTexture=void 0!==a.depthTexture?a.depthTexture:null,n.samples=void 0!==a.samples?a.samples:0,n}return _(t,[{key:"setSize",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;this.width===n&&this.height===e&&this.depth===t||(this.width=n,this.height=e,this.depth=t,this.texture.image.width=n,this.texture.image.height=e,this.texture.image.depth=t,this.dispose()),this.viewport.set(0,0,n,e),this.scissor.set(0,0,n,e)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){this.width=n.width,this.height=n.height,this.depth=n.depth,this.viewport.copy(n.viewport),this.texture=n.texture.clone(),this.texture.isRenderTargetTexture=!0;var e=Object.assign({},n.texture.image);return this.texture.source=new kr(e),this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,null!==n.depthTexture&&(this.depthTexture=n.depthTexture.clone()),this.samples=n.samples,this}},{key:"dispose",value:function(){this.dispatchEvent({type:"dispose"})}}]),t}(Wt),Dr=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;return y(this,t),(n=e.call(this,null)).isDataArrayTexture=!0,n.image={data:r,width:o,height:a,depth:i},n.magFilter=qn,n.minFilter=qn,n.wrapR=Gn,n.generateMipmaps=!1,n.flipY=!1,n.unpackAlignment=1,n}return _(t)}(Cr),Pr=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return y(this,t),(n=e.call(this,r,o)).isWebGLArrayRenderTarget=!0,n.depth=a,n.texture=new Dr(null,r,o,a),n.texture.isRenderTargetTexture=!0,n}return _(t)}(Rr),jr=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;return y(this,t),(n=e.call(this,null)).isData3DTexture=!0,n.image={data:r,width:o,height:a,depth:i},n.magFilter=qn,n.minFilter=qn,n.wrapR=Gn,n.generateMipmaps=!1,n.flipY=!1,n.unpackAlignment=1,n}return _(t)}(Cr),Fr=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return y(this,t),(n=e.call(this,r,o)).isWebGL3DRenderTarget=!0,n.depth=a,n.texture=new jr(null,r,o,a),n.texture.isRenderTargetTexture=!0,n}return _(t)}(Rr),Er=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};y(this,t),(n=e.call(this,r,o,i)).isWebGLMultipleRenderTargets=!0;var v=n.texture;n.texture=[];for(var c=0;c<a;c++)n.texture[c]=v.clone(),n.texture[c].isRenderTargetTexture=!0;return n}return _(t,[{key:"setSize",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(this.width!==n||this.height!==e||this.depth!==t){this.width=n,this.height=e,this.depth=t;for(var r=0,o=this.texture.length;r<o;r++)this.texture[r].image.width=n,this.texture[r].image.height=e,this.texture[r].image.depth=t;this.dispose()}return this.viewport.set(0,0,n,e),this.scissor.set(0,0,n,e),this}},{key:"copy",value:function(n){this.dispose(),this.width=n.width,this.height=n.height,this.depth=n.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,null!==n.depthTexture&&(this.depthTexture=n.depthTexture.clone()),this.texture.length=0;for(var e=0,t=n.texture.length;e<t;e++)this.texture[e]=n.texture[e].clone(),this.texture[e].isRenderTargetTexture=!0;return this}}]),t}(Rr),Ir=function(n){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;y(this,e),this.isQuaternion=!0,this._x=n,this._y=t,this._z=r,this._w=o}return _(e,[{key:"x",get:function(){return this._x},set:function(n){this._x=n,this._onChangeCallback()}},{key:"y",get:function(){return this._y},set:function(n){this._y=n,this._onChangeCallback()}},{key:"z",get:function(){return this._z},set:function(n){this._z=n,this._onChangeCallback()}},{key:"w",get:function(){return this._w},set:function(n){this._w=n,this._onChangeCallback()}},{key:"set",value:function(n,e,t,r){return this._x=n,this._y=e,this._z=t,this._w=r,this._onChangeCallback(),this}},{key:"clone",value:function(){return new this.constructor(this._x,this._y,this._z,this._w)}},{key:"copy",value:function(n){return this._x=n.x,this._y=n.y,this._z=n.z,this._w=n.w,this._onChangeCallback(),this}},{key:"setFromEuler",value:function(n,e){var t=n._x,r=n._y,o=n._z,a=n._order,i=Math.cos,v=Math.sin,c=i(t/2),l=i(r/2),s=i(o/2),u=v(t/2),f=v(r/2),p=v(o/2);switch(a){case"XYZ":this._x=u*l*s+c*f*p,this._y=c*f*s-u*l*p,this._z=c*l*p+u*f*s,this._w=c*l*s-u*f*p;break;case"YXZ":this._x=u*l*s+c*f*p,this._y=c*f*s-u*l*p,this._z=c*l*p-u*f*s,this._w=c*l*s+u*f*p;break;case"ZXY":this._x=u*l*s-c*f*p,this._y=c*f*s+u*l*p,this._z=c*l*p+u*f*s,this._w=c*l*s-u*f*p;break;case"ZYX":this._x=u*l*s-c*f*p,this._y=c*f*s+u*l*p,this._z=c*l*p-u*f*s,this._w=c*l*s+u*f*p;break;case"YZX":this._x=u*l*s+c*f*p,this._y=c*f*s+u*l*p,this._z=c*l*p-u*f*s,this._w=c*l*s-u*f*p;break;case"XZY":this._x=u*l*s-c*f*p,this._y=c*f*s-u*l*p,this._z=c*l*p+u*f*s,this._w=c*l*s+u*f*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return!1!==e&&this._onChangeCallback(),this}},{key:"setFromAxisAngle",value:function(n,e){var t=e/2,r=Math.sin(t);return this._x=n.x*r,this._y=n.y*r,this._z=n.z*r,this._w=Math.cos(t),this._onChangeCallback(),this}},{key:"setFromRotationMatrix",value:function(n){var e=n.elements,t=e[0],r=e[4],o=e[8],a=e[1],i=e[5],v=e[9],c=e[2],l=e[6],s=e[10],u=t+i+s;if(u>0){var f=.5/Math.sqrt(u+1);this._w=.25/f,this._x=(l-v)*f,this._y=(o-c)*f,this._z=(a-r)*f}else if(t>i&&t>s){var p=2*Math.sqrt(1+t-i-s);this._w=(l-v)/p,this._x=.25*p,this._y=(r+a)/p,this._z=(o+c)/p}else if(i>s){var d=2*Math.sqrt(1+i-t-s);this._w=(o-c)/d,this._x=(r+a)/d,this._y=.25*d,this._z=(v+l)/d}else{var m=2*Math.sqrt(1+s-t-i);this._w=(a-r)/m,this._x=(o+c)/m,this._y=(v+l)/m,this._z=.25*m}return this._onChangeCallback(),this}},{key:"setFromUnitVectors",value:function(n,e){var t=n.dot(e)+1;return t<Number.EPSILON?(t=0,Math.abs(n.x)>Math.abs(n.z)?(this._x=-n.y,this._y=n.x,this._z=0,this._w=t):(this._x=0,this._y=-n.z,this._z=n.y,this._w=t)):(this._x=n.y*e.z-n.z*e.y,this._y=n.z*e.x-n.x*e.z,this._z=n.x*e.y-n.y*e.x,this._w=t),this.normalize()}},{key:"angleTo",value:function(n){return 2*Math.acos(Math.abs(Kt(this.dot(n),-1,1)))}},{key:"rotateTowards",value:function(n,e){var t=this.angleTo(n);if(0===t)return this;var r=Math.min(1,e/t);return this.slerp(n,r),this}},{key:"identity",value:function(){return this.set(0,0,0,1)}},{key:"invert",value:function(){return this.conjugate()}},{key:"conjugate",value:function(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}},{key:"dot",value:function(n){return this._x*n._x+this._y*n._y+this._z*n._z+this._w*n._w}},{key:"lengthSq",value:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}},{key:"length",value:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}},{key:"normalize",value:function(){var n=this.length();return 0===n?(this._x=0,this._y=0,this._z=0,this._w=1):(n=1/n,this._x=this._x*n,this._y=this._y*n,this._z=this._z*n,this._w=this._w*n),this._onChangeCallback(),this}},{key:"multiply",value:function(n){return this.multiplyQuaternions(this,n)}},{key:"premultiply",value:function(n){return this.multiplyQuaternions(n,this)}},{key:"multiplyQuaternions",value:function(n,e){var t=n._x,r=n._y,o=n._z,a=n._w,i=e._x,v=e._y,c=e._z,l=e._w;return this._x=t*l+a*i+r*c-o*v,this._y=r*l+a*v+o*i-t*c,this._z=o*l+a*c+t*v-r*i,this._w=a*l-t*i-r*v-o*c,this._onChangeCallback(),this}},{key:"slerp",value:function(n,e){if(0===e)return this;if(1===e)return this.copy(n);var t=this._x,r=this._y,o=this._z,a=this._w,i=a*n._w+t*n._x+r*n._y+o*n._z;if(i<0?(this._w=-n._w,this._x=-n._x,this._y=-n._y,this._z=-n._z,i=-i):this.copy(n),i>=1)return this._w=a,this._x=t,this._y=r,this._z=o,this;var v=1-i*i;if(v<=Number.EPSILON){var c=1-e;return this._w=c*a+e*this._w,this._x=c*t+e*this._x,this._y=c*r+e*this._y,this._z=c*o+e*this._z,this.normalize(),this._onChangeCallback(),this}var l=Math.sqrt(v),s=Math.atan2(l,i),u=Math.sin((1-e)*s)/l,f=Math.sin(e*s)/l;return this._w=a*u+this._w*f,this._x=t*u+this._x*f,this._y=r*u+this._y*f,this._z=o*u+this._z*f,this._onChangeCallback(),this}},{key:"slerpQuaternions",value:function(n,e,t){return this.copy(n).slerp(e,t)}},{key:"random",value:function(){var n=Math.random(),e=Math.sqrt(1-n),t=Math.sqrt(n),r=2*Math.PI*Math.random(),o=2*Math.PI*Math.random();return this.set(e*Math.cos(r),t*Math.sin(o),t*Math.cos(o),e*Math.sin(r))}},{key:"equals",value:function(n){return n._x===this._x&&n._y===this._y&&n._z===this._z&&n._w===this._w}},{key:"fromArray",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._x=n[e],this._y=n[e+1],this._z=n[e+2],this._w=n[e+3],this._onChangeCallback(),this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this._x,n[e+1]=this._y,n[e+2]=this._z,n[e+3]=this._w,n}},{key:"fromBufferAttribute",value:function(n,e){return this._x=n.getX(e),this._y=n.getY(e),this._z=n.getZ(e),this._w=n.getW(e),this}},{key:"_onChange",value:function(n){return this._onChangeCallback=n,this}},{key:"_onChangeCallback",value:function(){}},{key:Symbol.iterator,value:j().mark((function n(){return j().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this._x;case 2:return n.next=4,this._y;case 4:return n.next=6,this._z;case 6:return n.next=8,this._w;case 8:case"end":return n.stop()}}),n,this)}))}],[{key:"slerpFlat",value:function(n,e,t,r,o,a,i){var v=t[r+0],c=t[r+1],l=t[r+2],s=t[r+3],u=o[a+0],f=o[a+1],p=o[a+2],d=o[a+3];if(0===i)return n[e+0]=v,n[e+1]=c,n[e+2]=l,void(n[e+3]=s);if(1===i)return n[e+0]=u,n[e+1]=f,n[e+2]=p,void(n[e+3]=d);if(s!==d||v!==u||c!==f||l!==p){var m=1-i,h=v*u+c*f+l*p+s*d,x=h>=0?1:-1,g=1-h*h;if(g>Number.EPSILON){var y=Math.sqrt(g),b=Math.atan2(y,h*x);m=Math.sin(m*b)/y,i=Math.sin(i*b)/y}var _=i*x;if(v=v*m+u*_,c=c*m+f*_,l=l*m+p*_,s=s*m+d*_,m===1-i){var U=1/Math.sqrt(v*v+c*c+l*l+s*s);v*=U,c*=U,l*=U,s*=U}}n[e]=v,n[e+1]=c,n[e+2]=l,n[e+3]=s}},{key:"multiplyQuaternionsFlat",value:function(n,e,t,r,o,a){var i=t[r],v=t[r+1],c=t[r+2],l=t[r+3],s=o[a],u=o[a+1],f=o[a+2],p=o[a+3];return n[e]=i*p+l*s+v*f-c*u,n[e+1]=v*p+l*u+c*s-i*f,n[e+2]=c*p+l*f+i*u-v*s,n[e+3]=l*p-i*s-v*u-c*f,n}}]),e}(),Or=function(n){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;y(this,e),e.prototype.isVector3=!0,this.x=n,this.y=t,this.z=r}return _(e,[{key:"set",value:function(n,e,t){return void 0===t&&(t=this.z),this.x=n,this.y=e,this.z=t,this}},{key:"setScalar",value:function(n){return this.x=n,this.y=n,this.z=n,this}},{key:"setX",value:function(n){return this.x=n,this}},{key:"setY",value:function(n){return this.y=n,this}},{key:"setZ",value:function(n){return this.z=n,this}},{key:"setComponent",value:function(n,e){switch(n){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+n)}return this}},{key:"getComponent",value:function(n){switch(n){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+n)}}},{key:"clone",value:function(){return new this.constructor(this.x,this.y,this.z)}},{key:"copy",value:function(n){return this.x=n.x,this.y=n.y,this.z=n.z,this}},{key:"add",value:function(n){return this.x+=n.x,this.y+=n.y,this.z+=n.z,this}},{key:"addScalar",value:function(n){return this.x+=n,this.y+=n,this.z+=n,this}},{key:"addVectors",value:function(n,e){return this.x=n.x+e.x,this.y=n.y+e.y,this.z=n.z+e.z,this}},{key:"addScaledVector",value:function(n,e){return this.x+=n.x*e,this.y+=n.y*e,this.z+=n.z*e,this}},{key:"sub",value:function(n){return this.x-=n.x,this.y-=n.y,this.z-=n.z,this}},{key:"subScalar",value:function(n){return this.x-=n,this.y-=n,this.z-=n,this}},{key:"subVectors",value:function(n,e){return this.x=n.x-e.x,this.y=n.y-e.y,this.z=n.z-e.z,this}},{key:"multiply",value:function(n){return this.x*=n.x,this.y*=n.y,this.z*=n.z,this}},{key:"multiplyScalar",value:function(n){return this.x*=n,this.y*=n,this.z*=n,this}},{key:"multiplyVectors",value:function(n,e){return this.x=n.x*e.x,this.y=n.y*e.y,this.z=n.z*e.z,this}},{key:"applyEuler",value:function(n){return this.applyQuaternion(Ar.setFromEuler(n))}},{key:"applyAxisAngle",value:function(n,e){return this.applyQuaternion(Ar.setFromAxisAngle(n,e))}},{key:"applyMatrix3",value:function(n){var e=this.x,t=this.y,r=this.z,o=n.elements;return this.x=o[0]*e+o[3]*t+o[6]*r,this.y=o[1]*e+o[4]*t+o[7]*r,this.z=o[2]*e+o[5]*t+o[8]*r,this}},{key:"applyNormalMatrix",value:function(n){return this.applyMatrix3(n).normalize()}},{key:"applyMatrix4",value:function(n){var e=this.x,t=this.y,r=this.z,o=n.elements,a=1/(o[3]*e+o[7]*t+o[11]*r+o[15]);return this.x=(o[0]*e+o[4]*t+o[8]*r+o[12])*a,this.y=(o[1]*e+o[5]*t+o[9]*r+o[13])*a,this.z=(o[2]*e+o[6]*t+o[10]*r+o[14])*a,this}},{key:"applyQuaternion",value:function(n){var e=this.x,t=this.y,r=this.z,o=n.x,a=n.y,i=n.z,v=n.w,c=v*e+a*r-i*t,l=v*t+i*e-o*r,s=v*r+o*t-a*e,u=-o*e-a*t-i*r;return this.x=c*v+u*-o+l*-i-s*-a,this.y=l*v+u*-a+s*-o-c*-i,this.z=s*v+u*-i+c*-a-l*-o,this}},{key:"project",value:function(n){return this.applyMatrix4(n.matrixWorldInverse).applyMatrix4(n.projectionMatrix)}},{key:"unproject",value:function(n){return this.applyMatrix4(n.projectionMatrixInverse).applyMatrix4(n.matrixWorld)}},{key:"transformDirection",value:function(n){var e=this.x,t=this.y,r=this.z,o=n.elements;return this.x=o[0]*e+o[4]*t+o[8]*r,this.y=o[1]*e+o[5]*t+o[9]*r,this.z=o[2]*e+o[6]*t+o[10]*r,this.normalize()}},{key:"divide",value:function(n){return this.x/=n.x,this.y/=n.y,this.z/=n.z,this}},{key:"divideScalar",value:function(n){return this.multiplyScalar(1/n)}},{key:"min",value:function(n){return this.x=Math.min(this.x,n.x),this.y=Math.min(this.y,n.y),this.z=Math.min(this.z,n.z),this}},{key:"max",value:function(n){return this.x=Math.max(this.x,n.x),this.y=Math.max(this.y,n.y),this.z=Math.max(this.z,n.z),this}},{key:"clamp",value:function(n,e){return this.x=Math.max(n.x,Math.min(e.x,this.x)),this.y=Math.max(n.y,Math.min(e.y,this.y)),this.z=Math.max(n.z,Math.min(e.z,this.z)),this}},{key:"clampScalar",value:function(n,e){return this.x=Math.max(n,Math.min(e,this.x)),this.y=Math.max(n,Math.min(e,this.y)),this.z=Math.max(n,Math.min(e,this.z)),this}},{key:"clampLength",value:function(n,e){var t=this.length();return this.divideScalar(t||1).multiplyScalar(Math.max(n,Math.min(e,t)))}},{key:"floor",value:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}},{key:"ceil",value:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}},{key:"round",value:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}},{key:"roundToZero",value:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}},{key:"negate",value:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}},{key:"dot",value:function(n){return this.x*n.x+this.y*n.y+this.z*n.z}},{key:"lengthSq",value:function(){return this.x*this.x+this.y*this.y+this.z*this.z}},{key:"length",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}},{key:"manhattanLength",value:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}},{key:"normalize",value:function(){return this.divideScalar(this.length()||1)}},{key:"setLength",value:function(n){return this.normalize().multiplyScalar(n)}},{key:"lerp",value:function(n,e){return this.x+=(n.x-this.x)*e,this.y+=(n.y-this.y)*e,this.z+=(n.z-this.z)*e,this}},{key:"lerpVectors",value:function(n,e,t){return this.x=n.x+(e.x-n.x)*t,this.y=n.y+(e.y-n.y)*t,this.z=n.z+(e.z-n.z)*t,this}},{key:"cross",value:function(n){return this.crossVectors(this,n)}},{key:"crossVectors",value:function(n,e){var t=n.x,r=n.y,o=n.z,a=e.x,i=e.y,v=e.z;return this.x=r*v-o*i,this.y=o*a-t*v,this.z=t*i-r*a,this}},{key:"projectOnVector",value:function(n){var e=n.lengthSq();if(0===e)return this.set(0,0,0);var t=n.dot(this)/e;return this.copy(n).multiplyScalar(t)}},{key:"projectOnPlane",value:function(n){return Lr.copy(this).projectOnVector(n),this.sub(Lr)}},{key:"reflect",value:function(n){return this.sub(Lr.copy(n).multiplyScalar(2*this.dot(n)))}},{key:"angleTo",value:function(n){var e=Math.sqrt(this.lengthSq()*n.lengthSq());if(0===e)return Math.PI/2;var t=this.dot(n)/e;return Math.acos(Kt(t,-1,1))}},{key:"distanceTo",value:function(n){return Math.sqrt(this.distanceToSquared(n))}},{key:"distanceToSquared",value:function(n){var e=this.x-n.x,t=this.y-n.y,r=this.z-n.z;return e*e+t*t+r*r}},{key:"manhattanDistanceTo",value:function(n){return Math.abs(this.x-n.x)+Math.abs(this.y-n.y)+Math.abs(this.z-n.z)}},{key:"setFromSpherical",value:function(n){return this.setFromSphericalCoords(n.radius,n.phi,n.theta)}},{key:"setFromSphericalCoords",value:function(n,e,t){var r=Math.sin(e)*n;return this.x=r*Math.sin(t),this.y=Math.cos(e)*n,this.z=r*Math.cos(t),this}},{key:"setFromCylindrical",value:function(n){return this.setFromCylindricalCoords(n.radius,n.theta,n.y)}},{key:"setFromCylindricalCoords",value:function(n,e,t){return this.x=n*Math.sin(e),this.y=t,this.z=n*Math.cos(e),this}},{key:"setFromMatrixPosition",value:function(n){var e=n.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}},{key:"setFromMatrixScale",value:function(n){var e=this.setFromMatrixColumn(n,0).length(),t=this.setFromMatrixColumn(n,1).length(),r=this.setFromMatrixColumn(n,2).length();return this.x=e,this.y=t,this.z=r,this}},{key:"setFromMatrixColumn",value:function(n,e){return this.fromArray(n.elements,4*e)}},{key:"setFromMatrix3Column",value:function(n,e){return this.fromArray(n.elements,3*e)}},{key:"setFromEuler",value:function(n){return this.x=n._x,this.y=n._y,this.z=n._z,this}},{key:"equals",value:function(n){return n.x===this.x&&n.y===this.y&&n.z===this.z}},{key:"fromArray",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=n[e],this.y=n[e+1],this.z=n[e+2],this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this.x,n[e+1]=this.y,n[e+2]=this.z,n}},{key:"fromBufferAttribute",value:function(n,e){return this.x=n.getX(e),this.y=n.getY(e),this.z=n.getZ(e),this}},{key:"random",value:function(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}},{key:"randomDirection",value:function(){var n=2*(Math.random()-.5),e=Math.random()*Math.PI*2,t=Math.sqrt(1-Math.pow(n,2));return this.x=t*Math.cos(e),this.y=t*Math.sin(e),this.z=n,this}},{key:Symbol.iterator,value:j().mark((function n(){return j().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this.x;case 2:return n.next=4,this.y;case 4:return n.next=6,this.z;case 6:case"end":return n.stop()}}),n,this)}))}]),e}(),Lr=new Or,Ar=new Ir,Nr=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Or(1/0,1/0,1/0),t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Or(-1/0,-1/0,-1/0);y(this,n),this.isBox3=!0,this.min=e,this.max=t}return _(n,[{key:"set",value:function(n,e){return this.min.copy(n),this.max.copy(e),this}},{key:"setFromArray",value:function(n){for(var e=1/0,t=1/0,r=1/0,o=-1/0,a=-1/0,i=-1/0,v=0,c=n.length;v<c;v+=3){var l=n[v],s=n[v+1],u=n[v+2];l<e&&(e=l),s<t&&(t=s),u<r&&(r=u),l>o&&(o=l),s>a&&(a=s),u>i&&(i=u)}return this.min.set(e,t,r),this.max.set(o,a,i),this}},{key:"setFromBufferAttribute",value:function(n){for(var e=1/0,t=1/0,r=1/0,o=-1/0,a=-1/0,i=-1/0,v=0,c=n.count;v<c;v++){var l=n.getX(v),s=n.getY(v),u=n.getZ(v);l<e&&(e=l),s<t&&(t=s),u<r&&(r=u),l>o&&(o=l),s>a&&(a=s),u>i&&(i=u)}return this.min.set(e,t,r),this.max.set(o,a,i),this}},{key:"setFromPoints",value:function(n){this.makeEmpty();for(var e=0,t=n.length;e<t;e++)this.expandByPoint(n[e]);return this}},{key:"setFromCenterAndSize",value:function(n,e){var t=Br.copy(e).multiplyScalar(.5);return this.min.copy(n).sub(t),this.max.copy(n).add(t),this}},{key:"setFromObject",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return this.makeEmpty(),this.expandByObject(n,e)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){return this.min.copy(n.min),this.max.copy(n.max),this}},{key:"makeEmpty",value:function(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}},{key:"isEmpty",value:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}},{key:"getCenter",value:function(n){return this.isEmpty()?n.set(0,0,0):n.addVectors(this.min,this.max).multiplyScalar(.5)}},{key:"getSize",value:function(n){return this.isEmpty()?n.set(0,0,0):n.subVectors(this.max,this.min)}},{key:"expandByPoint",value:function(n){return this.min.min(n),this.max.max(n),this}},{key:"expandByVector",value:function(n){return this.min.sub(n),this.max.add(n),this}},{key:"expandByScalar",value:function(n){return this.min.addScalar(-n),this.max.addScalar(n),this}},{key:"expandByObject",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n.updateWorldMatrix(!1,!1);var t=n.geometry;if(void 0!==t)if(e&&void 0!=t.attributes&&void 0!==t.attributes.position)for(var r=t.attributes.position,o=0,a=r.count;o<a;o++)Br.fromBufferAttribute(r,o).applyMatrix4(n.matrixWorld),this.expandByPoint(Br);else null===t.boundingBox&&t.computeBoundingBox(),qr.copy(t.boundingBox),qr.applyMatrix4(n.matrixWorld),this.union(qr);for(var i=n.children,v=0,c=i.length;v<c;v++)this.expandByObject(i[v],e);return this}},{key:"containsPoint",value:function(n){return!(n.x<this.min.x||n.x>this.max.x||n.y<this.min.y||n.y>this.max.y||n.z<this.min.z||n.z>this.max.z)}},{key:"containsBox",value:function(n){return this.min.x<=n.min.x&&n.max.x<=this.max.x&&this.min.y<=n.min.y&&n.max.y<=this.max.y&&this.min.z<=n.min.z&&n.max.z<=this.max.z}},{key:"getParameter",value:function(n,e){return e.set((n.x-this.min.x)/(this.max.x-this.min.x),(n.y-this.min.y)/(this.max.y-this.min.y),(n.z-this.min.z)/(this.max.z-this.min.z))}},{key:"intersectsBox",value:function(n){return!(n.max.x<this.min.x||n.min.x>this.max.x||n.max.y<this.min.y||n.min.y>this.max.y||n.max.z<this.min.z||n.min.z>this.max.z)}},{key:"intersectsSphere",value:function(n){return this.clampPoint(n.center,Br),Br.distanceToSquared(n.center)<=n.radius*n.radius}},{key:"intersectsPlane",value:function(n){var e,t;return n.normal.x>0?(e=n.normal.x*this.min.x,t=n.normal.x*this.max.x):(e=n.normal.x*this.max.x,t=n.normal.x*this.min.x),n.normal.y>0?(e+=n.normal.y*this.min.y,t+=n.normal.y*this.max.y):(e+=n.normal.y*this.max.y,t+=n.normal.y*this.min.y),n.normal.z>0?(e+=n.normal.z*this.min.z,t+=n.normal.z*this.max.z):(e+=n.normal.z*this.max.z,t+=n.normal.z*this.min.z),e<=-n.constant&&t>=-n.constant}},{key:"intersectsTriangle",value:function(n){if(this.isEmpty())return!1;this.getCenter(Zr),Kr.subVectors(this.max,Zr),Vr.subVectors(n.a,Zr),Wr.subVectors(n.b,Zr),Hr.subVectors(n.c,Zr),Xr.subVectors(Wr,Vr),Yr.subVectors(Hr,Wr),$r.subVectors(Vr,Hr);var e=[0,-Xr.z,Xr.y,0,-Yr.z,Yr.y,0,-$r.z,$r.y,Xr.z,0,-Xr.x,Yr.z,0,-Yr.x,$r.z,0,-$r.x,-Xr.y,Xr.x,0,-Yr.y,Yr.x,0,-$r.y,$r.x,0];return!!no(e,Vr,Wr,Hr,Kr)&&(!!no(e=[1,0,0,0,1,0,0,0,1],Vr,Wr,Hr,Kr)&&(Jr.crossVectors(Xr,Yr),no(e=[Jr.x,Jr.y,Jr.z],Vr,Wr,Hr,Kr)))}},{key:"clampPoint",value:function(n,e){return e.copy(n).clamp(this.min,this.max)}},{key:"distanceToPoint",value:function(n){return Br.copy(n).clamp(this.min,this.max).sub(n).length()}},{key:"getBoundingSphere",value:function(n){return this.getCenter(n.center),n.radius=.5*this.getSize(Br).length(),n}},{key:"intersect",value:function(n){return this.min.max(n.min),this.max.min(n.max),this.isEmpty()&&this.makeEmpty(),this}},{key:"union",value:function(n){return this.min.min(n.min),this.max.max(n.max),this}},{key:"applyMatrix4",value:function(n){return this.isEmpty()||(Gr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(n),Gr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(n),Gr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(n),Gr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(n),Gr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(n),Gr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(n),Gr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(n),Gr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(n),this.setFromPoints(Gr)),this}},{key:"translate",value:function(n){return this.min.add(n),this.max.add(n),this}},{key:"equals",value:function(n){return n.min.equals(this.min)&&n.max.equals(this.max)}}]),n}(),Gr=[new Or,new Or,new Or,new Or,new Or,new Or,new Or,new Or],Br=new Or,qr=new Nr,Vr=new Or,Wr=new Or,Hr=new Or,Xr=new Or,Yr=new Or,$r=new Or,Zr=new Or,Kr=new Or,Jr=new Or,Qr=new Or;function no(n,e,t,r,o){for(var a=0,i=n.length-3;a<=i;a+=3){Qr.fromArray(n,a);var v=o.x*Math.abs(Qr.x)+o.y*Math.abs(Qr.y)+o.z*Math.abs(Qr.z),c=e.dot(Qr),l=t.dot(Qr),s=r.dot(Qr);if(Math.max(-Math.max(c,l,s),Math.min(c,l,s))>v)return!1}return!0}var eo=new Nr,to=new Or,ro=new Or,oo=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Or,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;y(this,n),this.center=e,this.radius=t}return _(n,[{key:"set",value:function(n,e){return this.center.copy(n),this.radius=e,this}},{key:"setFromPoints",value:function(n,e){var t=this.center;void 0!==e?t.copy(e):eo.setFromPoints(n).getCenter(t);for(var r=0,o=0,a=n.length;o<a;o++)r=Math.max(r,t.distanceToSquared(n[o]));return this.radius=Math.sqrt(r),this}},{key:"copy",value:function(n){return this.center.copy(n.center),this.radius=n.radius,this}},{key:"isEmpty",value:function(){return this.radius<0}},{key:"makeEmpty",value:function(){return this.center.set(0,0,0),this.radius=-1,this}},{key:"containsPoint",value:function(n){return n.distanceToSquared(this.center)<=this.radius*this.radius}},{key:"distanceToPoint",value:function(n){return n.distanceTo(this.center)-this.radius}},{key:"intersectsSphere",value:function(n){var e=this.radius+n.radius;return n.center.distanceToSquared(this.center)<=e*e}},{key:"intersectsBox",value:function(n){return n.intersectsSphere(this)}},{key:"intersectsPlane",value:function(n){return Math.abs(n.distanceToPoint(this.center))<=this.radius}},{key:"clampPoint",value:function(n,e){var t=this.center.distanceToSquared(n);return e.copy(n),t>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}},{key:"getBoundingBox",value:function(n){return this.isEmpty()?(n.makeEmpty(),n):(n.set(this.center,this.center),n.expandByScalar(this.radius),n)}},{key:"applyMatrix4",value:function(n){return this.center.applyMatrix4(n),this.radius=this.radius*n.getMaxScaleOnAxis(),this}},{key:"translate",value:function(n){return this.center.add(n),this}},{key:"expandByPoint",value:function(n){if(this.isEmpty())return this.center.copy(n),this.radius=0,this;to.subVectors(n,this.center);var e=to.lengthSq();if(e>this.radius*this.radius){var t=Math.sqrt(e),r=.5*(t-this.radius);this.center.addScaledVector(to,r/t),this.radius+=r}return this}},{key:"union",value:function(n){return n.isEmpty()?this:this.isEmpty()?(this.copy(n),this):(!0===this.center.equals(n.center)?this.radius=Math.max(this.radius,n.radius):(ro.subVectors(n.center,this.center).setLength(n.radius),this.expandByPoint(to.copy(n.center).add(ro)),this.expandByPoint(to.copy(n.center).sub(ro))),this)}},{key:"equals",value:function(n){return n.center.equals(this.center)&&n.radius===this.radius}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),ao=new Or,io=new Or,vo=new Or,co=new Or,lo=new Or,so=new Or,uo=new Or,fo=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Or,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Or(0,0,-1);y(this,n),this.origin=e,this.direction=t}return _(n,[{key:"set",value:function(n,e){return this.origin.copy(n),this.direction.copy(e),this}},{key:"copy",value:function(n){return this.origin.copy(n.origin),this.direction.copy(n.direction),this}},{key:"at",value:function(n,e){return e.copy(this.direction).multiplyScalar(n).add(this.origin)}},{key:"lookAt",value:function(n){return this.direction.copy(n).sub(this.origin).normalize(),this}},{key:"recast",value:function(n){return this.origin.copy(this.at(n,ao)),this}},{key:"closestPointToPoint",value:function(n,e){e.subVectors(n,this.origin);var t=e.dot(this.direction);return t<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(t).add(this.origin)}},{key:"distanceToPoint",value:function(n){return Math.sqrt(this.distanceSqToPoint(n))}},{key:"distanceSqToPoint",value:function(n){var e=ao.subVectors(n,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(n):(ao.copy(this.direction).multiplyScalar(e).add(this.origin),ao.distanceToSquared(n))}},{key:"distanceSqToSegment",value:function(n,e,t,r){io.copy(n).add(e).multiplyScalar(.5),vo.copy(e).sub(n).normalize(),co.copy(this.origin).sub(io);var o,a,i,v,c=.5*n.distanceTo(e),l=-this.direction.dot(vo),s=co.dot(this.direction),u=-co.dot(vo),f=co.lengthSq(),p=Math.abs(1-l*l);if(p>0)if(a=l*s-u,v=c*p,(o=l*u-s)>=0)if(a>=-v)if(a<=v){var d=1/p;i=(o*=d)*(o+l*(a*=d)+2*s)+a*(l*o+a+2*u)+f}else a=c,i=-(o=Math.max(0,-(l*a+s)))*o+a*(a+2*u)+f;else a=-c,i=-(o=Math.max(0,-(l*a+s)))*o+a*(a+2*u)+f;else a<=-v?i=-(o=Math.max(0,-(-l*c+s)))*o+(a=o>0?-c:Math.min(Math.max(-c,-u),c))*(a+2*u)+f:a<=v?(o=0,i=(a=Math.min(Math.max(-c,-u),c))*(a+2*u)+f):i=-(o=Math.max(0,-(l*c+s)))*o+(a=o>0?c:Math.min(Math.max(-c,-u),c))*(a+2*u)+f;else a=l>0?-c:c,i=-(o=Math.max(0,-(l*a+s)))*o+a*(a+2*u)+f;return t&&t.copy(this.direction).multiplyScalar(o).add(this.origin),r&&r.copy(vo).multiplyScalar(a).add(io),i}},{key:"intersectSphere",value:function(n,e){ao.subVectors(n.center,this.origin);var t=ao.dot(this.direction),r=ao.dot(ao)-t*t,o=n.radius*n.radius;if(r>o)return null;var a=Math.sqrt(o-r),i=t-a,v=t+a;return i<0&&v<0?null:i<0?this.at(v,e):this.at(i,e)}},{key:"intersectsSphere",value:function(n){return this.distanceSqToPoint(n.center)<=n.radius*n.radius}},{key:"distanceToPlane",value:function(n){var e=n.normal.dot(this.direction);if(0===e)return 0===n.distanceToPoint(this.origin)?0:null;var t=-(this.origin.dot(n.normal)+n.constant)/e;return t>=0?t:null}},{key:"intersectPlane",value:function(n,e){var t=this.distanceToPlane(n);return null===t?null:this.at(t,e)}},{key:"intersectsPlane",value:function(n){var e=n.distanceToPoint(this.origin);return 0===e||n.normal.dot(this.direction)*e<0}},{key:"intersectBox",value:function(n,e){var t,r,o,a,i,v,c=1/this.direction.x,l=1/this.direction.y,s=1/this.direction.z,u=this.origin;return c>=0?(t=(n.min.x-u.x)*c,r=(n.max.x-u.x)*c):(t=(n.max.x-u.x)*c,r=(n.min.x-u.x)*c),l>=0?(o=(n.min.y-u.y)*l,a=(n.max.y-u.y)*l):(o=(n.max.y-u.y)*l,a=(n.min.y-u.y)*l),t>a||o>r?null:((o>t||isNaN(t))&&(t=o),(a<r||isNaN(r))&&(r=a),s>=0?(i=(n.min.z-u.z)*s,v=(n.max.z-u.z)*s):(i=(n.max.z-u.z)*s,v=(n.min.z-u.z)*s),t>v||i>r?null:((i>t||t!==t)&&(t=i),(v<r||r!==r)&&(r=v),r<0?null:this.at(t>=0?t:r,e)))}},{key:"intersectsBox",value:function(n){return null!==this.intersectBox(n,ao)}},{key:"intersectTriangle",value:function(n,e,t,r,o){lo.subVectors(e,n),so.subVectors(t,n),uo.crossVectors(lo,so);var a,i=this.direction.dot(uo);if(i>0){if(r)return null;a=1}else{if(!(i<0))return null;a=-1,i=-i}co.subVectors(this.origin,n);var v=a*this.direction.dot(so.crossVectors(co,so));if(v<0)return null;var c=a*this.direction.dot(lo.cross(co));if(c<0)return null;if(v+c>i)return null;var l=-a*co.dot(uo);return l<0?null:this.at(l/i,o)}},{key:"applyMatrix4",value:function(n){return this.origin.applyMatrix4(n),this.direction.transformDirection(n),this}},{key:"equals",value:function(n){return n.origin.equals(this.origin)&&n.direction.equals(this.direction)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),po=function(){function n(){y(this,n),n.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}return _(n,[{key:"set",value:function(n,e,t,r,o,a,i,v,c,l,s,u,f,p,d,m){var h=this.elements;return h[0]=n,h[4]=e,h[8]=t,h[12]=r,h[1]=o,h[5]=a,h[9]=i,h[13]=v,h[2]=c,h[6]=l,h[10]=s,h[14]=u,h[3]=f,h[7]=p,h[11]=d,h[15]=m,this}},{key:"identity",value:function(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}},{key:"clone",value:function(){return(new n).fromArray(this.elements)}},{key:"copy",value:function(n){var e=this.elements,t=n.elements;return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],this}},{key:"copyPosition",value:function(n){var e=this.elements,t=n.elements;return e[12]=t[12],e[13]=t[13],e[14]=t[14],this}},{key:"setFromMatrix3",value:function(n){var e=n.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}},{key:"extractBasis",value:function(n,e,t){return n.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),t.setFromMatrixColumn(this,2),this}},{key:"makeBasis",value:function(n,e,t){return this.set(n.x,e.x,t.x,0,n.y,e.y,t.y,0,n.z,e.z,t.z,0,0,0,0,1),this}},{key:"extractRotation",value:function(n){var e=this.elements,t=n.elements,r=1/mo.setFromMatrixColumn(n,0).length(),o=1/mo.setFromMatrixColumn(n,1).length(),a=1/mo.setFromMatrixColumn(n,2).length();return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=0,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=0,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}},{key:"makeRotationFromEuler",value:function(n){var e=this.elements,t=n.x,r=n.y,o=n.z,a=Math.cos(t),i=Math.sin(t),v=Math.cos(r),c=Math.sin(r),l=Math.cos(o),s=Math.sin(o);if("XYZ"===n.order){var u=a*l,f=a*s,p=i*l,d=i*s;e[0]=v*l,e[4]=-v*s,e[8]=c,e[1]=f+p*c,e[5]=u-d*c,e[9]=-i*v,e[2]=d-u*c,e[6]=p+f*c,e[10]=a*v}else if("YXZ"===n.order){var m=v*l,h=v*s,x=c*l,g=c*s;e[0]=m+g*i,e[4]=x*i-h,e[8]=a*c,e[1]=a*s,e[5]=a*l,e[9]=-i,e[2]=h*i-x,e[6]=g+m*i,e[10]=a*v}else if("ZXY"===n.order){var y=v*l,b=v*s,_=c*l,U=c*s;e[0]=y-U*i,e[4]=-a*s,e[8]=_+b*i,e[1]=b+_*i,e[5]=a*l,e[9]=U-y*i,e[2]=-a*c,e[6]=i,e[10]=a*v}else if("ZYX"===n.order){var w=a*l,S=a*s,k=i*l,M=i*s;e[0]=v*l,e[4]=k*c-S,e[8]=w*c+M,e[1]=v*s,e[5]=M*c+w,e[9]=S*c-k,e[2]=-c,e[6]=i*v,e[10]=a*v}else if("YZX"===n.order){var z=a*v,C=a*c,T=i*v,R=i*c;e[0]=v*l,e[4]=R-z*s,e[8]=T*s+C,e[1]=s,e[5]=a*l,e[9]=-i*l,e[2]=-c*l,e[6]=C*s+T,e[10]=z-R*s}else if("XZY"===n.order){var D=a*v,P=a*c,j=i*v,F=i*c;e[0]=v*l,e[4]=-s,e[8]=c*l,e[1]=D*s+F,e[5]=a*l,e[9]=P*s-j,e[2]=j*s-P,e[6]=i*l,e[10]=F*s+D}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}},{key:"makeRotationFromQuaternion",value:function(n){return this.compose(xo,n,go)}},{key:"lookAt",value:function(n,e,t){var r=this.elements;return _o.subVectors(n,e),0===_o.lengthSq()&&(_o.z=1),_o.normalize(),yo.crossVectors(t,_o),0===yo.lengthSq()&&(1===Math.abs(t.z)?_o.x+=1e-4:_o.z+=1e-4,_o.normalize(),yo.crossVectors(t,_o)),yo.normalize(),bo.crossVectors(_o,yo),r[0]=yo.x,r[4]=bo.x,r[8]=_o.x,r[1]=yo.y,r[5]=bo.y,r[9]=_o.y,r[2]=yo.z,r[6]=bo.z,r[10]=_o.z,this}},{key:"multiply",value:function(n){return this.multiplyMatrices(this,n)}},{key:"premultiply",value:function(n){return this.multiplyMatrices(n,this)}},{key:"multiplyMatrices",value:function(n,e){var t=n.elements,r=e.elements,o=this.elements,a=t[0],i=t[4],v=t[8],c=t[12],l=t[1],s=t[5],u=t[9],f=t[13],p=t[2],d=t[6],m=t[10],h=t[14],x=t[3],g=t[7],y=t[11],b=t[15],_=r[0],U=r[4],w=r[8],S=r[12],k=r[1],M=r[5],z=r[9],C=r[13],T=r[2],R=r[6],D=r[10],P=r[14],j=r[3],F=r[7],E=r[11],I=r[15];return o[0]=a*_+i*k+v*T+c*j,o[4]=a*U+i*M+v*R+c*F,o[8]=a*w+i*z+v*D+c*E,o[12]=a*S+i*C+v*P+c*I,o[1]=l*_+s*k+u*T+f*j,o[5]=l*U+s*M+u*R+f*F,o[9]=l*w+s*z+u*D+f*E,o[13]=l*S+s*C+u*P+f*I,o[2]=p*_+d*k+m*T+h*j,o[6]=p*U+d*M+m*R+h*F,o[10]=p*w+d*z+m*D+h*E,o[14]=p*S+d*C+m*P+h*I,o[3]=x*_+g*k+y*T+b*j,o[7]=x*U+g*M+y*R+b*F,o[11]=x*w+g*z+y*D+b*E,o[15]=x*S+g*C+y*P+b*I,this}},{key:"multiplyScalar",value:function(n){var e=this.elements;return e[0]*=n,e[4]*=n,e[8]*=n,e[12]*=n,e[1]*=n,e[5]*=n,e[9]*=n,e[13]*=n,e[2]*=n,e[6]*=n,e[10]*=n,e[14]*=n,e[3]*=n,e[7]*=n,e[11]*=n,e[15]*=n,this}},{key:"determinant",value:function(){var n=this.elements,e=n[0],t=n[4],r=n[8],o=n[12],a=n[1],i=n[5],v=n[9],c=n[13],l=n[2],s=n[6],u=n[10],f=n[14];return n[3]*(+o*v*s-r*c*s-o*i*u+t*c*u+r*i*f-t*v*f)+n[7]*(+e*v*f-e*c*u+o*a*u-r*a*f+r*c*l-o*v*l)+n[11]*(+e*c*s-e*i*f-o*a*s+t*a*f+o*i*l-t*c*l)+n[15]*(-r*i*l-e*v*s+e*i*u+r*a*s-t*a*u+t*v*l)}},{key:"transpose",value:function(){var n,e=this.elements;return n=e[1],e[1]=e[4],e[4]=n,n=e[2],e[2]=e[8],e[8]=n,n=e[6],e[6]=e[9],e[9]=n,n=e[3],e[3]=e[12],e[12]=n,n=e[7],e[7]=e[13],e[13]=n,n=e[11],e[11]=e[14],e[14]=n,this}},{key:"setPosition",value:function(n,e,t){var r=this.elements;return n.isVector3?(r[12]=n.x,r[13]=n.y,r[14]=n.z):(r[12]=n,r[13]=e,r[14]=t),this}},{key:"invert",value:function(){var n=this.elements,e=n[0],t=n[1],r=n[2],o=n[3],a=n[4],i=n[5],v=n[6],c=n[7],l=n[8],s=n[9],u=n[10],f=n[11],p=n[12],d=n[13],m=n[14],h=n[15],x=s*m*c-d*u*c+d*v*f-i*m*f-s*v*h+i*u*h,g=p*u*c-l*m*c-p*v*f+a*m*f+l*v*h-a*u*h,y=l*d*c-p*s*c+p*i*f-a*d*f-l*i*h+a*s*h,b=p*s*v-l*d*v-p*i*u+a*d*u+l*i*m-a*s*m,_=e*x+t*g+r*y+o*b;if(0===_)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);var U=1/_;return n[0]=x*U,n[1]=(d*u*o-s*m*o-d*r*f+t*m*f+s*r*h-t*u*h)*U,n[2]=(i*m*o-d*v*o+d*r*c-t*m*c-i*r*h+t*v*h)*U,n[3]=(s*v*o-i*u*o-s*r*c+t*u*c+i*r*f-t*v*f)*U,n[4]=g*U,n[5]=(l*m*o-p*u*o+p*r*f-e*m*f-l*r*h+e*u*h)*U,n[6]=(p*v*o-a*m*o-p*r*c+e*m*c+a*r*h-e*v*h)*U,n[7]=(a*u*o-l*v*o+l*r*c-e*u*c-a*r*f+e*v*f)*U,n[8]=y*U,n[9]=(p*s*o-l*d*o-p*t*f+e*d*f+l*t*h-e*s*h)*U,n[10]=(a*d*o-p*i*o+p*t*c-e*d*c-a*t*h+e*i*h)*U,n[11]=(l*i*o-a*s*o-l*t*c+e*s*c+a*t*f-e*i*f)*U,n[12]=b*U,n[13]=(l*d*r-p*s*r+p*t*u-e*d*u-l*t*m+e*s*m)*U,n[14]=(p*i*r-a*d*r-p*t*v+e*d*v+a*t*m-e*i*m)*U,n[15]=(a*s*r-l*i*r+l*t*v-e*s*v-a*t*u+e*i*u)*U,this}},{key:"scale",value:function(n){var e=this.elements,t=n.x,r=n.y,o=n.z;return e[0]*=t,e[4]*=r,e[8]*=o,e[1]*=t,e[5]*=r,e[9]*=o,e[2]*=t,e[6]*=r,e[10]*=o,e[3]*=t,e[7]*=r,e[11]*=o,this}},{key:"getMaxScaleOnAxis",value:function(){var n=this.elements,e=n[0]*n[0]+n[1]*n[1]+n[2]*n[2],t=n[4]*n[4]+n[5]*n[5]+n[6]*n[6],r=n[8]*n[8]+n[9]*n[9]+n[10]*n[10];return Math.sqrt(Math.max(e,t,r))}},{key:"makeTranslation",value:function(n,e,t){return this.set(1,0,0,n,0,1,0,e,0,0,1,t,0,0,0,1),this}},{key:"makeRotationX",value:function(n){var e=Math.cos(n),t=Math.sin(n);return this.set(1,0,0,0,0,e,-t,0,0,t,e,0,0,0,0,1),this}},{key:"makeRotationY",value:function(n){var e=Math.cos(n),t=Math.sin(n);return this.set(e,0,t,0,0,1,0,0,-t,0,e,0,0,0,0,1),this}},{key:"makeRotationZ",value:function(n){var e=Math.cos(n),t=Math.sin(n);return this.set(e,-t,0,0,t,e,0,0,0,0,1,0,0,0,0,1),this}},{key:"makeRotationAxis",value:function(n,e){var t=Math.cos(e),r=Math.sin(e),o=1-t,a=n.x,i=n.y,v=n.z,c=o*a,l=o*i;return this.set(c*a+t,c*i-r*v,c*v+r*i,0,c*i+r*v,l*i+t,l*v-r*a,0,c*v-r*i,l*v+r*a,o*v*v+t,0,0,0,0,1),this}},{key:"makeScale",value:function(n,e,t){return this.set(n,0,0,0,0,e,0,0,0,0,t,0,0,0,0,1),this}},{key:"makeShear",value:function(n,e,t,r,o,a){return this.set(1,t,o,0,n,1,a,0,e,r,1,0,0,0,0,1),this}},{key:"compose",value:function(n,e,t){var r=this.elements,o=e._x,a=e._y,i=e._z,v=e._w,c=o+o,l=a+a,s=i+i,u=o*c,f=o*l,p=o*s,d=a*l,m=a*s,h=i*s,x=v*c,g=v*l,y=v*s,b=t.x,_=t.y,U=t.z;return r[0]=(1-(d+h))*b,r[1]=(f+y)*b,r[2]=(p-g)*b,r[3]=0,r[4]=(f-y)*_,r[5]=(1-(u+h))*_,r[6]=(m+x)*_,r[7]=0,r[8]=(p+g)*U,r[9]=(m-x)*U,r[10]=(1-(u+d))*U,r[11]=0,r[12]=n.x,r[13]=n.y,r[14]=n.z,r[15]=1,this}},{key:"decompose",value:function(n,e,t){var r=this.elements,o=mo.set(r[0],r[1],r[2]).length(),a=mo.set(r[4],r[5],r[6]).length(),i=mo.set(r[8],r[9],r[10]).length();this.determinant()<0&&(o=-o),n.x=r[12],n.y=r[13],n.z=r[14],ho.copy(this);var v=1/o,c=1/a,l=1/i;return ho.elements[0]*=v,ho.elements[1]*=v,ho.elements[2]*=v,ho.elements[4]*=c,ho.elements[5]*=c,ho.elements[6]*=c,ho.elements[8]*=l,ho.elements[9]*=l,ho.elements[10]*=l,e.setFromRotationMatrix(ho),t.x=o,t.y=a,t.z=i,this}},{key:"makePerspective",value:function(n,e,t,r,o,a){var i=this.elements,v=2*o/(e-n),c=2*o/(t-r),l=(e+n)/(e-n),s=(t+r)/(t-r),u=-(a+o)/(a-o),f=-2*a*o/(a-o);return i[0]=v,i[4]=0,i[8]=l,i[12]=0,i[1]=0,i[5]=c,i[9]=s,i[13]=0,i[2]=0,i[6]=0,i[10]=u,i[14]=f,i[3]=0,i[7]=0,i[11]=-1,i[15]=0,this}},{key:"makeOrthographic",value:function(n,e,t,r,o,a){var i=this.elements,v=1/(e-n),c=1/(t-r),l=1/(a-o),s=(e+n)*v,u=(t+r)*c,f=(a+o)*l;return i[0]=2*v,i[4]=0,i[8]=0,i[12]=-s,i[1]=0,i[5]=2*c,i[9]=0,i[13]=-u,i[2]=0,i[6]=0,i[10]=-2*l,i[14]=-f,i[3]=0,i[7]=0,i[11]=0,i[15]=1,this}},{key:"equals",value:function(n){for(var e=this.elements,t=n.elements,r=0;r<16;r++)if(e[r]!==t[r])return!1;return!0}},{key:"fromArray",value:function(n){for(var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=0;t<16;t++)this.elements[t]=n[t+e];return this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=this.elements;return n[e]=t[0],n[e+1]=t[1],n[e+2]=t[2],n[e+3]=t[3],n[e+4]=t[4],n[e+5]=t[5],n[e+6]=t[6],n[e+7]=t[7],n[e+8]=t[8],n[e+9]=t[9],n[e+10]=t[10],n[e+11]=t[11],n[e+12]=t[12],n[e+13]=t[13],n[e+14]=t[14],n[e+15]=t[15],n}}]),n}(),mo=new Or,ho=new po,xo=new Or(0,0,0),go=new Or(1,1,1),yo=new Or,bo=new Or,_o=new Or,Uo=new po,wo=new Ir,So=function(n){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.DefaultOrder;y(this,e),this.isEuler=!0,this._x=n,this._y=t,this._z=r,this._order=o}return _(e,[{key:"x",get:function(){return this._x},set:function(n){this._x=n,this._onChangeCallback()}},{key:"y",get:function(){return this._y},set:function(n){this._y=n,this._onChangeCallback()}},{key:"z",get:function(){return this._z},set:function(n){this._z=n,this._onChangeCallback()}},{key:"order",get:function(){return this._order},set:function(n){this._order=n,this._onChangeCallback()}},{key:"set",value:function(n,e,t){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this._order;return this._x=n,this._y=e,this._z=t,this._order=r,this._onChangeCallback(),this}},{key:"clone",value:function(){return new this.constructor(this._x,this._y,this._z,this._order)}},{key:"copy",value:function(n){return this._x=n._x,this._y=n._y,this._z=n._z,this._order=n._order,this._onChangeCallback(),this}},{key:"setFromRotationMatrix",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this._order,t=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=n.elements,o=r[0],a=r[4],i=r[8],v=r[1],c=r[5],l=r[9],s=r[2],u=r[6],f=r[10];switch(e){case"XYZ":this._y=Math.asin(Kt(i,-1,1)),Math.abs(i)<.9999999?(this._x=Math.atan2(-l,f),this._z=Math.atan2(-a,o)):(this._x=Math.atan2(u,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Kt(l,-1,1)),Math.abs(l)<.9999999?(this._y=Math.atan2(i,f),this._z=Math.atan2(v,c)):(this._y=Math.atan2(-s,o),this._z=0);break;case"ZXY":this._x=Math.asin(Kt(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-s,f),this._z=Math.atan2(-a,c)):(this._y=0,this._z=Math.atan2(v,o));break;case"ZYX":this._y=Math.asin(-Kt(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(u,f),this._z=Math.atan2(v,o)):(this._x=0,this._z=Math.atan2(-a,c));break;case"YZX":this._z=Math.asin(Kt(v,-1,1)),Math.abs(v)<.9999999?(this._x=Math.atan2(-l,c),this._y=Math.atan2(-s,o)):(this._x=0,this._y=Math.atan2(i,f));break;case"XZY":this._z=Math.asin(-Kt(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(u,c),this._y=Math.atan2(i,o)):(this._x=Math.atan2(-l,f),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===t&&this._onChangeCallback(),this}},{key:"setFromQuaternion",value:function(n,e,t){return Uo.makeRotationFromQuaternion(n),this.setFromRotationMatrix(Uo,e,t)}},{key:"setFromVector3",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this._order;return this.set(n.x,n.y,n.z,e)}},{key:"reorder",value:function(n){return wo.setFromEuler(this),this.setFromQuaternion(wo,n)}},{key:"equals",value:function(n){return n._x===this._x&&n._y===this._y&&n._z===this._z&&n._order===this._order}},{key:"fromArray",value:function(n){return this._x=n[0],this._y=n[1],this._z=n[2],void 0!==n[3]&&(this._order=n[3]),this._onChangeCallback(),this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this._x,n[e+1]=this._y,n[e+2]=this._z,n[e+3]=this._order,n}},{key:"_onChange",value:function(n){return this._onChangeCallback=n,this}},{key:"_onChangeCallback",value:function(){}},{key:Symbol.iterator,value:j().mark((function n(){return j().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this._x;case 2:return n.next=4,this._y;case 4:return n.next=6,this._z;case 6:return n.next=8,this._order;case 8:case"end":return n.stop()}}),n,this)}))},{key:"toVector3",value:function(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}]),e}();So.DefaultOrder="XYZ",So.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];var ko=function(){function n(){y(this,n),this.mask=1}return _(n,[{key:"set",value:function(n){this.mask=(1<<n|0)>>>0}},{key:"enable",value:function(n){this.mask|=1<<n|0}},{key:"enableAll",value:function(){this.mask=-1}},{key:"toggle",value:function(n){this.mask^=1<<n|0}},{key:"disable",value:function(n){this.mask&=~(1<<n|0)}},{key:"disableAll",value:function(){this.mask=0}},{key:"test",value:function(n){return 0!==(this.mask&n.mask)}},{key:"isEnabled",value:function(n){return 0!==(this.mask&(1<<n|0))}}]),n}(),Mo=0,zo=new Or,Co=new Ir,To=new po,Ro=new Or,Do=new Or,Po=new Or,jo=new Ir,Fo=new Or(1,0,0),Eo=new Or(0,1,0),Io=new Or(0,0,1),Oo={type:"added"},Lo={type:"removed"},Ao=function(n){U(t,n);var e=z(t);function t(){var n;y(this,t),(n=e.call(this)).isObject3D=!0,Object.defineProperty(k(n),"id",{value:Mo++}),n.uuid=Zt(),n.name="",n.type="Object3D",n.parent=null,n.children=[],n.up=t.DefaultUp.clone();var r=new Or,o=new So,a=new Ir,i=new Or(1,1,1);return o._onChange((function(){a.setFromEuler(o,!1)})),a._onChange((function(){o.setFromQuaternion(a,void 0,!1)})),Object.defineProperties(k(n),{position:{configurable:!0,enumerable:!0,value:r},rotation:{configurable:!0,enumerable:!0,value:o},quaternion:{configurable:!0,enumerable:!0,value:a},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new po},normalMatrix:{value:new vr}}),n.matrix=new po,n.matrixWorld=new po,n.matrixAutoUpdate=t.DefaultMatrixAutoUpdate,n.matrixWorldNeedsUpdate=!1,n.matrixWorldAutoUpdate=t.DefaultMatrixWorldAutoUpdate,n.layers=new ko,n.visible=!0,n.castShadow=!1,n.receiveShadow=!1,n.frustumCulled=!0,n.renderOrder=0,n.animations=[],n.userData={},n}return _(t,[{key:"onBeforeRender",value:function(){}},{key:"onAfterRender",value:function(){}},{key:"applyMatrix4",value:function(n){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(n),this.matrix.decompose(this.position,this.quaternion,this.scale)}},{key:"applyQuaternion",value:function(n){return this.quaternion.premultiply(n),this}},{key:"setRotationFromAxisAngle",value:function(n,e){this.quaternion.setFromAxisAngle(n,e)}},{key:"setRotationFromEuler",value:function(n){this.quaternion.setFromEuler(n,!0)}},{key:"setRotationFromMatrix",value:function(n){this.quaternion.setFromRotationMatrix(n)}},{key:"setRotationFromQuaternion",value:function(n){this.quaternion.copy(n)}},{key:"rotateOnAxis",value:function(n,e){return Co.setFromAxisAngle(n,e),this.quaternion.multiply(Co),this}},{key:"rotateOnWorldAxis",value:function(n,e){return Co.setFromAxisAngle(n,e),this.quaternion.premultiply(Co),this}},{key:"rotateX",value:function(n){return this.rotateOnAxis(Fo,n)}},{key:"rotateY",value:function(n){return this.rotateOnAxis(Eo,n)}},{key:"rotateZ",value:function(n){return this.rotateOnAxis(Io,n)}},{key:"translateOnAxis",value:function(n,e){return zo.copy(n).applyQuaternion(this.quaternion),this.position.add(zo.multiplyScalar(e)),this}},{key:"translateX",value:function(n){return this.translateOnAxis(Fo,n)}},{key:"translateY",value:function(n){return this.translateOnAxis(Eo,n)}},{key:"translateZ",value:function(n){return this.translateOnAxis(Io,n)}},{key:"localToWorld",value:function(n){return n.applyMatrix4(this.matrixWorld)}},{key:"worldToLocal",value:function(n){return n.applyMatrix4(To.copy(this.matrixWorld).invert())}},{key:"lookAt",value:function(n,e,t){n.isVector3?Ro.copy(n):Ro.set(n,e,t);var r=this.parent;this.updateWorldMatrix(!0,!1),Do.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?To.lookAt(Do,Ro,this.up):To.lookAt(Ro,Do,this.up),this.quaternion.setFromRotationMatrix(To),r&&(To.extractRotation(r.matrixWorld),Co.setFromRotationMatrix(To),this.quaternion.premultiply(Co.invert()))}},{key:"add",value:function(n){if(arguments.length>1){for(var e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return n===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",n),this):(n&&n.isObject3D?(null!==n.parent&&n.parent.remove(n),n.parent=this,this.children.push(n),n.dispatchEvent(Oo)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",n),this)}},{key:"remove",value:function(n){if(arguments.length>1){for(var e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}var t=this.children.indexOf(n);return-1!==t&&(n.parent=null,this.children.splice(t,1),n.dispatchEvent(Lo)),this}},{key:"removeFromParent",value:function(){var n=this.parent;return null!==n&&n.remove(this),this}},{key:"clear",value:function(){for(var n=0;n<this.children.length;n++){var e=this.children[n];e.parent=null,e.dispatchEvent(Lo)}return this.children.length=0,this}},{key:"attach",value:function(n){return this.updateWorldMatrix(!0,!1),To.copy(this.matrixWorld).invert(),null!==n.parent&&(n.parent.updateWorldMatrix(!0,!1),To.multiply(n.parent.matrixWorld)),n.applyMatrix4(To),this.add(n),n.updateWorldMatrix(!1,!0),this}},{key:"getObjectById",value:function(n){return this.getObjectByProperty("id",n)}},{key:"getObjectByName",value:function(n){return this.getObjectByProperty("name",n)}},{key:"getObjectByProperty",value:function(n,e){if(this[n]===e)return this;for(var t=0,r=this.children.length;t<r;t++){var o=this.children[t].getObjectByProperty(n,e);if(void 0!==o)return o}}},{key:"getWorldPosition",value:function(n){return this.updateWorldMatrix(!0,!1),n.setFromMatrixPosition(this.matrixWorld)}},{key:"getWorldQuaternion",value:function(n){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Do,n,Po),n}},{key:"getWorldScale",value:function(n){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Do,jo,n),n}},{key:"getWorldDirection",value:function(n){this.updateWorldMatrix(!0,!1);var e=this.matrixWorld.elements;return n.set(e[8],e[9],e[10]).normalize()}},{key:"raycast",value:function(){}},{key:"traverse",value:function(n){n(this);for(var e=this.children,t=0,r=e.length;t<r;t++)e[t].traverse(n)}},{key:"traverseVisible",value:function(n){if(!1!==this.visible){n(this);for(var e=this.children,t=0,r=e.length;t<r;t++)e[t].traverseVisible(n)}}},{key:"traverseAncestors",value:function(n){var e=this.parent;null!==e&&(n(e),e.traverseAncestors(n))}},{key:"updateMatrix",value:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}},{key:"updateMatrixWorld",value:function(n){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||n)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,n=!0);for(var e=this.children,t=0,r=e.length;t<r;t++){var o=e[t];!0!==o.matrixWorldAutoUpdate&&!0!==n||o.updateMatrixWorld(n)}}},{key:"updateWorldMatrix",value:function(n,e){var t=this.parent;if(!0===n&&null!==t&&!0===t.matrixWorldAutoUpdate&&t.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e)for(var r=this.children,o=0,a=r.length;o<a;o++){var i=r[o];!0===i.matrixWorldAutoUpdate&&i.updateWorldMatrix(!1,!0)}}},{key:"toJSON",value:function(n){var e=void 0===n||"string"===typeof n,t={};e&&(n={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},t.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});var r={};function o(e,t){return void 0===e[t.uuid]&&(e[t.uuid]=t.toJSON(n)),t.uuid}if(r.uuid=this.uuid,r.type=this.type,""!==this.name&&(r.name=this.name),!0===this.castShadow&&(r.castShadow=!0),!0===this.receiveShadow&&(r.receiveShadow=!0),!1===this.visible&&(r.visible=!1),!1===this.frustumCulled&&(r.frustumCulled=!1),0!==this.renderOrder&&(r.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(r.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(n).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(r.environment=this.environment.toJSON(n).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=o(n.geometries,this.geometry);var a=this.geometry.parameters;if(void 0!==a&&void 0!==a.shapes){var i=a.shapes;if(Array.isArray(i))for(var v=0,c=i.length;v<c;v++){var l=i[v];o(n.shapes,l)}else o(n.shapes,i)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(o(n.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){for(var s=[],u=0,f=this.material.length;u<f;u++)s.push(o(n.materials,this.material[u]));r.material=s}else r.material=o(n.materials,this.material);if(this.children.length>0){r.children=[];for(var p=0;p<this.children.length;p++)r.children.push(this.children[p].toJSON(n).object)}if(this.animations.length>0){r.animations=[];for(var d=0;d<this.animations.length;d++){var m=this.animations[d];r.animations.push(o(n.animations,m))}}if(e){var h=S(n.geometries),x=S(n.materials),g=S(n.textures),y=S(n.images),b=S(n.shapes),_=S(n.skeletons),U=S(n.animations),w=S(n.nodes);h.length>0&&(t.geometries=h),x.length>0&&(t.materials=x),g.length>0&&(t.textures=g),y.length>0&&(t.images=y),b.length>0&&(t.shapes=b),_.length>0&&(t.skeletons=_),U.length>0&&(t.animations=U),w.length>0&&(t.nodes=w)}return t.object=r,t;function S(n){var e=[];for(var t in n){var r=n[t];delete r.metadata,e.push(r)}return e}}},{key:"clone",value:function(n){return(new this.constructor).copy(this,n)}},{key:"copy",value:function(n){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(this.name=n.name,this.up.copy(n.up),this.position.copy(n.position),this.rotation.order=n.rotation.order,this.quaternion.copy(n.quaternion),this.scale.copy(n.scale),this.matrix.copy(n.matrix),this.matrixWorld.copy(n.matrixWorld),this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrixWorldNeedsUpdate=n.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=n.matrixWorldAutoUpdate,this.layers.mask=n.layers.mask,this.visible=n.visible,this.castShadow=n.castShadow,this.receiveShadow=n.receiveShadow,this.frustumCulled=n.frustumCulled,this.renderOrder=n.renderOrder,this.userData=JSON.parse(JSON.stringify(n.userData)),!0===e)for(var t=0;t<n.children.length;t++){var r=n.children[t];this.add(r.clone())}return this}}]),t}(Wt);Ao.DefaultUp=new Or(0,1,0),Ao.DefaultMatrixAutoUpdate=!0,Ao.DefaultMatrixWorldAutoUpdate=!0;var No=new Or,Go=new Or,Bo=new Or,qo=new Or,Vo=new Or,Wo=new Or,Ho=new Or,Xo=new Or,Yo=new Or,$o=new Or,Zo=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Or,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Or,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Or;y(this,n),this.a=e,this.b=t,this.c=r}return _(n,[{key:"set",value:function(n,e,t){return this.a.copy(n),this.b.copy(e),this.c.copy(t),this}},{key:"setFromPointsAndIndices",value:function(n,e,t,r){return this.a.copy(n[e]),this.b.copy(n[t]),this.c.copy(n[r]),this}},{key:"setFromAttributeAndIndices",value:function(n,e,t,r){return this.a.fromBufferAttribute(n,e),this.b.fromBufferAttribute(n,t),this.c.fromBufferAttribute(n,r),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){return this.a.copy(n.a),this.b.copy(n.b),this.c.copy(n.c),this}},{key:"getArea",value:function(){return No.subVectors(this.c,this.b),Go.subVectors(this.a,this.b),.5*No.cross(Go).length()}},{key:"getMidpoint",value:function(n){return n.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}},{key:"getNormal",value:function(e){return n.getNormal(this.a,this.b,this.c,e)}},{key:"getPlane",value:function(n){return n.setFromCoplanarPoints(this.a,this.b,this.c)}},{key:"getBarycoord",value:function(e,t){return n.getBarycoord(e,this.a,this.b,this.c,t)}},{key:"getUV",value:function(e,t,r,o,a){return n.getUV(e,this.a,this.b,this.c,t,r,o,a)}},{key:"containsPoint",value:function(e){return n.containsPoint(e,this.a,this.b,this.c)}},{key:"isFrontFacing",value:function(e){return n.isFrontFacing(this.a,this.b,this.c,e)}},{key:"intersectsBox",value:function(n){return n.intersectsTriangle(this)}},{key:"closestPointToPoint",value:function(n,e){var t,r,o=this.a,a=this.b,i=this.c;Vo.subVectors(a,o),Wo.subVectors(i,o),Xo.subVectors(n,o);var v=Vo.dot(Xo),c=Wo.dot(Xo);if(v<=0&&c<=0)return e.copy(o);Yo.subVectors(n,a);var l=Vo.dot(Yo),s=Wo.dot(Yo);if(l>=0&&s<=l)return e.copy(a);var u=v*s-l*c;if(u<=0&&v>=0&&l<=0)return t=v/(v-l),e.copy(o).addScaledVector(Vo,t);$o.subVectors(n,i);var f=Vo.dot($o),p=Wo.dot($o);if(p>=0&&f<=p)return e.copy(i);var d=f*c-v*p;if(d<=0&&c>=0&&p<=0)return r=c/(c-p),e.copy(o).addScaledVector(Wo,r);var m=l*p-f*s;if(m<=0&&s-l>=0&&f-p>=0)return Ho.subVectors(i,a),r=(s-l)/(s-l+(f-p)),e.copy(a).addScaledVector(Ho,r);var h=1/(m+d+u);return t=d*h,r=u*h,e.copy(o).addScaledVector(Vo,t).addScaledVector(Wo,r)}},{key:"equals",value:function(n){return n.a.equals(this.a)&&n.b.equals(this.b)&&n.c.equals(this.c)}}],[{key:"getNormal",value:function(n,e,t,r){r.subVectors(t,e),No.subVectors(n,e),r.cross(No);var o=r.lengthSq();return o>0?r.multiplyScalar(1/Math.sqrt(o)):r.set(0,0,0)}},{key:"getBarycoord",value:function(n,e,t,r,o){No.subVectors(r,e),Go.subVectors(t,e),Bo.subVectors(n,e);var a=No.dot(No),i=No.dot(Go),v=No.dot(Bo),c=Go.dot(Go),l=Go.dot(Bo),s=a*c-i*i;if(0===s)return o.set(-2,-1,-1);var u=1/s,f=(c*v-i*l)*u,p=(a*l-i*v)*u;return o.set(1-f-p,p,f)}},{key:"containsPoint",value:function(n,e,t,r){return this.getBarycoord(n,e,t,r,qo),qo.x>=0&&qo.y>=0&&qo.x+qo.y<=1}},{key:"getUV",value:function(n,e,t,r,o,a,i,v){return this.getBarycoord(n,e,t,r,qo),v.set(0,0),v.addScaledVector(o,qo.x),v.addScaledVector(a,qo.y),v.addScaledVector(i,qo.z),v}},{key:"isFrontFacing",value:function(n,e,t,r){return No.subVectors(t,e),Go.subVectors(n,e),No.cross(Go).dot(r)<0}}]),n}(),Ko=0,Jo=function(n){U(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).isMaterial=!0,Object.defineProperty(k(n),"id",{value:Ko++}),n.uuid=Zt(),n.name="",n.type="Material",n.blending=$,n.side=W,n.vertexColors=!1,n.opacity=1,n.transparent=!1,n.blendSrc=sn,n.blendDst=un,n.blendEquation=nn,n.blendSrcAlpha=null,n.blendDstAlpha=null,n.blendEquationAlpha=null,n.depthFunc=bn,n.depthTest=!0,n.depthWrite=!0,n.stencilWriteMask=255,n.stencilFunc=Pt,n.stencilRef=0,n.stencilFuncMask=255,n.stencilFail=gt,n.stencilZFail=gt,n.stencilZPass=gt,n.stencilWrite=!1,n.clippingPlanes=null,n.clipIntersection=!1,n.clipShadows=!1,n.shadowSide=null,n.colorWrite=!0,n.precision=null,n.polygonOffset=!1,n.polygonOffsetFactor=0,n.polygonOffsetUnits=0,n.dithering=!1,n.alphaToCoverage=!1,n.premultipliedAlpha=!1,n.visible=!0,n.toneMapped=!0,n.userData={},n.version=0,n._alphaTest=0,n}return _(t,[{key:"alphaTest",get:function(){return this._alphaTest},set:function(n){this._alphaTest>0!==n>0&&this.version++,this._alphaTest=n}},{key:"onBuild",value:function(){}},{key:"onBeforeRender",value:function(){}},{key:"onBeforeCompile",value:function(){}},{key:"customProgramCacheKey",value:function(){return this.onBeforeCompile.toString()}},{key:"setValues",value:function(n){if(void 0!==n)for(var e in n){var t=n[e];if(void 0!==t){var r=this[e];void 0!==r?r&&r.isColor?r.set(t):r&&r.isVector3&&t&&t.isVector3?r.copy(t):this[e]=t:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}else console.warn("THREE.Material: '"+e+"' parameter is undefined.")}}},{key:"toJSON",value:function(n){var e=void 0===n||"string"===typeof n;e&&(n={textures:{},images:{}});var t={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function r(n){var e=[];for(var t in n){var r=n[t];delete r.metadata,e.push(r)}return e}if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),this.color&&this.color.isColor&&(t.color=this.color.getHex()),void 0!==this.roughness&&(t.roughness=this.roughness),void 0!==this.metalness&&(t.metalness=this.metalness),void 0!==this.sheen&&(t.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(t.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(t.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(t.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(t.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(t.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(t.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(t.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(t.shininess=this.shininess),void 0!==this.clearcoat&&(t.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(t.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(t.clearcoatMap=this.clearcoatMap.toJSON(n).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(t.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(n).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(t.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(n).uuid,t.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.iridescence&&(t.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(t.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(t.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(t.iridescenceMap=this.iridescenceMap.toJSON(n).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(t.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(n).uuid),this.map&&this.map.isTexture&&(t.map=this.map.toJSON(n).uuid),this.matcap&&this.matcap.isTexture&&(t.matcap=this.matcap.toJSON(n).uuid),this.alphaMap&&this.alphaMap.isTexture&&(t.alphaMap=this.alphaMap.toJSON(n).uuid),this.lightMap&&this.lightMap.isTexture&&(t.lightMap=this.lightMap.toJSON(n).uuid,t.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(t.aoMap=this.aoMap.toJSON(n).uuid,t.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(t.bumpMap=this.bumpMap.toJSON(n).uuid,t.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(t.normalMap=this.normalMap.toJSON(n).uuid,t.normalMapType=this.normalMapType,t.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(t.displacementMap=this.displacementMap.toJSON(n).uuid,t.displacementScale=this.displacementScale,t.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(t.roughnessMap=this.roughnessMap.toJSON(n).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(t.metalnessMap=this.metalnessMap.toJSON(n).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(t.emissiveMap=this.emissiveMap.toJSON(n).uuid),this.specularMap&&this.specularMap.isTexture&&(t.specularMap=this.specularMap.toJSON(n).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(t.specularIntensityMap=this.specularIntensityMap.toJSON(n).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(t.specularColorMap=this.specularColorMap.toJSON(n).uuid),this.envMap&&this.envMap.isTexture&&(t.envMap=this.envMap.toJSON(n).uuid,void 0!==this.combine&&(t.combine=this.combine)),void 0!==this.envMapIntensity&&(t.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(t.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(t.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(t.gradientMap=this.gradientMap.toJSON(n).uuid),void 0!==this.transmission&&(t.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(t.transmissionMap=this.transmissionMap.toJSON(n).uuid),void 0!==this.thickness&&(t.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(t.thicknessMap=this.thicknessMap.toJSON(n).uuid),void 0!==this.attenuationDistance&&this.attenuationDistance!==1/0&&(t.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(t.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(t.size=this.size),null!==this.shadowSide&&(t.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(t.sizeAttenuation=this.sizeAttenuation),this.blending!==$&&(t.blending=this.blending),this.side!==W&&(t.side=this.side),this.vertexColors&&(t.vertexColors=!0),this.opacity<1&&(t.opacity=this.opacity),!0===this.transparent&&(t.transparent=this.transparent),t.depthFunc=this.depthFunc,t.depthTest=this.depthTest,t.depthWrite=this.depthWrite,t.colorWrite=this.colorWrite,t.stencilWrite=this.stencilWrite,t.stencilWriteMask=this.stencilWriteMask,t.stencilFunc=this.stencilFunc,t.stencilRef=this.stencilRef,t.stencilFuncMask=this.stencilFuncMask,t.stencilFail=this.stencilFail,t.stencilZFail=this.stencilZFail,t.stencilZPass=this.stencilZPass,void 0!==this.rotation&&0!==this.rotation&&(t.rotation=this.rotation),!0===this.polygonOffset&&(t.polygonOffset=!0),0!==this.polygonOffsetFactor&&(t.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(t.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(t.linewidth=this.linewidth),void 0!==this.dashSize&&(t.dashSize=this.dashSize),void 0!==this.gapSize&&(t.gapSize=this.gapSize),void 0!==this.scale&&(t.scale=this.scale),!0===this.dithering&&(t.dithering=!0),this.alphaTest>0&&(t.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(t.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(t.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(t.wireframe=this.wireframe),this.wireframeLinewidth>1&&(t.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(t.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(t.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(t.flatShading=this.flatShading),!1===this.visible&&(t.visible=!1),!1===this.toneMapped&&(t.toneMapped=!1),!1===this.fog&&(t.fog=!1),"{}"!==JSON.stringify(this.userData)&&(t.userData=this.userData),e){var o=r(n.textures),a=r(n.images);o.length>0&&(t.textures=o),a.length>0&&(t.images=a)}return t}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){this.name=n.name,this.blending=n.blending,this.side=n.side,this.vertexColors=n.vertexColors,this.opacity=n.opacity,this.transparent=n.transparent,this.blendSrc=n.blendSrc,this.blendDst=n.blendDst,this.blendEquation=n.blendEquation,this.blendSrcAlpha=n.blendSrcAlpha,this.blendDstAlpha=n.blendDstAlpha,this.blendEquationAlpha=n.blendEquationAlpha,this.depthFunc=n.depthFunc,this.depthTest=n.depthTest,this.depthWrite=n.depthWrite,this.stencilWriteMask=n.stencilWriteMask,this.stencilFunc=n.stencilFunc,this.stencilRef=n.stencilRef,this.stencilFuncMask=n.stencilFuncMask,this.stencilFail=n.stencilFail,this.stencilZFail=n.stencilZFail,this.stencilZPass=n.stencilZPass,this.stencilWrite=n.stencilWrite;var e=n.clippingPlanes,t=null;if(null!==e){var r=e.length;t=new Array(r);for(var o=0;o!==r;++o)t[o]=e[o].clone()}return this.clippingPlanes=t,this.clipIntersection=n.clipIntersection,this.clipShadows=n.clipShadows,this.shadowSide=n.shadowSide,this.colorWrite=n.colorWrite,this.precision=n.precision,this.polygonOffset=n.polygonOffset,this.polygonOffsetFactor=n.polygonOffsetFactor,this.polygonOffsetUnits=n.polygonOffsetUnits,this.dithering=n.dithering,this.alphaTest=n.alphaTest,this.alphaToCoverage=n.alphaToCoverage,this.premultipliedAlpha=n.premultipliedAlpha,this.visible=n.visible,this.toneMapped=n.toneMapped,this.userData=JSON.parse(JSON.stringify(n.userData)),this}},{key:"dispose",value:function(){this.dispatchEvent({type:"dispose"})}},{key:"needsUpdate",set:function(n){!0===n&&this.version++}}]),t}(Wt),Qo=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).isMeshBasicMaterial=!0,r.type="MeshBasicMaterial",r.color=new wr(16777215),r.map=null,r.lightMap=null,r.lightMapIntensity=1,r.aoMap=null,r.aoMapIntensity=1,r.specularMap=null,r.alphaMap=null,r.envMap=null,r.combine=kn,r.reflectivity=1,r.refractionRatio=.98,r.wireframe=!1,r.wireframeLinewidth=1,r.wireframeLinecap="round",r.wireframeLinejoin="round",r.fog=!0,r.setValues(n),r}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.fog=n.fog,this}}]),t}(Jo),na=new Or,ea=new ir,ta=function(){function n(e,t,r){if(y(this,n),Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=void 0!==e?e.length/t:0,this.normalized=!0===r,this.usage=jt,this.updateRange={offset:0,count:-1},this.version=0}return _(n,[{key:"onUploadCallback",value:function(){}},{key:"needsUpdate",set:function(n){!0===n&&this.version++}},{key:"setUsage",value:function(n){return this.usage=n,this}},{key:"copy",value:function(n){return this.name=n.name,this.array=new n.array.constructor(n.array),this.itemSize=n.itemSize,this.count=n.count,this.normalized=n.normalized,this.usage=n.usage,this}},{key:"copyAt",value:function(n,e,t){n*=this.itemSize,t*=e.itemSize;for(var r=0,o=this.itemSize;r<o;r++)this.array[n+r]=e.array[t+r];return this}},{key:"copyArray",value:function(n){return this.array.set(n),this}},{key:"applyMatrix3",value:function(n){if(2===this.itemSize)for(var e=0,t=this.count;e<t;e++)ea.fromBufferAttribute(this,e),ea.applyMatrix3(n),this.setXY(e,ea.x,ea.y);else if(3===this.itemSize)for(var r=0,o=this.count;r<o;r++)na.fromBufferAttribute(this,r),na.applyMatrix3(n),this.setXYZ(r,na.x,na.y,na.z);return this}},{key:"applyMatrix4",value:function(n){for(var e=0,t=this.count;e<t;e++)na.fromBufferAttribute(this,e),na.applyMatrix4(n),this.setXYZ(e,na.x,na.y,na.z);return this}},{key:"applyNormalMatrix",value:function(n){for(var e=0,t=this.count;e<t;e++)na.fromBufferAttribute(this,e),na.applyNormalMatrix(n),this.setXYZ(e,na.x,na.y,na.z);return this}},{key:"transformDirection",value:function(n){for(var e=0,t=this.count;e<t;e++)na.fromBufferAttribute(this,e),na.transformDirection(n),this.setXYZ(e,na.x,na.y,na.z);return this}},{key:"set",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.array.set(n,e),this}},{key:"getX",value:function(n){var e=this.array[n*this.itemSize];return this.normalized&&(e=rr(e,this.array)),e}},{key:"setX",value:function(n,e){return this.normalized&&(e=or(e,this.array)),this.array[n*this.itemSize]=e,this}},{key:"getY",value:function(n){var e=this.array[n*this.itemSize+1];return this.normalized&&(e=rr(e,this.array)),e}},{key:"setY",value:function(n,e){return this.normalized&&(e=or(e,this.array)),this.array[n*this.itemSize+1]=e,this}},{key:"getZ",value:function(n){var e=this.array[n*this.itemSize+2];return this.normalized&&(e=rr(e,this.array)),e}},{key:"setZ",value:function(n,e){return this.normalized&&(e=or(e,this.array)),this.array[n*this.itemSize+2]=e,this}},{key:"getW",value:function(n){var e=this.array[n*this.itemSize+3];return this.normalized&&(e=rr(e,this.array)),e}},{key:"setW",value:function(n,e){return this.normalized&&(e=or(e,this.array)),this.array[n*this.itemSize+3]=e,this}},{key:"setXY",value:function(n,e,t){return n*=this.itemSize,this.normalized&&(e=or(e,this.array),t=or(t,this.array)),this.array[n+0]=e,this.array[n+1]=t,this}},{key:"setXYZ",value:function(n,e,t,r){return n*=this.itemSize,this.normalized&&(e=or(e,this.array),t=or(t,this.array),r=or(r,this.array)),this.array[n+0]=e,this.array[n+1]=t,this.array[n+2]=r,this}},{key:"setXYZW",value:function(n,e,t,r,o){return n*=this.itemSize,this.normalized&&(e=or(e,this.array),t=or(t,this.array),r=or(r,this.array),o=or(o,this.array)),this.array[n+0]=e,this.array[n+1]=t,this.array[n+2]=r,this.array[n+3]=o,this}},{key:"onUpload",value:function(n){return this.onUploadCallback=n,this}},{key:"clone",value:function(){return new this.constructor(this.array,this.itemSize).copy(this)}},{key:"toJSON",value:function(){var n={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(n.name=this.name),this.usage!==jt&&(n.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(n.updateRange=this.updateRange),n}},{key:"copyColorsArray",value:function(){console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")}},{key:"copyVector2sArray",value:function(){console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")}},{key:"copyVector3sArray",value:function(){console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")}},{key:"copyVector4sArray",value:function(){console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")}}]),n}(),ra=function(n){U(t,n);var e=z(t);function t(n,r,o){return y(this,t),e.call(this,new Int8Array(n),r,o)}return _(t)}(ta),oa=function(n){U(t,n);var e=z(t);function t(n,r,o){return y(this,t),e.call(this,new Uint8Array(n),r,o)}return _(t)}(ta),aa=function(n){U(t,n);var e=z(t);function t(n,r,o){return y(this,t),e.call(this,new Uint8ClampedArray(n),r,o)}return _(t)}(ta),ia=function(n){U(t,n);var e=z(t);function t(n,r,o){return y(this,t),e.call(this,new Int16Array(n),r,o)}return _(t)}(ta),va=function(n){U(t,n);var e=z(t);function t(n,r,o){return y(this,t),e.call(this,new Uint16Array(n),r,o)}return _(t)}(ta),ca=function(n){U(t,n);var e=z(t);function t(n,r,o){return y(this,t),e.call(this,new Int32Array(n),r,o)}return _(t)}(ta),la=function(n){U(t,n);var e=z(t);function t(n,r,o){return y(this,t),e.call(this,new Uint32Array(n),r,o)}return _(t)}(ta),sa=function(n){U(t,n);var e=z(t);function t(n,r,o){var a;return y(this,t),(a=e.call(this,new Uint16Array(n),r,o)).isFloat16BufferAttribute=!0,a}return _(t)}(ta),ua=function(n){U(t,n);var e=z(t);function t(n,r,o){return y(this,t),e.call(this,new Float32Array(n),r,o)}return _(t)}(ta),fa=function(n){U(t,n);var e=z(t);function t(n,r,o){return y(this,t),e.call(this,new Float64Array(n),r,o)}return _(t)}(ta),pa=0,da=new po,ma=new Ao,ha=new Or,xa=new Nr,ga=new Nr,ya=new Or,ba=function(n){U(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).isBufferGeometry=!0,Object.defineProperty(k(n),"id",{value:pa++}),n.uuid=Zt(),n.name="",n.type="BufferGeometry",n.index=null,n.attributes={},n.morphAttributes={},n.morphTargetsRelative=!1,n.groups=[],n.boundingBox=null,n.boundingSphere=null,n.drawRange={start:0,count:1/0},n.userData={},n}return _(t,[{key:"getIndex",value:function(){return this.index}},{key:"setIndex",value:function(n){return Array.isArray(n)?this.index=new(cr(n)?la:va)(n,1):this.index=n,this}},{key:"getAttribute",value:function(n){return this.attributes[n]}},{key:"setAttribute",value:function(n,e){return this.attributes[n]=e,this}},{key:"deleteAttribute",value:function(n){return delete this.attributes[n],this}},{key:"hasAttribute",value:function(n){return void 0!==this.attributes[n]}},{key:"addGroup",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.groups.push({start:n,count:e,materialIndex:t})}},{key:"clearGroups",value:function(){this.groups=[]}},{key:"setDrawRange",value:function(n,e){this.drawRange.start=n,this.drawRange.count=e}},{key:"applyMatrix4",value:function(n){var e=this.attributes.position;void 0!==e&&(e.applyMatrix4(n),e.needsUpdate=!0);var t=this.attributes.normal;if(void 0!==t){var r=(new vr).getNormalMatrix(n);t.applyNormalMatrix(r),t.needsUpdate=!0}var o=this.attributes.tangent;return void 0!==o&&(o.transformDirection(n),o.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}},{key:"applyQuaternion",value:function(n){return da.makeRotationFromQuaternion(n),this.applyMatrix4(da),this}},{key:"rotateX",value:function(n){return da.makeRotationX(n),this.applyMatrix4(da),this}},{key:"rotateY",value:function(n){return da.makeRotationY(n),this.applyMatrix4(da),this}},{key:"rotateZ",value:function(n){return da.makeRotationZ(n),this.applyMatrix4(da),this}},{key:"translate",value:function(n,e,t){return da.makeTranslation(n,e,t),this.applyMatrix4(da),this}},{key:"scale",value:function(n,e,t){return da.makeScale(n,e,t),this.applyMatrix4(da),this}},{key:"lookAt",value:function(n){return ma.lookAt(n),ma.updateMatrix(),this.applyMatrix4(ma.matrix),this}},{key:"center",value:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(ha).negate(),this.translate(ha.x,ha.y,ha.z),this}},{key:"setFromPoints",value:function(n){for(var e=[],t=0,r=n.length;t<r;t++){var o=n[t];e.push(o.x,o.y,o.z||0)}return this.setAttribute("position",new ua(e,3)),this}},{key:"computeBoundingBox",value:function(){null===this.boundingBox&&(this.boundingBox=new Nr);var n=this.attributes.position,e=this.morphAttributes.position;if(n&&n.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new Or(-1/0,-1/0,-1/0),new Or(1/0,1/0,1/0));if(void 0!==n){if(this.boundingBox.setFromBufferAttribute(n),e)for(var t=0,r=e.length;t<r;t++){var o=e[t];xa.setFromBufferAttribute(o),this.morphTargetsRelative?(ya.addVectors(this.boundingBox.min,xa.min),this.boundingBox.expandByPoint(ya),ya.addVectors(this.boundingBox.max,xa.max),this.boundingBox.expandByPoint(ya)):(this.boundingBox.expandByPoint(xa.min),this.boundingBox.expandByPoint(xa.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}},{key:"computeBoundingSphere",value:function(){null===this.boundingSphere&&(this.boundingSphere=new oo);var n=this.attributes.position,e=this.morphAttributes.position;if(n&&n.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new Or,1/0);if(n){var t=this.boundingSphere.center;if(xa.setFromBufferAttribute(n),e)for(var r=0,o=e.length;r<o;r++){var a=e[r];ga.setFromBufferAttribute(a),this.morphTargetsRelative?(ya.addVectors(xa.min,ga.min),xa.expandByPoint(ya),ya.addVectors(xa.max,ga.max),xa.expandByPoint(ya)):(xa.expandByPoint(ga.min),xa.expandByPoint(ga.max))}xa.getCenter(t);for(var i=0,v=0,c=n.count;v<c;v++)ya.fromBufferAttribute(n,v),i=Math.max(i,t.distanceToSquared(ya));if(e)for(var l=0,s=e.length;l<s;l++)for(var u=e[l],f=this.morphTargetsRelative,p=0,d=u.count;p<d;p++)ya.fromBufferAttribute(u,p),f&&(ha.fromBufferAttribute(n,p),ya.add(ha)),i=Math.max(i,t.distanceToSquared(ya));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}},{key:"computeTangents",value:function(){var n=this.index,e=this.attributes;if(null!==n&&void 0!==e.position&&void 0!==e.normal&&void 0!==e.uv){var t=n.array,r=e.position.array,o=e.normal.array,a=e.uv.array,i=r.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new ta(new Float32Array(4*i),4));for(var v=this.getAttribute("tangent").array,c=[],l=[],s=0;s<i;s++)c[s]=new Or,l[s]=new Or;var u=new Or,f=new Or,p=new Or,d=new ir,m=new ir,h=new ir,x=new Or,g=new Or,y=this.groups;0===y.length&&(y=[{start:0,count:t.length}]);for(var b=0,_=y.length;b<_;++b)for(var U=y[b],w=U.start,S=w,k=w+U.count;S<k;S+=3)I(t[S+0],t[S+1],t[S+2]);for(var M=new Or,z=new Or,C=new Or,T=new Or,R=0,D=y.length;R<D;++R)for(var P=y[R],j=P.start,F=j,E=j+P.count;F<E;F+=3)O(t[F+0]),O(t[F+1]),O(t[F+2])}else console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");function I(n,e,t){u.fromArray(r,3*n),f.fromArray(r,3*e),p.fromArray(r,3*t),d.fromArray(a,2*n),m.fromArray(a,2*e),h.fromArray(a,2*t),f.sub(u),p.sub(u),m.sub(d),h.sub(d);var o=1/(m.x*h.y-h.x*m.y);isFinite(o)&&(x.copy(f).multiplyScalar(h.y).addScaledVector(p,-m.y).multiplyScalar(o),g.copy(p).multiplyScalar(m.x).addScaledVector(f,-h.x).multiplyScalar(o),c[n].add(x),c[e].add(x),c[t].add(x),l[n].add(g),l[e].add(g),l[t].add(g))}function O(n){C.fromArray(o,3*n),T.copy(C);var e=c[n];M.copy(e),M.sub(C.multiplyScalar(C.dot(e))).normalize(),z.crossVectors(T,e);var t=z.dot(l[n])<0?-1:1;v[4*n]=M.x,v[4*n+1]=M.y,v[4*n+2]=M.z,v[4*n+3]=t}}},{key:"computeVertexNormals",value:function(){var n=this.index,e=this.getAttribute("position");if(void 0!==e){var t=this.getAttribute("normal");if(void 0===t)t=new ta(new Float32Array(3*e.count),3),this.setAttribute("normal",t);else for(var r=0,o=t.count;r<o;r++)t.setXYZ(r,0,0,0);var a=new Or,i=new Or,v=new Or,c=new Or,l=new Or,s=new Or,u=new Or,f=new Or;if(n)for(var p=0,d=n.count;p<d;p+=3){var m=n.getX(p+0),h=n.getX(p+1),x=n.getX(p+2);a.fromBufferAttribute(e,m),i.fromBufferAttribute(e,h),v.fromBufferAttribute(e,x),u.subVectors(v,i),f.subVectors(a,i),u.cross(f),c.fromBufferAttribute(t,m),l.fromBufferAttribute(t,h),s.fromBufferAttribute(t,x),c.add(u),l.add(u),s.add(u),t.setXYZ(m,c.x,c.y,c.z),t.setXYZ(h,l.x,l.y,l.z),t.setXYZ(x,s.x,s.y,s.z)}else for(var g=0,y=e.count;g<y;g+=3)a.fromBufferAttribute(e,g+0),i.fromBufferAttribute(e,g+1),v.fromBufferAttribute(e,g+2),u.subVectors(v,i),f.subVectors(a,i),u.cross(f),t.setXYZ(g+0,u.x,u.y,u.z),t.setXYZ(g+1,u.x,u.y,u.z),t.setXYZ(g+2,u.x,u.y,u.z);this.normalizeNormals(),t.needsUpdate=!0}}},{key:"merge",value:function(){return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),this}},{key:"normalizeNormals",value:function(){for(var n=this.attributes.normal,e=0,t=n.count;e<t;e++)ya.fromBufferAttribute(n,e),ya.normalize(),n.setXYZ(e,ya.x,ya.y,ya.z)}},{key:"toNonIndexed",value:function(){function n(n,e){for(var t=n.array,r=n.itemSize,o=n.normalized,a=new t.constructor(e.length*r),i=0,v=0,c=0,l=e.length;c<l;c++){i=n.isInterleavedBufferAttribute?e[c]*n.data.stride+n.offset:e[c]*r;for(var s=0;s<r;s++)a[v++]=t[i++]}return new ta(a,r,o)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;var e=new t,r=this.index.array,o=this.attributes;for(var a in o){var i=n(o[a],r);e.setAttribute(a,i)}var v=this.morphAttributes;for(var c in v){for(var l=[],s=v[c],u=0,f=s.length;u<f;u++){var p=n(s[u],r);l.push(p)}e.morphAttributes[c]=l}e.morphTargetsRelative=this.morphTargetsRelative;for(var d=this.groups,m=0,h=d.length;m<h;m++){var x=d[m];e.addGroup(x.start,x.count,x.materialIndex)}return e}},{key:"toJSON",value:function(){var n={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),Object.keys(this.userData).length>0&&(n.userData=this.userData),void 0!==this.parameters){var e=this.parameters;for(var t in e)void 0!==e[t]&&(n[t]=e[t]);return n}n.data={attributes:{}};var r=this.index;null!==r&&(n.data.index={type:r.array.constructor.name,array:Array.prototype.slice.call(r.array)});var o=this.attributes;for(var a in o){var i=o[a];n.data.attributes[a]=i.toJSON(n.data)}var v={},c=!1;for(var l in this.morphAttributes){for(var s=this.morphAttributes[l],u=[],f=0,p=s.length;f<p;f++){var d=s[f];u.push(d.toJSON(n.data))}u.length>0&&(v[l]=u,c=!0)}c&&(n.data.morphAttributes=v,n.data.morphTargetsRelative=this.morphTargetsRelative);var m=this.groups;m.length>0&&(n.data.groups=JSON.parse(JSON.stringify(m)));var h=this.boundingSphere;return null!==h&&(n.data.boundingSphere={center:h.center.toArray(),radius:h.radius}),n}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;var e={};this.name=n.name;var t=n.index;null!==t&&this.setIndex(t.clone(e));var r=n.attributes;for(var o in r){var a=r[o];this.setAttribute(o,a.clone(e))}var i=n.morphAttributes;for(var v in i){for(var c=[],l=i[v],s=0,u=l.length;s<u;s++)c.push(l[s].clone(e));this.morphAttributes[v]=c}this.morphTargetsRelative=n.morphTargetsRelative;for(var f=n.groups,p=0,d=f.length;p<d;p++){var m=f[p];this.addGroup(m.start,m.count,m.materialIndex)}var h=n.boundingBox;null!==h&&(this.boundingBox=h.clone());var x=n.boundingSphere;return null!==x&&(this.boundingSphere=x.clone()),this.drawRange.start=n.drawRange.start,this.drawRange.count=n.drawRange.count,this.userData=n.userData,void 0!==n.parameters&&(this.parameters=Object.assign({},n.parameters)),this}},{key:"dispose",value:function(){this.dispatchEvent({type:"dispose"})}}]),t}(Wt),_a=new po,Ua=new fo,wa=new oo,Sa=new Or,ka=new Or,Ma=new Or,za=new Or,Ca=new Or,Ta=new Or,Ra=new Or,Da=new Or,Pa=new Or,ja=new ir,Fa=new ir,Ea=new ir,Ia=new Or,Oa=new Or,La=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ba,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Qo;return y(this,t),(n=e.call(this)).isMesh=!0,n.type="Mesh",n.geometry=r,n.material=o,n.updateMorphTargets(),n}return _(t,[{key:"copy",value:function(n,e){return P(w(t.prototype),"copy",this).call(this,n,e),void 0!==n.morphTargetInfluences&&(this.morphTargetInfluences=n.morphTargetInfluences.slice()),void 0!==n.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},n.morphTargetDictionary)),this.material=n.material,this.geometry=n.geometry,this}},{key:"updateMorphTargets",value:function(){var n=this.geometry.morphAttributes,e=Object.keys(n);if(e.length>0){var t=n[e[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(var r=0,o=t.length;r<o;r++){var a=t[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}},{key:"raycast",value:function(n,e){var t=this.geometry,r=this.material,o=this.matrixWorld;if(void 0!==r&&(null===t.boundingSphere&&t.computeBoundingSphere(),wa.copy(t.boundingSphere),wa.applyMatrix4(o),!1!==n.ray.intersectsSphere(wa)&&(_a.copy(o).invert(),Ua.copy(n.ray).applyMatrix4(_a),null===t.boundingBox||!1!==Ua.intersectsBox(t.boundingBox)))){var a,i=t.index,v=t.attributes.position,c=t.morphAttributes.position,l=t.morphTargetsRelative,s=t.attributes.uv,u=t.attributes.uv2,f=t.groups,p=t.drawRange;if(null!==i)if(Array.isArray(r))for(var d=0,m=f.length;d<m;d++)for(var h=f[d],x=r[h.materialIndex],g=Math.max(h.start,p.start),y=Math.min(i.count,Math.min(h.start+h.count,p.start+p.count));g<y;g+=3){var b=i.getX(g),_=i.getX(g+1),U=i.getX(g+2);(a=Aa(this,x,n,Ua,v,c,l,s,u,b,_,U))&&(a.faceIndex=Math.floor(g/3),a.face.materialIndex=h.materialIndex,e.push(a))}else for(var w=Math.max(0,p.start),S=Math.min(i.count,p.start+p.count);w<S;w+=3){var k=i.getX(w),M=i.getX(w+1),z=i.getX(w+2);(a=Aa(this,r,n,Ua,v,c,l,s,u,k,M,z))&&(a.faceIndex=Math.floor(w/3),e.push(a))}else if(void 0!==v)if(Array.isArray(r))for(var C=0,T=f.length;C<T;C++)for(var R=f[C],D=r[R.materialIndex],P=Math.max(R.start,p.start),j=Math.min(v.count,Math.min(R.start+R.count,p.start+p.count));P<j;P+=3){(a=Aa(this,D,n,Ua,v,c,l,s,u,P,P+1,P+2))&&(a.faceIndex=Math.floor(P/3),a.face.materialIndex=R.materialIndex,e.push(a))}else for(var F=Math.max(0,p.start),E=Math.min(v.count,p.start+p.count);F<E;F+=3){(a=Aa(this,r,n,Ua,v,c,l,s,u,F,F+1,F+2))&&(a.faceIndex=Math.floor(F/3),e.push(a))}}}}]),t}(Ao);function Aa(n,e,t,r,o,a,i,v,c,l,s,u){Sa.fromBufferAttribute(o,l),ka.fromBufferAttribute(o,s),Ma.fromBufferAttribute(o,u);var f=n.morphTargetInfluences;if(a&&f){Ra.set(0,0,0),Da.set(0,0,0),Pa.set(0,0,0);for(var p=0,d=a.length;p<d;p++){var m=f[p],h=a[p];0!==m&&(za.fromBufferAttribute(h,l),Ca.fromBufferAttribute(h,s),Ta.fromBufferAttribute(h,u),i?(Ra.addScaledVector(za,m),Da.addScaledVector(Ca,m),Pa.addScaledVector(Ta,m)):(Ra.addScaledVector(za.sub(Sa),m),Da.addScaledVector(Ca.sub(ka),m),Pa.addScaledVector(Ta.sub(Ma),m)))}Sa.add(Ra),ka.add(Da),Ma.add(Pa)}n.isSkinnedMesh&&(n.boneTransform(l,Sa),n.boneTransform(s,ka),n.boneTransform(u,Ma));var x=function(n,e,t,r,o,a,i,v){if(null===(e.side===H?r.intersectTriangle(i,a,o,!0,v):r.intersectTriangle(o,a,i,e.side!==X,v)))return null;Oa.copy(v),Oa.applyMatrix4(n.matrixWorld);var c=t.ray.origin.distanceTo(Oa);return c<t.near||c>t.far?null:{distance:c,point:Oa.clone(),object:n}}(n,e,t,r,Sa,ka,Ma,Ia);if(x){v&&(ja.fromBufferAttribute(v,l),Fa.fromBufferAttribute(v,s),Ea.fromBufferAttribute(v,u),x.uv=Zo.getUV(Ia,Sa,ka,Ma,ja,Fa,Ea,new ir)),c&&(ja.fromBufferAttribute(c,l),Fa.fromBufferAttribute(c,s),Ea.fromBufferAttribute(c,u),x.uv2=Zo.getUV(Ia,Sa,ka,Ma,ja,Fa,Ea,new ir));var g={a:l,b:s,c:u,normal:new Or,materialIndex:0};Zo.getNormal(Sa,ka,Ma,g.normal),x.face=g}return x}var Na=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;y(this,t),(n=e.call(this)).type="BoxGeometry",n.parameters={width:r,height:o,depth:a,widthSegments:i,heightSegments:v,depthSegments:c};var l=k(n);i=Math.floor(i),v=Math.floor(v),c=Math.floor(c);var s=[],u=[],f=[],p=[],d=0,m=0;function h(n,e,t,r,o,a,i,v,c,h,x){for(var g=a/c,y=i/h,b=a/2,_=i/2,U=v/2,w=c+1,S=h+1,k=0,M=0,z=new Or,C=0;C<S;C++)for(var T=C*y-_,R=0;R<w;R++){var D=R*g-b;z[n]=D*r,z[e]=T*o,z[t]=U,u.push(z.x,z.y,z.z),z[n]=0,z[e]=0,z[t]=v>0?1:-1,f.push(z.x,z.y,z.z),p.push(R/c),p.push(1-C/h),k+=1}for(var P=0;P<h;P++)for(var j=0;j<c;j++){var F=d+j+w*P,E=d+j+w*(P+1),I=d+(j+1)+w*(P+1),O=d+(j+1)+w*P;s.push(F,E,O),s.push(E,I,O),M+=6}l.addGroup(m,M,x),m+=M,d+=k}return h("z","y","x",-1,-1,a,o,r,c,v,0),h("z","y","x",1,-1,a,o,-r,c,v,1),h("x","z","y",1,1,r,a,o,i,c,2),h("x","z","y",1,-1,r,a,-o,i,c,3),h("x","y","z",1,-1,r,o,a,i,v,4),h("x","y","z",-1,-1,r,o,-a,i,v,5),n.setIndex(s),n.setAttribute("position",new ua(u,3)),n.setAttribute("normal",new ua(f,3)),n.setAttribute("uv",new ua(p,2)),n}return _(t,null,[{key:"fromJSON",value:function(n){return new t(n.width,n.height,n.depth,n.widthSegments,n.heightSegments,n.depthSegments)}}]),t}(ba);function Ga(n){var e={};for(var t in n)for(var r in e[t]={},n[t]){var o=n[t][r];o&&(o.isColor||o.isMatrix3||o.isMatrix4||o.isVector2||o.isVector3||o.isVector4||o.isTexture||o.isQuaternion)?e[t][r]=o.clone():Array.isArray(o)?e[t][r]=o.slice():e[t][r]=o}return e}function Ba(n){for(var e={},t=0;t<n.length;t++){var r=Ga(n[t]);for(var o in r)e[o]=r[o]}return e}var qa={clone:Ga,merge:Ba},Va=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).isShaderMaterial=!0,r.type="ShaderMaterial",r.defines={},r.uniforms={},r.uniformsGroups=[],r.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",r.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",r.linewidth=1,r.wireframe=!1,r.wireframeLinewidth=1,r.fog=!1,r.lights=!1,r.clipping=!1,r.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},r.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},r.index0AttributeName=void 0,r.uniformsNeedUpdate=!1,r.glslVersion=null,void 0!==n&&r.setValues(n),r}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.fragmentShader=n.fragmentShader,this.vertexShader=n.vertexShader,this.uniforms=Ga(n.uniforms),this.uniformsGroups=function(n){for(var e=[],t=0;t<n.length;t++)e.push(n[t].clone());return e}(n.uniformsGroups),this.defines=Object.assign({},n.defines),this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.fog=n.fog,this.lights=n.lights,this.clipping=n.clipping,this.extensions=Object.assign({},n.extensions),this.glslVersion=n.glslVersion,this}},{key:"toJSON",value:function(n){var e=P(w(t.prototype),"toJSON",this).call(this,n);for(var r in e.glslVersion=this.glslVersion,e.uniforms={},this.uniforms){var o=this.uniforms[r].value;o&&o.isTexture?e.uniforms[r]={type:"t",value:o.toJSON(n).uuid}:o&&o.isColor?e.uniforms[r]={type:"c",value:o.getHex()}:o&&o.isVector2?e.uniforms[r]={type:"v2",value:o.toArray()}:o&&o.isVector3?e.uniforms[r]={type:"v3",value:o.toArray()}:o&&o.isVector4?e.uniforms[r]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?e.uniforms[r]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?e.uniforms[r]={type:"m4",value:o.toArray()}:e.uniforms[r]={value:o}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;var a={};for(var i in this.extensions)!0===this.extensions[i]&&(a[i]=!0);return Object.keys(a).length>0&&(e.extensions=a),e}}]),t}(Jo),Wa=function(n){U(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).isCamera=!0,n.type="Camera",n.matrixWorldInverse=new po,n.projectionMatrix=new po,n.projectionMatrixInverse=new po,n}return _(t,[{key:"copy",value:function(n,e){return P(w(t.prototype),"copy",this).call(this,n,e),this.matrixWorldInverse.copy(n.matrixWorldInverse),this.projectionMatrix.copy(n.projectionMatrix),this.projectionMatrixInverse.copy(n.projectionMatrixInverse),this}},{key:"getWorldDirection",value:function(n){this.updateWorldMatrix(!0,!1);var e=this.matrixWorld.elements;return n.set(-e[8],-e[9],-e[10]).normalize()}},{key:"updateMatrixWorld",value:function(n){P(w(t.prototype),"updateMatrixWorld",this).call(this,n),this.matrixWorldInverse.copy(this.matrixWorld).invert()}},{key:"updateWorldMatrix",value:function(n,e){P(w(t.prototype),"updateWorldMatrix",this).call(this,n,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),t}(Ao),Ha=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:50,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:2e3;return y(this,t),(n=e.call(this)).isPerspectiveCamera=!0,n.type="PerspectiveCamera",n.fov=r,n.zoom=1,n.near=a,n.far=i,n.focus=10,n.aspect=o,n.view=null,n.filmGauge=35,n.filmOffset=0,n.updateProjectionMatrix(),n}return _(t,[{key:"copy",value:function(n,e){return P(w(t.prototype),"copy",this).call(this,n,e),this.fov=n.fov,this.zoom=n.zoom,this.near=n.near,this.far=n.far,this.focus=n.focus,this.aspect=n.aspect,this.view=null===n.view?null:Object.assign({},n.view),this.filmGauge=n.filmGauge,this.filmOffset=n.filmOffset,this}},{key:"setFocalLength",value:function(n){var e=.5*this.getFilmHeight()/n;this.fov=2*$t*Math.atan(e),this.updateProjectionMatrix()}},{key:"getFocalLength",value:function(){var n=Math.tan(.5*Yt*this.fov);return.5*this.getFilmHeight()/n}},{key:"getEffectiveFOV",value:function(){return 2*$t*Math.atan(Math.tan(.5*Yt*this.fov)/this.zoom)}},{key:"getFilmWidth",value:function(){return this.filmGauge*Math.min(this.aspect,1)}},{key:"getFilmHeight",value:function(){return this.filmGauge/Math.max(this.aspect,1)}},{key:"setViewOffset",value:function(n,e,t,r,o,a){this.aspect=n/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=r,this.view.width=o,this.view.height=a,this.updateProjectionMatrix()}},{key:"clearViewOffset",value:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}},{key:"updateProjectionMatrix",value:function(){var n=this.near,e=n*Math.tan(.5*Yt*this.fov)/this.zoom,t=2*e,r=this.aspect*t,o=-.5*r,a=this.view;if(null!==this.view&&this.view.enabled){var i=a.fullWidth,v=a.fullHeight;o+=a.offsetX*r/i,e-=a.offsetY*t/v,r*=a.width/i,t*=a.height/v}var c=this.filmOffset;0!==c&&(o+=n*c/this.getFilmWidth()),this.projectionMatrix.makePerspective(o,o+r,e,e-t,n,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}},{key:"toJSON",value:function(n){var e=P(w(t.prototype),"toJSON",this).call(this,n);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}]),t}(Wa),Xa=90,Ya=function(n){U(t,n);var e=z(t);function t(n,r,o){var a;y(this,t),(a=e.call(this)).type="CubeCamera",a.renderTarget=o;var i=new Ha(Xa,1,n,r);i.layers=a.layers,i.up.set(0,-1,0),i.lookAt(new Or(1,0,0)),a.add(i);var v=new Ha(Xa,1,n,r);v.layers=a.layers,v.up.set(0,-1,0),v.lookAt(new Or(-1,0,0)),a.add(v);var c=new Ha(Xa,1,n,r);c.layers=a.layers,c.up.set(0,0,1),c.lookAt(new Or(0,1,0)),a.add(c);var l=new Ha(Xa,1,n,r);l.layers=a.layers,l.up.set(0,0,-1),l.lookAt(new Or(0,-1,0)),a.add(l);var s=new Ha(Xa,1,n,r);s.layers=a.layers,s.up.set(0,-1,0),s.lookAt(new Or(0,0,1)),a.add(s);var u=new Ha(Xa,1,n,r);return u.layers=a.layers,u.up.set(0,-1,0),u.lookAt(new Or(0,0,-1)),a.add(u),a}return _(t,[{key:"update",value:function(n,e){null===this.parent&&this.updateMatrixWorld();var t=this.renderTarget,r=c(this.children,6),o=r[0],a=r[1],i=r[2],v=r[3],l=r[4],s=r[5],u=n.getRenderTarget(),f=n.toneMapping,p=n.xr.enabled;n.toneMapping=Cn,n.xr.enabled=!1;var d=t.texture.generateMipmaps;t.texture.generateMipmaps=!1,n.setRenderTarget(t,0),n.render(e,o),n.setRenderTarget(t,1),n.render(e,a),n.setRenderTarget(t,2),n.render(e,i),n.setRenderTarget(t,3),n.render(e,v),n.setRenderTarget(t,4),n.render(e,l),t.texture.generateMipmaps=d,n.setRenderTarget(t,5),n.render(e,s),n.setRenderTarget(u),n.toneMapping=f,n.xr.enabled=p,t.texture.needsPMREMUpdate=!0}}]),t}(Ao),$a=function(n){U(t,n);var e=z(t);function t(n,r,o,a,i,v,c,l,s,u){var f;return y(this,t),n=void 0!==n?n:[],r=void 0!==r?r:En,(f=e.call(this,n,r,o,a,i,v,c,l,s,u)).isCubeTexture=!0,f.flipY=!1,f}return _(t,[{key:"images",get:function(){return this.image},set:function(n){this.image=n}}]),t}(Cr),Za=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};y(this,t),(n=e.call(this,r,r,o)).isWebGLCubeRenderTarget=!0;var a={width:r,height:r,depth:1},i=[a,a,a,a,a,a];return n.texture=new $a(i,o.mapping,o.wrapS,o.wrapT,o.magFilter,o.minFilter,o.format,o.type,o.anisotropy,o.encoding),n.texture.isRenderTargetTexture=!0,n.texture.generateMipmaps=void 0!==o.generateMipmaps&&o.generateMipmaps,n.texture.minFilter=void 0!==o.minFilter?o.minFilter:Yn,n}return _(t,[{key:"fromEquirectangularTexture",value:function(n,e){this.texture.type=e.type,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;var t={tEquirect:{value:null}},r="\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",o="\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",a=new Na(5,5,5),i=new Va({name:"CubemapFromEquirect",uniforms:Ga(t),vertexShader:r,fragmentShader:o,side:H,blending:Y});i.uniforms.tEquirect.value=e;var v=new La(a,i),c=e.minFilter;return e.minFilter===Kn&&(e.minFilter=Yn),new Ya(1,10,this).update(n,v),e.minFilter=c,v.geometry.dispose(),v.material.dispose(),this}},{key:"clear",value:function(n,e,t,r){for(var o=n.getRenderTarget(),a=0;a<6;a++)n.setRenderTarget(this,a),n.clear(e,t,r);n.setRenderTarget(o)}}]),t}(Rr),Ka=new Or,Ja=new Or,Qa=new vr,ni=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Or(1,0,0),t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;y(this,n),this.isPlane=!0,this.normal=e,this.constant=t}return _(n,[{key:"set",value:function(n,e){return this.normal.copy(n),this.constant=e,this}},{key:"setComponents",value:function(n,e,t,r){return this.normal.set(n,e,t),this.constant=r,this}},{key:"setFromNormalAndCoplanarPoint",value:function(n,e){return this.normal.copy(n),this.constant=-e.dot(this.normal),this}},{key:"setFromCoplanarPoints",value:function(n,e,t){var r=Ka.subVectors(t,e).cross(Ja.subVectors(n,e)).normalize();return this.setFromNormalAndCoplanarPoint(r,n),this}},{key:"copy",value:function(n){return this.normal.copy(n.normal),this.constant=n.constant,this}},{key:"normalize",value:function(){var n=1/this.normal.length();return this.normal.multiplyScalar(n),this.constant*=n,this}},{key:"negate",value:function(){return this.constant*=-1,this.normal.negate(),this}},{key:"distanceToPoint",value:function(n){return this.normal.dot(n)+this.constant}},{key:"distanceToSphere",value:function(n){return this.distanceToPoint(n.center)-n.radius}},{key:"projectPoint",value:function(n,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(n)).add(n)}},{key:"intersectLine",value:function(n,e){var t=n.delta(Ka),r=this.normal.dot(t);if(0===r)return 0===this.distanceToPoint(n.start)?e.copy(n.start):null;var o=-(n.start.dot(this.normal)+this.constant)/r;return o<0||o>1?null:e.copy(t).multiplyScalar(o).add(n.start)}},{key:"intersectsLine",value:function(n){var e=this.distanceToPoint(n.start),t=this.distanceToPoint(n.end);return e<0&&t>0||t<0&&e>0}},{key:"intersectsBox",value:function(n){return n.intersectsPlane(this)}},{key:"intersectsSphere",value:function(n){return n.intersectsPlane(this)}},{key:"coplanarPoint",value:function(n){return n.copy(this.normal).multiplyScalar(-this.constant)}},{key:"applyMatrix4",value:function(n,e){var t=e||Qa.getNormalMatrix(n),r=this.coplanarPoint(Ka).applyMatrix4(n),o=this.normal.applyMatrix3(t).normalize();return this.constant=-r.dot(o),this}},{key:"translate",value:function(n){return this.constant-=n.dot(this.normal),this}},{key:"equals",value:function(n){return n.normal.equals(this.normal)&&n.constant===this.constant}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),ei=new oo,ti=new Or,ri=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ni,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ni,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new ni,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new ni,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new ni,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:new ni;y(this,n),this.planes=[e,t,r,o,a,i]}return _(n,[{key:"set",value:function(n,e,t,r,o,a){var i=this.planes;return i[0].copy(n),i[1].copy(e),i[2].copy(t),i[3].copy(r),i[4].copy(o),i[5].copy(a),this}},{key:"copy",value:function(n){for(var e=this.planes,t=0;t<6;t++)e[t].copy(n.planes[t]);return this}},{key:"setFromProjectionMatrix",value:function(n){var e=this.planes,t=n.elements,r=t[0],o=t[1],a=t[2],i=t[3],v=t[4],c=t[5],l=t[6],s=t[7],u=t[8],f=t[9],p=t[10],d=t[11],m=t[12],h=t[13],x=t[14],g=t[15];return e[0].setComponents(i-r,s-v,d-u,g-m).normalize(),e[1].setComponents(i+r,s+v,d+u,g+m).normalize(),e[2].setComponents(i+o,s+c,d+f,g+h).normalize(),e[3].setComponents(i-o,s-c,d-f,g-h).normalize(),e[4].setComponents(i-a,s-l,d-p,g-x).normalize(),e[5].setComponents(i+a,s+l,d+p,g+x).normalize(),this}},{key:"intersectsObject",value:function(n){var e=n.geometry;return null===e.boundingSphere&&e.computeBoundingSphere(),ei.copy(e.boundingSphere).applyMatrix4(n.matrixWorld),this.intersectsSphere(ei)}},{key:"intersectsSprite",value:function(n){return ei.center.set(0,0,0),ei.radius=.7071067811865476,ei.applyMatrix4(n.matrixWorld),this.intersectsSphere(ei)}},{key:"intersectsSphere",value:function(n){for(var e=this.planes,t=n.center,r=-n.radius,o=0;o<6;o++){if(e[o].distanceToPoint(t)<r)return!1}return!0}},{key:"intersectsBox",value:function(n){for(var e=this.planes,t=0;t<6;t++){var r=e[t];if(ti.x=r.normal.x>0?n.max.x:n.min.x,ti.y=r.normal.y>0?n.max.y:n.min.y,ti.z=r.normal.z>0?n.max.z:n.min.z,r.distanceToPoint(ti)<0)return!1}return!0}},{key:"containsPoint",value:function(n){for(var e=this.planes,t=0;t<6;t++)if(e[t].distanceToPoint(n)<0)return!1;return!0}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}();function oi(){var n=null,e=!1,t=null,r=null;function o(e,a){t(e,a),r=n.requestAnimationFrame(o)}return{start:function(){!0!==e&&null!==t&&(r=n.requestAnimationFrame(o),e=!0)},stop:function(){n.cancelAnimationFrame(r),e=!1},setAnimationLoop:function(n){t=n},setContext:function(e){n=e}}}function ai(n,e){var t=e.isWebGL2,r=new WeakMap;return{get:function(n){return n.isInterleavedBufferAttribute&&(n=n.data),r.get(n)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);var t=r.get(e);t&&(n.deleteBuffer(t.buffer),r.delete(e))},update:function(e,o){if(e.isGLBufferAttribute){var a=r.get(e);(!a||a.version<e.version)&&r.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version})}else{e.isInterleavedBufferAttribute&&(e=e.data);var i=r.get(e);void 0===i?r.set(e,function(e,r){var o,a=e.array,i=e.usage,v=n.createBuffer();if(n.bindBuffer(r,v),n.bufferData(r,a,i),e.onUploadCallback(),a instanceof Float32Array)o=5126;else if(a instanceof Uint16Array)if(e.isFloat16BufferAttribute){if(!t)throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");o=5131}else o=5123;else if(a instanceof Int16Array)o=5122;else if(a instanceof Uint32Array)o=5125;else if(a instanceof Int32Array)o=5124;else if(a instanceof Int8Array)o=5120;else if(a instanceof Uint8Array)o=5121;else{if(!(a instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+a);o=5121}return{buffer:v,type:o,bytesPerElement:a.BYTES_PER_ELEMENT,version:e.version}}(e,o)):i.version<e.version&&(!function(e,r,o){var a=r.array,i=r.updateRange;n.bindBuffer(o,e),-1===i.count?n.bufferSubData(o,0,a):(t?n.bufferSubData(o,i.offset*a.BYTES_PER_ELEMENT,a,i.offset,i.count):n.bufferSubData(o,i.offset*a.BYTES_PER_ELEMENT,a.subarray(i.offset,i.offset+i.count)),i.count=-1)}(i.buffer,e,o),i.version=e.version)}}}}var ii=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;y(this,t),(n=e.call(this)).type="PlaneGeometry",n.parameters={width:r,height:o,widthSegments:a,heightSegments:i};for(var v=r/2,c=o/2,l=Math.floor(a),s=Math.floor(i),u=l+1,f=s+1,p=r/l,d=o/s,m=[],h=[],x=[],g=[],b=0;b<f;b++)for(var _=b*d-c,U=0;U<u;U++){var w=U*p-v;h.push(w,-_,0),x.push(0,0,1),g.push(U/l),g.push(1-b/s)}for(var S=0;S<s;S++)for(var k=0;k<l;k++){var M=k+u*S,z=k+u*(S+1),C=k+1+u*(S+1),T=k+1+u*S;m.push(M,z,T),m.push(z,C,T)}return n.setIndex(m),n.setAttribute("position",new ua(h,3)),n.setAttribute("normal",new ua(x,3)),n.setAttribute("uv",new ua(g,2)),n}return _(t,null,[{key:"fromJSON",value:function(n){return new t(n.width,n.height,n.widthSegments,n.heightSegments)}}]),t}(ba),vi={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",iridescence_fragment:"#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_fragment:"LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",lights_lambert_pars_fragment:"varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert\n#define Material_LightProbeLOD( material )\t(0)",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#if NUM_SPOT_LIGHT_COORDS > 0\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#if NUM_SPOT_LIGHT_COORDS > 0\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",backgroundCube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",backgroundCube_frag:"#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"},ci={common:{diffuse:{value:new wr(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new vr},uv2Transform:{value:new vr},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new ir(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new wr(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new wr(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new vr}},sprite:{diffuse:{value:new wr(16777215)},opacity:{value:1},center:{value:new ir(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new vr}}},li={basic:{uniforms:Ba([ci.common,ci.specularmap,ci.envmap,ci.aomap,ci.lightmap,ci.fog]),vertexShader:vi.meshbasic_vert,fragmentShader:vi.meshbasic_frag},lambert:{uniforms:Ba([ci.common,ci.specularmap,ci.envmap,ci.aomap,ci.lightmap,ci.emissivemap,ci.bumpmap,ci.normalmap,ci.displacementmap,ci.fog,ci.lights,{emissive:{value:new wr(0)}}]),vertexShader:vi.meshlambert_vert,fragmentShader:vi.meshlambert_frag},phong:{uniforms:Ba([ci.common,ci.specularmap,ci.envmap,ci.aomap,ci.lightmap,ci.emissivemap,ci.bumpmap,ci.normalmap,ci.displacementmap,ci.fog,ci.lights,{emissive:{value:new wr(0)},specular:{value:new wr(1118481)},shininess:{value:30}}]),vertexShader:vi.meshphong_vert,fragmentShader:vi.meshphong_frag},standard:{uniforms:Ba([ci.common,ci.envmap,ci.aomap,ci.lightmap,ci.emissivemap,ci.bumpmap,ci.normalmap,ci.displacementmap,ci.roughnessmap,ci.metalnessmap,ci.fog,ci.lights,{emissive:{value:new wr(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:vi.meshphysical_vert,fragmentShader:vi.meshphysical_frag},toon:{uniforms:Ba([ci.common,ci.aomap,ci.lightmap,ci.emissivemap,ci.bumpmap,ci.normalmap,ci.displacementmap,ci.gradientmap,ci.fog,ci.lights,{emissive:{value:new wr(0)}}]),vertexShader:vi.meshtoon_vert,fragmentShader:vi.meshtoon_frag},matcap:{uniforms:Ba([ci.common,ci.bumpmap,ci.normalmap,ci.displacementmap,ci.fog,{matcap:{value:null}}]),vertexShader:vi.meshmatcap_vert,fragmentShader:vi.meshmatcap_frag},points:{uniforms:Ba([ci.points,ci.fog]),vertexShader:vi.points_vert,fragmentShader:vi.points_frag},dashed:{uniforms:Ba([ci.common,ci.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:vi.linedashed_vert,fragmentShader:vi.linedashed_frag},depth:{uniforms:Ba([ci.common,ci.displacementmap]),vertexShader:vi.depth_vert,fragmentShader:vi.depth_frag},normal:{uniforms:Ba([ci.common,ci.bumpmap,ci.normalmap,ci.displacementmap,{opacity:{value:1}}]),vertexShader:vi.meshnormal_vert,fragmentShader:vi.meshnormal_frag},sprite:{uniforms:Ba([ci.sprite,ci.fog]),vertexShader:vi.sprite_vert,fragmentShader:vi.sprite_frag},background:{uniforms:{uvTransform:{value:new vr},t2D:{value:null}},vertexShader:vi.background_vert,fragmentShader:vi.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0}},vertexShader:vi.backgroundCube_vert,fragmentShader:vi.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:vi.cube_vert,fragmentShader:vi.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:vi.equirect_vert,fragmentShader:vi.equirect_frag},distanceRGBA:{uniforms:Ba([ci.common,ci.displacementmap,{referencePosition:{value:new Or},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:vi.distanceRGBA_vert,fragmentShader:vi.distanceRGBA_frag},shadow:{uniforms:Ba([ci.lights,ci.fog,{color:{value:new wr(0)},opacity:{value:1}}]),vertexShader:vi.shadow_vert,fragmentShader:vi.shadow_frag}};function si(n,e,t,r,o,a,i){var v,c,l=new wr(0),s=!0===a?0:1,u=null,f=0,p=null;function d(n,e){r.buffers.color.setClear(n.r,n.g,n.b,e,i)}return{getClearColor:function(){return l},setClearColor:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;l.set(n),d(l,s=e)},getClearAlpha:function(){return s},setClearAlpha:function(n){d(l,s=n)},render:function(r,a){var i=!1,m=!0===a.isScene?a.background:null;m&&m.isTexture&&(m=(a.backgroundBlurriness>0?t:e).get(m));var h=n.xr,x=h.getSession&&h.getSession();x&&"additive"===x.environmentBlendMode&&(m=null),null===m?d(l,s):m&&m.isColor&&(d(m,1),i=!0),(n.autoClear||i)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),m&&(m.isCubeTexture||m.mapping===An)?(void 0===c&&((c=new La(new Na(1,1,1),new Va({name:"BackgroundCubeMaterial",uniforms:Ga(li.backgroundCube.uniforms),vertexShader:li.backgroundCube.vertexShader,fragmentShader:li.backgroundCube.fragmentShader,side:H,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(n,e,t){this.matrixWorld.copyPosition(t.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),o.update(c)),c.material.uniforms.envMap.value=m,c.material.uniforms.flipEnvMap.value=m.isCubeTexture&&!1===m.isRenderTargetTexture?-1:1,c.material.uniforms.backgroundBlurriness.value=a.backgroundBlurriness,u===m&&f===m.version&&p===n.toneMapping||(c.material.needsUpdate=!0,u=m,f=m.version,p=n.toneMapping),c.layers.enableAll(),r.unshift(c,c.geometry,c.material,0,0,null)):m&&m.isTexture&&(void 0===v&&((v=new La(new ii(2,2),new Va({name:"BackgroundMaterial",uniforms:Ga(li.background.uniforms),vertexShader:li.background.vertexShader,fragmentShader:li.background.fragmentShader,side:W,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),Object.defineProperty(v.material,"map",{get:function(){return this.uniforms.t2D.value}}),o.update(v)),v.material.uniforms.t2D.value=m,!0===m.matrixAutoUpdate&&m.updateMatrix(),v.material.uniforms.uvTransform.value.copy(m.matrix),u===m&&f===m.version&&p===n.toneMapping||(v.material.needsUpdate=!0,u=m,f=m.version,p=n.toneMapping),v.layers.enableAll(),r.unshift(v,v.geometry,v.material,0,0,null))}}}function ui(n,e,t,r){var o=n.getParameter(34921),a=r.isWebGL2?null:e.get("OES_vertex_array_object"),i=r.isWebGL2||null!==a,v={},c=p(null),l=c,s=!1;function u(e){return r.isWebGL2?n.bindVertexArray(e):a.bindVertexArrayOES(e)}function f(e){return r.isWebGL2?n.deleteVertexArray(e):a.deleteVertexArrayOES(e)}function p(n){for(var e=[],t=[],r=[],a=0;a<o;a++)e[a]=0,t[a]=0,r[a]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:t,attributeDivisors:r,object:n,attributes:{},index:null}}function d(){for(var n=l.newAttributes,e=0,t=n.length;e<t;e++)n[e]=0}function m(n){h(n,0)}function h(t,o){var a=l.newAttributes,i=l.enabledAttributes,v=l.attributeDivisors;(a[t]=1,0===i[t]&&(n.enableVertexAttribArray(t),i[t]=1),v[t]!==o)&&((r.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](t,o),v[t]=o)}function x(){for(var e=l.newAttributes,t=l.enabledAttributes,r=0,o=t.length;r<o;r++)t[r]!==e[r]&&(n.disableVertexAttribArray(r),t[r]=0)}function g(e,t,o,a,i,v){!0!==r.isWebGL2||5124!==o&&5125!==o?n.vertexAttribPointer(e,t,o,a,i,v):n.vertexAttribIPointer(e,t,o,i,v)}function y(){b(),s=!0,l!==c&&u((l=c).object)}function b(){c.geometry=null,c.program=null,c.wireframe=!1}return{setup:function(o,c,f,y,b){var _=!1;if(i){var U=function(e,t,o){var i=!0===o.wireframe,c=v[e.id];void 0===c&&(c={},v[e.id]=c);var l=c[t.id];void 0===l&&(l={},c[t.id]=l);var s=l[i];void 0===s&&(s=p(r.isWebGL2?n.createVertexArray():a.createVertexArrayOES()),l[i]=s);return s}(y,f,c);l!==U&&u((l=U).object),_=function(n,e,t,r){var o=l.attributes,a=e.attributes,i=0,v=t.getAttributes();for(var c in v){if(v[c].location>=0){var s=o[c],u=a[c];if(void 0===u&&("instanceMatrix"===c&&n.instanceMatrix&&(u=n.instanceMatrix),"instanceColor"===c&&n.instanceColor&&(u=n.instanceColor)),void 0===s)return!0;if(s.attribute!==u)return!0;if(u&&s.data!==u.data)return!0;i++}}return l.attributesNum!==i||l.index!==r}(o,y,f,b),_&&function(n,e,t,r){var o={},a=e.attributes,i=0,v=t.getAttributes();for(var c in v){if(v[c].location>=0){var s=a[c];void 0===s&&("instanceMatrix"===c&&n.instanceMatrix&&(s=n.instanceMatrix),"instanceColor"===c&&n.instanceColor&&(s=n.instanceColor));var u={};u.attribute=s,s&&s.data&&(u.data=s.data),o[c]=u,i++}}l.attributes=o,l.attributesNum=i,l.index=r}(o,y,f,b)}else{var w=!0===c.wireframe;l.geometry===y.id&&l.program===f.id&&l.wireframe===w||(l.geometry=y.id,l.program=f.id,l.wireframe=w,_=!0)}null!==b&&t.update(b,34963),(_||s)&&(s=!1,function(o,a,i,v){if(!1===r.isWebGL2&&(o.isInstancedMesh||v.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;d();var c=v.attributes,l=i.getAttributes(),s=a.defaultAttributeValues;for(var u in l){var f=l[u];if(f.location>=0){var p=c[u];if(void 0===p&&("instanceMatrix"===u&&o.instanceMatrix&&(p=o.instanceMatrix),"instanceColor"===u&&o.instanceColor&&(p=o.instanceColor)),void 0!==p){var y=p.normalized,b=p.itemSize,_=t.get(p);if(void 0===_)continue;var U=_.buffer,w=_.type,S=_.bytesPerElement;if(p.isInterleavedBufferAttribute){var k=p.data,M=k.stride,z=p.offset;if(k.isInstancedInterleavedBuffer){for(var C=0;C<f.locationSize;C++)h(f.location+C,k.meshPerAttribute);!0!==o.isInstancedMesh&&void 0===v._maxInstanceCount&&(v._maxInstanceCount=k.meshPerAttribute*k.count)}else for(var T=0;T<f.locationSize;T++)m(f.location+T);n.bindBuffer(34962,U);for(var R=0;R<f.locationSize;R++)g(f.location+R,b/f.locationSize,w,y,M*S,(z+b/f.locationSize*R)*S)}else{if(p.isInstancedBufferAttribute){for(var D=0;D<f.locationSize;D++)h(f.location+D,p.meshPerAttribute);!0!==o.isInstancedMesh&&void 0===v._maxInstanceCount&&(v._maxInstanceCount=p.meshPerAttribute*p.count)}else for(var P=0;P<f.locationSize;P++)m(f.location+P);n.bindBuffer(34962,U);for(var j=0;j<f.locationSize;j++)g(f.location+j,b/f.locationSize,w,y,b*S,b/f.locationSize*j*S)}}else if(void 0!==s){var F=s[u];if(void 0!==F)switch(F.length){case 2:n.vertexAttrib2fv(f.location,F);break;case 3:n.vertexAttrib3fv(f.location,F);break;case 4:n.vertexAttrib4fv(f.location,F);break;default:n.vertexAttrib1fv(f.location,F)}}}}x()}(o,c,f,y),null!==b&&n.bindBuffer(34963,t.get(b).buffer))},reset:y,resetDefaultState:b,dispose:function(){for(var n in y(),v){var e=v[n];for(var t in e){var r=e[t];for(var o in r)f(r[o].object),delete r[o];delete e[t]}delete v[n]}},releaseStatesOfGeometry:function(n){if(void 0!==v[n.id]){var e=v[n.id];for(var t in e){var r=e[t];for(var o in r)f(r[o].object),delete r[o];delete e[t]}delete v[n.id]}},releaseStatesOfProgram:function(n){for(var e in v){var t=v[e];if(void 0!==t[n.id]){var r=t[n.id];for(var o in r)f(r[o].object),delete r[o];delete t[n.id]}}},initAttributes:d,enableAttribute:m,disableUnusedAttributes:x}}function fi(n,e,t,r){var o,a=r.isWebGL2;this.setMode=function(n){o=n},this.render=function(e,r){n.drawArrays(o,e,r),t.update(r,o,1)},this.renderInstances=function(r,i,v){if(0!==v){var c,l;if(a)c=n,l="drawArraysInstanced";else if(l="drawArraysInstancedANGLE",null===(c=e.get("ANGLE_instanced_arrays")))return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");c[l](o,r,i,v),t.update(i,o,v)}}}function pi(n,e,t){var r;function o(e){if("highp"===e){if(n.getShaderPrecisionFormat(35633,36338).precision>0&&n.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";e="mediump"}return"mediump"===e&&n.getShaderPrecisionFormat(35633,36337).precision>0&&n.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}var a="undefined"!==typeof WebGL2RenderingContext&&n instanceof WebGL2RenderingContext||"undefined"!==typeof WebGL2ComputeRenderingContext&&n instanceof WebGL2ComputeRenderingContext,i=void 0!==t.precision?t.precision:"highp",v=o(i);v!==i&&(console.warn("THREE.WebGLRenderer:",i,"not supported, using",v,"instead."),i=v);var c=a||e.has("WEBGL_draw_buffers"),l=!0===t.logarithmicDepthBuffer,s=n.getParameter(34930),u=n.getParameter(35660),f=n.getParameter(3379),p=n.getParameter(34076),d=n.getParameter(34921),m=n.getParameter(36347),h=n.getParameter(36348),x=n.getParameter(36349),g=u>0,y=a||e.has("OES_texture_float");return{isWebGL2:a,drawBuffers:c,getMaxAnisotropy:function(){if(void 0!==r)return r;if(!0===e.has("EXT_texture_filter_anisotropic")){var t=e.get("EXT_texture_filter_anisotropic");r=n.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r},getMaxPrecision:o,precision:i,logarithmicDepthBuffer:l,maxTextures:s,maxVertexTextures:u,maxTextureSize:f,maxCubemapSize:p,maxAttributes:d,maxVertexUniforms:m,maxVaryings:h,maxFragmentUniforms:x,vertexTextures:g,floatFragmentTextures:y,floatVertexTextures:g&&y,maxSamples:a?n.getParameter(36183):0}}function di(n){var e=this,t=null,r=0,o=!1,a=!1,i=new ni,v=new vr,c={value:null,needsUpdate:!1};function l(){c.value!==t&&(c.value=t,c.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0}function s(n,t,r,o){var a=null!==n?n.length:0,l=null;if(0!==a){if(l=c.value,!0!==o||null===l){var s=r+4*a,u=t.matrixWorldInverse;v.getNormalMatrix(u),(null===l||l.length<s)&&(l=new Float32Array(s));for(var f=0,p=r;f!==a;++f,p+=4)i.copy(n[f]).applyMatrix4(u,v),i.normal.toArray(l,p),l[p+3]=i.constant}c.value=l,c.needsUpdate=!0}return e.numPlanes=a,e.numIntersection=0,l}this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(n,e,a){var i=0!==n.length||e||0!==r||o;return o=e,t=s(n,a,0),r=n.length,i},this.beginShadows=function(){a=!0,s(null)},this.endShadows=function(){a=!1,l()},this.setState=function(e,i,v){var u=e.clippingPlanes,f=e.clipIntersection,p=e.clipShadows,d=n.get(e);if(!o||null===u||0===u.length||a&&!p)a?s(null):l();else{var m=a?0:r,h=4*m,x=d.clippingState||null;c.value=x,x=s(u,i,h,v);for(var g=0;g!==h;++g)x[g]=t[g];d.clippingState=x,this.numIntersection=f?this.numPlanes:0,this.numPlanes+=m}}}function mi(n){var e=new WeakMap;function t(n,e){return e===On?n.mapping=En:e===Ln&&(n.mapping=In),n}function r(n){var t=n.target;t.removeEventListener("dispose",r);var o=e.get(t);void 0!==o&&(e.delete(t),o.dispose())}return{get:function(o){if(o&&o.isTexture&&!1===o.isRenderTargetTexture){var a=o.mapping;if(a===On||a===Ln){if(e.has(o))return t(e.get(o).texture,o.mapping);var i=o.image;if(i&&i.height>0){var v=new Za(i.height/2);return v.fromEquirectangularTexture(n,o),e.set(o,v),o.addEventListener("dispose",r),t(v.texture,o.mapping)}return null}}return o},dispose:function(){e=new WeakMap}}}li.physical={uniforms:Ba([li.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new ir(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new wr(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new ir},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new wr(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new wr(1,1,1)},specularColorMap:{value:null}}]),vertexShader:vi.meshphysical_vert,fragmentShader:vi.meshphysical_frag};var hi=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.1,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2e3;return y(this,t),(n=e.call(this)).isOrthographicCamera=!0,n.type="OrthographicCamera",n.zoom=1,n.view=null,n.left=r,n.right=o,n.top=a,n.bottom=i,n.near=v,n.far=c,n.updateProjectionMatrix(),n}return _(t,[{key:"copy",value:function(n,e){return P(w(t.prototype),"copy",this).call(this,n,e),this.left=n.left,this.right=n.right,this.top=n.top,this.bottom=n.bottom,this.near=n.near,this.far=n.far,this.zoom=n.zoom,this.view=null===n.view?null:Object.assign({},n.view),this}},{key:"setViewOffset",value:function(n,e,t,r,o,a){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=r,this.view.width=o,this.view.height=a,this.updateProjectionMatrix()}},{key:"clearViewOffset",value:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}},{key:"updateProjectionMatrix",value:function(){var n=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),t=(this.right+this.left)/2,r=(this.top+this.bottom)/2,o=t-n,a=t+n,i=r+e,v=r-e;if(null!==this.view&&this.view.enabled){var c=(this.right-this.left)/this.view.fullWidth/this.zoom,l=(this.top-this.bottom)/this.view.fullHeight/this.zoom;a=(o+=c*this.view.offsetX)+c*this.view.width,v=(i-=l*this.view.offsetY)-l*this.view.height}this.projectionMatrix.makeOrthographic(o,a,i,v,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}},{key:"toJSON",value:function(n){var e=P(w(t.prototype),"toJSON",this).call(this,n);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}]),t}(Wa),xi=[.125,.215,.35,.446,.526,.582],gi=20,yi=new hi,bi=new wr,_i=null,Ui=(1+Math.sqrt(5))/2,wi=1/Ui,Si=[new Or(1,1,1),new Or(-1,1,1),new Or(1,1,-1),new Or(-1,1,-1),new Or(0,Ui,wi),new Or(0,Ui,-wi),new Or(wi,0,Ui),new Or(-wi,0,Ui),new Or(Ui,wi,0),new Or(-Ui,wi,0)],ki=function(){function n(e){y(this,n),this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}return _(n,[{key:"fromScene",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100;_i=this._renderer.getRenderTarget(),this._setSize(256);var o=this._allocateTargets();return o.depthBuffer=!0,this._sceneToCubeUV(n,t,r,o),e>0&&this._blur(o,0,0,e),this._applyPMREM(o),this._cleanup(o),o}},{key:"fromEquirectangular",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return this._fromTexture(n,e)}},{key:"fromCubemap",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return this._fromTexture(n,e)}},{key:"compileCubemapShader",value:function(){null===this._cubemapMaterial&&(this._cubemapMaterial=Ti(),this._compileMaterial(this._cubemapMaterial))}},{key:"compileEquirectangularShader",value:function(){null===this._equirectMaterial&&(this._equirectMaterial=Ci(),this._compileMaterial(this._equirectMaterial))}},{key:"dispose",value:function(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}},{key:"_setSize",value:function(n){this._lodMax=Math.floor(Math.log2(n)),this._cubeSize=Math.pow(2,this._lodMax)}},{key:"_dispose",value:function(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(var n=0;n<this._lodPlanes.length;n++)this._lodPlanes[n].dispose()}},{key:"_cleanup",value:function(n){this._renderer.setRenderTarget(_i),n.scissorTest=!1,zi(n,0,0,n.width,n.height)}},{key:"_fromTexture",value:function(n,e){n.mapping===En||n.mapping===In?this._setSize(0===n.image.length?16:n.image[0].width||n.image[0].image.width):this._setSize(n.image.width/4),_i=this._renderer.getRenderTarget();var t=e||this._allocateTargets();return this._textureToCubeUV(n,t),this._applyPMREM(t),this._cleanup(t),t}},{key:"_allocateTargets",value:function(){var n=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,t={magFilter:Yn,minFilter:Yn,generateMipmaps:!1,type:ie,format:fe,encoding:ct,depthBuffer:!1},r=Mi(n,e,t);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==n){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=Mi(n,e,t);var o=this._lodMax,a=function(n){for(var e=[],t=[],r=[],o=n,a=n-4+1+xi.length,i=0;i<a;i++){var v=Math.pow(2,o);t.push(v);var c=1/v;i>n-4?c=xi[i-n+4-1]:0===i&&(c=0),r.push(c);for(var l=1/(v-2),s=-l,u=1+l,f=[s,s,u,s,u,u,s,s,u,u,s,u],p=6,d=6,m=3,h=2,x=1,g=new Float32Array(m*d*p),y=new Float32Array(h*d*p),b=new Float32Array(x*d*p),_=0;_<p;_++){var U=_%3*2/3-1,w=_>2?0:-1,S=[U,w,0,U+2/3,w,0,U+2/3,w+1,0,U,w,0,U+2/3,w+1,0,U,w+1,0];g.set(S,m*d*_),y.set(f,h*d*_);var k=[_,_,_,_,_,_];b.set(k,x*d*_)}var M=new ba;M.setAttribute("position",new ta(g,m)),M.setAttribute("uv",new ta(y,h)),M.setAttribute("faceIndex",new ta(b,x)),e.push(M),o>4&&o--}return{lodPlanes:e,sizeLods:t,sigmas:r}}(o);this._sizeLods=a.sizeLods,this._lodPlanes=a.lodPlanes,this._sigmas=a.sigmas,this._blurMaterial=function(n,e,t){var r=new Float32Array(gi),o=new Or(0,1,0);return new Va({name:"SphericalGaussianBlur",defines:{n:gi,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:"".concat(n,".0")},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:o}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:Y,depthTest:!1,depthWrite:!1})}(o,n,e)}return r}},{key:"_compileMaterial",value:function(n){var e=new La(this._lodPlanes[0],n);this._renderer.compile(e,yi)}},{key:"_sceneToCubeUV",value:function(n,e,t,r){var o=new Ha(90,1,e,t),a=[1,-1,1,1,1,1],i=[1,1,1,-1,-1,-1],v=this._renderer,c=v.autoClear,l=v.toneMapping;v.getClearColor(bi),v.toneMapping=Cn,v.autoClear=!1;var s=new Qo({name:"PMREM.Background",side:H,depthWrite:!1,depthTest:!1}),u=new La(new Na,s),f=!1,p=n.background;p?p.isColor&&(s.color.copy(p),n.background=null,f=!0):(s.color.copy(bi),f=!0);for(var d=0;d<6;d++){var m=d%3;0===m?(o.up.set(0,a[d],0),o.lookAt(i[d],0,0)):1===m?(o.up.set(0,0,a[d]),o.lookAt(0,i[d],0)):(o.up.set(0,a[d],0),o.lookAt(0,0,i[d]));var h=this._cubeSize;zi(r,m*h,d>2?h:0,h,h),v.setRenderTarget(r),f&&v.render(u,o),v.render(n,o)}u.geometry.dispose(),u.material.dispose(),v.toneMapping=l,v.autoClear=c,n.background=p}},{key:"_textureToCubeUV",value:function(n,e){var t=this._renderer,r=n.mapping===En||n.mapping===In;r?(null===this._cubemapMaterial&&(this._cubemapMaterial=Ti()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===n.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=Ci());var o=r?this._cubemapMaterial:this._equirectMaterial,a=new La(this._lodPlanes[0],o);o.uniforms.envMap.value=n;var i=this._cubeSize;zi(e,0,0,3*i,2*i),t.setRenderTarget(e),t.render(a,yi)}},{key:"_applyPMREM",value:function(n){var e=this._renderer,t=e.autoClear;e.autoClear=!1;for(var r=1;r<this._lodPlanes.length;r++){var o=Math.sqrt(this._sigmas[r]*this._sigmas[r]-this._sigmas[r-1]*this._sigmas[r-1]),a=Si[(r-1)%Si.length];this._blur(n,r-1,r,o,a)}e.autoClear=t}},{key:"_blur",value:function(n,e,t,r,o){var a=this._pingPongRenderTarget;this._halfBlur(n,a,e,t,r,"latitudinal",o),this._halfBlur(a,n,t,t,r,"longitudinal",o)}},{key:"_halfBlur",value:function(n,e,t,r,o,a,i){var v=this._renderer,c=this._blurMaterial;"latitudinal"!==a&&"longitudinal"!==a&&console.error("blur direction must be either latitudinal or longitudinal!");var l=new La(this._lodPlanes[r],c),s=c.uniforms,u=this._sizeLods[t]-1,f=isFinite(o)?Math.PI/(2*u):2*Math.PI/39,p=o/f,d=isFinite(o)?1+Math.floor(3*p):gi;d>gi&&console.warn("sigmaRadians, ".concat(o,", is too large and will clip, as it requested ").concat(d," samples when the maximum is set to ").concat(gi));for(var m=[],h=0,x=0;x<gi;++x){var g=x/p,y=Math.exp(-g*g/2);m.push(y),0===x?h+=y:x<d&&(h+=2*y)}for(var b=0;b<m.length;b++)m[b]=m[b]/h;s.envMap.value=n.texture,s.samples.value=d,s.weights.value=m,s.latitudinal.value="latitudinal"===a,i&&(s.poleAxis.value=i);var _=this._lodMax;s.dTheta.value=f,s.mipInt.value=_-t;var U=this._sizeLods[r];zi(e,3*U*(r>_-4?r-_+4:0),4*(this._cubeSize-U),3*U,2*U),v.setRenderTarget(e),v.render(l,yi)}}]),n}();function Mi(n,e,t){var r=new Rr(n,e,t);return r.texture.mapping=An,r.texture.name="PMREM.cubeUv",r.scissorTest=!0,r}function zi(n,e,t,r,o){n.viewport.set(e,t,r,o),n.scissor.set(e,t,r,o)}function Ci(){return new Va({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:Y,depthTest:!1,depthWrite:!1})}function Ti(){return new Va({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:Y,depthTest:!1,depthWrite:!1})}function Ri(n){var e=new WeakMap,t=null;function r(n){var t=n.target;t.removeEventListener("dispose",r);var o=e.get(t);void 0!==o&&(e.delete(t),o.dispose())}return{get:function(o){if(o&&o.isTexture){var a=o.mapping,i=a===On||a===Ln,v=a===En||a===In;if(i||v){if(o.isRenderTargetTexture&&!0===o.needsPMREMUpdate){o.needsPMREMUpdate=!1;var c=e.get(o);return null===t&&(t=new ki(n)),c=i?t.fromEquirectangular(o,c):t.fromCubemap(o,c),e.set(o,c),c.texture}if(e.has(o))return e.get(o).texture;var l=o.image;if(i&&l&&l.height>0||v&&l&&function(n){for(var e=0,t=6,r=0;r<t;r++)void 0!==n[r]&&e++;return e===t}(l)){null===t&&(t=new ki(n));var s=i?t.fromEquirectangular(o):t.fromCubemap(o);return e.set(o,s),o.addEventListener("dispose",r),s.texture}return null}}return o},dispose:function(){e=new WeakMap,null!==t&&(t.dispose(),t=null)}}}function Di(n){var e={};function t(t){if(void 0!==e[t])return e[t];var r;switch(t){case"WEBGL_depth_texture":r=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=n.getExtension(t)}return e[t]=r,r}return{has:function(n){return null!==t(n)},init:function(n){n.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(n){var e=t(n);return null===e&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),e}}}function Pi(n,e,t,r){var o={},a=new WeakMap;function i(n){var v=n.target;for(var c in null!==v.index&&e.remove(v.index),v.attributes)e.remove(v.attributes[c]);v.removeEventListener("dispose",i),delete o[v.id];var l=a.get(v);l&&(e.remove(l),a.delete(v)),r.releaseStatesOfGeometry(v),!0===v.isInstancedBufferGeometry&&delete v._maxInstanceCount,t.memory.geometries--}function v(n){var t=[],r=n.index,o=n.attributes.position,i=0;if(null!==r){var v=r.array;i=r.version;for(var c=0,l=v.length;c<l;c+=3){var s=v[c+0],u=v[c+1],f=v[c+2];t.push(s,u,u,f,f,s)}}else{var p=o.array;i=o.version;for(var d=0,m=p.length/3-1;d<m;d+=3){var h=d+0,x=d+1,g=d+2;t.push(h,x,x,g,g,h)}}var y=new(cr(t)?la:va)(t,1);y.version=i;var b=a.get(n);b&&e.remove(b),a.set(n,y)}return{get:function(n,e){return!0===o[e.id]||(e.addEventListener("dispose",i),o[e.id]=!0,t.memory.geometries++),e},update:function(n){var t=n.attributes;for(var r in t)e.update(t[r],34962);var o=n.morphAttributes;for(var a in o)for(var i=o[a],v=0,c=i.length;v<c;v++)e.update(i[v],34962)},getWireframeAttribute:function(n){var e=a.get(n);if(e){var t=n.index;null!==t&&e.version<t.version&&v(n)}else v(n);return a.get(n)}}}function ji(n,e,t,r){var o,a,i,v=r.isWebGL2;this.setMode=function(n){o=n},this.setIndex=function(n){a=n.type,i=n.bytesPerElement},this.render=function(e,r){n.drawElements(o,r,a,e*i),t.update(r,o,1)},this.renderInstances=function(r,c,l){if(0!==l){var s,u;if(v)s=n,u="drawElementsInstanced";else if(u="drawElementsInstancedANGLE",null===(s=e.get("ANGLE_instanced_arrays")))return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");s[u](o,c,a,r*i,l),t.update(c,o,l)}}}function Fi(n){var e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(n,t,r){switch(e.calls++,t){case 4:e.triangles+=r*(n/3);break;case 1:e.lines+=r*(n/2);break;case 3:e.lines+=r*(n-1);break;case 2:e.lines+=r*n;break;case 0:e.points+=r*n;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",t)}}}}function Ei(n,e){return n[0]-e[0]}function Ii(n,e){return Math.abs(e[1])-Math.abs(n[1])}function Oi(n,e,t){for(var r={},o=new Float32Array(8),a=new WeakMap,i=new Tr,v=[],c=0;c<8;c++)v[c]=[c,0];return{update:function(c,l,s,u){var f=c.morphTargetInfluences;if(!0===e.isWebGL2){var p=l.morphAttributes.position||l.morphAttributes.normal||l.morphAttributes.color,d=void 0!==p?p.length:0,m=a.get(l);if(void 0===m||m.count!==d){void 0!==m&&m.texture.dispose();var h=void 0!==l.morphAttributes.position,x=void 0!==l.morphAttributes.normal,g=void 0!==l.morphAttributes.color,y=l.morphAttributes.position||[],b=l.morphAttributes.normal||[],_=l.morphAttributes.color||[],U=0;!0===h&&(U=1),!0===x&&(U=2),!0===g&&(U=3);var w=l.attributes.position.count*U,S=1;w>e.maxTextureSize&&(S=Math.ceil(w/e.maxTextureSize),w=e.maxTextureSize);var k=new Float32Array(w*S*4*d),M=new Dr(k,w,S,d);M.type=ae,M.needsUpdate=!0;for(var z=4*U,C=0;C<d;C++)for(var T=y[C],R=b[C],D=_[C],P=w*S*4*C,j=0;j<T.count;j++){var F=j*z;!0===h&&(i.fromBufferAttribute(T,j),k[P+F+0]=i.x,k[P+F+1]=i.y,k[P+F+2]=i.z,k[P+F+3]=0),!0===x&&(i.fromBufferAttribute(R,j),k[P+F+4]=i.x,k[P+F+5]=i.y,k[P+F+6]=i.z,k[P+F+7]=0),!0===g&&(i.fromBufferAttribute(D,j),k[P+F+8]=i.x,k[P+F+9]=i.y,k[P+F+10]=i.z,k[P+F+11]=4===D.itemSize?i.w:1)}m={count:d,texture:M,size:new ir(w,S)},a.set(l,m),l.addEventListener("dispose",(function n(){M.dispose(),a.delete(l),l.removeEventListener("dispose",n)}))}for(var E=0,I=0;I<f.length;I++)E+=f[I];var O=l.morphTargetsRelative?1:1-E;u.getUniforms().setValue(n,"morphTargetBaseInfluence",O),u.getUniforms().setValue(n,"morphTargetInfluences",f),u.getUniforms().setValue(n,"morphTargetsTexture",m.texture,t),u.getUniforms().setValue(n,"morphTargetsTextureSize",m.size)}else{var L=void 0===f?0:f.length,A=r[l.id];if(void 0===A||A.length!==L){A=[];for(var N=0;N<L;N++)A[N]=[N,0];r[l.id]=A}for(var G=0;G<L;G++){var B=A[G];B[0]=G,B[1]=f[G]}A.sort(Ii);for(var q=0;q<8;q++)q<L&&A[q][1]?(v[q][0]=A[q][0],v[q][1]=A[q][1]):(v[q][0]=Number.MAX_SAFE_INTEGER,v[q][1]=0);v.sort(Ei);for(var V=l.morphAttributes.position,W=l.morphAttributes.normal,H=0,X=0;X<8;X++){var Y=v[X],$=Y[0],Z=Y[1];$!==Number.MAX_SAFE_INTEGER&&Z?(V&&l.getAttribute("morphTarget"+X)!==V[$]&&l.setAttribute("morphTarget"+X,V[$]),W&&l.getAttribute("morphNormal"+X)!==W[$]&&l.setAttribute("morphNormal"+X,W[$]),o[X]=Z,H+=Z):(V&&!0===l.hasAttribute("morphTarget"+X)&&l.deleteAttribute("morphTarget"+X),W&&!0===l.hasAttribute("morphNormal"+X)&&l.deleteAttribute("morphNormal"+X),o[X]=0)}var K=l.morphTargetsRelative?1:1-H;u.getUniforms().setValue(n,"morphTargetBaseInfluence",K),u.getUniforms().setValue(n,"morphTargetInfluences",o)}}}}function Li(n,e,t,r){var o=new WeakMap;function a(n){var e=n.target;e.removeEventListener("dispose",a),t.remove(e.instanceMatrix),null!==e.instanceColor&&t.remove(e.instanceColor)}return{update:function(n){var i=r.render.frame,v=n.geometry,c=e.get(n,v);return o.get(c)!==i&&(e.update(c),o.set(c,i)),n.isInstancedMesh&&(!1===n.hasEventListener("dispose",a)&&n.addEventListener("dispose",a),t.update(n.instanceMatrix,34962),null!==n.instanceColor&&t.update(n.instanceColor,34962)),c},dispose:function(){o=new WeakMap}}}var Ai=new Cr,Ni=new Dr,Gi=new jr,Bi=new $a,qi=[],Vi=[],Wi=new Float32Array(16),Hi=new Float32Array(9),Xi=new Float32Array(4);function Yi(n,e,t){var r=n[0];if(r<=0||r>0)return n;var o=e*t,a=qi[o];if(void 0===a&&(a=new Float32Array(o),qi[o]=a),0!==e){r.toArray(a,0);for(var i=1,v=0;i!==e;++i)v+=t,n[i].toArray(a,v)}return a}function $i(n,e){if(n.length!==e.length)return!1;for(var t=0,r=n.length;t<r;t++)if(n[t]!==e[t])return!1;return!0}function Zi(n,e){for(var t=0,r=e.length;t<r;t++)n[t]=e[t]}function Ki(n,e){var t=Vi[e];void 0===t&&(t=new Int32Array(e),Vi[e]=t);for(var r=0;r!==e;++r)t[r]=n.allocateTextureUnit();return t}function Ji(n,e){var t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function Qi(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y||(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if($i(t,e))return;n.uniform2fv(this.addr,e),Zi(t,e)}}function nv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z||(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(void 0!==e.r)t[0]===e.r&&t[1]===e.g&&t[2]===e.b||(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if($i(t,e))return;n.uniform3fv(this.addr,e),Zi(t,e)}}function ev(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z&&t[3]===e.w||(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if($i(t,e))return;n.uniform4fv(this.addr,e),Zi(t,e)}}function tv(n,e){var t=this.cache,r=e.elements;if(void 0===r){if($i(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Zi(t,e)}else{if($i(t,r))return;Xi.set(r),n.uniformMatrix2fv(this.addr,!1,Xi),Zi(t,r)}}function rv(n,e){var t=this.cache,r=e.elements;if(void 0===r){if($i(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Zi(t,e)}else{if($i(t,r))return;Hi.set(r),n.uniformMatrix3fv(this.addr,!1,Hi),Zi(t,r)}}function ov(n,e){var t=this.cache,r=e.elements;if(void 0===r){if($i(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Zi(t,e)}else{if($i(t,r))return;Wi.set(r),n.uniformMatrix4fv(this.addr,!1,Wi),Zi(t,r)}}function av(n,e){var t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function iv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y||(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if($i(t,e))return;n.uniform2iv(this.addr,e),Zi(t,e)}}function vv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z||(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if($i(t,e))return;n.uniform3iv(this.addr,e),Zi(t,e)}}function cv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z&&t[3]===e.w||(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if($i(t,e))return;n.uniform4iv(this.addr,e),Zi(t,e)}}function lv(n,e){var t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function sv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y||(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if($i(t,e))return;n.uniform2uiv(this.addr,e),Zi(t,e)}}function uv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z||(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if($i(t,e))return;n.uniform3uiv(this.addr,e),Zi(t,e)}}function fv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z&&t[3]===e.w||(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if($i(t,e))return;n.uniform4uiv(this.addr,e),Zi(t,e)}}function pv(n,e,t){var r=this.cache,o=t.allocateTextureUnit();r[0]!==o&&(n.uniform1i(this.addr,o),r[0]=o),t.setTexture2D(e||Ai,o)}function dv(n,e,t){var r=this.cache,o=t.allocateTextureUnit();r[0]!==o&&(n.uniform1i(this.addr,o),r[0]=o),t.setTexture3D(e||Gi,o)}function mv(n,e,t){var r=this.cache,o=t.allocateTextureUnit();r[0]!==o&&(n.uniform1i(this.addr,o),r[0]=o),t.setTextureCube(e||Bi,o)}function hv(n,e,t){var r=this.cache,o=t.allocateTextureUnit();r[0]!==o&&(n.uniform1i(this.addr,o),r[0]=o),t.setTexture2DArray(e||Ni,o)}function xv(n,e){n.uniform1fv(this.addr,e)}function gv(n,e){var t=Yi(e,this.size,2);n.uniform2fv(this.addr,t)}function yv(n,e){var t=Yi(e,this.size,3);n.uniform3fv(this.addr,t)}function bv(n,e){var t=Yi(e,this.size,4);n.uniform4fv(this.addr,t)}function _v(n,e){var t=Yi(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function Uv(n,e){var t=Yi(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function wv(n,e){var t=Yi(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function Sv(n,e){n.uniform1iv(this.addr,e)}function kv(n,e){n.uniform2iv(this.addr,e)}function Mv(n,e){n.uniform3iv(this.addr,e)}function zv(n,e){n.uniform4iv(this.addr,e)}function Cv(n,e){n.uniform1uiv(this.addr,e)}function Tv(n,e){n.uniform2uiv(this.addr,e)}function Rv(n,e){n.uniform3uiv(this.addr,e)}function Dv(n,e){n.uniform4uiv(this.addr,e)}function Pv(n,e,t){var r=this.cache,o=e.length,a=Ki(t,o);$i(r,a)||(n.uniform1iv(this.addr,a),Zi(r,a));for(var i=0;i!==o;++i)t.setTexture2D(e[i]||Ai,a[i])}function jv(n,e,t){var r=this.cache,o=e.length,a=Ki(t,o);$i(r,a)||(n.uniform1iv(this.addr,a),Zi(r,a));for(var i=0;i!==o;++i)t.setTexture3D(e[i]||Gi,a[i])}function Fv(n,e,t){var r=this.cache,o=e.length,a=Ki(t,o);$i(r,a)||(n.uniform1iv(this.addr,a),Zi(r,a));for(var i=0;i!==o;++i)t.setTextureCube(e[i]||Bi,a[i])}function Ev(n,e,t){var r=this.cache,o=e.length,a=Ki(t,o);$i(r,a)||(n.uniform1iv(this.addr,a),Zi(r,a));for(var i=0;i!==o;++i)t.setTexture2DArray(e[i]||Ni,a[i])}var Iv=_((function n(e,t,r){y(this,n),this.id=e,this.addr=r,this.cache=[],this.setValue=function(n){switch(n){case 5126:return Ji;case 35664:return Qi;case 35665:return nv;case 35666:return ev;case 35674:return tv;case 35675:return rv;case 35676:return ov;case 5124:case 35670:return av;case 35667:case 35671:return iv;case 35668:case 35672:return vv;case 35669:case 35673:return cv;case 5125:return lv;case 36294:return sv;case 36295:return uv;case 36296:return fv;case 35678:case 36198:case 36298:case 36306:case 35682:return pv;case 35679:case 36299:case 36307:return dv;case 35680:case 36300:case 36308:case 36293:return mv;case 36289:case 36303:case 36311:case 36292:return hv}}(t.type)})),Ov=_((function n(e,t,r){y(this,n),this.id=e,this.addr=r,this.cache=[],this.size=t.size,this.setValue=function(n){switch(n){case 5126:return xv;case 35664:return gv;case 35665:return yv;case 35666:return bv;case 35674:return _v;case 35675:return Uv;case 35676:return wv;case 5124:case 35670:return Sv;case 35667:case 35671:return kv;case 35668:case 35672:return Mv;case 35669:case 35673:return zv;case 5125:return Cv;case 36294:return Tv;case 36295:return Rv;case 36296:return Dv;case 35678:case 36198:case 36298:case 36306:case 35682:return Pv;case 35679:case 36299:case 36307:return jv;case 35680:case 36300:case 36308:case 36293:return Fv;case 36289:case 36303:case 36311:case 36292:return Ev}}(t.type)})),Lv=function(){function n(e){y(this,n),this.id=e,this.seq=[],this.map={}}return _(n,[{key:"setValue",value:function(n,e,t){for(var r=this.seq,o=0,a=r.length;o!==a;++o){var i=r[o];i.setValue(n,e[i.id],t)}}}]),n}(),Av=/(\w+)(\])?(\[|\.)?/g;function Nv(n,e){n.seq.push(e),n.map[e.id]=e}function Gv(n,e,t){var r=n.name,o=r.length;for(Av.lastIndex=0;;){var a=Av.exec(r),i=Av.lastIndex,v=a[1],c="]"===a[2],l=a[3];if(c&&(v|=0),void 0===l||"["===l&&i+2===o){Nv(t,void 0===l?new Iv(v,n,e):new Ov(v,n,e));break}var s=t.map[v];void 0===s&&Nv(t,s=new Lv(v)),t=s}}var Bv=function(){function n(e,t){y(this,n),this.seq=[],this.map={};for(var r=e.getProgramParameter(t,35718),o=0;o<r;++o){var a=e.getActiveUniform(t,o);Gv(a,e.getUniformLocation(t,a.name),this)}}return _(n,[{key:"setValue",value:function(n,e,t,r){var o=this.map[e];void 0!==o&&o.setValue(n,t,r)}},{key:"setOptional",value:function(n,e,t){var r=e[t];void 0!==r&&this.setValue(n,t,r)}}],[{key:"upload",value:function(n,e,t,r){for(var o=0,a=e.length;o!==a;++o){var i=e[o],v=t[i.id];!1!==v.needsUpdate&&i.setValue(n,v.value,r)}}},{key:"seqWithValue",value:function(n,e){for(var t=[],r=0,o=n.length;r!==o;++r){var a=n[r];a.id in e&&t.push(a)}return t}}]),n}();function qv(n,e,t){var r=n.createShader(e);return n.shaderSource(r,t),n.compileShader(r),r}var Vv=0;function Wv(n,e,t){var r=n.getShaderParameter(e,35713),o=n.getShaderInfoLog(e).trim();if(r&&""===o)return"";var a=/ERROR: 0:(\d+)/.exec(o);if(a){var i=parseInt(a[1]);return t.toUpperCase()+"\n\n"+o+"\n\n"+function(n,e){for(var t=n.split("\n"),r=[],o=Math.max(e-6,0),a=Math.min(e+6,t.length),i=o;i<a;i++){var v=i+1;r.push("".concat(v===e?">":" "," ").concat(v,": ").concat(t[i]))}return r.join("\n")}(n.getShaderSource(e),i)}return o}function Hv(n,e){var t=function(n){switch(n){case ct:return["Linear","( value )"];case lt:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",n),["Linear","( value )"]}}(e);return"vec4 "+n+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function Xv(n,e){var t;switch(e){case Tn:t="Linear";break;case Rn:t="Reinhard";break;case Dn:t="OptimizedCineon";break;case Pn:t="ACESFilmic";break;case jn:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function Yv(n){return""!==n}function $v(n,e){var t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Zv(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}var Kv=/^[ \t]*#include +<([\w\d./]+)>/gm;function Jv(n){return n.replace(Kv,Qv)}function Qv(n,e){var t=vi[e];if(void 0===t)throw new Error("Can not resolve #include <"+e+">");return Jv(t)}var nc=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function ec(n){return n.replace(nc,tc)}function tc(n,e,t,r){for(var o="",a=parseInt(e);a<parseInt(t);a++)o+=r.replace(/\[\s*i\s*\]/g,"[ "+a+" ]").replace(/UNROLLED_LOOP_INDEX/g,a);return o}function rc(n){var e="precision "+n.precision+" float;\nprecision "+n.precision+" int;";return"highp"===n.precision?e+="\n#define HIGH_PRECISION":"mediump"===n.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===n.precision&&(e+="\n#define LOW_PRECISION"),e}function oc(n,e,t,r){var o,a,i=n.getContext(),v=t.defines,c=t.vertexShader,l=t.fragmentShader,s=function(n){var e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===B?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===q?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===V&&(e="SHADOWMAP_TYPE_VSM"),e}(t),u=function(n){var e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case En:case In:e="ENVMAP_TYPE_CUBE";break;case An:e="ENVMAP_TYPE_CUBE_UV"}return e}(t),f=function(n){var e="ENVMAP_MODE_REFLECTION";n.envMap&&n.envMapMode===In&&(e="ENVMAP_MODE_REFRACTION");return e}(t),p=function(n){var e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case kn:e="ENVMAP_BLENDING_MULTIPLY";break;case Mn:e="ENVMAP_BLENDING_MIX";break;case zn:e="ENVMAP_BLENDING_ADD"}return e}(t),d=function(n){var e=n.envMapCubeUVHeight;if(null===e)return null;var t=Math.log2(e)-2,r=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),112)),texelHeight:r,maxMip:t}}(t),m=t.isWebGL2?"":function(n){return[n.extensionDerivatives||n.envMapCubeUVHeight||n.bumpMap||n.tangentSpaceNormalMap||n.clearcoatNormalMap||n.flatShading||"physical"===n.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap||n.transmission)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Yv).join("\n")}(t),h=function(n){var e=[];for(var t in n){var r=n[t];!1!==r&&e.push("#define "+t+" "+r)}return e.join("\n")}(v),x=i.createProgram(),g=t.glslVersion?"#version "+t.glslVersion+"\n":"";t.isRawShaderMaterial?((o=[h].filter(Yv).join("\n")).length>0&&(o+="\n"),(a=[m,h].filter(Yv).join("\n")).length>0&&(a+="\n")):(o=[rc(t),"#define SHADER_NAME "+t.shaderName,h,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+f:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&!1===t.flatShading?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+s:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(Yv).join("\n"),a=[m,rc(t),"#define SHADER_NAME "+t.shaderName,h,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.envMap?"#define "+f:"",t.envMap?"#define "+p:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+s:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Cn?"#define TONE_MAPPING":"",t.toneMapping!==Cn?vi.tonemapping_pars_fragment:"",t.toneMapping!==Cn?Xv("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",vi.encodings_pars_fragment,Hv("linearToOutputTexel",t.outputEncoding),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"","\n"].filter(Yv).join("\n")),c=Zv(c=$v(c=Jv(c),t),t),l=Zv(l=$v(l=Jv(l),t),t),c=ec(c),l=ec(l),t.isWebGL2&&!0!==t.isRawShaderMaterial&&(g="#version 300 es\n",o=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+o,a=["#define varying in",t.glslVersion===qt?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===qt?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+a);var y,b,_=g+a+l,U=qv(i,35633,g+o+c),w=qv(i,35632,_);if(i.attachShader(x,U),i.attachShader(x,w),void 0!==t.index0AttributeName?i.bindAttribLocation(x,0,t.index0AttributeName):!0===t.morphTargets&&i.bindAttribLocation(x,0,"position"),i.linkProgram(x),n.debug.checkShaderErrors){var S=i.getProgramInfoLog(x).trim(),k=i.getShaderInfoLog(U).trim(),M=i.getShaderInfoLog(w).trim(),z=!0,C=!0;if(!1===i.getProgramParameter(x,35714)){z=!1;var T=Wv(i,U,"vertex"),R=Wv(i,w,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(x,35715)+"\n\nProgram Info Log: "+S+"\n"+T+"\n"+R)}else""!==S?console.warn("THREE.WebGLProgram: Program Info Log:",S):""!==k&&""!==M||(C=!1);C&&(this.diagnostics={runnable:z,programLog:S,vertexShader:{log:k,prefix:o},fragmentShader:{log:M,prefix:a}})}return i.deleteShader(U),i.deleteShader(w),this.getUniforms=function(){return void 0===y&&(y=new Bv(i,x)),y},this.getAttributes=function(){return void 0===b&&(b=function(n,e){for(var t={},r=n.getProgramParameter(e,35721),o=0;o<r;o++){var a=n.getActiveAttrib(e,o),i=a.name,v=1;35674===a.type&&(v=2),35675===a.type&&(v=3),35676===a.type&&(v=4),t[i]={type:a.type,location:n.getAttribLocation(e,i),locationSize:v}}return t}(i,x)),b},this.destroy=function(){r.releaseStatesOfProgram(this),i.deleteProgram(x),this.program=void 0},this.name=t.shaderName,this.id=Vv++,this.cacheKey=e,this.usedTimes=1,this.program=x,this.vertexShader=U,this.fragmentShader=w,this}var ac=0,ic=function(){function n(){y(this,n),this.shaderCache=new Map,this.materialCache=new Map}return _(n,[{key:"update",value:function(n){var e=n.vertexShader,t=n.fragmentShader,r=this._getShaderStage(e),o=this._getShaderStage(t),a=this._getShaderCacheForMaterial(n);return!1===a.has(r)&&(a.add(r),r.usedTimes++),!1===a.has(o)&&(a.add(o),o.usedTimes++),this}},{key:"remove",value:function(n){var e,t=f(this.materialCache.get(n));try{for(t.s();!(e=t.n()).done;){var r=e.value;r.usedTimes--,0===r.usedTimes&&this.shaderCache.delete(r.code)}}catch(o){t.e(o)}finally{t.f()}return this.materialCache.delete(n),this}},{key:"getVertexShaderID",value:function(n){return this._getShaderStage(n.vertexShader).id}},{key:"getFragmentShaderID",value:function(n){return this._getShaderStage(n.fragmentShader).id}},{key:"dispose",value:function(){this.shaderCache.clear(),this.materialCache.clear()}},{key:"_getShaderCacheForMaterial",value:function(n){var e=this.materialCache,t=e.get(n);return void 0===t&&(t=new Set,e.set(n,t)),t}},{key:"_getShaderStage",value:function(n){var e=this.shaderCache,t=e.get(n);return void 0===t&&(t=new vc(n),e.set(n,t)),t}}]),n}(),vc=_((function n(e){y(this,n),this.id=ac++,this.code=e,this.usedTimes=0}));function cc(n,e,t,r,o,a,i){var v=new ko,c=new ic,l=[],s=o.isWebGL2,u=o.logarithmicDepthBuffer,f=o.vertexTextures,p=o.precision,d={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};return{getParameters:function(a,v,l,m,h){var x=m.fog,g=h.geometry,y=a.isMeshStandardMaterial?m.environment:null,b=(a.isMeshStandardMaterial?t:e).get(a.envMap||y),_=b&&b.mapping===An?b.image.height:null,U=d[a.type];null!==a.precision&&(p=o.getMaxPrecision(a.precision))!==a.precision&&console.warn("THREE.WebGLProgram.getParameters:",a.precision,"not supported, using",p,"instead.");var w,S,k,M,z=g.morphAttributes.position||g.morphAttributes.normal||g.morphAttributes.color,C=void 0!==z?z.length:0,T=0;if(void 0!==g.morphAttributes.position&&(T=1),void 0!==g.morphAttributes.normal&&(T=2),void 0!==g.morphAttributes.color&&(T=3),U){var R=li[U];w=R.vertexShader,S=R.fragmentShader}else w=a.vertexShader,S=a.fragmentShader,c.update(a),k=c.getVertexShaderID(a),M=c.getFragmentShaderID(a);var D=n.getRenderTarget(),P=a.alphaTest>0,j=a.clearcoat>0,F=a.iridescence>0;return{isWebGL2:s,shaderID:U,shaderName:a.type,vertexShader:w,fragmentShader:S,defines:a.defines,customVertexShaderID:k,customFragmentShaderID:M,isRawShaderMaterial:!0===a.isRawShaderMaterial,glslVersion:a.glslVersion,precision:p,instancing:!0===h.isInstancedMesh,instancingColor:!0===h.isInstancedMesh&&null!==h.instanceColor,supportsVertexTextures:f,outputEncoding:null===D?n.outputEncoding:!0===D.isXRRenderTarget?D.texture.encoding:ct,map:!!a.map,matcap:!!a.matcap,envMap:!!b,envMapMode:b&&b.mapping,envMapCubeUVHeight:_,lightMap:!!a.lightMap,aoMap:!!a.aoMap,emissiveMap:!!a.emissiveMap,bumpMap:!!a.bumpMap,normalMap:!!a.normalMap,objectSpaceNormalMap:a.normalMapType===pt,tangentSpaceNormalMap:a.normalMapType===ft,decodeVideoTexture:!!a.map&&!0===a.map.isVideoTexture&&a.map.encoding===lt,clearcoat:j,clearcoatMap:j&&!!a.clearcoatMap,clearcoatRoughnessMap:j&&!!a.clearcoatRoughnessMap,clearcoatNormalMap:j&&!!a.clearcoatNormalMap,iridescence:F,iridescenceMap:F&&!!a.iridescenceMap,iridescenceThicknessMap:F&&!!a.iridescenceThicknessMap,displacementMap:!!a.displacementMap,roughnessMap:!!a.roughnessMap,metalnessMap:!!a.metalnessMap,specularMap:!!a.specularMap,specularIntensityMap:!!a.specularIntensityMap,specularColorMap:!!a.specularColorMap,opaque:!1===a.transparent&&a.blending===$,alphaMap:!!a.alphaMap,alphaTest:P,gradientMap:!!a.gradientMap,sheen:a.sheen>0,sheenColorMap:!!a.sheenColorMap,sheenRoughnessMap:!!a.sheenRoughnessMap,transmission:a.transmission>0,transmissionMap:!!a.transmissionMap,thicknessMap:!!a.thicknessMap,combine:a.combine,vertexTangents:!!a.normalMap&&!!g.attributes.tangent,vertexColors:a.vertexColors,vertexAlphas:!0===a.vertexColors&&!!g.attributes.color&&4===g.attributes.color.itemSize,vertexUvs:!!a.map||!!a.bumpMap||!!a.normalMap||!!a.specularMap||!!a.alphaMap||!!a.emissiveMap||!!a.roughnessMap||!!a.metalnessMap||!!a.clearcoatMap||!!a.clearcoatRoughnessMap||!!a.clearcoatNormalMap||!!a.iridescenceMap||!!a.iridescenceThicknessMap||!!a.displacementMap||!!a.transmissionMap||!!a.thicknessMap||!!a.specularIntensityMap||!!a.specularColorMap||!!a.sheenColorMap||!!a.sheenRoughnessMap,uvsVertexOnly:!(a.map||a.bumpMap||a.normalMap||a.specularMap||a.alphaMap||a.emissiveMap||a.roughnessMap||a.metalnessMap||a.clearcoatNormalMap||a.iridescenceMap||a.iridescenceThicknessMap||a.transmission>0||a.transmissionMap||a.thicknessMap||a.specularIntensityMap||a.specularColorMap||a.sheen>0||a.sheenColorMap||a.sheenRoughnessMap)&&!!a.displacementMap,fog:!!x,useFog:!0===a.fog,fogExp2:x&&x.isFogExp2,flatShading:!!a.flatShading,sizeAttenuation:a.sizeAttenuation,logarithmicDepthBuffer:u,skinning:!0===h.isSkinnedMesh,morphTargets:void 0!==g.morphAttributes.position,morphNormals:void 0!==g.morphAttributes.normal,morphColors:void 0!==g.morphAttributes.color,morphTargetsCount:C,morphTextureStride:T,numDirLights:v.directional.length,numPointLights:v.point.length,numSpotLights:v.spot.length,numSpotLightMaps:v.spotLightMap.length,numRectAreaLights:v.rectArea.length,numHemiLights:v.hemi.length,numDirLightShadows:v.directionalShadowMap.length,numPointLightShadows:v.pointShadowMap.length,numSpotLightShadows:v.spotShadowMap.length,numSpotLightShadowsWithMaps:v.numSpotLightShadowsWithMaps,numClippingPlanes:i.numPlanes,numClipIntersection:i.numIntersection,dithering:a.dithering,shadowMapEnabled:n.shadowMap.enabled&&l.length>0,shadowMapType:n.shadowMap.type,toneMapping:a.toneMapped?n.toneMapping:Cn,physicallyCorrectLights:n.physicallyCorrectLights,premultipliedAlpha:a.premultipliedAlpha,doubleSided:a.side===X,flipSided:a.side===H,useDepthPacking:!!a.depthPacking,depthPacking:a.depthPacking||0,index0AttributeName:a.index0AttributeName,extensionDerivatives:a.extensions&&a.extensions.derivatives,extensionFragDepth:a.extensions&&a.extensions.fragDepth,extensionDrawBuffers:a.extensions&&a.extensions.drawBuffers,extensionShaderTextureLOD:a.extensions&&a.extensions.shaderTextureLOD,rendererExtensionFragDepth:s||r.has("EXT_frag_depth"),rendererExtensionDrawBuffers:s||r.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:s||r.has("EXT_shader_texture_lod"),customProgramCacheKey:a.customProgramCacheKey()}},getProgramCacheKey:function(e){var t=[];if(e.shaderID?t.push(e.shaderID):(t.push(e.customVertexShaderID),t.push(e.customFragmentShaderID)),void 0!==e.defines)for(var r in e.defines)t.push(r),t.push(e.defines[r]);return!1===e.isRawShaderMaterial&&(!function(n,e){n.push(e.precision),n.push(e.outputEncoding),n.push(e.envMapMode),n.push(e.envMapCubeUVHeight),n.push(e.combine),n.push(e.vertexUvs),n.push(e.fogExp2),n.push(e.sizeAttenuation),n.push(e.morphTargetsCount),n.push(e.morphAttributeCount),n.push(e.numDirLights),n.push(e.numPointLights),n.push(e.numSpotLights),n.push(e.numSpotLightMaps),n.push(e.numHemiLights),n.push(e.numRectAreaLights),n.push(e.numDirLightShadows),n.push(e.numPointLightShadows),n.push(e.numSpotLightShadows),n.push(e.numSpotLightShadowsWithMaps),n.push(e.shadowMapType),n.push(e.toneMapping),n.push(e.numClippingPlanes),n.push(e.numClipIntersection),n.push(e.depthPacking)}(t,e),function(n,e){v.disableAll(),e.isWebGL2&&v.enable(0);e.supportsVertexTextures&&v.enable(1);e.instancing&&v.enable(2);e.instancingColor&&v.enable(3);e.map&&v.enable(4);e.matcap&&v.enable(5);e.envMap&&v.enable(6);e.lightMap&&v.enable(7);e.aoMap&&v.enable(8);e.emissiveMap&&v.enable(9);e.bumpMap&&v.enable(10);e.normalMap&&v.enable(11);e.objectSpaceNormalMap&&v.enable(12);e.tangentSpaceNormalMap&&v.enable(13);e.clearcoat&&v.enable(14);e.clearcoatMap&&v.enable(15);e.clearcoatRoughnessMap&&v.enable(16);e.clearcoatNormalMap&&v.enable(17);e.iridescence&&v.enable(18);e.iridescenceMap&&v.enable(19);e.iridescenceThicknessMap&&v.enable(20);e.displacementMap&&v.enable(21);e.specularMap&&v.enable(22);e.roughnessMap&&v.enable(23);e.metalnessMap&&v.enable(24);e.gradientMap&&v.enable(25);e.alphaMap&&v.enable(26);e.alphaTest&&v.enable(27);e.vertexColors&&v.enable(28);e.vertexAlphas&&v.enable(29);e.vertexUvs&&v.enable(30);e.vertexTangents&&v.enable(31);e.uvsVertexOnly&&v.enable(32);n.push(v.mask),v.disableAll(),e.fog&&v.enable(0);e.useFog&&v.enable(1);e.flatShading&&v.enable(2);e.logarithmicDepthBuffer&&v.enable(3);e.skinning&&v.enable(4);e.morphTargets&&v.enable(5);e.morphNormals&&v.enable(6);e.morphColors&&v.enable(7);e.premultipliedAlpha&&v.enable(8);e.shadowMapEnabled&&v.enable(9);e.physicallyCorrectLights&&v.enable(10);e.doubleSided&&v.enable(11);e.flipSided&&v.enable(12);e.useDepthPacking&&v.enable(13);e.dithering&&v.enable(14);e.specularIntensityMap&&v.enable(15);e.specularColorMap&&v.enable(16);e.transmission&&v.enable(17);e.transmissionMap&&v.enable(18);e.thicknessMap&&v.enable(19);e.sheen&&v.enable(20);e.sheenColorMap&&v.enable(21);e.sheenRoughnessMap&&v.enable(22);e.decodeVideoTexture&&v.enable(23);e.opaque&&v.enable(24);n.push(v.mask)}(t,e),t.push(n.outputEncoding)),t.push(e.customProgramCacheKey),t.join()},getUniforms:function(n){var e,t=d[n.type];if(t){var r=li[t];e=qa.clone(r.uniforms)}else e=n.uniforms;return e},acquireProgram:function(e,t){for(var r,o=0,i=l.length;o<i;o++){var v=l[o];if(v.cacheKey===t){++(r=v).usedTimes;break}}return void 0===r&&(r=new oc(n,t,e,a),l.push(r)),r},releaseProgram:function(n){if(0===--n.usedTimes){var e=l.indexOf(n);l[e]=l[l.length-1],l.pop(),n.destroy()}},releaseShaderCache:function(n){c.remove(n)},programs:l,dispose:function(){c.dispose()}}}function lc(){var n=new WeakMap;return{get:function(e){var t=n.get(e);return void 0===t&&(t={},n.set(e,t)),t},remove:function(e){n.delete(e)},update:function(e,t,r){n.get(e)[t]=r},dispose:function(){n=new WeakMap}}}function sc(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function uc(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function fc(){var n=[],e=0,t=[],r=[],o=[];function a(t,r,o,a,i,v){var c=n[e];return void 0===c?(c={id:t.id,object:t,geometry:r,material:o,groupOrder:a,renderOrder:t.renderOrder,z:i,group:v},n[e]=c):(c.id=t.id,c.object=t,c.geometry=r,c.material=o,c.groupOrder=a,c.renderOrder=t.renderOrder,c.z=i,c.group=v),e++,c}return{opaque:t,transmissive:r,transparent:o,init:function(){e=0,t.length=0,r.length=0,o.length=0},push:function(n,e,i,v,c,l){var s=a(n,e,i,v,c,l);i.transmission>0?r.push(s):!0===i.transparent?o.push(s):t.push(s)},unshift:function(n,e,i,v,c,l){var s=a(n,e,i,v,c,l);i.transmission>0?r.unshift(s):!0===i.transparent?o.unshift(s):t.unshift(s)},finish:function(){for(var t=e,r=n.length;t<r;t++){var o=n[t];if(null===o.id)break;o.id=null,o.object=null,o.geometry=null,o.material=null,o.group=null}},sort:function(n,e){t.length>1&&t.sort(n||sc),r.length>1&&r.sort(e||uc),o.length>1&&o.sort(e||uc)}}}function pc(){var n=new WeakMap;return{get:function(e,t){var r,o=n.get(e);return void 0===o?(r=new fc,n.set(e,[r])):t>=o.length?(r=new fc,o.push(r)):r=o[t],r},dispose:function(){n=new WeakMap}}}function dc(){var n={};return{get:function(e){if(void 0!==n[e.id])return n[e.id];var t;switch(e.type){case"DirectionalLight":t={direction:new Or,color:new wr};break;case"SpotLight":t={position:new Or,direction:new Or,color:new wr,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new Or,color:new wr,distance:0,decay:0};break;case"HemisphereLight":t={direction:new Or,skyColor:new wr,groundColor:new wr};break;case"RectAreaLight":t={color:new wr,position:new Or,halfWidth:new Or,halfHeight:new Or}}return n[e.id]=t,t}}}var mc=0;function hc(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}function xc(n,e){for(var t=new dc,r=function(){var n={};return{get:function(e){if(void 0!==n[e.id])return n[e.id];var t;switch(e.type){case"DirectionalLight":case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ir};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ir,shadowCameraNear:1,shadowCameraFar:1e3}}return n[e.id]=t,t}}}(),o={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0},a=0;a<9;a++)o.probe.push(new Or);var i=new Or,v=new po,c=new po;return{setup:function(a,i){for(var v=0,c=0,l=0,s=0;s<9;s++)o.probe[s].set(0,0,0);var u=0,f=0,p=0,d=0,m=0,h=0,x=0,g=0,y=0,b=0;a.sort(hc);for(var _=!0!==i?Math.PI:1,U=0,w=a.length;U<w;U++){var S=a[U],k=S.color,M=S.intensity,z=S.distance,C=S.shadow&&S.shadow.map?S.shadow.map.texture:null;if(S.isAmbientLight)v+=k.r*M*_,c+=k.g*M*_,l+=k.b*M*_;else if(S.isLightProbe)for(var T=0;T<9;T++)o.probe[T].addScaledVector(S.sh.coefficients[T],M);else if(S.isDirectionalLight){var R=t.get(S);if(R.color.copy(S.color).multiplyScalar(S.intensity*_),S.castShadow){var D=S.shadow,P=r.get(S);P.shadowBias=D.bias,P.shadowNormalBias=D.normalBias,P.shadowRadius=D.radius,P.shadowMapSize=D.mapSize,o.directionalShadow[u]=P,o.directionalShadowMap[u]=C,o.directionalShadowMatrix[u]=S.shadow.matrix,h++}o.directional[u]=R,u++}else if(S.isSpotLight){var j=t.get(S);j.position.setFromMatrixPosition(S.matrixWorld),j.color.copy(k).multiplyScalar(M*_),j.distance=z,j.coneCos=Math.cos(S.angle),j.penumbraCos=Math.cos(S.angle*(1-S.penumbra)),j.decay=S.decay,o.spot[p]=j;var F=S.shadow;if(S.map&&(o.spotLightMap[y]=S.map,y++,F.updateMatrices(S),S.castShadow&&b++),o.spotLightMatrix[p]=F.matrix,S.castShadow){var E=r.get(S);E.shadowBias=F.bias,E.shadowNormalBias=F.normalBias,E.shadowRadius=F.radius,E.shadowMapSize=F.mapSize,o.spotShadow[p]=E,o.spotShadowMap[p]=C,g++}p++}else if(S.isRectAreaLight){var I=t.get(S);I.color.copy(k).multiplyScalar(M),I.halfWidth.set(.5*S.width,0,0),I.halfHeight.set(0,.5*S.height,0),o.rectArea[d]=I,d++}else if(S.isPointLight){var O=t.get(S);if(O.color.copy(S.color).multiplyScalar(S.intensity*_),O.distance=S.distance,O.decay=S.decay,S.castShadow){var L=S.shadow,A=r.get(S);A.shadowBias=L.bias,A.shadowNormalBias=L.normalBias,A.shadowRadius=L.radius,A.shadowMapSize=L.mapSize,A.shadowCameraNear=L.camera.near,A.shadowCameraFar=L.camera.far,o.pointShadow[f]=A,o.pointShadowMap[f]=C,o.pointShadowMatrix[f]=S.shadow.matrix,x++}o.point[f]=O,f++}else if(S.isHemisphereLight){var N=t.get(S);N.skyColor.copy(S.color).multiplyScalar(M*_),N.groundColor.copy(S.groundColor).multiplyScalar(M*_),o.hemi[m]=N,m++}}d>0&&(e.isWebGL2||!0===n.has("OES_texture_float_linear")?(o.rectAreaLTC1=ci.LTC_FLOAT_1,o.rectAreaLTC2=ci.LTC_FLOAT_2):!0===n.has("OES_texture_half_float_linear")?(o.rectAreaLTC1=ci.LTC_HALF_1,o.rectAreaLTC2=ci.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),o.ambient[0]=v,o.ambient[1]=c,o.ambient[2]=l;var G=o.hash;G.directionalLength===u&&G.pointLength===f&&G.spotLength===p&&G.rectAreaLength===d&&G.hemiLength===m&&G.numDirectionalShadows===h&&G.numPointShadows===x&&G.numSpotShadows===g&&G.numSpotMaps===y||(o.directional.length=u,o.spot.length=p,o.rectArea.length=d,o.point.length=f,o.hemi.length=m,o.directionalShadow.length=h,o.directionalShadowMap.length=h,o.pointShadow.length=x,o.pointShadowMap.length=x,o.spotShadow.length=g,o.spotShadowMap.length=g,o.directionalShadowMatrix.length=h,o.pointShadowMatrix.length=x,o.spotLightMatrix.length=g+y-b,o.spotLightMap.length=y,o.numSpotLightShadowsWithMaps=b,G.directionalLength=u,G.pointLength=f,G.spotLength=p,G.rectAreaLength=d,G.hemiLength=m,G.numDirectionalShadows=h,G.numPointShadows=x,G.numSpotShadows=g,G.numSpotMaps=y,o.version=mc++)},setupView:function(n,e){for(var t=0,r=0,a=0,l=0,s=0,u=e.matrixWorldInverse,f=0,p=n.length;f<p;f++){var d=n[f];if(d.isDirectionalLight){var m=o.directional[t];m.direction.setFromMatrixPosition(d.matrixWorld),i.setFromMatrixPosition(d.target.matrixWorld),m.direction.sub(i),m.direction.transformDirection(u),t++}else if(d.isSpotLight){var h=o.spot[a];h.position.setFromMatrixPosition(d.matrixWorld),h.position.applyMatrix4(u),h.direction.setFromMatrixPosition(d.matrixWorld),i.setFromMatrixPosition(d.target.matrixWorld),h.direction.sub(i),h.direction.transformDirection(u),a++}else if(d.isRectAreaLight){var x=o.rectArea[l];x.position.setFromMatrixPosition(d.matrixWorld),x.position.applyMatrix4(u),c.identity(),v.copy(d.matrixWorld),v.premultiply(u),c.extractRotation(v),x.halfWidth.set(.5*d.width,0,0),x.halfHeight.set(0,.5*d.height,0),x.halfWidth.applyMatrix4(c),x.halfHeight.applyMatrix4(c),l++}else if(d.isPointLight){var g=o.point[r];g.position.setFromMatrixPosition(d.matrixWorld),g.position.applyMatrix4(u),r++}else if(d.isHemisphereLight){var y=o.hemi[s];y.direction.setFromMatrixPosition(d.matrixWorld),y.direction.transformDirection(u),s++}}},state:o}}function gc(n,e){var t=new xc(n,e),r=[],o=[];return{init:function(){r.length=0,o.length=0},state:{lightsArray:r,shadowsArray:o,lights:t},setupLights:function(n){t.setup(r,n)},setupLightsView:function(n){t.setupView(r,n)},pushLight:function(n){r.push(n)},pushShadow:function(n){o.push(n)}}}function yc(n,e){var t=new WeakMap;return{get:function(r){var o,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=t.get(r);return void 0===i?(o=new gc(n,e),t.set(r,[o])):a>=i.length?(o=new gc(n,e),i.push(o)):o=i[a],o},dispose:function(){t=new WeakMap}}}var bc=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).isMeshDepthMaterial=!0,r.type="MeshDepthMaterial",r.depthPacking=st,r.map=null,r.alphaMap=null,r.displacementMap=null,r.displacementScale=1,r.displacementBias=0,r.wireframe=!1,r.wireframeLinewidth=1,r.setValues(n),r}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.depthPacking=n.depthPacking,this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this}}]),t}(Jo),_c=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).isMeshDistanceMaterial=!0,r.type="MeshDistanceMaterial",r.referencePosition=new Or,r.nearDistance=1,r.farDistance=1e3,r.map=null,r.alphaMap=null,r.displacementMap=null,r.displacementScale=1,r.displacementBias=0,r.setValues(n),r}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.referencePosition.copy(n.referencePosition),this.nearDistance=n.nearDistance,this.farDistance=n.farDistance,this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this}}]),t}(Jo);function Uc(n,e,t){var r=new ri,o=new ir,a=new ir,i=new Tr,v=new bc({depthPacking:ut}),c=new _c,l={},s=t.maxTextureSize,u={0:H,1:W,2:X},f=new Va({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new ir},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),p=f.clone();p.defines.HORIZONTAL_PASS=1;var d=new ba;d.setAttribute("position",new ta(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));var m=new La(d,f),h=this;function x(t,r){var a=e.update(m);f.defines.VSM_SAMPLES!==t.blurSamples&&(f.defines.VSM_SAMPLES=t.blurSamples,p.defines.VSM_SAMPLES=t.blurSamples,f.needsUpdate=!0,p.needsUpdate=!0),null===t.mapPass&&(t.mapPass=new Rr(o.x,o.y)),f.uniforms.shadow_pass.value=t.map.texture,f.uniforms.resolution.value=t.mapSize,f.uniforms.radius.value=t.radius,n.setRenderTarget(t.mapPass),n.clear(),n.renderBufferDirect(r,null,a,f,m,null),p.uniforms.shadow_pass.value=t.mapPass.texture,p.uniforms.resolution.value=t.mapSize,p.uniforms.radius.value=t.radius,n.setRenderTarget(t.map),n.clear(),n.renderBufferDirect(r,null,a,p,m,null)}function g(e,t,r,o,a,i){var s=null,f=!0===r.isPointLight?e.customDistanceMaterial:e.customDepthMaterial;if(s=void 0!==f?f:!0===r.isPointLight?c:v,n.localClippingEnabled&&!0===t.clipShadows&&Array.isArray(t.clippingPlanes)&&0!==t.clippingPlanes.length||t.displacementMap&&0!==t.displacementScale||t.alphaMap&&t.alphaTest>0){var p=s.uuid,d=t.uuid,m=l[p];void 0===m&&(m={},l[p]=m);var h=m[d];void 0===h&&(h=s.clone(),m[d]=h),s=h}return s.visible=t.visible,s.wireframe=t.wireframe,s.side=i===V?null!==t.shadowSide?t.shadowSide:t.side:null!==t.shadowSide?t.shadowSide:u[t.side],s.alphaMap=t.alphaMap,s.alphaTest=t.alphaTest,s.clipShadows=t.clipShadows,s.clippingPlanes=t.clippingPlanes,s.clipIntersection=t.clipIntersection,s.displacementMap=t.displacementMap,s.displacementScale=t.displacementScale,s.displacementBias=t.displacementBias,s.wireframeLinewidth=t.wireframeLinewidth,s.linewidth=t.linewidth,!0===r.isPointLight&&!0===s.isMeshDistanceMaterial&&(s.referencePosition.setFromMatrixPosition(r.matrixWorld),s.nearDistance=o,s.farDistance=a),s}function y(t,o,a,i,v){if(!1!==t.visible){if(t.layers.test(o.layers)&&(t.isMesh||t.isLine||t.isPoints)&&(t.castShadow||t.receiveShadow&&v===V)&&(!t.frustumCulled||r.intersectsObject(t))){t.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse,t.matrixWorld);var c=e.update(t),l=t.material;if(Array.isArray(l))for(var s=c.groups,u=0,f=s.length;u<f;u++){var p=s[u],d=l[p.materialIndex];if(d&&d.visible){var m=g(t,d,i,a.near,a.far,v);n.renderBufferDirect(a,null,c,m,t,p)}}else if(l.visible){var h=g(t,l,i,a.near,a.far,v);n.renderBufferDirect(a,null,c,h,t,null)}}for(var x=t.children,b=0,_=x.length;b<_;b++)y(x[b],o,a,i,v)}}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=B,this.render=function(e,t,v){if(!1!==h.enabled&&(!1!==h.autoUpdate||!1!==h.needsUpdate)&&0!==e.length){var c=n.getRenderTarget(),l=n.getActiveCubeFace(),u=n.getActiveMipmapLevel(),f=n.state;f.setBlending(Y),f.buffers.color.setClear(1,1,1,1),f.buffers.depth.setTest(!0),f.setScissorTest(!1);for(var p=0,d=e.length;p<d;p++){var m=e[p],g=m.shadow;if(void 0!==g){if(!1!==g.autoUpdate||!1!==g.needsUpdate){o.copy(g.mapSize);var b=g.getFrameExtents();if(o.multiply(b),a.copy(g.mapSize),(o.x>s||o.y>s)&&(o.x>s&&(a.x=Math.floor(s/b.x),o.x=a.x*b.x,g.mapSize.x=a.x),o.y>s&&(a.y=Math.floor(s/b.y),o.y=a.y*b.y,g.mapSize.y=a.y)),null===g.map){var _=this.type!==V?{minFilter:qn,magFilter:qn}:{};g.map=new Rr(o.x,o.y,_),g.map.texture.name=m.name+".shadowMap",g.camera.updateProjectionMatrix()}n.setRenderTarget(g.map),n.clear();for(var U=g.getViewportCount(),w=0;w<U;w++){var S=g.getViewport(w);i.set(a.x*S.x,a.y*S.y,a.x*S.z,a.y*S.w),f.viewport(i),g.updateMatrices(m,w),r=g.getFrustum(),y(t,v,g.camera,m,this.type)}!0!==g.isPointLightShadow&&this.type===V&&x(g,v),g.needsUpdate=!1}}else console.warn("THREE.WebGLShadowMap:",m,"has no shadow.")}h.needsUpdate=!1,n.setRenderTarget(c,l,u)}}}function wc(n,e,t){var r,o,a=t.isWebGL2;var i=new function(){var e=!1,t=new Tr,r=null,o=new Tr(0,0,0,0);return{setMask:function(t){r===t||e||(n.colorMask(t,t,t,t),r=t)},setLocked:function(n){e=n},setClear:function(e,r,a,i,v){!0===v&&(e*=i,r*=i,a*=i),t.set(e,r,a,i),!1===o.equals(t)&&(n.clearColor(e,r,a,i),o.copy(t))},reset:function(){e=!1,r=null,o.set(-1,0,0,0)}}},v=new function(){var e=!1,t=null,r=null,o=null;return{setTest:function(n){n?kn(2929):Mn(2929)},setMask:function(r){t===r||e||(n.depthMask(r),t=r)},setFunc:function(e){if(r!==e){switch(e){case xn:n.depthFunc(512);break;case gn:n.depthFunc(519);break;case yn:n.depthFunc(513);break;case bn:n.depthFunc(515);break;case _n:n.depthFunc(514);break;case Un:n.depthFunc(518);break;case wn:n.depthFunc(516);break;case Sn:n.depthFunc(517);break;default:n.depthFunc(515)}r=e}},setLocked:function(n){e=n},setClear:function(e){o!==e&&(n.clearDepth(e),o=e)},reset:function(){e=!1,t=null,r=null,o=null}}},c=new function(){var e=!1,t=null,r=null,o=null,a=null,i=null,v=null,c=null,l=null;return{setTest:function(n){e||(n?kn(2960):Mn(2960))},setMask:function(r){t===r||e||(n.stencilMask(r),t=r)},setFunc:function(e,t,i){r===e&&o===t&&a===i||(n.stencilFunc(e,t,i),r=e,o=t,a=i)},setOp:function(e,t,r){i===e&&v===t&&c===r||(n.stencilOp(e,t,r),i=e,v=t,c=r)},setLocked:function(n){e=n},setClear:function(e){l!==e&&(n.clearStencil(e),l=e)},reset:function(){e=!1,t=null,r=null,o=null,a=null,i=null,v=null,c=null,l=null}}},s=new WeakMap,u=new WeakMap,f={},p={},d=new WeakMap,m=[],h=null,x=!1,g=null,y=null,b=null,_=null,U=null,w=null,S=null,k=!1,M=null,z=null,C=null,T=null,R=null,D=n.getParameter(35661),P=!1,j=0,F=n.getParameter(7938);-1!==F.indexOf("WebGL")?(j=parseFloat(/^WebGL (\d)/.exec(F)[1]),P=j>=1):-1!==F.indexOf("OpenGL ES")&&(j=parseFloat(/^OpenGL ES (\d)/.exec(F)[1]),P=j>=2);var E=null,I={},N=n.getParameter(3088),G=n.getParameter(2978),B=(new Tr).fromArray(N),q=(new Tr).fromArray(G);function V(e,t,r){var o=new Uint8Array(4),a=n.createTexture();n.bindTexture(e,a),n.texParameteri(e,10241,9728),n.texParameteri(e,10240,9728);for(var i=0;i<r;i++)n.texImage2D(t+i,0,6408,1,1,0,6408,5121,o);return a}var W={};function kn(e){!0!==f[e]&&(n.enable(e),f[e]=!0)}function Mn(e){!1!==f[e]&&(n.disable(e),f[e]=!1)}W[3553]=V(3553,3553,1),W[34067]=V(34067,34069,6),i.setClear(0,0,0,1),v.setClear(1),c.setClear(0),kn(2929),v.setFunc(bn),Dn(!1),Pn(L),kn(2884),Rn(Y);var zn=(l(r={},nn,32774),l(r,en,32778),l(r,tn,32779),r);if(a)zn[rn]=32775,zn[on]=32776;else{var Cn=e.get("EXT_blend_minmax");null!==Cn&&(zn[rn]=Cn.MIN_EXT,zn[on]=Cn.MAX_EXT)}var Tn=(l(o={},an,0),l(o,vn,1),l(o,cn,768),l(o,sn,770),l(o,hn,776),l(o,dn,774),l(o,fn,772),l(o,ln,769),l(o,un,771),l(o,mn,775),l(o,pn,773),o);function Rn(e,t,r,o,a,i,v,c){if(e!==Y){if(!1===x&&(kn(3042),x=!0),e===Q)a=a||t,i=i||r,v=v||o,t===y&&a===U||(n.blendEquationSeparate(zn[t],zn[a]),y=t,U=a),r===b&&o===_&&i===w&&v===S||(n.blendFuncSeparate(Tn[r],Tn[o],Tn[i],Tn[v]),b=r,_=o,w=i,S=v),g=e,k=null;else if(e!==g||c!==k){if(y===nn&&U===nn||(n.blendEquation(32774),y=nn,U=nn),c)switch(e){case $:n.blendFuncSeparate(1,771,1,771);break;case Z:n.blendFunc(1,1);break;case K:n.blendFuncSeparate(0,769,0,1);break;case J:n.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case $:n.blendFuncSeparate(770,771,1,771);break;case Z:n.blendFunc(770,1);break;case K:n.blendFuncSeparate(0,769,0,1);break;case J:n.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}b=null,_=null,w=null,S=null,g=e,k=c}}else!0===x&&(Mn(3042),x=!1)}function Dn(e){M!==e&&(e?n.frontFace(2304):n.frontFace(2305),M=e)}function Pn(e){e!==O?(kn(2884),e!==z&&(e===L?n.cullFace(1029):e===A?n.cullFace(1028):n.cullFace(1032))):Mn(2884),z=e}function jn(e,t,r){e?(kn(32823),T===t&&R===r||(n.polygonOffset(t,r),T=t,R=r)):Mn(32823)}return{buffers:{color:i,depth:v,stencil:c},enable:kn,disable:Mn,bindFramebuffer:function(e,t){return p[e]!==t&&(n.bindFramebuffer(e,t),p[e]=t,a&&(36009===e&&(p[36160]=t),36160===e&&(p[36009]=t)),!0)},drawBuffers:function(r,o){var a=m,i=!1;if(r)if(void 0===(a=d.get(o))&&(a=[],d.set(o,a)),r.isWebGLMultipleRenderTargets){var v=r.texture;if(a.length!==v.length||36064!==a[0]){for(var c=0,l=v.length;c<l;c++)a[c]=36064+c;a.length=v.length,i=!0}}else 36064!==a[0]&&(a[0]=36064,i=!0);else 1029!==a[0]&&(a[0]=1029,i=!0);i&&(t.isWebGL2?n.drawBuffers(a):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(a))},useProgram:function(e){return h!==e&&(n.useProgram(e),h=e,!0)},setBlending:Rn,setMaterial:function(n,e){n.side===X?Mn(2884):kn(2884);var t=n.side===H;e&&(t=!t),Dn(t),n.blending===$&&!1===n.transparent?Rn(Y):Rn(n.blending,n.blendEquation,n.blendSrc,n.blendDst,n.blendEquationAlpha,n.blendSrcAlpha,n.blendDstAlpha,n.premultipliedAlpha),v.setFunc(n.depthFunc),v.setTest(n.depthTest),v.setMask(n.depthWrite),i.setMask(n.colorWrite);var r=n.stencilWrite;c.setTest(r),r&&(c.setMask(n.stencilWriteMask),c.setFunc(n.stencilFunc,n.stencilRef,n.stencilFuncMask),c.setOp(n.stencilFail,n.stencilZFail,n.stencilZPass)),jn(n.polygonOffset,n.polygonOffsetFactor,n.polygonOffsetUnits),!0===n.alphaToCoverage?kn(32926):Mn(32926)},setFlipSided:Dn,setCullFace:Pn,setLineWidth:function(e){e!==C&&(P&&n.lineWidth(e),C=e)},setPolygonOffset:jn,setScissorTest:function(n){n?kn(3089):Mn(3089)},activeTexture:function(e){void 0===e&&(e=33984+D-1),E!==e&&(n.activeTexture(e),E=e)},bindTexture:function(e,t,r){void 0===r&&(r=null===E?33984+D-1:E);var o=I[r];void 0===o&&(o={type:void 0,texture:void 0},I[r]=o),o.type===e&&o.texture===t||(E!==r&&(n.activeTexture(r),E=r),n.bindTexture(e,t||W[e]),o.type=e,o.texture=t)},unbindTexture:function(){var e=I[E];void 0!==e&&void 0!==e.type&&(n.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{n.compressedTexImage2D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},compressedTexImage3D:function(){try{n.compressedTexImage3D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage2D:function(){try{n.texImage2D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage3D:function(){try{n.texImage3D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},updateUBOMapping:function(e,t){var r=u.get(t);void 0===r&&(r=new WeakMap,u.set(t,r));var o=r.get(e);void 0===o&&(o=n.getUniformBlockIndex(t,e.name),r.set(e,o))},uniformBlockBinding:function(e,t){var r=u.get(t).get(e);s.get(e)!==r&&(n.uniformBlockBinding(t,r,e.__bindingPointIndex),s.set(e,r))},texStorage2D:function(){try{n.texStorage2D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texStorage3D:function(){try{n.texStorage3D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texSubImage2D:function(){try{n.texSubImage2D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texSubImage3D:function(){try{n.texSubImage3D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},compressedTexSubImage2D:function(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},compressedTexSubImage3D:function(){try{n.compressedTexSubImage3D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},scissor:function(e){!1===B.equals(e)&&(n.scissor(e.x,e.y,e.z,e.w),B.copy(e))},viewport:function(e){!1===q.equals(e)&&(n.viewport(e.x,e.y,e.z,e.w),q.copy(e))},reset:function(){n.disable(3042),n.disable(2884),n.disable(2929),n.disable(32823),n.disable(3089),n.disable(2960),n.disable(32926),n.blendEquation(32774),n.blendFunc(1,0),n.blendFuncSeparate(1,0,1,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(513),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(519,0,4294967295),n.stencilOp(7680,7680,7680),n.clearStencil(0),n.cullFace(1029),n.frontFace(2305),n.polygonOffset(0,0),n.activeTexture(33984),n.bindFramebuffer(36160,null),!0===a&&(n.bindFramebuffer(36009,null),n.bindFramebuffer(36008,null)),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),f={},E=null,I={},p={},d=new WeakMap,m=[],h=null,x=!1,g=null,y=null,b=null,_=null,U=null,w=null,S=null,k=!1,M=null,z=null,C=null,T=null,R=null,B.set(0,0,n.canvas.width,n.canvas.height),q.set(0,0,n.canvas.width,n.canvas.height),i.reset(),v.reset(),c.reset()}}}function Sc(n,e,t,r,o,a,i){var v,c,s,u=o.isWebGL2,f=o.maxTextures,p=o.maxCubemapSize,d=o.maxTextureSize,m=o.maxSamples,h=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,x=/OculusBrowser/g.test("undefined"===typeof navigator?"":navigator.userAgent),g=new WeakMap,y=new WeakMap,b=!1;try{b="undefined"!==typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(W){}function _(n,e){return b?new OffscreenCanvas(n,e):ur("canvas")}function U(n,e,t,r){var o=1;if((n.width>r||n.height>r)&&(o=r/Math.max(n.width,n.height)),o<1||!0===e){if("undefined"!==typeof HTMLImageElement&&n instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&n instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&n instanceof ImageBitmap){var a=e?tr:Math.floor,i=a(o*n.width),v=a(o*n.height);void 0===s&&(s=_(i,v));var c=t?_(i,v):s;return c.width=i,c.height=v,c.getContext("2d").drawImage(n,0,0,i,v),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+n.width+"x"+n.height+") to ("+i+"x"+v+")."),c}return"data"in n&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+n.width+"x"+n.height+")."),n}return n}function w(n){return nr(n.width)&&nr(n.height)}function S(n,e){return n.generateMipmaps&&e&&n.minFilter!==qn&&n.minFilter!==Yn}function k(e){n.generateMipmap(e)}function M(t,r,o,a){var i=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!1===u)return r;if(null!==t){if(void 0!==n[t])return n[t];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+t+"'")}var v=r;return 6403===r&&(5126===o&&(v=33326),5131===o&&(v=33325),5121===o&&(v=33321)),33319===r&&(5126===o&&(v=33328),5131===o&&(v=33327),5121===o&&(v=33323)),6408===r&&(5126===o&&(v=34836),5131===o&&(v=34842),5121===o&&(v=a===lt&&!1===i?35907:32856),32819===o&&(v=32854),32820===o&&(v=32855)),33325!==v&&33326!==v&&33327!==v&&33328!==v&&34842!==v&&34836!==v||e.get("EXT_color_buffer_float"),v}function z(n,e,t){return!0===S(n,t)||n.isFramebufferTexture&&n.minFilter!==qn&&n.minFilter!==Yn?Math.log2(Math.max(e.width,e.height))+1:void 0!==n.mipmaps&&n.mipmaps.length>0?n.mipmaps.length:n.isCompressedTexture&&Array.isArray(n.image)?e.mipmaps.length:1}function C(n){return n===qn||n===Vn||n===Hn?9728:9729}function T(n){var e=n.target;e.removeEventListener("dispose",T),function(n){var e=r.get(n);if(void 0===e.__webglInit)return;var t=n.source,o=y.get(t);if(o){var a=o[e.__cacheKey];a.usedTimes--,0===a.usedTimes&&D(n),0===Object.keys(o).length&&y.delete(t)}r.remove(n)}(e),e.isVideoTexture&&g.delete(e)}function R(e){var t=e.target;t.removeEventListener("dispose",R),function(e){var t=e.texture,o=r.get(e),a=r.get(t);void 0!==a.__webglTexture&&(n.deleteTexture(a.__webglTexture),i.memory.textures--);e.depthTexture&&e.depthTexture.dispose();if(e.isWebGLCubeRenderTarget)for(var v=0;v<6;v++)n.deleteFramebuffer(o.__webglFramebuffer[v]),o.__webglDepthbuffer&&n.deleteRenderbuffer(o.__webglDepthbuffer[v]);else{if(n.deleteFramebuffer(o.__webglFramebuffer),o.__webglDepthbuffer&&n.deleteRenderbuffer(o.__webglDepthbuffer),o.__webglMultisampledFramebuffer&&n.deleteFramebuffer(o.__webglMultisampledFramebuffer),o.__webglColorRenderbuffer)for(var c=0;c<o.__webglColorRenderbuffer.length;c++)o.__webglColorRenderbuffer[c]&&n.deleteRenderbuffer(o.__webglColorRenderbuffer[c]);o.__webglDepthRenderbuffer&&n.deleteRenderbuffer(o.__webglDepthRenderbuffer)}if(e.isWebGLMultipleRenderTargets)for(var l=0,s=t.length;l<s;l++){var u=r.get(t[l]);u.__webglTexture&&(n.deleteTexture(u.__webglTexture),i.memory.textures--),r.remove(t[l])}r.remove(t),r.remove(e)}(t)}function D(e){var t=r.get(e);n.deleteTexture(t.__webglTexture);var o=e.source;delete y.get(o)[t.__cacheKey],i.memory.textures--}var P=0;function j(n,e){var o=r.get(n);if(n.isVideoTexture&&function(n){var e=i.render.frame;g.get(n)!==e&&(g.set(n,e),n.update())}(n),!1===n.isRenderTargetTexture&&n.version>0&&o.__version!==n.version){var a=n.image;if(null===a)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==a.complete)return void L(o,n,e);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}t.bindTexture(3553,o.__webglTexture,33984+e)}var F=(l(v={},Nn,10497),l(v,Gn,33071),l(v,Bn,33648),v),E=(l(c={},qn,9728),l(c,Vn,9984),l(c,Hn,9986),l(c,Yn,9729),l(c,$n,9985),l(c,Kn,9987),c);function I(t,a,i){if(i?(n.texParameteri(t,10242,F[a.wrapS]),n.texParameteri(t,10243,F[a.wrapT]),32879!==t&&35866!==t||n.texParameteri(t,32882,F[a.wrapR]),n.texParameteri(t,10240,E[a.magFilter]),n.texParameteri(t,10241,E[a.minFilter])):(n.texParameteri(t,10242,33071),n.texParameteri(t,10243,33071),32879!==t&&35866!==t||n.texParameteri(t,32882,33071),a.wrapS===Gn&&a.wrapT===Gn||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(t,10240,C(a.magFilter)),n.texParameteri(t,10241,C(a.minFilter)),a.minFilter!==qn&&a.minFilter!==Yn&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===e.has("EXT_texture_filter_anisotropic")){var v=e.get("EXT_texture_filter_anisotropic");if(a.type===ae&&!1===e.has("OES_texture_float_linear"))return;if(!1===u&&a.type===ie&&!1===e.has("OES_texture_half_float_linear"))return;(a.anisotropy>1||r.get(a).__currentAnisotropy)&&(n.texParameterf(t,v.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(a.anisotropy,o.getMaxAnisotropy())),r.get(a).__currentAnisotropy=a.anisotropy)}}function O(e,t){var r=!1;void 0===e.__webglInit&&(e.__webglInit=!0,t.addEventListener("dispose",T));var o=t.source,a=y.get(o);void 0===a&&(a={},y.set(o,a));var v=function(n){var e=[];return e.push(n.wrapS),e.push(n.wrapT),e.push(n.wrapR||0),e.push(n.magFilter),e.push(n.minFilter),e.push(n.anisotropy),e.push(n.internalFormat),e.push(n.format),e.push(n.type),e.push(n.generateMipmaps),e.push(n.premultiplyAlpha),e.push(n.flipY),e.push(n.unpackAlignment),e.push(n.encoding),e.join()}(t);if(v!==e.__cacheKey){void 0===a[v]&&(a[v]={texture:n.createTexture(),usedTimes:0},i.memory.textures++,r=!0),a[v].usedTimes++;var c=a[e.__cacheKey];void 0!==c&&(a[e.__cacheKey].usedTimes--,0===c.usedTimes&&D(t)),e.__cacheKey=v,e.__webglTexture=a[v].texture}return r}function L(e,o,i){var v=3553;(o.isDataArrayTexture||o.isCompressedArrayTexture)&&(v=35866),o.isData3DTexture&&(v=32879);var c=O(e,o),l=o.source;t.bindTexture(v,e.__webglTexture,33984+i);var s=r.get(l);if(l.version!==s.__version||!0===c){t.activeTexture(33984+i),n.pixelStorei(37440,o.flipY),n.pixelStorei(37441,o.premultiplyAlpha),n.pixelStorei(3317,o.unpackAlignment),n.pixelStorei(37443,0);var f,p=function(n){return!u&&(n.wrapS!==Gn||n.wrapT!==Gn||n.minFilter!==qn&&n.minFilter!==Yn)}(o)&&!1===w(o.image),m=U(o.image,p,!1,d),h=w(m=V(o,m))||u,x=a.convert(o.format,o.encoding),g=a.convert(o.type),y=M(o.internalFormat,x,g,o.encoding,o.isVideoTexture);I(v,o,h);var b=o.mipmaps,_=u&&!0!==o.isVideoTexture,C=void 0===s.__version||!0===c,T=z(o,m,h);if(o.isDepthTexture)y=6402,u?y=o.type===ae?36012:o.type===oe?33190:o.type===le?35056:33189:o.type===ae&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),o.format===me&&6402===y&&o.type!==te&&o.type!==oe&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),o.type=oe,g=a.convert(o.type)),o.format===he&&6402===y&&(y=34041,o.type!==le&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),o.type=le,g=a.convert(o.type))),C&&(_?t.texStorage2D(3553,1,y,m.width,m.height):t.texImage2D(3553,0,y,m.width,m.height,0,x,g,null));else if(o.isDataTexture)if(b.length>0&&h){_&&C&&t.texStorage2D(3553,T,y,b[0].width,b[0].height);for(var R=0,D=b.length;R<D;R++)f=b[R],_?t.texSubImage2D(3553,R,0,0,f.width,f.height,x,g,f.data):t.texImage2D(3553,R,y,f.width,f.height,0,x,g,f.data);o.generateMipmaps=!1}else _?(C&&t.texStorage2D(3553,T,y,m.width,m.height),t.texSubImage2D(3553,0,0,0,m.width,m.height,x,g,m.data)):t.texImage2D(3553,0,y,m.width,m.height,0,x,g,m.data);else if(o.isCompressedTexture)if(o.isCompressedArrayTexture){_&&C&&t.texStorage3D(35866,T,y,b[0].width,b[0].height,m.depth);for(var P=0,j=b.length;P<j;P++)f=b[P],o.format!==fe?null!==x?_?t.compressedTexSubImage3D(35866,P,0,0,0,f.width,f.height,m.depth,x,f.data,0,0):t.compressedTexImage3D(35866,P,y,f.width,f.height,m.depth,0,f.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):_?t.texSubImage3D(35866,P,0,0,0,f.width,f.height,m.depth,x,g,f.data):t.texImage3D(35866,P,y,f.width,f.height,m.depth,0,x,g,f.data)}else{_&&C&&t.texStorage2D(3553,T,y,b[0].width,b[0].height);for(var F=0,E=b.length;F<E;F++)f=b[F],o.format!==fe?null!==x?_?t.compressedTexSubImage2D(3553,F,0,0,f.width,f.height,x,f.data):t.compressedTexImage2D(3553,F,y,f.width,f.height,0,f.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):_?t.texSubImage2D(3553,F,0,0,f.width,f.height,x,g,f.data):t.texImage2D(3553,F,y,f.width,f.height,0,x,g,f.data)}else if(o.isDataArrayTexture)_?(C&&t.texStorage3D(35866,T,y,m.width,m.height,m.depth),t.texSubImage3D(35866,0,0,0,0,m.width,m.height,m.depth,x,g,m.data)):t.texImage3D(35866,0,y,m.width,m.height,m.depth,0,x,g,m.data);else if(o.isData3DTexture)_?(C&&t.texStorage3D(32879,T,y,m.width,m.height,m.depth),t.texSubImage3D(32879,0,0,0,0,m.width,m.height,m.depth,x,g,m.data)):t.texImage3D(32879,0,y,m.width,m.height,m.depth,0,x,g,m.data);else if(o.isFramebufferTexture){if(C)if(_)t.texStorage2D(3553,T,y,m.width,m.height);else for(var L=m.width,A=m.height,N=0;N<T;N++)t.texImage2D(3553,N,y,L,A,0,x,g,null),L>>=1,A>>=1}else if(b.length>0&&h){_&&C&&t.texStorage2D(3553,T,y,b[0].width,b[0].height);for(var G=0,B=b.length;G<B;G++)f=b[G],_?t.texSubImage2D(3553,G,0,0,x,g,f):t.texImage2D(3553,G,y,x,g,f);o.generateMipmaps=!1}else _?(C&&t.texStorage2D(3553,T,y,m.width,m.height),t.texSubImage2D(3553,0,0,0,x,g,m)):t.texImage2D(3553,0,y,x,g,m);S(o,h)&&k(v),s.__version=l.version,o.onUpdate&&o.onUpdate(o)}e.__version=o.version}function A(e,o,i,v,c){var l=a.convert(i.format,i.encoding),s=a.convert(i.type),u=M(i.internalFormat,l,s,i.encoding);r.get(o).__hasExternalTextures||(32879===c||35866===c?t.texImage3D(c,0,u,o.width,o.height,o.depth,0,l,s,null):t.texImage2D(c,0,u,o.width,o.height,0,l,s,null)),t.bindFramebuffer(36160,e),q(o)?h.framebufferTexture2DMultisampleEXT(36160,v,c,r.get(i).__webglTexture,0,B(o)):(3553===c||c>=34069&&c<=34074)&&n.framebufferTexture2D(36160,v,c,r.get(i).__webglTexture,0),t.bindFramebuffer(36160,null)}function N(e,t,r){if(n.bindRenderbuffer(36161,e),t.depthBuffer&&!t.stencilBuffer){var o=33189;if(r||q(t)){var i=t.depthTexture;i&&i.isDepthTexture&&(i.type===ae?o=36012:i.type===oe&&(o=33190));var v=B(t);q(t)?h.renderbufferStorageMultisampleEXT(36161,v,o,t.width,t.height):n.renderbufferStorageMultisample(36161,v,o,t.width,t.height)}else n.renderbufferStorage(36161,o,t.width,t.height);n.framebufferRenderbuffer(36160,36096,36161,e)}else if(t.depthBuffer&&t.stencilBuffer){var c=B(t);r&&!1===q(t)?n.renderbufferStorageMultisample(36161,c,35056,t.width,t.height):q(t)?h.renderbufferStorageMultisampleEXT(36161,c,35056,t.width,t.height):n.renderbufferStorage(36161,34041,t.width,t.height),n.framebufferRenderbuffer(36160,33306,36161,e)}else for(var l=!0===t.isWebGLMultipleRenderTargets?t.texture:[t.texture],s=0;s<l.length;s++){var u=l[s],f=a.convert(u.format,u.encoding),p=a.convert(u.type),d=M(u.internalFormat,f,p,u.encoding),m=B(t);r&&!1===q(t)?n.renderbufferStorageMultisample(36161,m,d,t.width,t.height):q(t)?h.renderbufferStorageMultisampleEXT(36161,m,d,t.width,t.height):n.renderbufferStorage(36161,d,t.width,t.height)}n.bindRenderbuffer(36161,null)}function G(e){var o=r.get(e),a=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture&&!o.__autoAllocateDepthBuffer){if(a)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,o){if(o&&o.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,e),!o.depthTexture||!o.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");r.get(o.depthTexture).__webglTexture&&o.depthTexture.image.width===o.width&&o.depthTexture.image.height===o.height||(o.depthTexture.image.width=o.width,o.depthTexture.image.height=o.height,o.depthTexture.needsUpdate=!0),j(o.depthTexture,0);var a=r.get(o.depthTexture).__webglTexture,i=B(o);if(o.depthTexture.format===me)q(o)?h.framebufferTexture2DMultisampleEXT(36160,36096,3553,a,0,i):n.framebufferTexture2D(36160,36096,3553,a,0);else{if(o.depthTexture.format!==he)throw new Error("Unknown depthTexture format");q(o)?h.framebufferTexture2DMultisampleEXT(36160,33306,3553,a,0,i):n.framebufferTexture2D(36160,33306,3553,a,0)}}(o.__webglFramebuffer,e)}else if(a){o.__webglDepthbuffer=[];for(var i=0;i<6;i++)t.bindFramebuffer(36160,o.__webglFramebuffer[i]),o.__webglDepthbuffer[i]=n.createRenderbuffer(),N(o.__webglDepthbuffer[i],e,!1)}else t.bindFramebuffer(36160,o.__webglFramebuffer),o.__webglDepthbuffer=n.createRenderbuffer(),N(o.__webglDepthbuffer,e,!1);t.bindFramebuffer(36160,null)}function B(n){return Math.min(m,n.samples)}function q(n){var t=r.get(n);return u&&n.samples>0&&!0===e.has("WEBGL_multisampled_render_to_texture")&&!1!==t.__useRenderToTexture}function V(n,t){var r=n.encoding,o=n.format,a=n.type;return!0===n.isCompressedTexture||!0===n.isVideoTexture||n.format===Vt||r!==ct&&(r===lt?!1===u?!0===e.has("EXT_sRGB")&&o===fe?(n.format=Vt,n.minFilter=Yn,n.generateMipmaps=!1):t=Sr.sRGBToLinear(t):o===fe&&a===Qn||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",r)),t}this.allocateTextureUnit=function(){var n=P;return n>=f&&console.warn("THREE.WebGLTextures: Trying to use "+n+" texture units while this GPU supports only "+f),P+=1,n},this.resetTextureUnits=function(){P=0},this.setTexture2D=j,this.setTexture2DArray=function(n,e){var o=r.get(n);n.version>0&&o.__version!==n.version?L(o,n,e):t.bindTexture(35866,o.__webglTexture,33984+e)},this.setTexture3D=function(n,e){var o=r.get(n);n.version>0&&o.__version!==n.version?L(o,n,e):t.bindTexture(32879,o.__webglTexture,33984+e)},this.setTextureCube=function(e,o){var i=r.get(e);e.version>0&&i.__version!==e.version?function(e,o,i){if(6!==o.image.length)return;var v=O(e,o),c=o.source;t.bindTexture(34067,e.__webglTexture,33984+i);var l=r.get(c);if(c.version!==l.__version||!0===v){t.activeTexture(33984+i),n.pixelStorei(37440,o.flipY),n.pixelStorei(37441,o.premultiplyAlpha),n.pixelStorei(3317,o.unpackAlignment),n.pixelStorei(37443,0);for(var s=o.isCompressedTexture||o.image[0].isCompressedTexture,f=o.image[0]&&o.image[0].isDataTexture,d=[],m=0;m<6;m++)d[m]=s||f?f?o.image[m].image:o.image[m]:U(o.image[m],!1,!0,p),d[m]=V(o,d[m]);var h,x=d[0],g=w(x)||u,y=a.convert(o.format,o.encoding),b=a.convert(o.type),_=M(o.internalFormat,y,b,o.encoding),C=u&&!0!==o.isVideoTexture,T=void 0===l.__version||!0===v,R=z(o,x,g);if(I(34067,o,g),s){C&&T&&t.texStorage2D(34067,R,_,x.width,x.height);for(var D=0;D<6;D++){h=d[D].mipmaps;for(var P=0;P<h.length;P++){var j=h[P];o.format!==fe?null!==y?C?t.compressedTexSubImage2D(34069+D,P,0,0,j.width,j.height,y,j.data):t.compressedTexImage2D(34069+D,P,_,j.width,j.height,0,j.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):C?t.texSubImage2D(34069+D,P,0,0,j.width,j.height,y,b,j.data):t.texImage2D(34069+D,P,_,j.width,j.height,0,y,b,j.data)}}}else{h=o.mipmaps,C&&T&&(h.length>0&&R++,t.texStorage2D(34067,R,_,d[0].width,d[0].height));for(var F=0;F<6;F++)if(f){C?t.texSubImage2D(34069+F,0,0,0,d[F].width,d[F].height,y,b,d[F].data):t.texImage2D(34069+F,0,_,d[F].width,d[F].height,0,y,b,d[F].data);for(var E=0;E<h.length;E++){var L=h[E].image[F].image;C?t.texSubImage2D(34069+F,E+1,0,0,L.width,L.height,y,b,L.data):t.texImage2D(34069+F,E+1,_,L.width,L.height,0,y,b,L.data)}}else{C?t.texSubImage2D(34069+F,0,0,0,y,b,d[F]):t.texImage2D(34069+F,0,_,y,b,d[F]);for(var A=0;A<h.length;A++){var N=h[A];C?t.texSubImage2D(34069+F,A+1,0,0,y,b,N.image[F]):t.texImage2D(34069+F,A+1,_,y,b,N.image[F])}}}S(o,g)&&k(34067),l.__version=c.version,o.onUpdate&&o.onUpdate(o)}e.__version=o.version}(i,e,o):t.bindTexture(34067,i.__webglTexture,33984+o)},this.rebindTextures=function(n,e,t){var o=r.get(n);void 0!==e&&A(o.__webglFramebuffer,n,n.texture,36064,3553),void 0!==t&&G(n)},this.setupRenderTarget=function(e){var v=e.texture,c=r.get(e),l=r.get(v);e.addEventListener("dispose",R),!0!==e.isWebGLMultipleRenderTargets&&(void 0===l.__webglTexture&&(l.__webglTexture=n.createTexture()),l.__version=v.version,i.memory.textures++);var s=!0===e.isWebGLCubeRenderTarget,f=!0===e.isWebGLMultipleRenderTargets,p=w(e)||u;if(s){c.__webglFramebuffer=[];for(var d=0;d<6;d++)c.__webglFramebuffer[d]=n.createFramebuffer()}else{if(c.__webglFramebuffer=n.createFramebuffer(),f)if(o.drawBuffers)for(var m=e.texture,h=0,x=m.length;h<x;h++){var g=r.get(m[h]);void 0===g.__webglTexture&&(g.__webglTexture=n.createTexture(),i.memory.textures++)}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(u&&e.samples>0&&!1===q(e)){var y=f?v:[v];c.__webglMultisampledFramebuffer=n.createFramebuffer(),c.__webglColorRenderbuffer=[],t.bindFramebuffer(36160,c.__webglMultisampledFramebuffer);for(var b=0;b<y.length;b++){var _=y[b];c.__webglColorRenderbuffer[b]=n.createRenderbuffer(),n.bindRenderbuffer(36161,c.__webglColorRenderbuffer[b]);var U=a.convert(_.format,_.encoding),z=a.convert(_.type),C=M(_.internalFormat,U,z,_.encoding,!0===e.isXRRenderTarget),T=B(e);n.renderbufferStorageMultisample(36161,T,C,e.width,e.height),n.framebufferRenderbuffer(36160,36064+b,36161,c.__webglColorRenderbuffer[b])}n.bindRenderbuffer(36161,null),e.depthBuffer&&(c.__webglDepthRenderbuffer=n.createRenderbuffer(),N(c.__webglDepthRenderbuffer,e,!0)),t.bindFramebuffer(36160,null)}}if(s){t.bindTexture(34067,l.__webglTexture),I(34067,v,p);for(var D=0;D<6;D++)A(c.__webglFramebuffer[D],e,v,36064,34069+D);S(v,p)&&k(34067),t.unbindTexture()}else if(f){for(var P=e.texture,j=0,F=P.length;j<F;j++){var E=P[j],O=r.get(E);t.bindTexture(3553,O.__webglTexture),I(3553,E,p),A(c.__webglFramebuffer,e,E,36064+j,3553),S(E,p)&&k(3553)}t.unbindTexture()}else{var L=3553;(e.isWebGL3DRenderTarget||e.isWebGLArrayRenderTarget)&&(u?L=e.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(L,l.__webglTexture),I(L,v,p),A(c.__webglFramebuffer,e,v,36064,L),S(v,p)&&k(L),t.unbindTexture()}e.depthBuffer&&G(e)},this.updateRenderTargetMipmap=function(n){for(var e=w(n)||u,o=!0===n.isWebGLMultipleRenderTargets?n.texture:[n.texture],a=0,i=o.length;a<i;a++){var v=o[a];if(S(v,e)){var c=n.isWebGLCubeRenderTarget?34067:3553,l=r.get(v).__webglTexture;t.bindTexture(c,l),k(c),t.unbindTexture()}}},this.updateMultisampleRenderTarget=function(e){if(u&&e.samples>0&&!1===q(e)){var o=e.isWebGLMultipleRenderTargets?e.texture:[e.texture],a=e.width,i=e.height,v=16384,c=[],l=e.stencilBuffer?33306:36096,s=r.get(e),f=!0===e.isWebGLMultipleRenderTargets;if(f)for(var p=0;p<o.length;p++)t.bindFramebuffer(36160,s.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064+p,36161,null),t.bindFramebuffer(36160,s.__webglFramebuffer),n.framebufferTexture2D(36009,36064+p,3553,null,0);t.bindFramebuffer(36008,s.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,s.__webglFramebuffer);for(var d=0;d<o.length;d++){c.push(36064+d),e.depthBuffer&&c.push(l);var m=void 0!==s.__ignoreDepthValues&&s.__ignoreDepthValues;if(!1===m&&(e.depthBuffer&&(v|=256),e.stencilBuffer&&(v|=1024)),f&&n.framebufferRenderbuffer(36008,36064,36161,s.__webglColorRenderbuffer[d]),!0===m&&(n.invalidateFramebuffer(36008,[l]),n.invalidateFramebuffer(36009,[l])),f){var h=r.get(o[d]).__webglTexture;n.framebufferTexture2D(36009,36064,3553,h,0)}n.blitFramebuffer(0,0,a,i,0,0,a,i,v,9728),x&&n.invalidateFramebuffer(36008,c)}if(t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,null),f)for(var g=0;g<o.length;g++){t.bindFramebuffer(36160,s.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064+g,36161,s.__webglColorRenderbuffer[g]);var y=r.get(o[g]).__webglTexture;t.bindFramebuffer(36160,s.__webglFramebuffer),n.framebufferTexture2D(36009,36064+g,3553,y,0)}t.bindFramebuffer(36009,s.__webglMultisampledFramebuffer)}},this.setupDepthRenderbuffer=G,this.setupFrameBufferTexture=A,this.useMultisampledRTT=q}function kc(n,e,t){var r=t.isWebGL2;return{convert:function(t){var o,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t===Qn)return 5121;if(t===ve)return 32819;if(t===ce)return 32820;if(t===ne)return 5120;if(t===ee)return 5122;if(t===te)return 5123;if(t===re)return 5124;if(t===oe)return 5125;if(t===ae)return 5126;if(t===ie)return r?5131:null!==(o=e.get("OES_texture_half_float"))?o.HALF_FLOAT_OES:null;if(t===se)return 6406;if(t===fe)return 6408;if(t===pe)return 6409;if(t===de)return 6410;if(t===me)return 6402;if(t===he)return 34041;if(t===xe)return 6403;if(t===ue)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(t===Vt)return null!==(o=e.get("EXT_sRGB"))?o.SRGB_ALPHA_EXT:null;if(t===ge)return 36244;if(t===ye)return 33319;if(t===be)return 33320;if(t===_e)return 36249;if(t===Ue||t===we||t===Se||t===ke)if(a===lt){if(null===(o=e.get("WEBGL_compressed_texture_s3tc_srgb")))return null;if(t===Ue)return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(t===we)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(t===Se)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(t===ke)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(null===(o=e.get("WEBGL_compressed_texture_s3tc")))return null;if(t===Ue)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(t===we)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(t===Se)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(t===ke)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(t===Me||t===ze||t===Ce||t===Te){if(null===(o=e.get("WEBGL_compressed_texture_pvrtc")))return null;if(t===Me)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(t===ze)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(t===Ce)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(t===Te)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(t===Re)return null!==(o=e.get("WEBGL_compressed_texture_etc1"))?o.COMPRESSED_RGB_ETC1_WEBGL:null;if(t===De||t===Pe){if(null===(o=e.get("WEBGL_compressed_texture_etc")))return null;if(t===De)return a===lt?o.COMPRESSED_SRGB8_ETC2:o.COMPRESSED_RGB8_ETC2;if(t===Pe)return a===lt?o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:o.COMPRESSED_RGBA8_ETC2_EAC}if(t===je||t===Fe||t===Ee||t===Ie||t===Oe||t===Le||t===Ae||t===Ne||t===Ge||t===Be||t===qe||t===Ve||t===We||t===He){if(null===(o=e.get("WEBGL_compressed_texture_astc")))return null;if(t===je)return a===lt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:o.COMPRESSED_RGBA_ASTC_4x4_KHR;if(t===Fe)return a===lt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:o.COMPRESSED_RGBA_ASTC_5x4_KHR;if(t===Ee)return a===lt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:o.COMPRESSED_RGBA_ASTC_5x5_KHR;if(t===Ie)return a===lt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:o.COMPRESSED_RGBA_ASTC_6x5_KHR;if(t===Oe)return a===lt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:o.COMPRESSED_RGBA_ASTC_6x6_KHR;if(t===Le)return a===lt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:o.COMPRESSED_RGBA_ASTC_8x5_KHR;if(t===Ae)return a===lt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:o.COMPRESSED_RGBA_ASTC_8x6_KHR;if(t===Ne)return a===lt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:o.COMPRESSED_RGBA_ASTC_8x8_KHR;if(t===Ge)return a===lt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:o.COMPRESSED_RGBA_ASTC_10x5_KHR;if(t===Be)return a===lt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:o.COMPRESSED_RGBA_ASTC_10x6_KHR;if(t===qe)return a===lt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:o.COMPRESSED_RGBA_ASTC_10x8_KHR;if(t===Ve)return a===lt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:o.COMPRESSED_RGBA_ASTC_10x10_KHR;if(t===We)return a===lt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:o.COMPRESSED_RGBA_ASTC_12x10_KHR;if(t===He)return a===lt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:o.COMPRESSED_RGBA_ASTC_12x12_KHR}if(t===Xe){if(null===(o=e.get("EXT_texture_compression_bptc")))return null;if(t===Xe)return a===lt?o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:o.COMPRESSED_RGBA_BPTC_UNORM_EXT}return t===le?r?34042:null!==(o=e.get("WEBGL_depth_texture"))?o.UNSIGNED_INT_24_8_WEBGL:null:void 0!==n[t]?n[t]:null}}}var Mc=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return y(this,t),(n=e.call(this)).isArrayCamera=!0,n.cameras=r,n}return _(t)}(Ha),zc=function(n){U(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).isGroup=!0,n.type="Group",n}return _(t)}(Ao),Cc={type:"move"},Tc=function(){function n(){y(this,n),this._targetRay=null,this._grip=null,this._hand=null}return _(n,[{key:"getHandSpace",value:function(){return null===this._hand&&(this._hand=new zc,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}},{key:"getTargetRaySpace",value:function(){return null===this._targetRay&&(this._targetRay=new zc,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Or,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Or),this._targetRay}},{key:"getGripSpace",value:function(){return null===this._grip&&(this._grip=new zc,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Or,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Or),this._grip}},{key:"dispatchEvent",value:function(n){return null!==this._targetRay&&this._targetRay.dispatchEvent(n),null!==this._grip&&this._grip.dispatchEvent(n),null!==this._hand&&this._hand.dispatchEvent(n),this}},{key:"disconnect",value:function(n){return this.dispatchEvent({type:"disconnected",data:n}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}},{key:"update",value:function(n,e,t){var r=null,o=null,a=null,i=this._targetRay,v=this._grip,c=this._hand;if(n&&"visible-blurred"!==e.session.visibilityState){if(c&&n.hand){a=!0;var l,s=f(n.hand.values());try{for(s.s();!(l=s.n()).done;){var u=l.value,p=e.getJointPose(u,t);if(void 0===c.joints[u.jointName]){var d=new zc;d.matrixAutoUpdate=!1,d.visible=!1,c.joints[u.jointName]=d,c.add(d)}var m=c.joints[u.jointName];null!==p&&(m.matrix.fromArray(p.transform.matrix),m.matrix.decompose(m.position,m.rotation,m.scale),m.jointRadius=p.radius),m.visible=null!==p}}catch(y){s.e(y)}finally{s.f()}var h=c.joints["index-finger-tip"],x=c.joints["thumb-tip"],g=h.position.distanceTo(x.position);c.inputState.pinching&&g>.025?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:n.handedness,target:this})):!c.inputState.pinching&&g<=.015&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:n.handedness,target:this}))}else null!==v&&n.gripSpace&&null!==(o=e.getPose(n.gripSpace,t))&&(v.matrix.fromArray(o.transform.matrix),v.matrix.decompose(v.position,v.rotation,v.scale),o.linearVelocity?(v.hasLinearVelocity=!0,v.linearVelocity.copy(o.linearVelocity)):v.hasLinearVelocity=!1,o.angularVelocity?(v.hasAngularVelocity=!0,v.angularVelocity.copy(o.angularVelocity)):v.hasAngularVelocity=!1);null!==i&&(null===(r=e.getPose(n.targetRaySpace,t))&&null!==o&&(r=o),null!==r&&(i.matrix.fromArray(r.transform.matrix),i.matrix.decompose(i.position,i.rotation,i.scale),r.linearVelocity?(i.hasLinearVelocity=!0,i.linearVelocity.copy(r.linearVelocity)):i.hasLinearVelocity=!1,r.angularVelocity?(i.hasAngularVelocity=!0,i.angularVelocity.copy(r.angularVelocity)):i.hasAngularVelocity=!1,this.dispatchEvent(Cc)))}return null!==i&&(i.visible=null!==r),null!==v&&(v.visible=null!==o),null!==c&&(c.visible=null!==a),this}}]),n}(),Rc=function(n){U(t,n);var e=z(t);function t(n,r,o,a,i,v,c,l,s,u){var f;if(y(this,t),(u=void 0!==u?u:me)!==me&&u!==he)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");return void 0===o&&u===me&&(o=oe),void 0===o&&u===he&&(o=le),(f=e.call(this,null,a,i,v,c,l,u,o,s)).isDepthTexture=!0,f.image={width:n,height:r},f.magFilter=void 0!==c?c:qn,f.minFilter=void 0!==l?l:qn,f.flipY=!1,f.generateMipmaps=!1,f}return _(t)}(Cr),Dc=function(n){U(t,n);var e=z(t);function t(n,r){var o;y(this,t);var a=k(o=e.call(this)),i=null,v=1,c=null,l="local-floor",s=null,u=null,f=null,p=null,d=null,m=null,h=r.getContextAttributes(),x=null,g=null,b=[],_=[],U=new Ha;U.layers.enable(1),U.viewport=new Tr;var w=new Ha;w.layers.enable(2),w.viewport=new Tr;var S=[U,w],M=new Mc;M.layers.enable(1),M.layers.enable(2);var z=null,C=null;function T(n){var e=_.indexOf(n.inputSource);if(-1!==e){var t=b[e];void 0!==t&&t.dispatchEvent({type:n.type,data:n.inputSource})}}function D(){i.removeEventListener("select",T),i.removeEventListener("selectstart",T),i.removeEventListener("selectend",T),i.removeEventListener("squeeze",T),i.removeEventListener("squeezestart",T),i.removeEventListener("squeezeend",T),i.removeEventListener("end",D),i.removeEventListener("inputsourceschange",P);for(var e=0;e<b.length;e++){var t=_[e];null!==t&&(_[e]=null,b[e].disconnect(t))}z=null,C=null,n.setRenderTarget(x),d=null,p=null,f=null,i=null,g=null,L.stop(),a.isPresenting=!1,a.dispatchEvent({type:"sessionend"})}function P(n){for(var e=0;e<n.removed.length;e++){var t=n.removed[e],r=_.indexOf(t);r>=0&&(_[r]=null,b[r].dispatchEvent({type:"disconnected",data:t}))}for(var o=0;o<n.added.length;o++){var a=n.added[o],i=_.indexOf(a);if(-1===i){for(var v=0;v<b.length;v++){if(v>=_.length){_.push(a),i=v;break}if(null===_[v]){_[v]=a,i=v;break}}if(-1===i)break}var c=b[i];c&&c.dispatchEvent({type:"connected",data:a})}}o.cameraAutoUpdate=!0,o.enabled=!1,o.isPresenting=!1,o.getController=function(n){var e=b[n];return void 0===e&&(e=new Tc,b[n]=e),e.getTargetRaySpace()},o.getControllerGrip=function(n){var e=b[n];return void 0===e&&(e=new Tc,b[n]=e),e.getGripSpace()},o.getHand=function(n){var e=b[n];return void 0===e&&(e=new Tc,b[n]=e),e.getHandSpace()},o.setFramebufferScaleFactor=function(n){v=n,!0===a.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},o.setReferenceSpaceType=function(n){l=n,!0===a.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},o.getReferenceSpace=function(){return s||c},o.setReferenceSpace=function(n){s=n},o.getBaseLayer=function(){return null!==p?p:d},o.getBinding=function(){return f},o.getFrame=function(){return m},o.getSession=function(){return i},o.setSession=function(){var e=R(j().mark((function e(t){var o,u,m,y,b;return j().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(null===(i=t)){e.next=25;break}if(x=n.getRenderTarget(),i.addEventListener("select",T),i.addEventListener("selectstart",T),i.addEventListener("selectend",T),i.addEventListener("squeeze",T),i.addEventListener("squeezestart",T),i.addEventListener("squeezeend",T),i.addEventListener("end",D),i.addEventListener("inputsourceschange",P),!0===h.xrCompatible){e.next=14;break}return e.next=14,r.makeXRCompatible();case 14:return void 0===i.renderState.layers||!1===n.capabilities.isWebGL2?(o={antialias:void 0!==i.renderState.layers||h.antialias,alpha:h.alpha,depth:h.depth,stencil:h.stencil,framebufferScaleFactor:v},d=new XRWebGLLayer(i,r,o),i.updateRenderState({baseLayer:d}),g=new Rr(d.framebufferWidth,d.framebufferHeight,{format:fe,type:Qn,encoding:n.outputEncoding,stencilBuffer:h.stencil})):(u=null,m=null,y=null,h.depth&&(y=h.stencil?35056:33190,u=h.stencil?he:me,m=h.stencil?le:oe),b={colorFormat:32856,depthFormat:y,scaleFactor:v},f=new XRWebGLBinding(i,r),p=f.createProjectionLayer(b),i.updateRenderState({layers:[p]}),g=new Rr(p.textureWidth,p.textureHeight,{format:fe,type:Qn,depthTexture:new Rc(p.textureWidth,p.textureHeight,m,void 0,void 0,void 0,void 0,void 0,void 0,u),stencilBuffer:h.stencil,encoding:n.outputEncoding,samples:h.antialias?4:0}),n.properties.get(g).__ignoreDepthValues=p.ignoreDepthValues),g.isXRRenderTarget=!0,this.setFoveation(1),s=null,e.next=20,i.requestReferenceSpace(l);case 20:c=e.sent,L.setContext(i),L.start(),a.isPresenting=!0,a.dispatchEvent({type:"sessionstart"});case 25:case"end":return e.stop()}}),e,this)})));return function(n){return e.apply(this,arguments)}}();var F=new Or,E=new Or;function I(n,e){null===e?n.matrixWorld.copy(n.matrix):n.matrixWorld.multiplyMatrices(e.matrixWorld,n.matrix),n.matrixWorldInverse.copy(n.matrixWorld).invert()}o.updateCamera=function(n){if(null!==i){M.near=w.near=U.near=n.near,M.far=w.far=U.far=n.far,z===M.near&&C===M.far||(i.updateRenderState({depthNear:M.near,depthFar:M.far}),z=M.near,C=M.far);var e=n.parent,t=M.cameras;I(M,e);for(var r=0;r<t.length;r++)I(t[r],e);M.matrixWorld.decompose(M.position,M.quaternion,M.scale),n.matrix.copy(M.matrix),n.matrix.decompose(n.position,n.quaternion,n.scale);for(var o=n.children,a=0,v=o.length;a<v;a++)o[a].updateMatrixWorld(!0);2===t.length?function(n,e,t){F.setFromMatrixPosition(e.matrixWorld),E.setFromMatrixPosition(t.matrixWorld);var r=F.distanceTo(E),o=e.projectionMatrix.elements,a=t.projectionMatrix.elements,i=o[14]/(o[10]-1),v=o[14]/(o[10]+1),c=(o[9]+1)/o[5],l=(o[9]-1)/o[5],s=(o[8]-1)/o[0],u=(a[8]+1)/a[0],f=i*s,p=i*u,d=r/(-s+u),m=d*-s;e.matrixWorld.decompose(n.position,n.quaternion,n.scale),n.translateX(m),n.translateZ(d),n.matrixWorld.compose(n.position,n.quaternion,n.scale),n.matrixWorldInverse.copy(n.matrixWorld).invert();var h=i+d,x=v+d,g=f-m,y=p+(r-m),b=c*v/x*h,_=l*v/x*h;n.projectionMatrix.makePerspective(g,y,b,_,h,x)}(M,U,w):M.projectionMatrix.copy(U.projectionMatrix)}},o.getCamera=function(){return M},o.getFoveation=function(){return null!==p?p.fixedFoveation:null!==d?d.fixedFoveation:void 0},o.setFoveation=function(n){null!==p&&(p.fixedFoveation=n),null!==d&&void 0!==d.fixedFoveation&&(d.fixedFoveation=n)};var O=null;var L=new oi;return L.setAnimationLoop((function(e,t){if(u=t.getViewerPose(s||c),m=t,null!==u){var r=u.views;null!==d&&(n.setRenderTargetFramebuffer(g,d.framebuffer),n.setRenderTarget(g));var o=!1;r.length!==M.cameras.length&&(M.cameras.length=0,o=!0);for(var a=0;a<r.length;a++){var i=r[a],v=null;if(null!==d)v=d.getViewport(i);else{var l=f.getViewSubImage(p,i);v=l.viewport,0===a&&(n.setRenderTargetTextures(g,l.colorTexture,p.ignoreDepthValues?void 0:l.depthStencilTexture),n.setRenderTarget(g))}var h=S[a];void 0===h&&((h=new Ha).layers.enable(a),h.viewport=new Tr,S[a]=h),h.matrix.fromArray(i.transform.matrix),h.projectionMatrix.fromArray(i.projectionMatrix),h.viewport.set(v.x,v.y,v.width,v.height),0===a&&M.matrix.copy(h.matrix),!0===o&&M.cameras.push(h)}}for(var x=0;x<b.length;x++){var y=_[x],U=b[x];null!==y&&void 0!==U&&U.update(y,t,s||c)}O&&O(e,t),m=null})),o.setAnimationLoop=function(n){O=n},o.dispose=function(){},o}return _(t)}(Wt);function Pc(n,e){function t(t,r){t.opacity.value=r.opacity,r.color&&t.diffuse.value.copy(r.color),r.emissive&&t.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),r.map&&(t.map.value=r.map),r.alphaMap&&(t.alphaMap.value=r.alphaMap),r.bumpMap&&(t.bumpMap.value=r.bumpMap,t.bumpScale.value=r.bumpScale,r.side===H&&(t.bumpScale.value*=-1)),r.displacementMap&&(t.displacementMap.value=r.displacementMap,t.displacementScale.value=r.displacementScale,t.displacementBias.value=r.displacementBias),r.emissiveMap&&(t.emissiveMap.value=r.emissiveMap),r.normalMap&&(t.normalMap.value=r.normalMap,t.normalScale.value.copy(r.normalScale),r.side===H&&t.normalScale.value.negate()),r.specularMap&&(t.specularMap.value=r.specularMap),r.alphaTest>0&&(t.alphaTest.value=r.alphaTest);var o,a,i=e.get(r).envMap;if(i&&(t.envMap.value=i,t.flipEnvMap.value=i.isCubeTexture&&!1===i.isRenderTargetTexture?-1:1,t.reflectivity.value=r.reflectivity,t.ior.value=r.ior,t.refractionRatio.value=r.refractionRatio),r.lightMap){t.lightMap.value=r.lightMap;var v=!0!==n.physicallyCorrectLights?Math.PI:1;t.lightMapIntensity.value=r.lightMapIntensity*v}r.aoMap&&(t.aoMap.value=r.aoMap,t.aoMapIntensity.value=r.aoMapIntensity),r.map?o=r.map:r.specularMap?o=r.specularMap:r.displacementMap?o=r.displacementMap:r.normalMap?o=r.normalMap:r.bumpMap?o=r.bumpMap:r.roughnessMap?o=r.roughnessMap:r.metalnessMap?o=r.metalnessMap:r.alphaMap?o=r.alphaMap:r.emissiveMap?o=r.emissiveMap:r.clearcoatMap?o=r.clearcoatMap:r.clearcoatNormalMap?o=r.clearcoatNormalMap:r.clearcoatRoughnessMap?o=r.clearcoatRoughnessMap:r.iridescenceMap?o=r.iridescenceMap:r.iridescenceThicknessMap?o=r.iridescenceThicknessMap:r.specularIntensityMap?o=r.specularIntensityMap:r.specularColorMap?o=r.specularColorMap:r.transmissionMap?o=r.transmissionMap:r.thicknessMap?o=r.thicknessMap:r.sheenColorMap?o=r.sheenColorMap:r.sheenRoughnessMap&&(o=r.sheenRoughnessMap),void 0!==o&&(o.isWebGLRenderTarget&&(o=o.texture),!0===o.matrixAutoUpdate&&o.updateMatrix(),t.uvTransform.value.copy(o.matrix)),r.aoMap?a=r.aoMap:r.lightMap&&(a=r.lightMap),void 0!==a&&(a.isWebGLRenderTarget&&(a=a.texture),!0===a.matrixAutoUpdate&&a.updateMatrix(),t.uv2Transform.value.copy(a.matrix))}return{refreshFogUniforms:function(n,e){n.fogColor.value.copy(e.color),e.isFog?(n.fogNear.value=e.near,n.fogFar.value=e.far):e.isFogExp2&&(n.fogDensity.value=e.density)},refreshMaterialUniforms:function(n,r,o,a,i){r.isMeshBasicMaterial||r.isMeshLambertMaterial?t(n,r):r.isMeshToonMaterial?(t(n,r),function(n,e){e.gradientMap&&(n.gradientMap.value=e.gradientMap)}(n,r)):r.isMeshPhongMaterial?(t(n,r),function(n,e){n.specular.value.copy(e.specular),n.shininess.value=Math.max(e.shininess,1e-4)}(n,r)):r.isMeshStandardMaterial?(t(n,r),function(n,t){n.roughness.value=t.roughness,n.metalness.value=t.metalness,t.roughnessMap&&(n.roughnessMap.value=t.roughnessMap);t.metalnessMap&&(n.metalnessMap.value=t.metalnessMap);e.get(t).envMap&&(n.envMapIntensity.value=t.envMapIntensity)}(n,r),r.isMeshPhysicalMaterial&&function(n,e,t){n.ior.value=e.ior,e.sheen>0&&(n.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),n.sheenRoughness.value=e.sheenRoughness,e.sheenColorMap&&(n.sheenColorMap.value=e.sheenColorMap),e.sheenRoughnessMap&&(n.sheenRoughnessMap.value=e.sheenRoughnessMap));e.clearcoat>0&&(n.clearcoat.value=e.clearcoat,n.clearcoatRoughness.value=e.clearcoatRoughness,e.clearcoatMap&&(n.clearcoatMap.value=e.clearcoatMap),e.clearcoatRoughnessMap&&(n.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap),e.clearcoatNormalMap&&(n.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),n.clearcoatNormalMap.value=e.clearcoatNormalMap,e.side===H&&n.clearcoatNormalScale.value.negate()));e.iridescence>0&&(n.iridescence.value=e.iridescence,n.iridescenceIOR.value=e.iridescenceIOR,n.iridescenceThicknessMinimum.value=e.iridescenceThicknessRange[0],n.iridescenceThicknessMaximum.value=e.iridescenceThicknessRange[1],e.iridescenceMap&&(n.iridescenceMap.value=e.iridescenceMap),e.iridescenceThicknessMap&&(n.iridescenceThicknessMap.value=e.iridescenceThicknessMap));e.transmission>0&&(n.transmission.value=e.transmission,n.transmissionSamplerMap.value=t.texture,n.transmissionSamplerSize.value.set(t.width,t.height),e.transmissionMap&&(n.transmissionMap.value=e.transmissionMap),n.thickness.value=e.thickness,e.thicknessMap&&(n.thicknessMap.value=e.thicknessMap),n.attenuationDistance.value=e.attenuationDistance,n.attenuationColor.value.copy(e.attenuationColor));n.specularIntensity.value=e.specularIntensity,n.specularColor.value.copy(e.specularColor),e.specularIntensityMap&&(n.specularIntensityMap.value=e.specularIntensityMap);e.specularColorMap&&(n.specularColorMap.value=e.specularColorMap)}(n,r,i)):r.isMeshMatcapMaterial?(t(n,r),function(n,e){e.matcap&&(n.matcap.value=e.matcap)}(n,r)):r.isMeshDepthMaterial?t(n,r):r.isMeshDistanceMaterial?(t(n,r),function(n,e){n.referencePosition.value.copy(e.referencePosition),n.nearDistance.value=e.nearDistance,n.farDistance.value=e.farDistance}(n,r)):r.isMeshNormalMaterial?t(n,r):r.isLineBasicMaterial?(function(n,e){n.diffuse.value.copy(e.color),n.opacity.value=e.opacity}(n,r),r.isLineDashedMaterial&&function(n,e){n.dashSize.value=e.dashSize,n.totalSize.value=e.dashSize+e.gapSize,n.scale.value=e.scale}(n,r)):r.isPointsMaterial?function(n,e,t,r){n.diffuse.value.copy(e.color),n.opacity.value=e.opacity,n.size.value=e.size*t,n.scale.value=.5*r,e.map&&(n.map.value=e.map);e.alphaMap&&(n.alphaMap.value=e.alphaMap);e.alphaTest>0&&(n.alphaTest.value=e.alphaTest);var o;e.map?o=e.map:e.alphaMap&&(o=e.alphaMap);void 0!==o&&(!0===o.matrixAutoUpdate&&o.updateMatrix(),n.uvTransform.value.copy(o.matrix))}(n,r,o,a):r.isSpriteMaterial?function(n,e){n.diffuse.value.copy(e.color),n.opacity.value=e.opacity,n.rotation.value=e.rotation,e.map&&(n.map.value=e.map);e.alphaMap&&(n.alphaMap.value=e.alphaMap);e.alphaTest>0&&(n.alphaTest.value=e.alphaTest);var t;e.map?t=e.map:e.alphaMap&&(t=e.alphaMap);void 0!==t&&(!0===t.matrixAutoUpdate&&t.updateMatrix(),n.uvTransform.value.copy(t.matrix))}(n,r):r.isShadowMaterial?(n.color.value.copy(r.color),n.opacity.value=r.opacity):r.isShaderMaterial&&(r.uniformsNeedUpdate=!1)}}}function jc(n,e,t,r){var o={},a={},i=[],v=t.isWebGL2?n.getParameter(35375):0;function c(n,e,t){var r=n.value;if(void 0===t[e])return t[e]="number"===typeof r?r:r.clone(),!0;if("number"===typeof r){if(t[e]!==r)return t[e]=r,!0}else{var o=t[e];if(!1===o.equals(r))return o.copy(r),!0}return!1}function l(n){var e=n.value,t={boundary:0,storage:0};return"number"===typeof e?(t.boundary=4,t.storage=4):e.isVector2?(t.boundary=8,t.storage=8):e.isVector3||e.isColor?(t.boundary=16,t.storage=12):e.isVector4?(t.boundary=16,t.storage=16):e.isMatrix3?(t.boundary=48,t.storage=48):e.isMatrix4?(t.boundary=64,t.storage=64):e.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",e),t}function s(e){var t=e.target;t.removeEventListener("dispose",s);var r=i.indexOf(t.__bindingPointIndex);i.splice(r,1),n.deleteBuffer(o[t.id]),delete o[t.id],delete a[t.id]}return{bind:function(n,e){var t=e.program;r.uniformBlockBinding(n,t)},update:function(t,u){var f=o[t.id];void 0===f&&(!function(n){for(var e=n.uniforms,t=0,r=16,o=0,a=0,i=e.length;a<i;a++){var v=e[a],c=l(v);if(v.__data=new Float32Array(c.storage/Float32Array.BYTES_PER_ELEMENT),v.__offset=t,a>0)0!==(o=t%r)&&r-o-c.boundary<0&&(t+=r-o,v.__offset=t);t+=c.storage}(o=t%r)>0&&(t+=r-o);n.__size=t,n.__cache={}}(t),f=function(e){var t=function(){for(var n=0;n<v;n++)if(-1===i.indexOf(n))return i.push(n),n;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();e.__bindingPointIndex=t;var r=n.createBuffer(),o=e.__size,a=e.usage;return n.bindBuffer(35345,r),n.bufferData(35345,o,a),n.bindBuffer(35345,null),n.bindBufferBase(35345,t,r),r}(t),o[t.id]=f,t.addEventListener("dispose",s));var p=u.program;r.updateUBOMapping(t,p);var d=e.render.frame;a[t.id]!==d&&(!function(e){var t=o[e.id],r=e.uniforms,a=e.__cache;n.bindBuffer(35345,t);for(var i=0,v=r.length;i<v;i++){var l=r[i];if(!0===c(l,i,a)){var s=l.value,u=l.__offset;"number"===typeof s?(l.__data[0]=s,n.bufferSubData(35345,u,l.__data)):(l.value.isMatrix3?(l.__data[0]=l.value.elements[0],l.__data[1]=l.value.elements[1],l.__data[2]=l.value.elements[2],l.__data[3]=l.value.elements[0],l.__data[4]=l.value.elements[3],l.__data[5]=l.value.elements[4],l.__data[6]=l.value.elements[5],l.__data[7]=l.value.elements[0],l.__data[8]=l.value.elements[6],l.__data[9]=l.value.elements[7],l.__data[10]=l.value.elements[8],l.__data[11]=l.value.elements[0]):s.toArray(l.__data),n.bufferSubData(35345,u,l.__data))}}n.bindBuffer(35345,null)}(t),a[t.id]=d)},dispose:function(){for(var e in o)n.deleteBuffer(o[e]);i=[],o={},a={}}}}function Fc(){var n=ur("canvas");return n.style.display="block",n}function Ec(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.isWebGLRenderer=!0;var e,t=void 0!==n.canvas?n.canvas:Fc(),r=void 0!==n.context?n.context:null,o=void 0===n.depth||n.depth,a=void 0===n.stencil||n.stencil,i=void 0!==n.antialias&&n.antialias,v=void 0===n.premultipliedAlpha||n.premultipliedAlpha,c=void 0!==n.preserveDrawingBuffer&&n.preserveDrawingBuffer,l=void 0!==n.powerPreference?n.powerPreference:"default",s=void 0!==n.failIfMajorPerformanceCaveat&&n.failIfMajorPerformanceCaveat;e=null!==r?r.getContextAttributes().alpha:void 0!==n.alpha&&n.alpha;var u=null,f=null,p=[],d=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=ct,this.physicallyCorrectLights=!1,this.toneMapping=Cn,this.toneMappingExposure=1,Object.defineProperties(this,{gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});var m=this,h=!1,x=0,g=0,y=null,b=-1,_=null,U=new Tr,w=new Tr,S=null,k=t.width,M=t.height,z=1,C=null,T=null,R=new Tr(0,0,k,M),D=new Tr(0,0,k,M),P=!1,j=new ri,E=!1,I=!1,O=null,L=new po,A=new ir,N=new Or,G={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function B(){return null===y?z:1}var q,V,Y,$,Z,K,J,Q,nn,en,tn,rn,on,an,vn,cn,ln,sn,un,fn,pn,dn,mn,hn,xn=r;function gn(n,e){for(var r=0;r<n.length;r++){var o=n[r],a=t.getContext(o,e);if(null!==a)return a}return null}try{var yn={alpha:!0,depth:o,stencil:a,antialias:i,premultipliedAlpha:v,preserveDrawingBuffer:c,powerPreference:l,failIfMajorPerformanceCaveat:s};if("setAttribute"in t&&t.setAttribute("data-engine","three.js r".concat(F)),t.addEventListener("webglcontextlost",wn,!1),t.addEventListener("webglcontextrestored",Sn,!1),t.addEventListener("webglcontextcreationerror",kn,!1),null===xn){var bn=["webgl2","webgl","experimental-webgl"];if(!0===m.isWebGL1Renderer&&bn.shift(),null===(xn=gn(bn,yn)))throw gn(bn)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===xn.getShaderPrecisionFormat&&(xn.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(Wn){throw console.error("THREE.WebGLRenderer: "+Wn.message),Wn}function _n(){q=new Di(xn),V=new pi(xn,q,n),q.init(V),dn=new kc(xn,q,V),Y=new wc(xn,q,V),$=new Fi,Z=new lc,K=new Sc(xn,q,Y,Z,V,dn,$),J=new mi(m),Q=new Ri(m),nn=new ai(xn,V),mn=new ui(xn,q,nn,V),en=new Pi(xn,nn,$,mn),tn=new Li(xn,en,nn,$),un=new Oi(xn,V,K),cn=new di(Z),rn=new cc(m,J,Q,q,V,mn,cn),on=new Pc(m,Z),an=new pc,vn=new yc(q,V),sn=new si(m,J,Q,Y,tn,e,v),ln=new Uc(m,tn,V),hn=new jc(xn,$,V,Y),fn=new fi(xn,q,$,V),pn=new ji(xn,q,$,V),$.programs=rn.programs,m.capabilities=V,m.extensions=q,m.properties=Z,m.renderLists=an,m.shadowMap=ln,m.state=Y,m.info=$}_n();var Un=new Dc(m,xn);function wn(n){n.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),h=!0}function Sn(){console.log("THREE.WebGLRenderer: Context Restored."),h=!1;var n=$.autoReset,e=ln.enabled,t=ln.autoUpdate,r=ln.needsUpdate,o=ln.type;_n(),$.autoReset=n,ln.enabled=e,ln.autoUpdate=t,ln.needsUpdate=r,ln.type=o}function kn(n){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",n.statusMessage)}function Mn(n){var e=n.target;e.removeEventListener("dispose",Mn),zn(e)}function zn(n){Tn(n),Z.remove(n)}function Tn(n){var e=Z.get(n).programs;void 0!==e&&(e.forEach((function(n){rn.releaseProgram(n)})),n.isShaderMaterial&&rn.releaseShaderCache(n))}this.xr=Un,this.getContext=function(){return xn},this.getContextAttributes=function(){return xn.getContextAttributes()},this.forceContextLoss=function(){var n=q.get("WEBGL_lose_context");n&&n.loseContext()},this.forceContextRestore=function(){var n=q.get("WEBGL_lose_context");n&&n.restoreContext()},this.getPixelRatio=function(){return z},this.setPixelRatio=function(n){void 0!==n&&(z=n,this.setSize(k,M,!1))},this.getSize=function(n){return n.set(k,M)},this.setSize=function(n,e,r){Un.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(k=n,M=e,t.width=Math.floor(n*z),t.height=Math.floor(e*z),!1!==r&&(t.style.width=n+"px",t.style.height=e+"px"),this.setViewport(0,0,n,e))},this.getDrawingBufferSize=function(n){return n.set(k*z,M*z).floor()},this.setDrawingBufferSize=function(n,e,r){k=n,M=e,z=r,t.width=Math.floor(n*r),t.height=Math.floor(e*r),this.setViewport(0,0,n,e)},this.getCurrentViewport=function(n){return n.copy(U)},this.getViewport=function(n){return n.copy(R)},this.setViewport=function(n,e,t,r){n.isVector4?R.set(n.x,n.y,n.z,n.w):R.set(n,e,t,r),Y.viewport(U.copy(R).multiplyScalar(z).floor())},this.getScissor=function(n){return n.copy(D)},this.setScissor=function(n,e,t,r){n.isVector4?D.set(n.x,n.y,n.z,n.w):D.set(n,e,t,r),Y.scissor(w.copy(D).multiplyScalar(z).floor())},this.getScissorTest=function(){return P},this.setScissorTest=function(n){Y.setScissorTest(P=n)},this.setOpaqueSort=function(n){C=n},this.setTransparentSort=function(n){T=n},this.getClearColor=function(n){return n.copy(sn.getClearColor())},this.setClearColor=function(){sn.setClearColor.apply(sn,arguments)},this.getClearAlpha=function(){return sn.getClearAlpha()},this.setClearAlpha=function(){sn.setClearAlpha.apply(sn,arguments)},this.clear=function(){var n=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],t=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=0;n&&(r|=16384),e&&(r|=256),t&&(r|=1024),xn.clear(r)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",wn,!1),t.removeEventListener("webglcontextrestored",Sn,!1),t.removeEventListener("webglcontextcreationerror",kn,!1),an.dispose(),vn.dispose(),Z.dispose(),J.dispose(),Q.dispose(),tn.dispose(),mn.dispose(),hn.dispose(),rn.dispose(),Un.dispose(),Un.removeEventListener("sessionstart",Pn),Un.removeEventListener("sessionend",jn),O&&(O.dispose(),O=null),Fn.stop()},this.renderBufferDirect=function(n,e,t,r,o,a){null===e&&(e=G);var i=o.isMesh&&o.matrixWorld.determinant()<0,v=Bn(n,e,t,r,o);Y.setMaterial(r,i);var c=t.index,l=t.attributes.position;if(null===c){if(void 0===l||0===l.count)return}else if(0===c.count)return;var s,u=1;!0===r.wireframe&&(c=en.getWireframeAttribute(t),u=2),mn.setup(o,r,v,t,c);var f=fn;null!==c&&(s=nn.get(c),(f=pn).setIndex(s));var p=null!==c?c.count:l.count,d=t.drawRange.start*u,m=t.drawRange.count*u,h=null!==a?a.start*u:0,x=null!==a?a.count*u:1/0,g=Math.max(d,h),y=Math.min(p,d+m,h+x)-1,b=Math.max(0,y-g+1);if(0!==b){if(o.isMesh)!0===r.wireframe?(Y.setLineWidth(r.wireframeLinewidth*B()),f.setMode(1)):f.setMode(4);else if(o.isLine){var _=r.linewidth;void 0===_&&(_=1),Y.setLineWidth(_*B()),o.isLineSegments?f.setMode(1):o.isLineLoop?f.setMode(2):f.setMode(3)}else o.isPoints?f.setMode(0):o.isSprite&&f.setMode(4);if(o.isInstancedMesh)f.renderInstances(g,b,o.count);else if(t.isInstancedBufferGeometry){var U=Math.min(t.instanceCount,t._maxInstanceCount);f.renderInstances(g,b,U)}else f.render(g,b)}},this.compile=function(n,e){function t(n,e,t){!0===n.transparent&&n.side===X?(n.side=H,n.needsUpdate=!0,Nn(n,e,t),n.side=W,n.needsUpdate=!0,Nn(n,e,t),n.side=X):Nn(n,e,t)}(f=vn.get(n)).init(),d.push(f),n.traverseVisible((function(n){n.isLight&&n.layers.test(e.layers)&&(f.pushLight(n),n.castShadow&&f.pushShadow(n))})),f.setupLights(m.physicallyCorrectLights),n.traverse((function(e){var r=e.material;if(r)if(Array.isArray(r))for(var o=0;o<r.length;o++){t(r[o],n,e)}else t(r,n,e)})),d.pop(),f=null};var Rn=null;function Dn(n){Rn&&Rn(n)}function Pn(){Fn.stop()}function jn(){Fn.start()}var Fn=new oi;function En(n,e,t,r){if(!1!==n.visible){if(n.layers.test(e.layers))if(n.isGroup)t=n.renderOrder;else if(n.isLOD)!0===n.autoUpdate&&n.update(e);else if(n.isLight)f.pushLight(n),n.castShadow&&f.pushShadow(n);else if(n.isSprite){if(!n.frustumCulled||j.intersectsSprite(n)){r&&N.setFromMatrixPosition(n.matrixWorld).applyMatrix4(L);var o=tn.update(n),a=n.material;a.visible&&u.push(n,o,a,t,N.z,null)}}else if((n.isMesh||n.isLine||n.isPoints)&&(n.isSkinnedMesh&&n.skeleton.frame!==$.render.frame&&(n.skeleton.update(),n.skeleton.frame=$.render.frame),!n.frustumCulled||j.intersectsObject(n))){r&&N.setFromMatrixPosition(n.matrixWorld).applyMatrix4(L);var i=tn.update(n),v=n.material;if(Array.isArray(v))for(var c=i.groups,l=0,s=c.length;l<s;l++){var p=c[l],d=v[p.materialIndex];d&&d.visible&&u.push(n,i,d,t,N.z,p)}else v.visible&&u.push(n,i,v,t,N.z,null)}for(var m=n.children,h=0,x=m.length;h<x;h++)En(m[h],e,t,r)}}function In(n,e,t,r){var o=n.opaque,a=n.transmissive,i=n.transparent;f.setupLightsView(t),a.length>0&&On(o,e,t),r&&Y.viewport(U.copy(r)),o.length>0&&Ln(o,e,t),a.length>0&&Ln(a,e,t),i.length>0&&Ln(i,e,t),Y.buffers.depth.setTest(!0),Y.buffers.depth.setMask(!0),Y.buffers.color.setMask(!0),Y.setPolygonOffset(!1)}function On(n,e,t){var r=V.isWebGL2;null===O&&(O=new Rr(1,1,{generateMipmaps:!0,type:q.has("EXT_color_buffer_half_float")?ie:Qn,minFilter:Kn,samples:r&&!0===i?4:0})),m.getDrawingBufferSize(A),r?O.setSize(A.x,A.y):O.setSize(tr(A.x),tr(A.y));var o=m.getRenderTarget();m.setRenderTarget(O),m.clear();var a=m.toneMapping;m.toneMapping=Cn,Ln(n,e,t),m.toneMapping=a,K.updateMultisampleRenderTarget(O),K.updateRenderTargetMipmap(O),m.setRenderTarget(o)}function Ln(n,e,t){for(var r=!0===e.isScene?e.overrideMaterial:null,o=0,a=n.length;o<a;o++){var i=n[o],v=i.object,c=i.geometry,l=null===r?i.material:r,s=i.group;v.layers.test(t.layers)&&An(v,e,t,c,l,s)}}function An(n,e,t,r,o,a){n.onBeforeRender(m,e,t,r,o,a),n.modelViewMatrix.multiplyMatrices(t.matrixWorldInverse,n.matrixWorld),n.normalMatrix.getNormalMatrix(n.modelViewMatrix),o.onBeforeRender(m,e,t,r,n,a),!0===o.transparent&&o.side===X?(o.side=H,o.needsUpdate=!0,m.renderBufferDirect(t,e,r,o,n,a),o.side=W,o.needsUpdate=!0,m.renderBufferDirect(t,e,r,o,n,a),o.side=X):m.renderBufferDirect(t,e,r,o,n,a),n.onAfterRender(m,e,t,r,o,a)}function Nn(n,e,t){!0!==e.isScene&&(e=G);var r=Z.get(n),o=f.state.lights,a=f.state.shadowsArray,i=o.state.version,v=rn.getParameters(n,o.state,a,e,t),c=rn.getProgramCacheKey(v),l=r.programs;r.environment=n.isMeshStandardMaterial?e.environment:null,r.fog=e.fog,r.envMap=(n.isMeshStandardMaterial?Q:J).get(n.envMap||r.environment),void 0===l&&(n.addEventListener("dispose",Mn),l=new Map,r.programs=l);var s=l.get(c);if(void 0!==s){if(r.currentProgram===s&&r.lightsStateVersion===i)return Gn(n,v),s}else v.uniforms=rn.getUniforms(n),n.onBuild(t,v,m),n.onBeforeCompile(v,m),s=rn.acquireProgram(v,c),l.set(c,s),r.uniforms=v.uniforms;var u=r.uniforms;(n.isShaderMaterial||n.isRawShaderMaterial)&&!0!==n.clipping||(u.clippingPlanes=cn.uniform),Gn(n,v),r.needsLights=Vn(n),r.lightsStateVersion=i,r.needsLights&&(u.ambientLightColor.value=o.state.ambient,u.lightProbe.value=o.state.probe,u.directionalLights.value=o.state.directional,u.directionalLightShadows.value=o.state.directionalShadow,u.spotLights.value=o.state.spot,u.spotLightShadows.value=o.state.spotShadow,u.rectAreaLights.value=o.state.rectArea,u.ltc_1.value=o.state.rectAreaLTC1,u.ltc_2.value=o.state.rectAreaLTC2,u.pointLights.value=o.state.point,u.pointLightShadows.value=o.state.pointShadow,u.hemisphereLights.value=o.state.hemi,u.directionalShadowMap.value=o.state.directionalShadowMap,u.directionalShadowMatrix.value=o.state.directionalShadowMatrix,u.spotShadowMap.value=o.state.spotShadowMap,u.spotLightMatrix.value=o.state.spotLightMatrix,u.spotLightMap.value=o.state.spotLightMap,u.pointShadowMap.value=o.state.pointShadowMap,u.pointShadowMatrix.value=o.state.pointShadowMatrix);var p=s.getUniforms(),d=Bv.seqWithValue(p.seq,u);return r.currentProgram=s,r.uniformsList=d,s}function Gn(n,e){var t=Z.get(n);t.outputEncoding=e.outputEncoding,t.instancing=e.instancing,t.skinning=e.skinning,t.morphTargets=e.morphTargets,t.morphNormals=e.morphNormals,t.morphColors=e.morphColors,t.morphTargetsCount=e.morphTargetsCount,t.numClippingPlanes=e.numClippingPlanes,t.numIntersection=e.numClipIntersection,t.vertexAlphas=e.vertexAlphas,t.vertexTangents=e.vertexTangents,t.toneMapping=e.toneMapping}function Bn(n,e,t,r,o){!0!==e.isScene&&(e=G),K.resetTextureUnits();var a=e.fog,i=r.isMeshStandardMaterial?e.environment:null,v=null===y?m.outputEncoding:!0===y.isXRRenderTarget?y.texture.encoding:ct,c=(r.isMeshStandardMaterial?Q:J).get(r.envMap||i),l=!0===r.vertexColors&&!!t.attributes.color&&4===t.attributes.color.itemSize,s=!!r.normalMap&&!!t.attributes.tangent,u=!!t.morphAttributes.position,p=!!t.morphAttributes.normal,d=!!t.morphAttributes.color,h=r.toneMapped?m.toneMapping:Cn,x=t.morphAttributes.position||t.morphAttributes.normal||t.morphAttributes.color,g=void 0!==x?x.length:0,U=Z.get(r),w=f.state.lights;if(!0===E&&(!0===I||n!==_)){var S=n===_&&r.id===b;cn.setState(r,n,S)}var k=!1;r.version===U.__version?U.needsLights&&U.lightsStateVersion!==w.state.version||U.outputEncoding!==v||o.isInstancedMesh&&!1===U.instancing?k=!0:o.isInstancedMesh||!0!==U.instancing?o.isSkinnedMesh&&!1===U.skinning?k=!0:o.isSkinnedMesh||!0!==U.skinning?U.envMap!==c||!0===r.fog&&U.fog!==a?k=!0:void 0===U.numClippingPlanes||U.numClippingPlanes===cn.numPlanes&&U.numIntersection===cn.numIntersection?(U.vertexAlphas!==l||U.vertexTangents!==s||U.morphTargets!==u||U.morphNormals!==p||U.morphColors!==d||U.toneMapping!==h||!0===V.isWebGL2&&U.morphTargetsCount!==g)&&(k=!0):k=!0:k=!0:k=!0:(k=!0,U.__version=r.version);var C=U.currentProgram;!0===k&&(C=Nn(r,e,o));var T=!1,R=!1,D=!1,P=C.getUniforms(),j=U.uniforms;if(Y.useProgram(C.program)&&(T=!0,R=!0,D=!0),r.id!==b&&(b=r.id,R=!0),T||_!==n){if(P.setValue(xn,"projectionMatrix",n.projectionMatrix),V.logarithmicDepthBuffer&&P.setValue(xn,"logDepthBufFC",2/(Math.log(n.far+1)/Math.LN2)),_!==n&&(_=n,R=!0,D=!0),r.isShaderMaterial||r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshStandardMaterial||r.envMap){var F=P.map.cameraPosition;void 0!==F&&F.setValue(xn,N.setFromMatrixPosition(n.matrixWorld))}(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial)&&P.setValue(xn,"isOrthographic",!0===n.isOrthographicCamera),(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial||r.isShadowMaterial||o.isSkinnedMesh)&&P.setValue(xn,"viewMatrix",n.matrixWorldInverse)}if(o.isSkinnedMesh){P.setOptional(xn,o,"bindMatrix"),P.setOptional(xn,o,"bindMatrixInverse");var L=o.skeleton;L&&(V.floatVertexTextures?(null===L.boneTexture&&L.computeBoneTexture(),P.setValue(xn,"boneTexture",L.boneTexture,K),P.setValue(xn,"boneTextureSize",L.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}var A=t.morphAttributes;if((void 0!==A.position||void 0!==A.normal||void 0!==A.color&&!0===V.isWebGL2)&&un.update(o,t,r,C),(R||U.receiveShadow!==o.receiveShadow)&&(U.receiveShadow=o.receiveShadow,P.setValue(xn,"receiveShadow",o.receiveShadow)),r.isMeshGouraudMaterial&&null!==r.envMap&&(j.envMap.value=c,j.flipEnvMap.value=c.isCubeTexture&&!1===c.isRenderTargetTexture?-1:1),R&&(P.setValue(xn,"toneMappingExposure",m.toneMappingExposure),U.needsLights&&qn(j,D),a&&!0===r.fog&&on.refreshFogUniforms(j,a),on.refreshMaterialUniforms(j,r,z,M,O),Bv.upload(xn,U.uniformsList,j,K)),r.isShaderMaterial&&!0===r.uniformsNeedUpdate&&(Bv.upload(xn,U.uniformsList,j,K),r.uniformsNeedUpdate=!1),r.isSpriteMaterial&&P.setValue(xn,"center",o.center),P.setValue(xn,"modelViewMatrix",o.modelViewMatrix),P.setValue(xn,"normalMatrix",o.normalMatrix),P.setValue(xn,"modelMatrix",o.matrixWorld),r.isShaderMaterial||r.isRawShaderMaterial)for(var B=r.uniformsGroups,q=0,W=B.length;q<W;q++)if(V.isWebGL2){var H=B[q];hn.update(H,C),hn.bind(H,C)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");return C}function qn(n,e){n.ambientLightColor.needsUpdate=e,n.lightProbe.needsUpdate=e,n.directionalLights.needsUpdate=e,n.directionalLightShadows.needsUpdate=e,n.pointLights.needsUpdate=e,n.pointLightShadows.needsUpdate=e,n.spotLights.needsUpdate=e,n.spotLightShadows.needsUpdate=e,n.rectAreaLights.needsUpdate=e,n.hemisphereLights.needsUpdate=e}function Vn(n){return n.isMeshLambertMaterial||n.isMeshToonMaterial||n.isMeshPhongMaterial||n.isMeshStandardMaterial||n.isShadowMaterial||n.isShaderMaterial&&!0===n.lights}Fn.setAnimationLoop(Dn),"undefined"!==typeof self&&Fn.setContext(self),this.setAnimationLoop=function(n){Rn=n,Un.setAnimationLoop(n),null===n?Fn.stop():Fn.start()},Un.addEventListener("sessionstart",Pn),Un.addEventListener("sessionend",jn),this.render=function(n,e){if(void 0===e||!0===e.isCamera){if(!0!==h){!0===n.matrixWorldAutoUpdate&&n.updateMatrixWorld(),null===e.parent&&!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),!0===Un.enabled&&!0===Un.isPresenting&&(!0===Un.cameraAutoUpdate&&Un.updateCamera(e),e=Un.getCamera()),!0===n.isScene&&n.onBeforeRender(m,n,e,y),(f=vn.get(n,d.length)).init(),d.push(f),L.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),j.setFromProjectionMatrix(L),I=this.localClippingEnabled,E=cn.init(this.clippingPlanes,I,e),(u=an.get(n,p.length)).init(),p.push(u),En(n,e,0,m.sortObjects),u.finish(),!0===m.sortObjects&&u.sort(C,T),!0===E&&cn.beginShadows();var t=f.state.shadowsArray;if(ln.render(t,n,e),!0===E&&cn.endShadows(),!0===this.info.autoReset&&this.info.reset(),sn.render(u,n),f.setupLights(m.physicallyCorrectLights),e.isArrayCamera)for(var r=e.cameras,o=0,a=r.length;o<a;o++){var i=r[o];In(u,n,i,i.viewport)}else In(u,n,e);null!==y&&(K.updateMultisampleRenderTarget(y),K.updateRenderTargetMipmap(y)),!0===n.isScene&&n.onAfterRender(m,n,e),mn.resetDefaultState(),b=-1,_=null,d.pop(),f=d.length>0?d[d.length-1]:null,p.pop(),u=p.length>0?p[p.length-1]:null}}else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")},this.getActiveCubeFace=function(){return x},this.getActiveMipmapLevel=function(){return g},this.getRenderTarget=function(){return y},this.setRenderTargetTextures=function(n,e,t){Z.get(n.texture).__webglTexture=e,Z.get(n.depthTexture).__webglTexture=t;var r=Z.get(n);r.__hasExternalTextures=!0,r.__hasExternalTextures&&(r.__autoAllocateDepthBuffer=void 0===t,r.__autoAllocateDepthBuffer||!0===q.has("WEBGL_multisampled_render_to_texture")&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),r.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(n,e){var t=Z.get(n);t.__webglFramebuffer=e,t.__useDefaultFramebuffer=void 0===e},this.setRenderTarget=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;y=n,x=e,g=t;var r=!0,o=null,a=!1,i=!1;if(n){var v=Z.get(n);void 0!==v.__useDefaultFramebuffer?(Y.bindFramebuffer(36160,null),r=!1):void 0===v.__webglFramebuffer?K.setupRenderTarget(n):v.__hasExternalTextures&&K.rebindTextures(n,Z.get(n.texture).__webglTexture,Z.get(n.depthTexture).__webglTexture);var c=n.texture;(c.isData3DTexture||c.isDataArrayTexture||c.isCompressedArrayTexture)&&(i=!0);var l=Z.get(n).__webglFramebuffer;n.isWebGLCubeRenderTarget?(o=l[e],a=!0):o=V.isWebGL2&&n.samples>0&&!1===K.useMultisampledRTT(n)?Z.get(n).__webglMultisampledFramebuffer:l,U.copy(n.viewport),w.copy(n.scissor),S=n.scissorTest}else U.copy(R).multiplyScalar(z).floor(),w.copy(D).multiplyScalar(z).floor(),S=P;var s=Y.bindFramebuffer(36160,o);if(s&&V.drawBuffers&&r&&Y.drawBuffers(n,o),Y.viewport(U),Y.scissor(w),Y.setScissorTest(S),a){var u=Z.get(n.texture);xn.framebufferTexture2D(36160,36064,34069+e,u.__webglTexture,t)}else if(i){var f=Z.get(n.texture),p=e||0;xn.framebufferTextureLayer(36160,36064,f.__webglTexture,t||0,p)}b=-1},this.readRenderTargetPixels=function(n,e,t,r,o,a,i){if(n&&n.isWebGLRenderTarget){var v=Z.get(n).__webglFramebuffer;if(n.isWebGLCubeRenderTarget&&void 0!==i&&(v=v[i]),v){Y.bindFramebuffer(36160,v);try{var c=n.texture,l=c.format,s=c.type;if(l!==fe&&dn.convert(l)!==xn.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");var u=s===ie&&(q.has("EXT_color_buffer_half_float")||V.isWebGL2&&q.has("EXT_color_buffer_float"));if(s!==Qn&&dn.convert(s)!==xn.getParameter(35738)&&(s!==ae||!(V.isWebGL2||q.has("OES_texture_float")||q.has("WEBGL_color_buffer_float")))&&!u)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");e>=0&&e<=n.width-r&&t>=0&&t<=n.height-o&&xn.readPixels(e,t,r,o,dn.convert(l),dn.convert(s),a)}finally{var f=null!==y?Z.get(y).__webglFramebuffer:null;Y.bindFramebuffer(36160,f)}}}else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")},this.copyFramebufferToTexture=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=Math.pow(2,-t),o=Math.floor(e.image.width*r),a=Math.floor(e.image.height*r);K.setTexture2D(e,0),xn.copyTexSubImage2D(3553,t,0,0,n.x,n.y,o,a),Y.unbindTexture()},this.copyTextureToTexture=function(n,e,t){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,o=e.image.width,a=e.image.height,i=dn.convert(t.format),v=dn.convert(t.type);K.setTexture2D(t,0),xn.pixelStorei(37440,t.flipY),xn.pixelStorei(37441,t.premultiplyAlpha),xn.pixelStorei(3317,t.unpackAlignment),e.isDataTexture?xn.texSubImage2D(3553,r,n.x,n.y,o,a,i,v,e.image.data):e.isCompressedTexture?xn.compressedTexSubImage2D(3553,r,n.x,n.y,e.mipmaps[0].width,e.mipmaps[0].height,i,e.mipmaps[0].data):xn.texSubImage2D(3553,r,n.x,n.y,i,v,e.image),0===r&&t.generateMipmaps&&xn.generateMipmap(3553),Y.unbindTexture()},this.copyTextureToTexture3D=function(n,e,t,r){var o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;if(m.isWebGL1Renderer)console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");else{var a,i=n.max.x-n.min.x+1,v=n.max.y-n.min.y+1,c=n.max.z-n.min.z+1,l=dn.convert(r.format),s=dn.convert(r.type);if(r.isData3DTexture)K.setTexture3D(r,0),a=32879;else{if(!r.isDataArrayTexture)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");K.setTexture2DArray(r,0),a=35866}xn.pixelStorei(37440,r.flipY),xn.pixelStorei(37441,r.premultiplyAlpha),xn.pixelStorei(3317,r.unpackAlignment);var u=xn.getParameter(3314),f=xn.getParameter(32878),p=xn.getParameter(3316),d=xn.getParameter(3315),h=xn.getParameter(32877),x=t.isCompressedTexture?t.mipmaps[0]:t.image;xn.pixelStorei(3314,x.width),xn.pixelStorei(32878,x.height),xn.pixelStorei(3316,n.min.x),xn.pixelStorei(3315,n.min.y),xn.pixelStorei(32877,n.min.z),t.isDataTexture||t.isData3DTexture?xn.texSubImage3D(a,o,e.x,e.y,e.z,i,v,c,l,s,x.data):t.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),xn.compressedTexSubImage3D(a,o,e.x,e.y,e.z,i,v,c,l,x.data)):xn.texSubImage3D(a,o,e.x,e.y,e.z,i,v,c,l,s,x),xn.pixelStorei(3314,u),xn.pixelStorei(32878,f),xn.pixelStorei(3316,p),xn.pixelStorei(3315,d),xn.pixelStorei(32877,h),0===o&&r.generateMipmaps&&xn.generateMipmap(a),Y.unbindTexture()}},this.initTexture=function(n){n.isCubeTexture?K.setTextureCube(n,0):n.isData3DTexture?K.setTexture3D(n,0):n.isDataArrayTexture||n.isCompressedArrayTexture?K.setTexture2DArray(n,0):K.setTexture2D(n,0),Y.unbindTexture()},this.resetState=function(){x=0,g=0,y=null,Y.reset(),mn.reset()},"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}var Ic=function(n){U(t,n);var e=z(t);function t(){return y(this,t),e.apply(this,arguments)}return _(t)}(Ec);Ic.prototype.isWebGL1Renderer=!0;var Oc,Lc=function(){function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:25e-5;y(this,n),this.isFogExp2=!0,this.name="",this.color=new wr(e),this.density=t}return _(n,[{key:"clone",value:function(){return new n(this.color,this.density)}},{key:"toJSON",value:function(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}]),n}(),Ac=function(){function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;y(this,n),this.isFog=!0,this.name="",this.color=new wr(e),this.near=t,this.far=r}return _(n,[{key:"clone",value:function(){return new n(this.color,this.near,this.far)}},{key:"toJSON",value:function(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}]),n}(),Nc=function(n){U(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).isScene=!0,n.type="Scene",n.background=null,n.environment=null,n.fog=null,n.backgroundBlurriness=0,n.overrideMaterial=null,"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:k(n)})),n}return _(t,[{key:"copy",value:function(n,e){return P(w(t.prototype),"copy",this).call(this,n,e),null!==n.background&&(this.background=n.background.clone()),null!==n.environment&&(this.environment=n.environment.clone()),null!==n.fog&&(this.fog=n.fog.clone()),this.backgroundBlurriness=n.backgroundBlurriness,null!==n.overrideMaterial&&(this.overrideMaterial=n.overrideMaterial.clone()),this.matrixAutoUpdate=n.matrixAutoUpdate,this}},{key:"toJSON",value:function(n){var e=P(w(t.prototype),"toJSON",this).call(this,n);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.backgroundBlurriness=this.backgroundBlurriness),e}},{key:"autoUpdate",get:function(){return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate},set:function(n){console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate=n}}]),t}(Ao),Gc=function(){function n(e,t){y(this,n),this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=void 0!==e?e.length/t:0,this.usage=jt,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Zt()}return _(n,[{key:"onUploadCallback",value:function(){}},{key:"needsUpdate",set:function(n){!0===n&&this.version++}},{key:"setUsage",value:function(n){return this.usage=n,this}},{key:"copy",value:function(n){return this.array=new n.array.constructor(n.array),this.count=n.count,this.stride=n.stride,this.usage=n.usage,this}},{key:"copyAt",value:function(n,e,t){n*=this.stride,t*=e.stride;for(var r=0,o=this.stride;r<o;r++)this.array[n+r]=e.array[t+r];return this}},{key:"set",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.array.set(n,e),this}},{key:"clone",value:function(n){void 0===n.arrayBuffers&&(n.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Zt()),void 0===n.arrayBuffers[this.array.buffer._uuid]&&(n.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);var e=new this.array.constructor(n.arrayBuffers[this.array.buffer._uuid]),t=new this.constructor(e,this.stride);return t.setUsage(this.usage),t}},{key:"onUpload",value:function(n){return this.onUploadCallback=n,this}},{key:"toJSON",value:function(n){return void 0===n.arrayBuffers&&(n.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Zt()),void 0===n.arrayBuffers[this.array.buffer._uuid]&&(n.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}]),n}(),Bc=new Or,qc=function(){function n(e,t,r){var o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];y(this,n),this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=r,this.normalized=!0===o}return _(n,[{key:"count",get:function(){return this.data.count}},{key:"array",get:function(){return this.data.array}},{key:"needsUpdate",set:function(n){this.data.needsUpdate=n}},{key:"applyMatrix4",value:function(n){for(var e=0,t=this.data.count;e<t;e++)Bc.fromBufferAttribute(this,e),Bc.applyMatrix4(n),this.setXYZ(e,Bc.x,Bc.y,Bc.z);return this}},{key:"applyNormalMatrix",value:function(n){for(var e=0,t=this.count;e<t;e++)Bc.fromBufferAttribute(this,e),Bc.applyNormalMatrix(n),this.setXYZ(e,Bc.x,Bc.y,Bc.z);return this}},{key:"transformDirection",value:function(n){for(var e=0,t=this.count;e<t;e++)Bc.fromBufferAttribute(this,e),Bc.transformDirection(n),this.setXYZ(e,Bc.x,Bc.y,Bc.z);return this}},{key:"setX",value:function(n,e){return this.normalized&&(e=or(e,this.array)),this.data.array[n*this.data.stride+this.offset]=e,this}},{key:"setY",value:function(n,e){return this.normalized&&(e=or(e,this.array)),this.data.array[n*this.data.stride+this.offset+1]=e,this}},{key:"setZ",value:function(n,e){return this.normalized&&(e=or(e,this.array)),this.data.array[n*this.data.stride+this.offset+2]=e,this}},{key:"setW",value:function(n,e){return this.normalized&&(e=or(e,this.array)),this.data.array[n*this.data.stride+this.offset+3]=e,this}},{key:"getX",value:function(n){var e=this.data.array[n*this.data.stride+this.offset];return this.normalized&&(e=rr(e,this.array)),e}},{key:"getY",value:function(n){var e=this.data.array[n*this.data.stride+this.offset+1];return this.normalized&&(e=rr(e,this.array)),e}},{key:"getZ",value:function(n){var e=this.data.array[n*this.data.stride+this.offset+2];return this.normalized&&(e=rr(e,this.array)),e}},{key:"getW",value:function(n){var e=this.data.array[n*this.data.stride+this.offset+3];return this.normalized&&(e=rr(e,this.array)),e}},{key:"setXY",value:function(n,e,t){return n=n*this.data.stride+this.offset,this.normalized&&(e=or(e,this.array),t=or(t,this.array)),this.data.array[n+0]=e,this.data.array[n+1]=t,this}},{key:"setXYZ",value:function(n,e,t,r){return n=n*this.data.stride+this.offset,this.normalized&&(e=or(e,this.array),t=or(t,this.array),r=or(r,this.array)),this.data.array[n+0]=e,this.data.array[n+1]=t,this.data.array[n+2]=r,this}},{key:"setXYZW",value:function(n,e,t,r,o){return n=n*this.data.stride+this.offset,this.normalized&&(e=or(e,this.array),t=or(t,this.array),r=or(r,this.array),o=or(o,this.array)),this.data.array[n+0]=e,this.data.array[n+1]=t,this.data.array[n+2]=r,this.data.array[n+3]=o,this}},{key:"clone",value:function(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");for(var t=[],r=0;r<this.count;r++)for(var o=r*this.data.stride+this.offset,a=0;a<this.itemSize;a++)t.push(this.data.array[o+a]);return new ta(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new n(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}},{key:"toJSON",value:function(n){if(void 0===n){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");for(var e=[],t=0;t<this.count;t++)for(var r=t*this.data.stride+this.offset,o=0;o<this.itemSize;o++)e.push(this.data.array[r+o]);return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}return void 0===n.interleavedBuffers&&(n.interleavedBuffers={}),void 0===n.interleavedBuffers[this.data.uuid]&&(n.interleavedBuffers[this.data.uuid]=this.data.toJSON(n)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}]),n}(),Vc=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).isSpriteMaterial=!0,r.type="SpriteMaterial",r.color=new wr(16777215),r.map=null,r.alphaMap=null,r.rotation=0,r.sizeAttenuation=!0,r.transparent=!0,r.fog=!0,r.setValues(n),r}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.rotation=n.rotation,this.sizeAttenuation=n.sizeAttenuation,this.fog=n.fog,this}}]),t}(Jo),Wc=new Or,Hc=new Or,Xc=new Or,Yc=new ir,$c=new ir,Zc=new po,Kc=new Or,Jc=new Or,Qc=new Or,nl=new ir,el=new ir,tl=new ir,rl=function(n){U(t,n);var e=z(t);function t(n){var r;if(y(this,t),(r=e.call(this)).isSprite=!0,r.type="Sprite",void 0===Oc){Oc=new ba;var o=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),a=new Gc(o,5);Oc.setIndex([0,1,2,0,2,3]),Oc.setAttribute("position",new qc(a,3,0,!1)),Oc.setAttribute("uv",new qc(a,2,3,!1))}return r.geometry=Oc,r.material=void 0!==n?n:new Vc,r.center=new ir(.5,.5),r}return _(t,[{key:"raycast",value:function(n,e){null===n.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Hc.setFromMatrixScale(this.matrixWorld),Zc.copy(n.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(n.camera.matrixWorldInverse,this.matrixWorld),Xc.setFromMatrixPosition(this.modelViewMatrix),n.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Hc.multiplyScalar(-Xc.z);var t,r,o=this.material.rotation;0!==o&&(r=Math.cos(o),t=Math.sin(o));var a=this.center;ol(Kc.set(-.5,-.5,0),Xc,a,Hc,t,r),ol(Jc.set(.5,-.5,0),Xc,a,Hc,t,r),ol(Qc.set(.5,.5,0),Xc,a,Hc,t,r),nl.set(0,0),el.set(1,0),tl.set(1,1);var i=n.ray.intersectTriangle(Kc,Jc,Qc,!1,Wc);if(null!==i||(ol(Jc.set(-.5,.5,0),Xc,a,Hc,t,r),el.set(0,1),null!==(i=n.ray.intersectTriangle(Kc,Qc,Jc,!1,Wc)))){var v=n.ray.origin.distanceTo(Wc);v<n.near||v>n.far||e.push({distance:v,point:Wc.clone(),uv:Zo.getUV(Wc,Kc,Jc,Qc,nl,el,tl,new ir),face:null,object:this})}}},{key:"copy",value:function(n,e){return P(w(t.prototype),"copy",this).call(this,n,e),void 0!==n.center&&this.center.copy(n.center),this.material=n.material,this}}]),t}(Ao);function ol(n,e,t,r,o,a){Yc.subVectors(n,t).addScalar(.5).multiply(r),void 0!==o?($c.x=a*Yc.x-o*Yc.y,$c.y=o*Yc.x+a*Yc.y):$c.copy(Yc),n.copy(e),n.x+=$c.x,n.y+=$c.y,n.applyMatrix4(Zc)}var al=new Or,il=new Or,vl=function(n){U(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this))._currentLevel=0,n.type="LOD",Object.defineProperties(k(n),{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),n.autoUpdate=!0,n}return _(t,[{key:"copy",value:function(n){P(w(t.prototype),"copy",this).call(this,n,!1);for(var e=n.levels,r=0,o=e.length;r<o;r++){var a=e[r];this.addLevel(a.object.clone(),a.distance)}return this.autoUpdate=n.autoUpdate,this}},{key:"addLevel",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;e=Math.abs(e);var t,r=this.levels;for(t=0;t<r.length&&!(e<r[t].distance);t++);return r.splice(t,0,{distance:e,object:n}),this.add(n),this}},{key:"getCurrentLevel",value:function(){return this._currentLevel}},{key:"getObjectForDistance",value:function(n){var e=this.levels;if(e.length>0){var t,r;for(t=1,r=e.length;t<r&&!(n<e[t].distance);t++);return e[t-1].object}return null}},{key:"raycast",value:function(n,e){if(this.levels.length>0){al.setFromMatrixPosition(this.matrixWorld);var t=n.ray.origin.distanceTo(al);this.getObjectForDistance(t).raycast(n,e)}}},{key:"update",value:function(n){var e=this.levels;if(e.length>1){al.setFromMatrixPosition(n.matrixWorld),il.setFromMatrixPosition(this.matrixWorld);var t,r,o=al.distanceTo(il)/n.zoom;for(e[0].object.visible=!0,t=1,r=e.length;t<r&&o>=e[t].distance;t++)e[t-1].object.visible=!1,e[t].object.visible=!0;for(this._currentLevel=t-1;t<r;t++)e[t].object.visible=!1}}},{key:"toJSON",value:function(n){var e=P(w(t.prototype),"toJSON",this).call(this,n);!1===this.autoUpdate&&(e.object.autoUpdate=!1),e.object.levels=[];for(var r=this.levels,o=0,a=r.length;o<a;o++){var i=r[o];e.object.levels.push({object:i.object.uuid,distance:i.distance})}return e}}]),t}(Ao),cl=new Or,ll=new Tr,sl=new Tr,ul=new Or,fl=new po,pl=function(n){U(t,n);var e=z(t);function t(n,r){var o;return y(this,t),(o=e.call(this,n,r)).isSkinnedMesh=!0,o.type="SkinnedMesh",o.bindMode="attached",o.bindMatrix=new po,o.bindMatrixInverse=new po,o}return _(t,[{key:"copy",value:function(n,e){return P(w(t.prototype),"copy",this).call(this,n,e),this.bindMode=n.bindMode,this.bindMatrix.copy(n.bindMatrix),this.bindMatrixInverse.copy(n.bindMatrixInverse),this.skeleton=n.skeleton,this}},{key:"bind",value:function(n,e){this.skeleton=n,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}},{key:"pose",value:function(){this.skeleton.pose()}},{key:"normalizeSkinWeights",value:function(){for(var n=new Tr,e=this.geometry.attributes.skinWeight,t=0,r=e.count;t<r;t++){n.fromBufferAttribute(e,t);var o=1/n.manhattanLength();o!==1/0?n.multiplyScalar(o):n.set(1,0,0,0),e.setXYZW(t,n.x,n.y,n.z,n.w)}}},{key:"updateMatrixWorld",value:function(n){P(w(t.prototype),"updateMatrixWorld",this).call(this,n),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}},{key:"boneTransform",value:function(n,e){var t=this.skeleton,r=this.geometry;ll.fromBufferAttribute(r.attributes.skinIndex,n),sl.fromBufferAttribute(r.attributes.skinWeight,n),cl.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(var o=0;o<4;o++){var a=sl.getComponent(o);if(0!==a){var i=ll.getComponent(o);fl.multiplyMatrices(t.bones[i].matrixWorld,t.boneInverses[i]),e.addScaledVector(ul.copy(cl).applyMatrix4(fl),a)}}return e.applyMatrix4(this.bindMatrixInverse)}}]),t}(La),dl=function(n){U(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).isBone=!0,n.type="Bone",n}return _(t)}(Ao),ml=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3?arguments[3]:void 0,v=arguments.length>4?arguments[4]:void 0,c=arguments.length>5?arguments[5]:void 0,l=arguments.length>6?arguments[6]:void 0,s=arguments.length>7?arguments[7]:void 0,u=arguments.length>8&&void 0!==arguments[8]?arguments[8]:qn,f=arguments.length>9&&void 0!==arguments[9]?arguments[9]:qn,p=arguments.length>10?arguments[10]:void 0,d=arguments.length>11?arguments[11]:void 0;return y(this,t),(n=e.call(this,null,c,l,s,u,f,i,v,p,d)).isDataTexture=!0,n.image={data:r,width:o,height:a},n.generateMipmaps=!1,n.flipY=!1,n.unpackAlignment=1,n}return _(t)}(Cr),hl=new po,xl=new po,gl=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];y(this,n),this.uuid=Zt(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}return _(n,[{key:"init",value:function(){var n=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*n.length),0===e.length)this.calculateInverses();else if(n.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(var t=0,r=this.bones.length;t<r;t++)this.boneInverses.push(new po)}}},{key:"calculateInverses",value:function(){this.boneInverses.length=0;for(var n=0,e=this.bones.length;n<e;n++){var t=new po;this.bones[n]&&t.copy(this.bones[n].matrixWorld).invert(),this.boneInverses.push(t)}}},{key:"pose",value:function(){for(var n=0,e=this.bones.length;n<e;n++){var t=this.bones[n];t&&t.matrixWorld.copy(this.boneInverses[n]).invert()}for(var r=0,o=this.bones.length;r<o;r++){var a=this.bones[r];a&&(a.parent&&a.parent.isBone?(a.matrix.copy(a.parent.matrixWorld).invert(),a.matrix.multiply(a.matrixWorld)):a.matrix.copy(a.matrixWorld),a.matrix.decompose(a.position,a.quaternion,a.scale))}}},{key:"update",value:function(){for(var n=this.bones,e=this.boneInverses,t=this.boneMatrices,r=this.boneTexture,o=0,a=n.length;o<a;o++){var i=n[o]?n[o].matrixWorld:xl;hl.multiplyMatrices(i,e[o]),hl.toArray(t,16*o)}null!==r&&(r.needsUpdate=!0)}},{key:"clone",value:function(){return new n(this.bones,this.boneInverses)}},{key:"computeBoneTexture",value:function(){var n=Math.sqrt(4*this.bones.length);n=er(n),n=Math.max(n,4);var e=new Float32Array(n*n*4);e.set(this.boneMatrices);var t=new ml(e,n,n,fe,ae);return t.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=t,this.boneTextureSize=n,this}},{key:"getBoneByName",value:function(n){for(var e=0,t=this.bones.length;e<t;e++){var r=this.bones[e];if(r.name===n)return r}}},{key:"dispose",value:function(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}},{key:"fromJSON",value:function(n,e){this.uuid=n.uuid;for(var t=0,r=n.bones.length;t<r;t++){var o=n.bones[t],a=e[o];void 0===a&&(console.warn("THREE.Skeleton: No bone found with UUID:",o),a=new dl),this.bones.push(a),this.boneInverses.push((new po).fromArray(n.boneInverses[t]))}return this.init(),this}},{key:"toJSON",value:function(){var n={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};n.uuid=this.uuid;for(var e=this.bones,t=this.boneInverses,r=0,o=e.length;r<o;r++){var a=e[r];n.bones.push(a.uuid);var i=t[r];n.boneInverses.push(i.toArray())}return n}}]),n}(),yl=function(n){U(t,n);var e=z(t);function t(n,r,o){var a,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;return y(this,t),(a=e.call(this,n,r,o)).isInstancedBufferAttribute=!0,a.meshPerAttribute=i,a}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.meshPerAttribute=n.meshPerAttribute,this}},{key:"toJSON",value:function(){var n=P(w(t.prototype),"toJSON",this).call(this);return n.meshPerAttribute=this.meshPerAttribute,n.isInstancedBufferAttribute=!0,n}}]),t}(ta),bl=new po,_l=new po,Ul=[],wl=new po,Sl=new La,kl=function(n){U(t,n);var e=z(t);function t(n,r,o){var a;y(this,t),(a=e.call(this,n,r)).isInstancedMesh=!0,a.instanceMatrix=new yl(new Float32Array(16*o),16),a.instanceColor=null,a.count=o,a.frustumCulled=!1;for(var i=0;i<o;i++)a.setMatrixAt(i,wl);return a}return _(t,[{key:"copy",value:function(n,e){return P(w(t.prototype),"copy",this).call(this,n,e),this.instanceMatrix.copy(n.instanceMatrix),null!==n.instanceColor&&(this.instanceColor=n.instanceColor.clone()),this.count=n.count,this}},{key:"getColorAt",value:function(n,e){e.fromArray(this.instanceColor.array,3*n)}},{key:"getMatrixAt",value:function(n,e){e.fromArray(this.instanceMatrix.array,16*n)}},{key:"raycast",value:function(n,e){var t=this.matrixWorld,r=this.count;if(Sl.geometry=this.geometry,Sl.material=this.material,void 0!==Sl.material)for(var o=0;o<r;o++){this.getMatrixAt(o,bl),_l.multiplyMatrices(t,bl),Sl.matrixWorld=_l,Sl.raycast(n,Ul);for(var a=0,i=Ul.length;a<i;a++){var v=Ul[a];v.instanceId=o,v.object=this,e.push(v)}Ul.length=0}}},{key:"setColorAt",value:function(n,e){null===this.instanceColor&&(this.instanceColor=new yl(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*n)}},{key:"setMatrixAt",value:function(n,e){e.toArray(this.instanceMatrix.array,16*n)}},{key:"updateMorphTargets",value:function(){}},{key:"dispose",value:function(){this.dispatchEvent({type:"dispose"})}}]),t}(La),Ml=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).isLineBasicMaterial=!0,r.type="LineBasicMaterial",r.color=new wr(16777215),r.linewidth=1,r.linecap="round",r.linejoin="round",r.fog=!0,r.setValues(n),r}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.linewidth=n.linewidth,this.linecap=n.linecap,this.linejoin=n.linejoin,this.fog=n.fog,this}}]),t}(Jo),zl=new Or,Cl=new Or,Tl=new po,Rl=new fo,Dl=new oo,Pl=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ba,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Ml;return y(this,t),(n=e.call(this)).isLine=!0,n.type="Line",n.geometry=r,n.material=o,n.updateMorphTargets(),n}return _(t,[{key:"copy",value:function(n,e){return P(w(t.prototype),"copy",this).call(this,n,e),this.material=n.material,this.geometry=n.geometry,this}},{key:"computeLineDistances",value:function(){var n=this.geometry;if(null===n.index){for(var e=n.attributes.position,t=[0],r=1,o=e.count;r<o;r++)zl.fromBufferAttribute(e,r-1),Cl.fromBufferAttribute(e,r),t[r]=t[r-1],t[r]+=zl.distanceTo(Cl);n.setAttribute("lineDistance",new ua(t,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}},{key:"raycast",value:function(n,e){var t=this.geometry,r=this.matrixWorld,o=n.params.Line.threshold,a=t.drawRange;if(null===t.boundingSphere&&t.computeBoundingSphere(),Dl.copy(t.boundingSphere),Dl.applyMatrix4(r),Dl.radius+=o,!1!==n.ray.intersectsSphere(Dl)){Tl.copy(r).invert(),Rl.copy(n.ray).applyMatrix4(Tl);var i=o/((this.scale.x+this.scale.y+this.scale.z)/3),v=i*i,c=new Or,l=new Or,s=new Or,u=new Or,f=this.isLineSegments?2:1,p=t.index,d=t.attributes.position;if(null!==p)for(var m=Math.max(0,a.start),h=Math.min(p.count,a.start+a.count)-1;m<h;m+=f){var x=p.getX(m),g=p.getX(m+1);if(c.fromBufferAttribute(d,x),l.fromBufferAttribute(d,g),!(Rl.distanceSqToSegment(c,l,u,s)>v)){u.applyMatrix4(this.matrixWorld);var y=n.ray.origin.distanceTo(u);y<n.near||y>n.far||e.push({distance:y,point:s.clone().applyMatrix4(this.matrixWorld),index:m,face:null,faceIndex:null,object:this})}}else for(var b=Math.max(0,a.start),_=Math.min(d.count,a.start+a.count)-1;b<_;b+=f){if(c.fromBufferAttribute(d,b),l.fromBufferAttribute(d,b+1),!(Rl.distanceSqToSegment(c,l,u,s)>v)){u.applyMatrix4(this.matrixWorld);var U=n.ray.origin.distanceTo(u);U<n.near||U>n.far||e.push({distance:U,point:s.clone().applyMatrix4(this.matrixWorld),index:b,face:null,faceIndex:null,object:this})}}}}},{key:"updateMorphTargets",value:function(){var n=this.geometry.morphAttributes,e=Object.keys(n);if(e.length>0){var t=n[e[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(var r=0,o=t.length;r<o;r++){var a=t[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}}]),t}(Ao),jl=new Or,Fl=new Or,El=function(n){U(t,n);var e=z(t);function t(n,r){var o;return y(this,t),(o=e.call(this,n,r)).isLineSegments=!0,o.type="LineSegments",o}return _(t,[{key:"computeLineDistances",value:function(){var n=this.geometry;if(null===n.index){for(var e=n.attributes.position,t=[],r=0,o=e.count;r<o;r+=2)jl.fromBufferAttribute(e,r),Fl.fromBufferAttribute(e,r+1),t[r]=0===r?0:t[r-1],t[r+1]=t[r]+jl.distanceTo(Fl);n.setAttribute("lineDistance",new ua(t,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}]),t}(Pl),Il=function(n){U(t,n);var e=z(t);function t(n,r){var o;return y(this,t),(o=e.call(this,n,r)).isLineLoop=!0,o.type="LineLoop",o}return _(t)}(Pl),Ol=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).isPointsMaterial=!0,r.type="PointsMaterial",r.color=new wr(16777215),r.map=null,r.alphaMap=null,r.size=1,r.sizeAttenuation=!0,r.fog=!0,r.setValues(n),r}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.size=n.size,this.sizeAttenuation=n.sizeAttenuation,this.fog=n.fog,this}}]),t}(Jo),Ll=new po,Al=new fo,Nl=new oo,Gl=new Or,Bl=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ba,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Ol;return y(this,t),(n=e.call(this)).isPoints=!0,n.type="Points",n.geometry=r,n.material=o,n.updateMorphTargets(),n}return _(t,[{key:"copy",value:function(n,e){return P(w(t.prototype),"copy",this).call(this,n,e),this.material=n.material,this.geometry=n.geometry,this}},{key:"raycast",value:function(n,e){var t=this.geometry,r=this.matrixWorld,o=n.params.Points.threshold,a=t.drawRange;if(null===t.boundingSphere&&t.computeBoundingSphere(),Nl.copy(t.boundingSphere),Nl.applyMatrix4(r),Nl.radius+=o,!1!==n.ray.intersectsSphere(Nl)){Ll.copy(r).invert(),Al.copy(n.ray).applyMatrix4(Ll);var i=o/((this.scale.x+this.scale.y+this.scale.z)/3),v=i*i,c=t.index,l=t.attributes.position;if(null!==c)for(var s=Math.max(0,a.start),u=Math.min(c.count,a.start+a.count);s<u;s++){var f=c.getX(s);Gl.fromBufferAttribute(l,f),ql(Gl,f,v,r,n,e,this)}else for(var p=Math.max(0,a.start),d=Math.min(l.count,a.start+a.count);p<d;p++)Gl.fromBufferAttribute(l,p),ql(Gl,p,v,r,n,e,this)}}},{key:"updateMorphTargets",value:function(){var n=this.geometry.morphAttributes,e=Object.keys(n);if(e.length>0){var t=n[e[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(var r=0,o=t.length;r<o;r++){var a=t[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}}]),t}(Ao);function ql(n,e,t,r,o,a,i){var v=Al.distanceSqToPoint(n);if(v<t){var c=new Or;Al.closestPointToPoint(n,c),c.applyMatrix4(r);var l=o.ray.origin.distanceTo(c);if(l<o.near||l>o.far)return;a.push({distance:l,distanceToRay:Math.sqrt(v),point:c,index:e,face:null,object:i})}}var Vl=function(n){U(t,n);var e=z(t);function t(n,r,o,a,i,v,c,l,s){var u;y(this,t),(u=e.call(this,n,r,o,a,i,v,c,l,s)).isVideoTexture=!0,u.minFilter=void 0!==v?v:Yn,u.magFilter=void 0!==i?i:Yn,u.generateMipmaps=!1;var f=k(u);return"requestVideoFrameCallback"in n&&n.requestVideoFrameCallback((function e(){f.needsUpdate=!0,n.requestVideoFrameCallback(e)})),u}return _(t,[{key:"clone",value:function(){return new this.constructor(this.image).copy(this)}},{key:"update",value:function(){var n=this.image;!1==="requestVideoFrameCallback"in n&&n.readyState>=n.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}]),t}(Cr),Wl=function(n){U(t,n);var e=z(t);function t(n,r,o){var a;return y(this,t),(a=e.call(this,{width:n,height:r})).isFramebufferTexture=!0,a.format=o,a.magFilter=qn,a.minFilter=qn,a.generateMipmaps=!1,a.needsUpdate=!0,a}return _(t)}(Cr),Hl=function(n){U(t,n);var e=z(t);function t(n,r,o,a,i,v,c,l,s,u,f,p){var d;return y(this,t),(d=e.call(this,null,v,c,l,s,u,a,i,f,p)).isCompressedTexture=!0,d.image={width:r,height:o},d.mipmaps=n,d.flipY=!1,d.generateMipmaps=!1,d}return _(t)}(Cr),Xl=function(n){U(t,n);var e=z(t);function t(n,r,o,a,i,v){var c;return y(this,t),(c=e.call(this,n,r,o,i,v)).isCompressedArrayTexture=!0,c.image.depth=a,c.wrapR=Gn,c}return _(t)}(Hl),Yl=function(n){U(t,n);var e=z(t);function t(n,r,o,a,i,v,c,l,s){var u;return y(this,t),(u=e.call(this,n,r,o,a,i,v,c,l,s)).isCanvasTexture=!0,u.needsUpdate=!0,u}return _(t)}(Cr),$l=function(){function n(){y(this,n),this.type="Curve",this.arcLengthDivisions=200}return _(n,[{key:"getPoint",value:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}},{key:"getPointAt",value:function(n,e){var t=this.getUtoTmapping(n);return this.getPoint(t,e)}},{key:"getPoints",value:function(){for(var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:5,e=[],t=0;t<=n;t++)e.push(this.getPoint(t/n));return e}},{key:"getSpacedPoints",value:function(){for(var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:5,e=[],t=0;t<=n;t++)e.push(this.getPointAt(t/n));return e}},{key:"getLength",value:function(){var n=this.getLengths();return n[n.length-1]}},{key:"getLengths",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.arcLengthDivisions;if(this.cacheArcLengths&&this.cacheArcLengths.length===n+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;var e,t=[],r=this.getPoint(0),o=0;t.push(0);for(var a=1;a<=n;a++)o+=(e=this.getPoint(a/n)).distanceTo(r),t.push(o),r=e;return this.cacheArcLengths=t,t}},{key:"updateArcLengths",value:function(){this.needsUpdate=!0,this.getLengths()}},{key:"getUtoTmapping",value:function(n,e){var t,r=this.getLengths(),o=0,a=r.length;t=e||n*r[a-1];for(var i,v=0,c=a-1;v<=c;)if((i=r[o=Math.floor(v+(c-v)/2)]-t)<0)v=o+1;else{if(!(i>0)){c=o;break}c=o-1}if(r[o=c]===t)return o/(a-1);var l=r[o];return(o+(t-l)/(r[o+1]-l))/(a-1)}},{key:"getTangent",value:function(n,e){var t=1e-4,r=n-t,o=n+t;r<0&&(r=0),o>1&&(o=1);var a=this.getPoint(r),i=this.getPoint(o),v=e||(a.isVector2?new ir:new Or);return v.copy(i).sub(a).normalize(),v}},{key:"getTangentAt",value:function(n,e){var t=this.getUtoTmapping(n);return this.getTangent(t,e)}},{key:"computeFrenetFrames",value:function(n,e){for(var t=new Or,r=[],o=[],a=[],i=new Or,v=new po,c=0;c<=n;c++){var l=c/n;r[c]=this.getTangentAt(l,new Or)}o[0]=new Or,a[0]=new Or;var s=Number.MAX_VALUE,u=Math.abs(r[0].x),f=Math.abs(r[0].y),p=Math.abs(r[0].z);u<=s&&(s=u,t.set(1,0,0)),f<=s&&(s=f,t.set(0,1,0)),p<=s&&t.set(0,0,1),i.crossVectors(r[0],t).normalize(),o[0].crossVectors(r[0],i),a[0].crossVectors(r[0],o[0]);for(var d=1;d<=n;d++){if(o[d]=o[d-1].clone(),a[d]=a[d-1].clone(),i.crossVectors(r[d-1],r[d]),i.length()>Number.EPSILON){i.normalize();var m=Math.acos(Kt(r[d-1].dot(r[d]),-1,1));o[d].applyMatrix4(v.makeRotationAxis(i,m))}a[d].crossVectors(r[d],o[d])}if(!0===e){var h=Math.acos(Kt(o[0].dot(o[n]),-1,1));h/=n,r[0].dot(i.crossVectors(o[0],o[n]))>0&&(h=-h);for(var x=1;x<=n;x++)o[x].applyMatrix4(v.makeRotationAxis(r[x],h*x)),a[x].crossVectors(r[x],o[x])}return{tangents:r,normals:o,binormals:a}}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this}},{key:"toJSON",value:function(){var n={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return n.arcLengthDivisions=this.arcLengthDivisions,n.type=this.type,n}},{key:"fromJSON",value:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this}}]),n}(),Zl=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2*Math.PI,l=arguments.length>6&&void 0!==arguments[6]&&arguments[6],s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;return y(this,t),(n=e.call(this)).isEllipseCurve=!0,n.type="EllipseCurve",n.aX=r,n.aY=o,n.xRadius=a,n.yRadius=i,n.aStartAngle=v,n.aEndAngle=c,n.aClockwise=l,n.aRotation=s,n}return _(t,[{key:"getPoint",value:function(n,e){for(var t=e||new ir,r=2*Math.PI,o=this.aEndAngle-this.aStartAngle,a=Math.abs(o)<Number.EPSILON;o<0;)o+=r;for(;o>r;)o-=r;o<Number.EPSILON&&(o=a?0:r),!0!==this.aClockwise||a||(o===r?o=-r:o-=r);var i=this.aStartAngle+n*o,v=this.aX+this.xRadius*Math.cos(i),c=this.aY+this.yRadius*Math.sin(i);if(0!==this.aRotation){var l=Math.cos(this.aRotation),s=Math.sin(this.aRotation),u=v-this.aX,f=c-this.aY;v=u*l-f*s+this.aX,c=u*s+f*l+this.aY}return t.set(v,c)}},{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this}},{key:"toJSON",value:function(){var n=P(w(t.prototype),"toJSON",this).call(this);return n.aX=this.aX,n.aY=this.aY,n.xRadius=this.xRadius,n.yRadius=this.yRadius,n.aStartAngle=this.aStartAngle,n.aEndAngle=this.aEndAngle,n.aClockwise=this.aClockwise,n.aRotation=this.aRotation,n}},{key:"fromJSON",value:function(n){return P(w(t.prototype),"fromJSON",this).call(this,n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this}}]),t}($l),Kl=function(n){U(t,n);var e=z(t);function t(n,r,o,a,i,v){var c;return y(this,t),(c=e.call(this,n,r,o,o,a,i,v)).isArcCurve=!0,c.type="ArcCurve",c}return _(t)}(Zl);function Jl(){var n=0,e=0,t=0,r=0;function o(o,a,i,v){n=o,e=i,t=-3*o+3*a-2*i-v,r=2*o-2*a+i+v}return{initCatmullRom:function(n,e,t,r,a){o(e,t,a*(t-n),a*(r-e))},initNonuniformCatmullRom:function(n,e,t,r,a,i,v){var c=(e-n)/a-(t-n)/(a+i)+(t-e)/i,l=(t-e)/i-(r-e)/(i+v)+(r-t)/v;o(e,t,c*=i,l*=i)},calc:function(o){var a=o*o;return n+e*o+t*a+r*(a*o)}}}var Ql=new Or,ns=new Jl,es=new Jl,ts=new Jl,rs=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],o=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"centripetal",i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;return y(this,t),(n=e.call(this)).isCatmullRomCurve3=!0,n.type="CatmullRomCurve3",n.points=r,n.closed=o,n.curveType=a,n.tension=i,n}return _(t,[{key:"getPoint",value:function(n){var e,t,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Or,o=r,a=this.points,i=a.length,v=(i-(this.closed?0:1))*n,c=Math.floor(v),l=v-c;this.closed?c+=c>0?0:(Math.floor(Math.abs(c)/i)+1)*i:0===l&&c===i-1&&(c=i-2,l=1),this.closed||c>0?e=a[(c-1)%i]:(Ql.subVectors(a[0],a[1]).add(a[0]),e=Ql);var s=a[c%i],u=a[(c+1)%i];if(this.closed||c+2<i?t=a[(c+2)%i]:(Ql.subVectors(a[i-1],a[i-2]).add(a[i-1]),t=Ql),"centripetal"===this.curveType||"chordal"===this.curveType){var f="chordal"===this.curveType?.5:.25,p=Math.pow(e.distanceToSquared(s),f),d=Math.pow(s.distanceToSquared(u),f),m=Math.pow(u.distanceToSquared(t),f);d<1e-4&&(d=1),p<1e-4&&(p=d),m<1e-4&&(m=d),ns.initNonuniformCatmullRom(e.x,s.x,u.x,t.x,p,d,m),es.initNonuniformCatmullRom(e.y,s.y,u.y,t.y,p,d,m),ts.initNonuniformCatmullRom(e.z,s.z,u.z,t.z,p,d,m)}else"catmullrom"===this.curveType&&(ns.initCatmullRom(e.x,s.x,u.x,t.x,this.tension),es.initCatmullRom(e.y,s.y,u.y,t.y,this.tension),ts.initCatmullRom(e.z,s.z,u.z,t.z,this.tension));return o.set(ns.calc(l),es.calc(l),ts.calc(l)),o}},{key:"copy",value:function(n){P(w(t.prototype),"copy",this).call(this,n),this.points=[];for(var e=0,r=n.points.length;e<r;e++){var o=n.points[e];this.points.push(o.clone())}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this}},{key:"toJSON",value:function(){var n=P(w(t.prototype),"toJSON",this).call(this);n.points=[];for(var e=0,r=this.points.length;e<r;e++){var o=this.points[e];n.points.push(o.toArray())}return n.closed=this.closed,n.curveType=this.curveType,n.tension=this.tension,n}},{key:"fromJSON",value:function(n){P(w(t.prototype),"fromJSON",this).call(this,n),this.points=[];for(var e=0,r=n.points.length;e<r;e++){var o=n.points[e];this.points.push((new Or).fromArray(o))}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this}}]),t}($l);function os(n,e,t,r,o){var a=.5*(r-e),i=.5*(o-t),v=n*n;return(2*t-2*r+a+i)*(n*v)+(-3*t+3*r-2*a-i)*v+a*n+t}function as(n,e,t,r){return function(n,e){var t=1-n;return t*t*e}(n,e)+function(n,e){return 2*(1-n)*n*e}(n,t)+function(n,e){return n*n*e}(n,r)}function is(n,e,t,r,o){return function(n,e){var t=1-n;return t*t*t*e}(n,e)+function(n,e){var t=1-n;return 3*t*t*n*e}(n,t)+function(n,e){return 3*(1-n)*n*n*e}(n,r)+function(n,e){return n*n*n*e}(n,o)}var vs=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ir,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ir,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new ir,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new ir;return y(this,t),(n=e.call(this)).isCubicBezierCurve=!0,n.type="CubicBezierCurve",n.v0=r,n.v1=o,n.v2=a,n.v3=i,n}return _(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ir,t=e,r=this.v0,o=this.v1,a=this.v2,i=this.v3;return t.set(is(n,r.x,o.x,a.x,i.x),is(n,r.y,o.y,a.y,i.y)),t}},{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this}},{key:"toJSON",value:function(){var n=P(w(t.prototype),"toJSON",this).call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n}},{key:"fromJSON",value:function(n){return P(w(t.prototype),"fromJSON",this).call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this}}]),t}($l),cs=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Or,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Or,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Or,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Or;return y(this,t),(n=e.call(this)).isCubicBezierCurve3=!0,n.type="CubicBezierCurve3",n.v0=r,n.v1=o,n.v2=a,n.v3=i,n}return _(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Or,t=e,r=this.v0,o=this.v1,a=this.v2,i=this.v3;return t.set(is(n,r.x,o.x,a.x,i.x),is(n,r.y,o.y,a.y,i.y),is(n,r.z,o.z,a.z,i.z)),t}},{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this}},{key:"toJSON",value:function(){var n=P(w(t.prototype),"toJSON",this).call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n}},{key:"fromJSON",value:function(n){return P(w(t.prototype),"fromJSON",this).call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this}}]),t}($l),ls=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ir,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ir;return y(this,t),(n=e.call(this)).isLineCurve=!0,n.type="LineCurve",n.v1=r,n.v2=o,n}return _(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ir,t=e;return 1===n?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(n).add(this.v1)),t}},{key:"getPointAt",value:function(n,e){return this.getPoint(n,e)}},{key:"getTangent",value:function(n,e){var t=e||new ir;return t.copy(this.v2).sub(this.v1).normalize(),t}},{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.v1.copy(n.v1),this.v2.copy(n.v2),this}},{key:"toJSON",value:function(){var n=P(w(t.prototype),"toJSON",this).call(this);return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n}},{key:"fromJSON",value:function(n){return P(w(t.prototype),"fromJSON",this).call(this,n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this}}]),t}($l),ss=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Or,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Or;return y(this,t),(n=e.call(this)).isLineCurve3=!0,n.type="LineCurve3",n.v1=r,n.v2=o,n}return _(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Or,t=e;return 1===n?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(n).add(this.v1)),t}},{key:"getPointAt",value:function(n,e){return this.getPoint(n,e)}},{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.v1.copy(n.v1),this.v2.copy(n.v2),this}},{key:"toJSON",value:function(){var n=P(w(t.prototype),"toJSON",this).call(this);return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n}},{key:"fromJSON",value:function(n){return P(w(t.prototype),"fromJSON",this).call(this,n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this}}]),t}($l),us=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ir,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ir,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new ir;return y(this,t),(n=e.call(this)).isQuadraticBezierCurve=!0,n.type="QuadraticBezierCurve",n.v0=r,n.v1=o,n.v2=a,n}return _(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ir,t=e,r=this.v0,o=this.v1,a=this.v2;return t.set(as(n,r.x,o.x,a.x),as(n,r.y,o.y,a.y)),t}},{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this}},{key:"toJSON",value:function(){var n=P(w(t.prototype),"toJSON",this).call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n}},{key:"fromJSON",value:function(n){return P(w(t.prototype),"fromJSON",this).call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this}}]),t}($l),fs=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Or,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Or,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Or;return y(this,t),(n=e.call(this)).isQuadraticBezierCurve3=!0,n.type="QuadraticBezierCurve3",n.v0=r,n.v1=o,n.v2=a,n}return _(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Or,t=e,r=this.v0,o=this.v1,a=this.v2;return t.set(as(n,r.x,o.x,a.x),as(n,r.y,o.y,a.y),as(n,r.z,o.z,a.z)),t}},{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this}},{key:"toJSON",value:function(){var n=P(w(t.prototype),"toJSON",this).call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n}},{key:"fromJSON",value:function(n){return P(w(t.prototype),"fromJSON",this).call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this}}]),t}($l),ps=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return y(this,t),(n=e.call(this)).isSplineCurve=!0,n.type="SplineCurve",n.points=r,n}return _(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ir,t=e,r=this.points,o=(r.length-1)*n,a=Math.floor(o),i=o-a,v=r[0===a?a:a-1],c=r[a],l=r[a>r.length-2?r.length-1:a+1],s=r[a>r.length-3?r.length-1:a+2];return t.set(os(i,v.x,c.x,l.x,s.x),os(i,v.y,c.y,l.y,s.y)),t}},{key:"copy",value:function(n){P(w(t.prototype),"copy",this).call(this,n),this.points=[];for(var e=0,r=n.points.length;e<r;e++){var o=n.points[e];this.points.push(o.clone())}return this}},{key:"toJSON",value:function(){var n=P(w(t.prototype),"toJSON",this).call(this);n.points=[];for(var e=0,r=this.points.length;e<r;e++){var o=this.points[e];n.points.push(o.toArray())}return n}},{key:"fromJSON",value:function(n){P(w(t.prototype),"fromJSON",this).call(this,n),this.points=[];for(var e=0,r=n.points.length;e<r;e++){var o=n.points[e];this.points.push((new ir).fromArray(o))}return this}}]),t}($l),ds=Object.freeze({__proto__:null,ArcCurve:Kl,CatmullRomCurve3:rs,CubicBezierCurve:vs,CubicBezierCurve3:cs,EllipseCurve:Zl,LineCurve:ls,LineCurve3:ss,QuadraticBezierCurve:us,QuadraticBezierCurve3:fs,SplineCurve:ps}),ms=function(n){U(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).type="CurvePath",n.curves=[],n.autoClose=!1,n}return _(t,[{key:"add",value:function(n){this.curves.push(n)}},{key:"closePath",value:function(){var n=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);n.equals(e)||this.curves.push(new ls(e,n))}},{key:"getPoint",value:function(n,e){for(var t=n*this.getLength(),r=this.getCurveLengths(),o=0;o<r.length;){if(r[o]>=t){var a=r[o]-t,i=this.curves[o],v=i.getLength(),c=0===v?0:1-a/v;return i.getPointAt(c,e)}o++}return null}},{key:"getLength",value:function(){var n=this.getCurveLengths();return n[n.length-1]}},{key:"updateArcLengths",value:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}},{key:"getCurveLengths",value:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;for(var n=[],e=0,t=0,r=this.curves.length;t<r;t++)e+=this.curves[t].getLength(),n.push(e);return this.cacheLengths=n,n}},{key:"getSpacedPoints",value:function(){for(var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:40,e=[],t=0;t<=n;t++)e.push(this.getPoint(t/n));return this.autoClose&&e.push(e[0]),e}},{key:"getPoints",value:function(){for(var n,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:12,t=[],r=0,o=this.curves;r<o.length;r++)for(var a=o[r],i=a.isEllipseCurve?2*e:a.isLineCurve||a.isLineCurve3?1:a.isSplineCurve?e*a.points.length:e,v=a.getPoints(i),c=0;c<v.length;c++){var l=v[c];n&&n.equals(l)||(t.push(l),n=l)}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}},{key:"copy",value:function(n){P(w(t.prototype),"copy",this).call(this,n),this.curves=[];for(var e=0,r=n.curves.length;e<r;e++){var o=n.curves[e];this.curves.push(o.clone())}return this.autoClose=n.autoClose,this}},{key:"toJSON",value:function(){var n=P(w(t.prototype),"toJSON",this).call(this);n.autoClose=this.autoClose,n.curves=[];for(var e=0,r=this.curves.length;e<r;e++){var o=this.curves[e];n.curves.push(o.toJSON())}return n}},{key:"fromJSON",value:function(n){P(w(t.prototype),"fromJSON",this).call(this,n),this.autoClose=n.autoClose,this.curves=[];for(var e=0,r=n.curves.length;e<r;e++){var o=n.curves[e];this.curves.push((new ds[o.type]).fromJSON(o))}return this}}]),t}($l),hs=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).type="Path",r.currentPoint=new ir,n&&r.setFromPoints(n),r}return _(t,[{key:"setFromPoints",value:function(n){this.moveTo(n[0].x,n[0].y);for(var e=1,t=n.length;e<t;e++)this.lineTo(n[e].x,n[e].y);return this}},{key:"moveTo",value:function(n,e){return this.currentPoint.set(n,e),this}},{key:"lineTo",value:function(n,e){var t=new ls(this.currentPoint.clone(),new ir(n,e));return this.curves.push(t),this.currentPoint.set(n,e),this}},{key:"quadraticCurveTo",value:function(n,e,t,r){var o=new us(this.currentPoint.clone(),new ir(n,e),new ir(t,r));return this.curves.push(o),this.currentPoint.set(t,r),this}},{key:"bezierCurveTo",value:function(n,e,t,r,o,a){var i=new vs(this.currentPoint.clone(),new ir(n,e),new ir(t,r),new ir(o,a));return this.curves.push(i),this.currentPoint.set(o,a),this}},{key:"splineThru",value:function(n){var e=[this.currentPoint.clone()].concat(n),t=new ps(e);return this.curves.push(t),this.currentPoint.copy(n[n.length-1]),this}},{key:"arc",value:function(n,e,t,r,o,a){var i=this.currentPoint.x,v=this.currentPoint.y;return this.absarc(n+i,e+v,t,r,o,a),this}},{key:"absarc",value:function(n,e,t,r,o,a){return this.absellipse(n,e,t,t,r,o,a),this}},{key:"ellipse",value:function(n,e,t,r,o,a,i,v){var c=this.currentPoint.x,l=this.currentPoint.y;return this.absellipse(n+c,e+l,t,r,o,a,i,v),this}},{key:"absellipse",value:function(n,e,t,r,o,a,i,v){var c=new Zl(n,e,t,r,o,a,i,v);if(this.curves.length>0){var l=c.getPoint(0);l.equals(this.currentPoint)||this.lineTo(l.x,l.y)}this.curves.push(c);var s=c.getPoint(1);return this.currentPoint.copy(s),this}},{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.currentPoint.copy(n.currentPoint),this}},{key:"toJSON",value:function(){var n=P(w(t.prototype),"toJSON",this).call(this);return n.currentPoint=this.currentPoint.toArray(),n}},{key:"fromJSON",value:function(n){return P(w(t.prototype),"fromJSON",this).call(this,n),this.currentPoint.fromArray(n.currentPoint),this}}]),t}(ms),xs=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[new ir(0,-.5),new ir(.5,0),new ir(0,.5)],o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:12,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:2*Math.PI;y(this,t),(n=e.call(this)).type="LatheGeometry",n.parameters={points:r,segments:o,phiStart:a,phiLength:i},o=Math.floor(o),i=Kt(i,0,2*Math.PI);for(var v=[],c=[],l=[],s=[],u=[],f=1/o,p=new Or,d=new ir,m=new Or,h=new Or,x=new Or,g=0,b=0,_=0;_<=r.length-1;_++)switch(_){case 0:g=r[_+1].x-r[_].x,b=r[_+1].y-r[_].y,m.x=1*b,m.y=-g,m.z=0*b,x.copy(m),m.normalize(),s.push(m.x,m.y,m.z);break;case r.length-1:s.push(x.x,x.y,x.z);break;default:g=r[_+1].x-r[_].x,b=r[_+1].y-r[_].y,m.x=1*b,m.y=-g,m.z=0*b,h.copy(m),m.x+=x.x,m.y+=x.y,m.z+=x.z,m.normalize(),s.push(m.x,m.y,m.z),x.copy(h)}for(var U=0;U<=o;U++)for(var w=a+U*f*i,S=Math.sin(w),k=Math.cos(w),M=0;M<=r.length-1;M++){p.x=r[M].x*S,p.y=r[M].y,p.z=r[M].x*k,c.push(p.x,p.y,p.z),d.x=U/o,d.y=M/(r.length-1),l.push(d.x,d.y);var z=s[3*M+0]*S,C=s[3*M+1],T=s[3*M+0]*k;u.push(z,C,T)}for(var R=0;R<o;R++)for(var D=0;D<r.length-1;D++){var P=D+R*r.length,j=P,F=P+r.length,E=P+r.length+1,I=P+1;v.push(j,F,I),v.push(E,I,F)}return n.setIndex(v),n.setAttribute("position",new ua(c,3)),n.setAttribute("uv",new ua(l,2)),n.setAttribute("normal",new ua(u,3)),n}return _(t,null,[{key:"fromJSON",value:function(n){return new t(n.points,n.segments,n.phiStart,n.phiLength)}}]),t}(ba),gs=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:4,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:8;y(this,t);var v=new hs;return v.absarc(0,-o/2,r,1.5*Math.PI,0),v.absarc(0,o/2,r,0,.5*Math.PI),(n=e.call(this,v.getPoints(a),i)).type="CapsuleGeometry",n.parameters={radius:r,height:o,capSegments:a,radialSegments:i},n}return _(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.length,n.capSegments,n.radialSegments)}}]),t}(xs),ys=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:8,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:2*Math.PI;y(this,t),(n=e.call(this)).type="CircleGeometry",n.parameters={radius:r,segments:o,thetaStart:a,thetaLength:i},o=Math.max(3,o);var v=[],c=[],l=[],s=[],u=new Or,f=new ir;c.push(0,0,0),l.push(0,0,1),s.push(.5,.5);for(var p=0,d=3;p<=o;p++,d+=3){var m=a+p/o*i;u.x=r*Math.cos(m),u.y=r*Math.sin(m),c.push(u.x,u.y,u.z),l.push(0,0,1),f.x=(c[d]/r+1)/2,f.y=(c[d+1]/r+1)/2,s.push(f.x,f.y)}for(var h=1;h<=o;h++)v.push(h,h+1,0);return n.setIndex(v),n.setAttribute("position",new ua(c,3)),n.setAttribute("normal",new ua(l,3)),n.setAttribute("uv",new ua(s,2)),n}return _(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.segments,n.thetaStart,n.thetaLength)}}]),t}(ba),bs=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:8,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,c=arguments.length>5&&void 0!==arguments[5]&&arguments[5],l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,s=arguments.length>7&&void 0!==arguments[7]?arguments[7]:2*Math.PI;y(this,t),(n=e.call(this)).type="CylinderGeometry",n.parameters={radiusTop:r,radiusBottom:o,height:a,radialSegments:i,heightSegments:v,openEnded:c,thetaStart:l,thetaLength:s};var u=k(n);i=Math.floor(i),v=Math.floor(v);var f=[],p=[],d=[],m=[],h=0,x=[],g=a/2,b=0;function _(){for(var n=new Or,e=new Or,t=0,c=(o-r)/a,y=0;y<=v;y++){for(var _=[],U=y/v,w=U*(o-r)+r,S=0;S<=i;S++){var k=S/i,M=k*s+l,z=Math.sin(M),C=Math.cos(M);e.x=w*z,e.y=-U*a+g,e.z=w*C,p.push(e.x,e.y,e.z),n.set(z,c,C).normalize(),d.push(n.x,n.y,n.z),m.push(k,1-U),_.push(h++)}x.push(_)}for(var T=0;T<i;T++)for(var R=0;R<v;R++){var D=x[R][T],P=x[R+1][T],j=x[R+1][T+1],F=x[R][T+1];f.push(D,P,F),f.push(P,j,F),t+=6}u.addGroup(b,t,0),b+=t}function U(n){for(var e=h,t=new ir,a=new Or,v=0,c=!0===n?r:o,x=!0===n?1:-1,y=1;y<=i;y++)p.push(0,g*x,0),d.push(0,x,0),m.push(.5,.5),h++;for(var _=h,U=0;U<=i;U++){var w=U/i*s+l,S=Math.cos(w),k=Math.sin(w);a.x=c*k,a.y=g*x,a.z=c*S,p.push(a.x,a.y,a.z),d.push(0,x,0),t.x=.5*S+.5,t.y=.5*k*x+.5,m.push(t.x,t.y),h++}for(var M=0;M<i;M++){var z=e+M,C=_+M;!0===n?f.push(C,C+1,z):f.push(C+1,C,z),v+=3}u.addGroup(b,v,!0===n?1:2),b+=v}return _(),!1===c&&(r>0&&U(!0),o>0&&U(!1)),n.setIndex(f),n.setAttribute("position",new ua(p,3)),n.setAttribute("normal",new ua(d,3)),n.setAttribute("uv",new ua(m,2)),n}return _(t,null,[{key:"fromJSON",value:function(n){return new t(n.radiusTop,n.radiusBottom,n.height,n.radialSegments,n.heightSegments,n.openEnded,n.thetaStart,n.thetaLength)}}]),t}(ba),_s=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:8,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,v=arguments.length>4&&void 0!==arguments[4]&&arguments[4],c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:2*Math.PI;return y(this,t),(n=e.call(this,0,r,o,a,i,v,c,l)).type="ConeGeometry",n.parameters={radius:r,height:o,radialSegments:a,heightSegments:i,openEnded:v,thetaStart:c,thetaLength:l},n}return _(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.height,n.radialSegments,n.heightSegments,n.openEnded,n.thetaStart,n.thetaLength)}}]),t}(bs),Us=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;y(this,t),(n=e.call(this)).type="PolyhedronGeometry",n.parameters={vertices:r,indices:o,radius:a,detail:i};var v=[],c=[];function l(n){for(var e=new Or,t=new Or,r=new Or,a=0;a<o.length;a+=3)m(o[a+0],e),m(o[a+1],t),m(o[a+2],r),s(e,t,r,n)}function s(n,e,t,r){for(var o=r+1,a=[],i=0;i<=o;i++){a[i]=[];for(var v=n.clone().lerp(t,i/o),c=e.clone().lerp(t,i/o),l=o-i,s=0;s<=l;s++)a[i][s]=0===s&&i===o?v:v.clone().lerp(c,s/l)}for(var u=0;u<o;u++)for(var f=0;f<2*(o-u)-1;f++){var p=Math.floor(f/2);f%2===0?(d(a[u][p+1]),d(a[u+1][p]),d(a[u][p])):(d(a[u][p+1]),d(a[u+1][p+1]),d(a[u+1][p]))}}function u(n){for(var e=new Or,t=0;t<v.length;t+=3)e.x=v[t+0],e.y=v[t+1],e.z=v[t+2],e.normalize().multiplyScalar(n),v[t+0]=e.x,v[t+1]=e.y,v[t+2]=e.z}function f(){for(var n=new Or,e=0;e<v.length;e+=3){n.x=v[e+0],n.y=v[e+1],n.z=v[e+2];var t=g(n)/2/Math.PI+.5,r=b(n)/Math.PI+.5;c.push(t,1-r)}h(),p()}function p(){for(var n=0;n<c.length;n+=6){var e=c[n+0],t=c[n+2],r=c[n+4],o=Math.max(e,t,r),a=Math.min(e,t,r);o>.9&&a<.1&&(e<.2&&(c[n+0]+=1),t<.2&&(c[n+2]+=1),r<.2&&(c[n+4]+=1))}}function d(n){v.push(n.x,n.y,n.z)}function m(n,e){var t=3*n;e.x=r[t+0],e.y=r[t+1],e.z=r[t+2]}function h(){for(var n=new Or,e=new Or,t=new Or,r=new Or,o=new ir,a=new ir,i=new ir,l=0,s=0;l<v.length;l+=9,s+=6){n.set(v[l+0],v[l+1],v[l+2]),e.set(v[l+3],v[l+4],v[l+5]),t.set(v[l+6],v[l+7],v[l+8]),o.set(c[s+0],c[s+1]),a.set(c[s+2],c[s+3]),i.set(c[s+4],c[s+5]),r.copy(n).add(e).add(t).divideScalar(3);var u=g(r);x(o,s+0,n,u),x(a,s+2,e,u),x(i,s+4,t,u)}}function x(n,e,t,r){r<0&&1===n.x&&(c[e]=n.x-1),0===t.x&&0===t.z&&(c[e]=r/2/Math.PI+.5)}function g(n){return Math.atan2(n.z,-n.x)}function b(n){return Math.atan2(-n.y,Math.sqrt(n.x*n.x+n.z*n.z))}return l(i),u(a),f(),n.setAttribute("position",new ua(v,3)),n.setAttribute("normal",new ua(v.slice(),3)),n.setAttribute("uv",new ua(c,2)),0===i?n.computeVertexNormals():n.normalizeNormals(),n}return _(t,null,[{key:"fromJSON",value:function(n){return new t(n.vertices,n.indices,n.radius,n.details)}}]),t}(ba),ws=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;y(this,t);var a=(1+Math.sqrt(5))/2,i=1/a,v=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-a,0,-i,a,0,i,-a,0,i,a,-i,-a,0,-i,a,0,i,-a,0,i,a,0,-a,0,-i,a,0,-i,-a,0,i,a,0,i],c=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];return(n=e.call(this,v,c,r,o)).type="DodecahedronGeometry",n.parameters={radius:r,detail:o},n}return _(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.detail)}}]),t}(Us),Ss=new Or,ks=new Or,Ms=new Or,zs=new Zo,Cs=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(y(this,t),(n=e.call(this)).type="EdgesGeometry",n.parameters={geometry:r,thresholdAngle:o},null!==r){for(var a=4,i=Math.pow(10,a),v=Math.cos(Yt*o),c=r.getIndex(),l=r.getAttribute("position"),s=c?c.count:l.count,u=[0,0,0],f=["a","b","c"],p=new Array(3),d={},m=[],h=0;h<s;h+=3){c?(u[0]=c.getX(h),u[1]=c.getX(h+1),u[2]=c.getX(h+2)):(u[0]=h,u[1]=h+1,u[2]=h+2);var x=zs.a,g=zs.b,b=zs.c;if(x.fromBufferAttribute(l,u[0]),g.fromBufferAttribute(l,u[1]),b.fromBufferAttribute(l,u[2]),zs.getNormal(Ms),p[0]="".concat(Math.round(x.x*i),",").concat(Math.round(x.y*i),",").concat(Math.round(x.z*i)),p[1]="".concat(Math.round(g.x*i),",").concat(Math.round(g.y*i),",").concat(Math.round(g.z*i)),p[2]="".concat(Math.round(b.x*i),",").concat(Math.round(b.y*i),",").concat(Math.round(b.z*i)),p[0]!==p[1]&&p[1]!==p[2]&&p[2]!==p[0])for(var _=0;_<3;_++){var U=(_+1)%3,w=p[_],S=p[U],k=zs[f[_]],M=zs[f[U]],z="".concat(w,"_").concat(S),C="".concat(S,"_").concat(w);C in d&&d[C]?(Ms.dot(d[C].normal)<=v&&(m.push(k.x,k.y,k.z),m.push(M.x,M.y,M.z)),d[C]=null):z in d||(d[z]={index0:u[_],index1:u[U],normal:Ms.clone()})}}for(var T in d)if(d[T]){var R=d[T],D=R.index0,P=R.index1;Ss.fromBufferAttribute(l,D),ks.fromBufferAttribute(l,P),m.push(Ss.x,Ss.y,Ss.z),m.push(ks.x,ks.y,ks.z)}n.setAttribute("position",new ua(m,3))}return n}return _(t)}(ba),Ts=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this,n)).uuid=Zt(),r.type="Shape",r.holes=[],r}return _(t,[{key:"getPointsHoles",value:function(n){for(var e=[],t=0,r=this.holes.length;t<r;t++)e[t]=this.holes[t].getPoints(n);return e}},{key:"extractPoints",value:function(n){return{shape:this.getPoints(n),holes:this.getPointsHoles(n)}}},{key:"copy",value:function(n){P(w(t.prototype),"copy",this).call(this,n),this.holes=[];for(var e=0,r=n.holes.length;e<r;e++){var o=n.holes[e];this.holes.push(o.clone())}return this}},{key:"toJSON",value:function(){var n=P(w(t.prototype),"toJSON",this).call(this);n.uuid=this.uuid,n.holes=[];for(var e=0,r=this.holes.length;e<r;e++){var o=this.holes[e];n.holes.push(o.toJSON())}return n}},{key:"fromJSON",value:function(n){P(w(t.prototype),"fromJSON",this).call(this,n),this.uuid=n.uuid,this.holes=[];for(var e=0,r=n.holes.length;e<r;e++){var o=n.holes[e];this.holes.push((new hs).fromJSON(o))}return this}}]),t}(hs),Rs=function(n,e){var t,r,o,a,i,v,c,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2,s=e&&e.length,u=s?e[0]*l:n.length,f=Ds(n,0,u,l,!0),p=[];if(!f||f.next===f.prev)return p;if(s&&(f=Ls(n,e,f,l)),n.length>80*l){t=o=n[0],r=a=n[1];for(var d=l;d<u;d+=l)(i=n[d])<t&&(t=i),(v=n[d+1])<r&&(r=v),i>o&&(o=i),v>a&&(a=v);c=0!==(c=Math.max(o-t,a-r))?32767/c:0}return js(f,p,l,t,r,c,0),p};function Ds(n,e,t,r,o){var a,i;if(o===function(n,e,t,r){for(var o=0,a=e,i=t-r;a<t;a+=r)o+=(n[i]-n[a])*(n[a+1]+n[i+1]),i=a;return o}(n,e,t,r)>0)for(a=e;a<t;a+=r)i=Qs(a,n[a],n[a+1],i);else for(a=t-r;a>=e;a-=r)i=Qs(a,n[a],n[a+1],i);return i&&Xs(i,i.next)&&(nu(i),i=i.next),i}function Ps(n,e){if(!n)return n;e||(e=n);var t,r=n;do{if(t=!1,r.steiner||!Xs(r,r.next)&&0!==Hs(r.prev,r,r.next))r=r.next;else{if(nu(r),(r=e=r.prev)===r.next)break;t=!0}}while(t||r!==e);return e}function js(n,e,t,r,o,a,i){if(n){!i&&a&&function(n,e,t,r){var o=n;do{0===o.z&&(o.z=Bs(o.x,o.y,e,t,r)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next}while(o!==n);o.prevZ.nextZ=null,o.prevZ=null,function(n){var e,t,r,o,a,i,v,c,l=1;do{for(t=n,n=null,a=null,i=0;t;){for(i++,r=t,v=0,e=0;e<l&&(v++,r=r.nextZ);e++);for(c=l;v>0||c>0&&r;)0!==v&&(0===c||!r||t.z<=r.z)?(o=t,t=t.nextZ,v--):(o=r,r=r.nextZ,c--),a?a.nextZ=o:n=o,o.prevZ=a,a=o;t=r}a.nextZ=null,l*=2}while(i>1)}(o)}(n,r,o,a);for(var v,c,l=n;n.prev!==n.next;)if(v=n.prev,c=n.next,a?Es(n,r,o,a):Fs(n))e.push(v.i/t|0),e.push(n.i/t|0),e.push(c.i/t|0),nu(n),n=c.next,l=c.next;else if((n=c)===l){i?1===i?js(n=Is(Ps(n),e,t),e,t,r,o,a,2):2===i&&Os(n,e,t,r,o,a):js(Ps(n),e,t,r,o,a,1);break}}}function Fs(n){var e=n.prev,t=n,r=n.next;if(Hs(e,t,r)>=0)return!1;for(var o=e.x,a=t.x,i=r.x,v=e.y,c=t.y,l=r.y,s=o<a?o<i?o:i:a<i?a:i,u=v<c?v<l?v:l:c<l?c:l,f=o>a?o>i?o:i:a>i?a:i,p=v>c?v>l?v:l:c>l?c:l,d=r.next;d!==e;){if(d.x>=s&&d.x<=f&&d.y>=u&&d.y<=p&&Vs(o,v,a,c,i,l,d.x,d.y)&&Hs(d.prev,d,d.next)>=0)return!1;d=d.next}return!0}function Es(n,e,t,r){var o=n.prev,a=n,i=n.next;if(Hs(o,a,i)>=0)return!1;for(var v=o.x,c=a.x,l=i.x,s=o.y,u=a.y,f=i.y,p=v<c?v<l?v:l:c<l?c:l,d=s<u?s<f?s:f:u<f?u:f,m=v>c?v>l?v:l:c>l?c:l,h=s>u?s>f?s:f:u>f?u:f,x=Bs(p,d,e,t,r),g=Bs(m,h,e,t,r),y=n.prevZ,b=n.nextZ;y&&y.z>=x&&b&&b.z<=g;){if(y.x>=p&&y.x<=m&&y.y>=d&&y.y<=h&&y!==o&&y!==i&&Vs(v,s,c,u,l,f,y.x,y.y)&&Hs(y.prev,y,y.next)>=0)return!1;if(y=y.prevZ,b.x>=p&&b.x<=m&&b.y>=d&&b.y<=h&&b!==o&&b!==i&&Vs(v,s,c,u,l,f,b.x,b.y)&&Hs(b.prev,b,b.next)>=0)return!1;b=b.nextZ}for(;y&&y.z>=x;){if(y.x>=p&&y.x<=m&&y.y>=d&&y.y<=h&&y!==o&&y!==i&&Vs(v,s,c,u,l,f,y.x,y.y)&&Hs(y.prev,y,y.next)>=0)return!1;y=y.prevZ}for(;b&&b.z<=g;){if(b.x>=p&&b.x<=m&&b.y>=d&&b.y<=h&&b!==o&&b!==i&&Vs(v,s,c,u,l,f,b.x,b.y)&&Hs(b.prev,b,b.next)>=0)return!1;b=b.nextZ}return!0}function Is(n,e,t){var r=n;do{var o=r.prev,a=r.next.next;!Xs(o,a)&&Ys(o,r,r.next,a)&&Ks(o,a)&&Ks(a,o)&&(e.push(o.i/t|0),e.push(r.i/t|0),e.push(a.i/t|0),nu(r),nu(r.next),r=n=a),r=r.next}while(r!==n);return Ps(r)}function Os(n,e,t,r,o,a){var i=n;do{for(var v=i.next.next;v!==i.prev;){if(i.i!==v.i&&Ws(i,v)){var c=Js(i,v);return i=Ps(i,i.next),c=Ps(c,c.next),js(i,e,t,r,o,a,0),void js(c,e,t,r,o,a,0)}v=v.next}i=i.next}while(i!==n)}function Ls(n,e,t,r){var o,a,i,v=[];for(o=0,a=e.length;o<a;o++)(i=Ds(n,e[o]*r,o<a-1?e[o+1]*r:n.length,r,!1))===i.next&&(i.steiner=!0),v.push(qs(i));for(v.sort(As),o=0;o<v.length;o++)t=Ns(v[o],t);return t}function As(n,e){return n.x-e.x}function Ns(n,e){var t=function(n,e){var t,r=e,o=-1/0,a=n.x,i=n.y;do{if(i<=r.y&&i>=r.next.y&&r.next.y!==r.y){var v=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(v<=a&&v>o&&(o=v,t=r.x<r.next.x?r:r.next,v===a))return t}r=r.next}while(r!==e);if(!t)return null;var c,l=t,s=t.x,u=t.y,f=1/0;r=t;do{a>=r.x&&r.x>=s&&a!==r.x&&Vs(i<u?a:o,i,s,u,i<u?o:a,i,r.x,r.y)&&(c=Math.abs(i-r.y)/(a-r.x),Ks(r,n)&&(c<f||c===f&&(r.x>t.x||r.x===t.x&&Gs(t,r)))&&(t=r,f=c)),r=r.next}while(r!==l);return t}(n,e);if(!t)return e;var r=Js(t,n);return Ps(r,r.next),Ps(t,t.next)}function Gs(n,e){return Hs(n.prev,n,e.prev)<0&&Hs(e.next,n,n.next)<0}function Bs(n,e,t,r,o){return(n=1431655765&((n=858993459&((n=252645135&((n=16711935&((n=(n-t)*o|0)|n<<8))|n<<4))|n<<2))|n<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-r)*o|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function qs(n){var e=n,t=n;do{(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next}while(e!==n);return t}function Vs(n,e,t,r,o,a,i,v){return(o-i)*(e-v)>=(n-i)*(a-v)&&(n-i)*(r-v)>=(t-i)*(e-v)&&(t-i)*(a-v)>=(o-i)*(r-v)}function Ws(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!function(n,e){var t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&Ys(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}(n,e)&&(Ks(n,e)&&Ks(e,n)&&function(n,e){var t=n,r=!1,o=(n.x+e.x)/2,a=(n.y+e.y)/2;do{t.y>a!==t.next.y>a&&t.next.y!==t.y&&o<(t.next.x-t.x)*(a-t.y)/(t.next.y-t.y)+t.x&&(r=!r),t=t.next}while(t!==n);return r}(n,e)&&(Hs(n.prev,n,e.prev)||Hs(n,e.prev,e))||Xs(n,e)&&Hs(n.prev,n,n.next)>0&&Hs(e.prev,e,e.next)>0)}function Hs(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function Xs(n,e){return n.x===e.x&&n.y===e.y}function Ys(n,e,t,r){var o=Zs(Hs(n,e,t)),a=Zs(Hs(n,e,r)),i=Zs(Hs(t,r,n)),v=Zs(Hs(t,r,e));return o!==a&&i!==v||(!(0!==o||!$s(n,t,e))||(!(0!==a||!$s(n,r,e))||(!(0!==i||!$s(t,n,r))||!(0!==v||!$s(t,e,r)))))}function $s(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function Zs(n){return n>0?1:n<0?-1:0}function Ks(n,e){return Hs(n.prev,n,n.next)<0?Hs(n,e,n.next)>=0&&Hs(n,n.prev,e)>=0:Hs(n,e,n.prev)<0||Hs(n,n.next,e)<0}function Js(n,e){var t=new eu(n.i,n.x,n.y),r=new eu(e.i,e.x,e.y),o=n.next,a=e.prev;return n.next=e,e.prev=n,t.next=o,o.prev=t,r.next=t,t.prev=r,a.next=r,r.prev=a,r}function Qs(n,e,t,r){var o=new eu(n,e,t);return r?(o.next=r.next,o.prev=r,r.next.prev=o,r.next=o):(o.prev=o,o.next=o),o}function nu(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function eu(n,e,t){this.i=n,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}var tu=function(){function n(){y(this,n)}return _(n,null,[{key:"area",value:function(n){for(var e=n.length,t=0,r=e-1,o=0;o<e;r=o++)t+=n[r].x*n[o].y-n[o].x*n[r].y;return.5*t}},{key:"isClockWise",value:function(e){return n.area(e)<0}},{key:"triangulateShape",value:function(n,e){var t=[],r=[],o=[];ru(n),ou(t,n);var a=n.length;e.forEach(ru);for(var i=0;i<e.length;i++)r.push(a),a+=e[i].length,ou(t,e[i]);for(var v=Rs(t,r),c=0;c<v.length;c+=3)o.push(v.slice(c,c+3));return o}}]),n}();function ru(n){var e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function ou(n,e){for(var t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}var au=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Ts([new ir(.5,.5),new ir(-.5,.5),new ir(-.5,-.5),new ir(.5,-.5)]),o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};y(this,t),(n=e.call(this)).type="ExtrudeGeometry",n.parameters={shapes:r,options:o},r=Array.isArray(r)?r:[r];for(var a=k(n),i=[],v=[],c=0,l=r.length;c<l;c++){var s=r[c];u(s)}function u(n){var e,t,r,c,l,s=[],u=void 0!==o.curveSegments?o.curveSegments:12,f=void 0!==o.steps?o.steps:1,p=void 0!==o.depth?o.depth:1,d=void 0===o.bevelEnabled||o.bevelEnabled,m=void 0!==o.bevelThickness?o.bevelThickness:.2,h=void 0!==o.bevelSize?o.bevelSize:m-.1,x=void 0!==o.bevelOffset?o.bevelOffset:0,g=void 0!==o.bevelSegments?o.bevelSegments:3,y=o.extrudePath,b=void 0!==o.UVGenerator?o.UVGenerator:iu,_=!1;y&&(e=y.getSpacedPoints(f),_=!0,d=!1,t=y.computeFrenetFrames(f,!1),r=new Or,c=new Or,l=new Or),d||(g=0,m=0,h=0,x=0);var U=n.extractPoints(u),w=U.shape,S=U.holes;if(!tu.isClockWise(w)){w=w.reverse();for(var k=0,M=S.length;k<M;k++){var z=S[k];tu.isClockWise(z)&&(S[k]=z.reverse())}}for(var C=tu.triangulateShape(w,S),T=w,R=0,D=S.length;R<D;R++){var P=S[R];w=w.concat(P)}function j(n,e,t){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),e.clone().multiplyScalar(t).add(n)}var F=w.length,E=C.length;function I(n,e,t){var r,o,a,i=n.x-e.x,v=n.y-e.y,c=t.x-n.x,l=t.y-n.y,s=i*i+v*v,u=i*l-v*c;if(Math.abs(u)>Number.EPSILON){var f=Math.sqrt(s),p=Math.sqrt(c*c+l*l),d=e.x-v/f,m=e.y+i/f,h=((t.x-l/p-d)*l-(t.y+c/p-m)*c)/(i*l-v*c),x=(r=d+i*h-n.x)*r+(o=m+v*h-n.y)*o;if(x<=2)return new ir(r,o);a=Math.sqrt(x/2)}else{var g=!1;i>Number.EPSILON?c>Number.EPSILON&&(g=!0):i<-Number.EPSILON?c<-Number.EPSILON&&(g=!0):Math.sign(v)===Math.sign(l)&&(g=!0),g?(r=-v,o=i,a=Math.sqrt(s)):(r=i,o=v,a=Math.sqrt(s/2))}return new ir(r/a,o/a)}for(var O=[],L=0,A=T.length,N=A-1,G=L+1;L<A;L++,N++,G++)N===A&&(N=0),G===A&&(G=0),O[L]=I(T[L],T[N],T[G]);for(var B,q=[],V=O.concat(),W=0,H=S.length;W<H;W++){var X=S[W];B=[];for(var Y=0,$=X.length,Z=$-1,K=Y+1;Y<$;Y++,Z++,K++)Z===$&&(Z=0),K===$&&(K=0),B[Y]=I(X[Y],X[Z],X[K]);q.push(B),V=V.concat(B)}for(var J=0;J<g;J++){for(var Q=J/g,nn=m*Math.cos(Q*Math.PI/2),en=h*Math.sin(Q*Math.PI/2)+x,tn=0,rn=T.length;tn<rn;tn++){var on=j(T[tn],O[tn],en);Pn(on.x,on.y,-nn)}for(var an=0,vn=S.length;an<vn;an++){var cn=S[an];B=q[an];for(var ln=0,sn=cn.length;ln<sn;ln++){var un=j(cn[ln],B[ln],en);Pn(un.x,un.y,-nn)}}}for(var fn=h+x,pn=0;pn<F;pn++){var dn=d?j(w[pn],V[pn],fn):w[pn];_?(c.copy(t.normals[0]).multiplyScalar(dn.x),r.copy(t.binormals[0]).multiplyScalar(dn.y),l.copy(e[0]).add(c).add(r),Pn(l.x,l.y,l.z)):Pn(dn.x,dn.y,0)}for(var mn=1;mn<=f;mn++)for(var hn=0;hn<F;hn++){var xn=d?j(w[hn],V[hn],fn):w[hn];_?(c.copy(t.normals[mn]).multiplyScalar(xn.x),r.copy(t.binormals[mn]).multiplyScalar(xn.y),l.copy(e[mn]).add(c).add(r),Pn(l.x,l.y,l.z)):Pn(xn.x,xn.y,p/f*mn)}for(var gn=g-1;gn>=0;gn--){for(var yn=gn/g,bn=m*Math.cos(yn*Math.PI/2),_n=h*Math.sin(yn*Math.PI/2)+x,Un=0,wn=T.length;Un<wn;Un++){var Sn=j(T[Un],O[Un],_n);Pn(Sn.x,Sn.y,p+bn)}for(var kn=0,Mn=S.length;kn<Mn;kn++){var zn=S[kn];B=q[kn];for(var Cn=0,Tn=zn.length;Cn<Tn;Cn++){var Rn=j(zn[Cn],B[Cn],_n);_?Pn(Rn.x,Rn.y+e[f-1].y,e[f-1].x+bn):Pn(Rn.x,Rn.y,p+bn)}}}function Dn(n,e){for(var t=n.length;--t>=0;){var r=t,o=t-1;o<0&&(o=n.length-1);for(var a=0,i=f+2*g;a<i;a++){var v=F*a,c=F*(a+1);Fn(e+r+v,e+o+v,e+o+c,e+r+c)}}}function Pn(n,e,t){s.push(n),s.push(e),s.push(t)}function jn(n,e,t){En(n),En(e),En(t);var r=i.length/3,o=b.generateTopUV(a,i,r-3,r-2,r-1);In(o[0]),In(o[1]),In(o[2])}function Fn(n,e,t,r){En(n),En(e),En(r),En(e),En(t),En(r);var o=i.length/3,v=b.generateSideWallUV(a,i,o-6,o-3,o-2,o-1);In(v[0]),In(v[1]),In(v[3]),In(v[1]),In(v[2]),In(v[3])}function En(n){i.push(s[3*n+0]),i.push(s[3*n+1]),i.push(s[3*n+2])}function In(n){v.push(n.x),v.push(n.y)}!function(){var n=i.length/3;if(d){for(var e=0,t=F*e,r=0;r<E;r++){var o=C[r];jn(o[2]+t,o[1]+t,o[0]+t)}t=F*(e=f+2*g);for(var v=0;v<E;v++){var c=C[v];jn(c[0]+t,c[1]+t,c[2]+t)}}else{for(var l=0;l<E;l++){var s=C[l];jn(s[2],s[1],s[0])}for(var u=0;u<E;u++){var p=C[u];jn(p[0]+F*f,p[1]+F*f,p[2]+F*f)}}a.addGroup(n,i.length/3-n,0)}(),function(){var n=i.length/3,e=0;Dn(T,e),e+=T.length;for(var t=0,r=S.length;t<r;t++){var o=S[t];Dn(o,e),e+=o.length}a.addGroup(n,i.length/3-n,1)}()}return n.setAttribute("position",new ua(i,3)),n.setAttribute("uv",new ua(v,2)),n.computeVertexNormals(),n}return _(t,[{key:"toJSON",value:function(){var n=P(w(t.prototype),"toJSON",this).call(this);return function(n,e,t){if(t.shapes=[],Array.isArray(n))for(var r=0,o=n.length;r<o;r++){var a=n[r];t.shapes.push(a.uuid)}else t.shapes.push(n.uuid);t.options=Object.assign({},e),void 0!==e.extrudePath&&(t.options.extrudePath=e.extrudePath.toJSON());return t}(this.parameters.shapes,this.parameters.options,n)}}],[{key:"fromJSON",value:function(n,e){for(var r=[],o=0,a=n.shapes.length;o<a;o++){var i=e[n.shapes[o]];r.push(i)}var v=n.options.extrudePath;return void 0!==v&&(n.options.extrudePath=(new ds[v.type]).fromJSON(v)),new t(r,n.options)}}]),t}(ba),iu={generateTopUV:function(n,e,t,r,o){var a=e[3*t],i=e[3*t+1],v=e[3*r],c=e[3*r+1],l=e[3*o],s=e[3*o+1];return[new ir(a,i),new ir(v,c),new ir(l,s)]},generateSideWallUV:function(n,e,t,r,o,a){var i=e[3*t],v=e[3*t+1],c=e[3*t+2],l=e[3*r],s=e[3*r+1],u=e[3*r+2],f=e[3*o],p=e[3*o+1],d=e[3*o+2],m=e[3*a],h=e[3*a+1],x=e[3*a+2];return Math.abs(v-s)<Math.abs(i-l)?[new ir(i,1-c),new ir(l,1-u),new ir(f,1-d),new ir(m,1-x)]:[new ir(v,1-c),new ir(s,1-u),new ir(p,1-d),new ir(h,1-x)]}};var vu=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;y(this,t);var a=(1+Math.sqrt(5))/2,i=[-1,a,0,1,a,0,-1,-a,0,1,-a,0,0,-1,a,0,1,a,0,-1,-a,0,1,-a,a,0,-1,a,0,1,-a,0,-1,-a,0,1],v=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];return(n=e.call(this,i,v,r,o)).type="IcosahedronGeometry",n.parameters={radius:r,detail:o},n}return _(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.detail)}}]),t}(Us),cu=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;y(this,t);var a=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];return(n=e.call(this,a,i,r,o)).type="OctahedronGeometry",n.parameters={radius:r,detail:o},n}return _(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.detail)}}]),t}(Us),lu=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:.5,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:8,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2*Math.PI;y(this,t),(n=e.call(this)).type="RingGeometry",n.parameters={innerRadius:r,outerRadius:o,thetaSegments:a,phiSegments:i,thetaStart:v,thetaLength:c},a=Math.max(3,a);for(var l=[],s=[],u=[],f=[],p=r,d=(o-r)/(i=Math.max(1,i)),m=new Or,h=new ir,x=0;x<=i;x++){for(var g=0;g<=a;g++){var b=v+g/a*c;m.x=p*Math.cos(b),m.y=p*Math.sin(b),s.push(m.x,m.y,m.z),u.push(0,0,1),h.x=(m.x/o+1)/2,h.y=(m.y/o+1)/2,f.push(h.x,h.y)}p+=d}for(var _=0;_<i;_++)for(var U=_*(a+1),w=0;w<a;w++){var S=w+U,k=S,M=S+a+1,z=S+a+2,C=S+1;l.push(k,M,C),l.push(M,z,C)}return n.setIndex(l),n.setAttribute("position",new ua(s,3)),n.setAttribute("normal",new ua(u,3)),n.setAttribute("uv",new ua(f,2)),n}return _(t,null,[{key:"fromJSON",value:function(n){return new t(n.innerRadius,n.outerRadius,n.thetaSegments,n.phiSegments,n.thetaStart,n.thetaLength)}}]),t}(ba),su=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Ts([new ir(0,.5),new ir(-.5,-.5),new ir(.5,-.5)]),o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:12;y(this,t),(n=e.call(this)).type="ShapeGeometry",n.parameters={shapes:r,curveSegments:o};var a=[],i=[],v=[],c=[],l=0,s=0;if(!1===Array.isArray(r))f(r);else for(var u=0;u<r.length;u++)f(r[u]),n.addGroup(l,s,u),l+=s,s=0;function f(n){var e=i.length/3,t=n.extractPoints(o),r=t.shape,l=t.holes;!1===tu.isClockWise(r)&&(r=r.reverse());for(var u=0,f=l.length;u<f;u++){var p=l[u];!0===tu.isClockWise(p)&&(l[u]=p.reverse())}for(var d=tu.triangulateShape(r,l),m=0,h=l.length;m<h;m++){var x=l[m];r=r.concat(x)}for(var g=0,y=r.length;g<y;g++){var b=r[g];i.push(b.x,b.y,0),v.push(0,0,1),c.push(b.x,b.y)}for(var _=0,U=d.length;_<U;_++){var w=d[_],S=w[0]+e,k=w[1]+e,M=w[2]+e;a.push(S,k,M),s+=3}}return n.setIndex(a),n.setAttribute("position",new ua(i,3)),n.setAttribute("normal",new ua(v,3)),n.setAttribute("uv",new ua(c,2)),n}return _(t,[{key:"toJSON",value:function(){var n=P(w(t.prototype),"toJSON",this).call(this);return function(n,e){if(e.shapes=[],Array.isArray(n))for(var t=0,r=n.length;t<r;t++){var o=n[t];e.shapes.push(o.uuid)}else e.shapes.push(n.uuid);return e}(this.parameters.shapes,n)}}],[{key:"fromJSON",value:function(n,e){for(var r=[],o=0,a=n.shapes.length;o<a;o++){var i=e[n.shapes[o]];r.push(i)}return new t(r,n.curveSegments)}}]),t}(ba);var uu=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:16,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:Math.PI;y(this,t),(n=e.call(this)).type="SphereGeometry",n.parameters={radius:r,widthSegments:o,heightSegments:a,phiStart:i,phiLength:v,thetaStart:c,thetaLength:l},o=Math.max(3,Math.floor(o)),a=Math.max(2,Math.floor(a));for(var s=Math.min(c+l,Math.PI),u=0,f=[],p=new Or,d=new Or,m=[],h=[],x=[],g=[],b=0;b<=a;b++){var _=[],U=b/a,w=0;0==b&&0==c?w=.5/o:b==a&&s==Math.PI&&(w=-.5/o);for(var S=0;S<=o;S++){var k=S/o;p.x=-r*Math.cos(i+k*v)*Math.sin(c+U*l),p.y=r*Math.cos(c+U*l),p.z=r*Math.sin(i+k*v)*Math.sin(c+U*l),h.push(p.x,p.y,p.z),d.copy(p).normalize(),x.push(d.x,d.y,d.z),g.push(k+w,1-U),_.push(u++)}f.push(_)}for(var M=0;M<a;M++)for(var z=0;z<o;z++){var C=f[M][z+1],T=f[M][z],R=f[M+1][z],D=f[M+1][z+1];(0!==M||c>0)&&m.push(C,T,D),(M!==a-1||s<Math.PI)&&m.push(T,R,D)}return n.setIndex(m),n.setAttribute("position",new ua(h,3)),n.setAttribute("normal",new ua(x,3)),n.setAttribute("uv",new ua(g,2)),n}return _(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.widthSegments,n.heightSegments,n.phiStart,n.phiLength,n.thetaStart,n.thetaLength)}}]),t}(ba),fu=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;y(this,t);var a=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];return(n=e.call(this,a,i,r,o)).type="TetrahedronGeometry",n.parameters={radius:r,detail:o},n}return _(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.detail)}}]),t}(Us),pu=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.4,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:8,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:6,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI;y(this,t),(n=e.call(this)).type="TorusGeometry",n.parameters={radius:r,tube:o,radialSegments:a,tubularSegments:i,arc:v},a=Math.floor(a),i=Math.floor(i);for(var c=[],l=[],s=[],u=[],f=new Or,p=new Or,d=new Or,m=0;m<=a;m++)for(var h=0;h<=i;h++){var x=h/i*v,g=m/a*Math.PI*2;p.x=(r+o*Math.cos(g))*Math.cos(x),p.y=(r+o*Math.cos(g))*Math.sin(x),p.z=o*Math.sin(g),l.push(p.x,p.y,p.z),f.x=r*Math.cos(x),f.y=r*Math.sin(x),d.subVectors(p,f).normalize(),s.push(d.x,d.y,d.z),u.push(h/i),u.push(m/a)}for(var b=1;b<=a;b++)for(var _=1;_<=i;_++){var U=(i+1)*b+_-1,w=(i+1)*(b-1)+_-1,S=(i+1)*(b-1)+_,k=(i+1)*b+_;c.push(U,w,k),c.push(w,S,k)}return n.setIndex(c),n.setAttribute("position",new ua(l,3)),n.setAttribute("normal",new ua(s,3)),n.setAttribute("uv",new ua(u,2)),n}return _(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.tube,n.radialSegments,n.tubularSegments,n.arc)}}]),t}(ba),du=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.4,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:64,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:8,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:3;y(this,t),(n=e.call(this)).type="TorusKnotGeometry",n.parameters={radius:r,tube:o,tubularSegments:a,radialSegments:i,p:v,q:c},a=Math.floor(a),i=Math.floor(i);for(var l=[],s=[],u=[],f=[],p=new Or,d=new Or,m=new Or,h=new Or,x=new Or,g=new Or,b=new Or,_=0;_<=a;++_){var U=_/a*v*Math.PI*2;j(U,v,c,r,m),j(U+.01,v,c,r,h),g.subVectors(h,m),b.addVectors(h,m),x.crossVectors(g,b),b.crossVectors(x,g),x.normalize(),b.normalize();for(var w=0;w<=i;++w){var S=w/i*Math.PI*2,k=-o*Math.cos(S),M=o*Math.sin(S);p.x=m.x+(k*b.x+M*x.x),p.y=m.y+(k*b.y+M*x.y),p.z=m.z+(k*b.z+M*x.z),s.push(p.x,p.y,p.z),d.subVectors(p,m).normalize(),u.push(d.x,d.y,d.z),f.push(_/a),f.push(w/i)}}for(var z=1;z<=a;z++)for(var C=1;C<=i;C++){var T=(i+1)*(z-1)+(C-1),R=(i+1)*z+(C-1),D=(i+1)*z+C,P=(i+1)*(z-1)+C;l.push(T,R,P),l.push(R,D,P)}function j(n,e,t,r,o){var a=Math.cos(n),i=Math.sin(n),v=t/e*n,c=Math.cos(v);o.x=r*(2+c)*.5*a,o.y=r*(2+c)*i*.5,o.z=r*Math.sin(v)*.5}return n.setIndex(l),n.setAttribute("position",new ua(s,3)),n.setAttribute("normal",new ua(u,3)),n.setAttribute("uv",new ua(f,2)),n}return _(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.tube,n.tubularSegments,n.radialSegments,n.p,n.q)}}]),t}(ba),mu=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new fs(new Or(-1,-1,0),new Or(-1,1,0),new Or(1,1,0)),o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:64,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:8,v=arguments.length>4&&void 0!==arguments[4]&&arguments[4];y(this,t),(n=e.call(this)).type="TubeGeometry",n.parameters={path:r,tubularSegments:o,radius:a,radialSegments:i,closed:v};var c=r.computeFrenetFrames(o,v);n.tangents=c.tangents,n.normals=c.normals,n.binormals=c.binormals;var l=new Or,s=new Or,u=new ir,f=new Or,p=[],d=[],m=[],h=[];function x(){for(var n=0;n<o;n++)g(n);g(!1===v?o:0),_(),b()}function g(n){f=r.getPointAt(n/o,f);for(var e=c.normals[n],t=c.binormals[n],v=0;v<=i;v++){var u=v/i*Math.PI*2,m=Math.sin(u),h=-Math.cos(u);s.x=h*e.x+m*t.x,s.y=h*e.y+m*t.y,s.z=h*e.z+m*t.z,s.normalize(),d.push(s.x,s.y,s.z),l.x=f.x+a*s.x,l.y=f.y+a*s.y,l.z=f.z+a*s.z,p.push(l.x,l.y,l.z)}}function b(){for(var n=1;n<=o;n++)for(var e=1;e<=i;e++){var t=(i+1)*(n-1)+(e-1),r=(i+1)*n+(e-1),a=(i+1)*n+e,v=(i+1)*(n-1)+e;h.push(t,r,v),h.push(r,a,v)}}function _(){for(var n=0;n<=o;n++)for(var e=0;e<=i;e++)u.x=n/o,u.y=e/i,m.push(u.x,u.y)}return x(),n.setIndex(h),n.setAttribute("position",new ua(p,3)),n.setAttribute("normal",new ua(d,3)),n.setAttribute("uv",new ua(m,2)),n}return _(t,[{key:"toJSON",value:function(){var n=P(w(t.prototype),"toJSON",this).call(this);return n.path=this.parameters.path.toJSON(),n}}],[{key:"fromJSON",value:function(n){return new t((new ds[n.path.type]).fromJSON(n.path),n.tubularSegments,n.radius,n.radialSegments,n.closed)}}]),t}(ba),hu=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(y(this,t),(n=e.call(this)).type="WireframeGeometry",n.parameters={geometry:r},null!==r){var o=[],a=new Set,i=new Or,v=new Or;if(null!==r.index){var c=r.attributes.position,l=r.index,s=r.groups;0===s.length&&(s=[{start:0,count:l.count,materialIndex:0}]);for(var u=0,f=s.length;u<f;++u)for(var p=s[u],d=p.start,m=p.count,h=d,x=d+m;h<x;h+=3)for(var g=0;g<3;g++){var b=l.getX(h+g),_=l.getX(h+(g+1)%3);i.fromBufferAttribute(c,b),v.fromBufferAttribute(c,_),!0===xu(i,v,a)&&(o.push(i.x,i.y,i.z),o.push(v.x,v.y,v.z))}}else for(var U=r.attributes.position,w=0,S=U.count/3;w<S;w++)for(var k=0;k<3;k++){var M=3*w+k,z=3*w+(k+1)%3;i.fromBufferAttribute(U,M),v.fromBufferAttribute(U,z),!0===xu(i,v,a)&&(o.push(i.x,i.y,i.z),o.push(v.x,v.y,v.z))}n.setAttribute("position",new ua(o,3))}return n}return _(t)}(ba);function xu(n,e,t){var r="".concat(n.x,",").concat(n.y,",").concat(n.z,"-").concat(e.x,",").concat(e.y,",").concat(e.z),o="".concat(e.x,",").concat(e.y,",").concat(e.z,"-").concat(n.x,",").concat(n.y,",").concat(n.z);return!0!==t.has(r)&&!0!==t.has(o)&&(t.add(r),t.add(o),!0)}var gu=Object.freeze({__proto__:null,BoxGeometry:Na,CapsuleGeometry:gs,CircleGeometry:ys,ConeGeometry:_s,CylinderGeometry:bs,DodecahedronGeometry:ws,EdgesGeometry:Cs,ExtrudeGeometry:au,IcosahedronGeometry:vu,LatheGeometry:xs,OctahedronGeometry:cu,PlaneGeometry:ii,PolyhedronGeometry:Us,RingGeometry:lu,ShapeGeometry:su,SphereGeometry:uu,TetrahedronGeometry:fu,TorusGeometry:pu,TorusKnotGeometry:du,TubeGeometry:mu,WireframeGeometry:hu}),yu=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).isShadowMaterial=!0,r.type="ShadowMaterial",r.color=new wr(0),r.transparent=!0,r.fog=!0,r.setValues(n),r}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.fog=n.fog,this}}]),t}(Jo),bu=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this,n)).isRawShaderMaterial=!0,r.type="RawShaderMaterial",r}return _(t)}(Va),_u=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).isMeshStandardMaterial=!0,r.defines={STANDARD:""},r.type="MeshStandardMaterial",r.color=new wr(16777215),r.roughness=1,r.metalness=0,r.map=null,r.lightMap=null,r.lightMapIntensity=1,r.aoMap=null,r.aoMapIntensity=1,r.emissive=new wr(0),r.emissiveIntensity=1,r.emissiveMap=null,r.bumpMap=null,r.bumpScale=1,r.normalMap=null,r.normalMapType=ft,r.normalScale=new ir(1,1),r.displacementMap=null,r.displacementScale=1,r.displacementBias=0,r.roughnessMap=null,r.metalnessMap=null,r.alphaMap=null,r.envMap=null,r.envMapIntensity=1,r.wireframe=!1,r.wireframeLinewidth=1,r.wireframeLinecap="round",r.wireframeLinejoin="round",r.flatShading=!1,r.fog=!0,r.setValues(n),r}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.defines={STANDARD:""},this.color.copy(n.color),this.roughness=n.roughness,this.metalness=n.metalness,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.roughnessMap=n.roughnessMap,this.metalnessMap=n.metalnessMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.envMapIntensity=n.envMapIntensity,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.flatShading=n.flatShading,this.fog=n.fog,this}}]),t}(Jo),Uu=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).isMeshPhysicalMaterial=!0,r.defines={STANDARD:"",PHYSICAL:""},r.type="MeshPhysicalMaterial",r.clearcoatMap=null,r.clearcoatRoughness=0,r.clearcoatRoughnessMap=null,r.clearcoatNormalScale=new ir(1,1),r.clearcoatNormalMap=null,r.ior=1.5,Object.defineProperty(k(r),"reflectivity",{get:function(){return Kt(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(n){this.ior=(1+.4*n)/(1-.4*n)}}),r.iridescenceMap=null,r.iridescenceIOR=1.3,r.iridescenceThicknessRange=[100,400],r.iridescenceThicknessMap=null,r.sheenColor=new wr(0),r.sheenColorMap=null,r.sheenRoughness=1,r.sheenRoughnessMap=null,r.transmissionMap=null,r.thickness=0,r.thicknessMap=null,r.attenuationDistance=1/0,r.attenuationColor=new wr(1,1,1),r.specularIntensity=1,r.specularIntensityMap=null,r.specularColor=new wr(1,1,1),r.specularColorMap=null,r._sheen=0,r._clearcoat=0,r._iridescence=0,r._transmission=0,r.setValues(n),r}return _(t,[{key:"sheen",get:function(){return this._sheen},set:function(n){this._sheen>0!==n>0&&this.version++,this._sheen=n}},{key:"clearcoat",get:function(){return this._clearcoat},set:function(n){this._clearcoat>0!==n>0&&this.version++,this._clearcoat=n}},{key:"iridescence",get:function(){return this._iridescence},set:function(n){this._iridescence>0!==n>0&&this.version++,this._iridescence=n}},{key:"transmission",get:function(){return this._transmission},set:function(n){this._transmission>0!==n>0&&this.version++,this._transmission=n}},{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=n.clearcoat,this.clearcoatMap=n.clearcoatMap,this.clearcoatRoughness=n.clearcoatRoughness,this.clearcoatRoughnessMap=n.clearcoatRoughnessMap,this.clearcoatNormalMap=n.clearcoatNormalMap,this.clearcoatNormalScale.copy(n.clearcoatNormalScale),this.ior=n.ior,this.iridescence=n.iridescence,this.iridescenceMap=n.iridescenceMap,this.iridescenceIOR=n.iridescenceIOR,this.iridescenceThicknessRange=x(n.iridescenceThicknessRange),this.iridescenceThicknessMap=n.iridescenceThicknessMap,this.sheen=n.sheen,this.sheenColor.copy(n.sheenColor),this.sheenColorMap=n.sheenColorMap,this.sheenRoughness=n.sheenRoughness,this.sheenRoughnessMap=n.sheenRoughnessMap,this.transmission=n.transmission,this.transmissionMap=n.transmissionMap,this.thickness=n.thickness,this.thicknessMap=n.thicknessMap,this.attenuationDistance=n.attenuationDistance,this.attenuationColor.copy(n.attenuationColor),this.specularIntensity=n.specularIntensity,this.specularIntensityMap=n.specularIntensityMap,this.specularColor.copy(n.specularColor),this.specularColorMap=n.specularColorMap,this}}]),t}(_u),wu=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).isMeshPhongMaterial=!0,r.type="MeshPhongMaterial",r.color=new wr(16777215),r.specular=new wr(1118481),r.shininess=30,r.map=null,r.lightMap=null,r.lightMapIntensity=1,r.aoMap=null,r.aoMapIntensity=1,r.emissive=new wr(0),r.emissiveIntensity=1,r.emissiveMap=null,r.bumpMap=null,r.bumpScale=1,r.normalMap=null,r.normalMapType=ft,r.normalScale=new ir(1,1),r.displacementMap=null,r.displacementScale=1,r.displacementBias=0,r.specularMap=null,r.alphaMap=null,r.envMap=null,r.combine=kn,r.reflectivity=1,r.refractionRatio=.98,r.wireframe=!1,r.wireframeLinewidth=1,r.wireframeLinecap="round",r.wireframeLinejoin="round",r.flatShading=!1,r.fog=!0,r.setValues(n),r}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.specular.copy(n.specular),this.shininess=n.shininess,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.flatShading=n.flatShading,this.fog=n.fog,this}}]),t}(Jo),Su=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).isMeshToonMaterial=!0,r.defines={TOON:""},r.type="MeshToonMaterial",r.color=new wr(16777215),r.map=null,r.gradientMap=null,r.lightMap=null,r.lightMapIntensity=1,r.aoMap=null,r.aoMapIntensity=1,r.emissive=new wr(0),r.emissiveIntensity=1,r.emissiveMap=null,r.bumpMap=null,r.bumpScale=1,r.normalMap=null,r.normalMapType=ft,r.normalScale=new ir(1,1),r.displacementMap=null,r.displacementScale=1,r.displacementBias=0,r.alphaMap=null,r.wireframe=!1,r.wireframeLinewidth=1,r.wireframeLinecap="round",r.wireframeLinejoin="round",r.fog=!0,r.setValues(n),r}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.map=n.map,this.gradientMap=n.gradientMap,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.fog=n.fog,this}}]),t}(Jo),ku=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).isMeshNormalMaterial=!0,r.type="MeshNormalMaterial",r.bumpMap=null,r.bumpScale=1,r.normalMap=null,r.normalMapType=ft,r.normalScale=new ir(1,1),r.displacementMap=null,r.displacementScale=1,r.displacementBias=0,r.wireframe=!1,r.wireframeLinewidth=1,r.flatShading=!1,r.setValues(n),r}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.flatShading=n.flatShading,this}}]),t}(Jo),Mu=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).isMeshLambertMaterial=!0,r.type="MeshLambertMaterial",r.color=new wr(16777215),r.map=null,r.lightMap=null,r.lightMapIntensity=1,r.aoMap=null,r.aoMapIntensity=1,r.emissive=new wr(0),r.emissiveIntensity=1,r.emissiveMap=null,r.bumpMap=null,r.bumpScale=1,r.normalMap=null,r.normalMapType=ft,r.normalScale=new ir(1,1),r.displacementMap=null,r.displacementScale=1,r.displacementBias=0,r.specularMap=null,r.alphaMap=null,r.envMap=null,r.combine=kn,r.reflectivity=1,r.refractionRatio=.98,r.wireframe=!1,r.wireframeLinewidth=1,r.wireframeLinecap="round",r.wireframeLinejoin="round",r.flatShading=!1,r.fog=!0,r.setValues(n),r}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.flatShading=n.flatShading,this.fog=n.fog,this}}]),t}(Jo),zu=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).isMeshMatcapMaterial=!0,r.defines={MATCAP:""},r.type="MeshMatcapMaterial",r.color=new wr(16777215),r.matcap=null,r.map=null,r.bumpMap=null,r.bumpScale=1,r.normalMap=null,r.normalMapType=ft,r.normalScale=new ir(1,1),r.displacementMap=null,r.displacementScale=1,r.displacementBias=0,r.alphaMap=null,r.flatShading=!1,r.fog=!0,r.setValues(n),r}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.defines={MATCAP:""},this.color.copy(n.color),this.matcap=n.matcap,this.map=n.map,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.flatShading=n.flatShading,this.fog=n.fog,this}}]),t}(Jo),Cu=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).isLineDashedMaterial=!0,r.type="LineDashedMaterial",r.scale=1,r.dashSize=3,r.gapSize=1,r.setValues(n),r}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.scale=n.scale,this.dashSize=n.dashSize,this.gapSize=n.gapSize,this}}]),t}(Ml);function Tu(n,e,t){return Du(n)?new n.constructor(n.subarray(e,void 0!==t?t:n.length)):n.slice(e,t)}function Ru(n,e,t){return!n||!t&&n.constructor===e?n:"number"===typeof e.BYTES_PER_ELEMENT?new e(n):Array.prototype.slice.call(n)}function Du(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)}function Pu(n){for(var e=n.length,t=new Array(e),r=0;r!==e;++r)t[r]=r;return t.sort((function(e,t){return n[e]-n[t]})),t}function ju(n,e,t){for(var r=n.length,o=new n.constructor(r),a=0,i=0;i!==r;++a)for(var v=t[a]*e,c=0;c!==e;++c)o[i++]=n[v+c];return o}function Fu(n,e,t,r){for(var o=1,a=n[0];void 0!==a&&void 0===a[r];)a=n[o++];if(void 0!==a){var i=a[r];if(void 0!==i)if(Array.isArray(i))do{void 0!==(i=a[r])&&(e.push(a.time),t.push.apply(t,i)),a=n[o++]}while(void 0!==a);else if(void 0!==i.toArray)do{void 0!==(i=a[r])&&(e.push(a.time),i.toArray(t,t.length)),a=n[o++]}while(void 0!==a);else do{void 0!==(i=a[r])&&(e.push(a.time),t.push(i)),a=n[o++]}while(void 0!==a)}}var Eu=Object.freeze({__proto__:null,arraySlice:Tu,convertArray:Ru,isTypedArray:Du,getKeyframeOrder:Pu,sortedArray:ju,flattenJSON:Fu,subclip:function(n,e,t,r){var o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:30,a=n.clone();a.name=e;for(var i=[],v=0;v<a.tracks.length;++v){for(var c=a.tracks[v],l=c.getValueSize(),s=[],u=[],f=0;f<c.times.length;++f){var p=c.times[f]*o;if(!(p<t||p>=r)){s.push(c.times[f]);for(var d=0;d<l;++d)u.push(c.values[f*l+d])}}0!==s.length&&(c.times=Ru(s,c.times.constructor),c.values=Ru(u,c.values.constructor),i.push(c))}a.tracks=i;for(var m=1/0,h=0;h<a.tracks.length;++h)m>a.tracks[h].times[0]&&(m=a.tracks[h].times[0]);for(var x=0;x<a.tracks.length;++x)a.tracks[x].shift(-1*m);return a.resetDuration(),a},makeClipAdditive:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:n,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:30;r<=0&&(r=30);for(var o=t.tracks.length,a=e/r,i=function(e){var r=t.tracks[e],o=r.ValueTypeName;if("bool"===o||"string"===o)return"continue";var i=n.tracks.find((function(n){return n.name===r.name&&n.ValueTypeName===o}));if(void 0===i)return"continue";var v=0,c=r.getValueSize();r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(v=c/3);var l=0,s=i.getValueSize();i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(l=s/3);var u=r.times.length-1,f=void 0;if(a<=r.times[0]){var p=v,d=c-v;f=Tu(r.values,p,d)}else if(a>=r.times[u]){var m=u*c+v,h=m+c-v;f=Tu(r.values,m,h)}else{var x=r.createInterpolant(),g=v,y=c-v;x.evaluate(a),f=Tu(x.resultBuffer,g,y)}"quaternion"===o&&(new Ir).fromArray(f).normalize().conjugate().toArray(f);for(var b=i.times.length,_=0;_<b;++_){var U=_*s+l;if("quaternion"===o)Ir.multiplyQuaternionsFlat(i.values,U,f,0,i.values,U);else for(var w=s-2*l,S=0;S<w;++S)i.values[U+S]-=f[S]}},v=0;v<o;++v)i(v);return n.blendMode=ot,n}}),Iu=function(){function n(e,t,r,o){y(this,n),this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=void 0!==o?o:new t.constructor(r),this.sampleValues=t,this.valueSize=r,this.settings=null,this.DefaultSettings_={}}return _(n,[{key:"evaluate",value:function(n){var e=this.parameterPositions,t=this._cachedIndex,r=e[t],o=e[t-1];n:{e:{var a;t:{r:if(!(n<r)){for(var i=t+2;;){if(void 0===r){if(n<o)break r;return t=e.length,this._cachedIndex=t,this.copySampleValue_(t-1)}if(t===i)break;if(o=r,n<(r=e[++t]))break e}a=e.length;break t}if(n>=o)break n;var v=e[1];n<v&&(t=2,o=v);for(var c=t-2;;){if(void 0===o)return this._cachedIndex=0,this.copySampleValue_(0);if(t===c)break;if(r=o,n>=(o=e[--t-1]))break e}a=t,t=0}for(;t<a;){var l=t+a>>>1;n<e[l]?a=l:t=l+1}if(r=e[t],void 0===(o=e[t-1]))return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===r)return t=e.length,this._cachedIndex=t,this.copySampleValue_(t-1)}this._cachedIndex=t,this.intervalChanged_(t,o,r)}return this.interpolate_(t,o,n,r)}},{key:"getSettings_",value:function(){return this.settings||this.DefaultSettings_}},{key:"copySampleValue_",value:function(n){for(var e=this.resultBuffer,t=this.sampleValues,r=this.valueSize,o=n*r,a=0;a!==r;++a)e[a]=t[o+a];return e}},{key:"interpolate_",value:function(){throw new Error("call to abstract method")}},{key:"intervalChanged_",value:function(){}}]),n}(),Ou=function(n){U(t,n);var e=z(t);function t(n,r,o,a){var i;return y(this,t),(i=e.call(this,n,r,o,a))._weightPrev=-0,i._offsetPrev=-0,i._weightNext=-0,i._offsetNext=-0,i.DefaultSettings_={endingStart:nt,endingEnd:nt},i}return _(t,[{key:"intervalChanged_",value:function(n,e,t){var r=this.parameterPositions,o=n-2,a=n+1,i=r[o],v=r[a];if(void 0===i)switch(this.getSettings_().endingStart){case et:o=n,i=2*e-t;break;case tt:i=e+r[o=r.length-2]-r[o+1];break;default:o=n,i=t}if(void 0===v)switch(this.getSettings_().endingEnd){case et:a=n,v=2*t-e;break;case tt:a=1,v=t+r[1]-r[0];break;default:a=n-1,v=e}var c=.5*(t-e),l=this.valueSize;this._weightPrev=c/(e-i),this._weightNext=c/(v-t),this._offsetPrev=o*l,this._offsetNext=a*l}},{key:"interpolate_",value:function(n,e,t,r){for(var o=this.resultBuffer,a=this.sampleValues,i=this.valueSize,v=n*i,c=v-i,l=this._offsetPrev,s=this._offsetNext,u=this._weightPrev,f=this._weightNext,p=(t-e)/(r-e),d=p*p,m=d*p,h=-u*m+2*u*d-u*p,x=(1+u)*m+(-1.5-2*u)*d+(-.5+u)*p+1,g=(-1-f)*m+(1.5+f)*d+.5*p,y=f*m-f*d,b=0;b!==i;++b)o[b]=h*a[l+b]+x*a[c+b]+g*a[v+b]+y*a[s+b];return o}}]),t}(Iu),Lu=function(n){U(t,n);var e=z(t);function t(n,r,o,a){return y(this,t),e.call(this,n,r,o,a)}return _(t,[{key:"interpolate_",value:function(n,e,t,r){for(var o=this.resultBuffer,a=this.sampleValues,i=this.valueSize,v=n*i,c=v-i,l=(t-e)/(r-e),s=1-l,u=0;u!==i;++u)o[u]=a[c+u]*s+a[v+u]*l;return o}}]),t}(Iu),Au=function(n){U(t,n);var e=z(t);function t(n,r,o,a){return y(this,t),e.call(this,n,r,o,a)}return _(t,[{key:"interpolate_",value:function(n){return this.copySampleValue_(n-1)}}]),t}(Iu),Nu=function(){function n(e,t,r,o){if(y(this,n),void 0===e)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===t||0===t.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Ru(t,this.TimeBufferType),this.values=Ru(r,this.ValueBufferType),this.setInterpolation(o||this.DefaultInterpolation)}return _(n,[{key:"InterpolantFactoryMethodDiscrete",value:function(n){return new Au(this.times,this.values,this.getValueSize(),n)}},{key:"InterpolantFactoryMethodLinear",value:function(n){return new Lu(this.times,this.values,this.getValueSize(),n)}},{key:"InterpolantFactoryMethodSmooth",value:function(n){return new Ou(this.times,this.values,this.getValueSize(),n)}},{key:"setInterpolation",value:function(n){var e;switch(n){case Ke:e=this.InterpolantFactoryMethodDiscrete;break;case Je:e=this.InterpolantFactoryMethodLinear;break;case Qe:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){var t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(n===this.DefaultInterpolation)throw new Error(t);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=e,this}},{key:"getInterpolation",value:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Ke;case this.InterpolantFactoryMethodLinear:return Je;case this.InterpolantFactoryMethodSmooth:return Qe}}},{key:"getValueSize",value:function(){return this.values.length/this.times.length}},{key:"shift",value:function(n){if(0!==n)for(var e=this.times,t=0,r=e.length;t!==r;++t)e[t]+=n;return this}},{key:"scale",value:function(n){if(1!==n)for(var e=this.times,t=0,r=e.length;t!==r;++t)e[t]*=n;return this}},{key:"trim",value:function(n,e){for(var t=this.times,r=t.length,o=0,a=r-1;o!==r&&t[o]<n;)++o;for(;-1!==a&&t[a]>e;)--a;if(++a,0!==o||a!==r){o>=a&&(o=(a=Math.max(a,1))-1);var i=this.getValueSize();this.times=Tu(t,o,a),this.values=Tu(this.values,o*i,a*i)}return this}},{key:"validate",value:function(){var n=!0,e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),n=!1);var t=this.times,r=this.values,o=t.length;0===o&&(console.error("THREE.KeyframeTrack: Track is empty.",this),n=!1);for(var a=null,i=0;i!==o;i++){var v=t[i];if("number"===typeof v&&isNaN(v)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,i,v),n=!1;break}if(null!==a&&a>v){console.error("THREE.KeyframeTrack: Out of order keys.",this,i,v,a),n=!1;break}a=v}if(void 0!==r&&Du(r))for(var c=0,l=r.length;c!==l;++c){var s=r[c];if(isNaN(s)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,c,s),n=!1;break}}return n}},{key:"optimize",value:function(){for(var n=Tu(this.times),e=Tu(this.values),t=this.getValueSize(),r=this.getInterpolation()===Qe,o=n.length-1,a=1,i=1;i<o;++i){var v=!1,c=n[i];if(c!==n[i+1]&&(1!==i||c!==n[0]))if(r)v=!0;else for(var l=i*t,s=l-t,u=l+t,f=0;f!==t;++f){var p=e[l+f];if(p!==e[s+f]||p!==e[u+f]){v=!0;break}}if(v){if(i!==a){n[a]=n[i];for(var d=i*t,m=a*t,h=0;h!==t;++h)e[m+h]=e[d+h]}++a}}if(o>0){n[a]=n[o];for(var x=o*t,g=a*t,y=0;y!==t;++y)e[g+y]=e[x+y];++a}return a!==n.length?(this.times=Tu(n,0,a),this.values=Tu(e,0,a*t)):(this.times=n,this.values=e),this}},{key:"clone",value:function(){var n=Tu(this.times,0),e=Tu(this.values,0),t=new(0,this.constructor)(this.name,n,e);return t.createInterpolant=this.createInterpolant,t}}],[{key:"toJSON",value:function(n){var e,t=n.constructor;if(t.toJSON!==this.toJSON)e=t.toJSON(n);else{e={name:n.name,times:Ru(n.times,Array),values:Ru(n.values,Array)};var r=n.getInterpolation();r!==n.DefaultInterpolation&&(e.interpolation=r)}return e.type=n.ValueTypeName,e}}]),n}();Nu.prototype.TimeBufferType=Float32Array,Nu.prototype.ValueBufferType=Float32Array,Nu.prototype.DefaultInterpolation=Je;var Gu=function(n){U(t,n);var e=z(t);function t(){return y(this,t),e.apply(this,arguments)}return _(t)}(Nu);Gu.prototype.ValueTypeName="bool",Gu.prototype.ValueBufferType=Array,Gu.prototype.DefaultInterpolation=Ke,Gu.prototype.InterpolantFactoryMethodLinear=void 0,Gu.prototype.InterpolantFactoryMethodSmooth=void 0;var Bu=function(n){U(t,n);var e=z(t);function t(){return y(this,t),e.apply(this,arguments)}return _(t)}(Nu);Bu.prototype.ValueTypeName="color";var qu=function(n){U(t,n);var e=z(t);function t(){return y(this,t),e.apply(this,arguments)}return _(t)}(Nu);qu.prototype.ValueTypeName="number";var Vu=function(n){U(t,n);var e=z(t);function t(n,r,o,a){return y(this,t),e.call(this,n,r,o,a)}return _(t,[{key:"interpolate_",value:function(n,e,t,r){for(var o=this.resultBuffer,a=this.sampleValues,i=this.valueSize,v=(t-e)/(r-e),c=n*i,l=c+i;c!==l;c+=4)Ir.slerpFlat(o,0,a,c-i,a,c,v);return o}}]),t}(Iu),Wu=function(n){U(t,n);var e=z(t);function t(){return y(this,t),e.apply(this,arguments)}return _(t,[{key:"InterpolantFactoryMethodLinear",value:function(n){return new Vu(this.times,this.values,this.getValueSize(),n)}}]),t}(Nu);Wu.prototype.ValueTypeName="quaternion",Wu.prototype.DefaultInterpolation=Je,Wu.prototype.InterpolantFactoryMethodSmooth=void 0;var Hu=function(n){U(t,n);var e=z(t);function t(){return y(this,t),e.apply(this,arguments)}return _(t)}(Nu);Hu.prototype.ValueTypeName="string",Hu.prototype.ValueBufferType=Array,Hu.prototype.DefaultInterpolation=Ke,Hu.prototype.InterpolantFactoryMethodLinear=void 0,Hu.prototype.InterpolantFactoryMethodSmooth=void 0;var Xu=function(n){U(t,n);var e=z(t);function t(){return y(this,t),e.apply(this,arguments)}return _(t)}(Nu);Xu.prototype.ValueTypeName="vector";var Yu=function(){function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,r=arguments.length>2?arguments[2]:void 0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:rt;y(this,n),this.name=e,this.tracks=r,this.duration=t,this.blendMode=o,this.uuid=Zt(),this.duration<0&&this.resetDuration()}return _(n,[{key:"resetDuration",value:function(){for(var n=0,e=0,t=this.tracks.length;e!==t;++e){var r=this.tracks[e];n=Math.max(n,r.times[r.times.length-1])}return this.duration=n,this}},{key:"trim",value:function(){for(var n=0;n<this.tracks.length;n++)this.tracks[n].trim(0,this.duration);return this}},{key:"validate",value:function(){for(var n=!0,e=0;e<this.tracks.length;e++)n=n&&this.tracks[e].validate();return n}},{key:"optimize",value:function(){for(var n=0;n<this.tracks.length;n++)this.tracks[n].optimize();return this}},{key:"clone",value:function(){for(var n=[],e=0;e<this.tracks.length;e++)n.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,n,this.blendMode)}},{key:"toJSON",value:function(){return this.constructor.toJSON(this)}}],[{key:"parse",value:function(n){for(var e=[],t=n.tracks,r=1/(n.fps||1),o=0,a=t.length;o!==a;++o)e.push($u(t[o]).scale(r));var i=new this(n.name,n.duration,e,n.blendMode);return i.uuid=n.uuid,i}},{key:"toJSON",value:function(n){for(var e=[],t=n.tracks,r={name:n.name,duration:n.duration,tracks:e,uuid:n.uuid,blendMode:n.blendMode},o=0,a=t.length;o!==a;++o)e.push(Nu.toJSON(t[o]));return r}},{key:"CreateFromMorphTargetSequence",value:function(n,e,t,r){for(var o=e.length,a=[],i=0;i<o;i++){var v=[],c=[];v.push((i+o-1)%o,i,(i+1)%o),c.push(0,1,0);var l=Pu(v);v=ju(v,1,l),c=ju(c,1,l),r||0!==v[0]||(v.push(o),c.push(c[0])),a.push(new qu(".morphTargetInfluences["+e[i].name+"]",v,c).scale(1/t))}return new this(n,-1,a)}},{key:"findByName",value:function(n,e){var t=n;if(!Array.isArray(n)){var r=n;t=r.geometry&&r.geometry.animations||r.animations}for(var o=0;o<t.length;o++)if(t[o].name===e)return t[o];return null}},{key:"CreateClipsFromMorphTargetSequences",value:function(n,e,t){for(var r={},o=/^([\w-]*?)([\d]+)$/,a=0,i=n.length;a<i;a++){var v=n[a],c=v.name.match(o);if(c&&c.length>1){var l=c[1],s=r[l];s||(r[l]=s=[]),s.push(v)}}var u=[];for(var f in r)u.push(this.CreateFromMorphTargetSequence(f,r[f],e,t));return u}},{key:"parseAnimation",value:function(n,e){if(!n)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;for(var t=function(n,e,t,r,o){if(0!==t.length){var a=[],i=[];Fu(t,a,i,r),0!==a.length&&o.push(new n(e,a,i))}},r=[],o=n.name||"default",a=n.fps||30,i=n.blendMode,v=n.length||-1,c=n.hierarchy||[],l=0;l<c.length;l++){var s=c[l].keys;if(s&&0!==s.length)if(s[0].morphTargets){var u={},f=void 0;for(f=0;f<s.length;f++)if(s[f].morphTargets)for(var p=0;p<s[f].morphTargets.length;p++)u[s[f].morphTargets[p]]=-1;for(var d in u){for(var m=[],h=[],x=0;x!==s[f].morphTargets.length;++x){var g=s[f];m.push(g.time),h.push(g.morphTarget===d?1:0)}r.push(new qu(".morphTargetInfluence["+d+"]",m,h))}v=u.length*a}else{var y=".bones["+e[l].name+"]";t(Xu,y+".position",s,"pos",r),t(Wu,y+".quaternion",s,"rot",r),t(Xu,y+".scale",s,"scl",r)}}return 0===r.length?null:new this(o,v,r,i)}}]),n}();function $u(n){if(void 0===n.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");var e=function(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return qu;case"vector":case"vector2":case"vector3":case"vector4":return Xu;case"color":return Bu;case"quaternion":return Wu;case"bool":case"boolean":return Gu;case"string":return Hu}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}(n.type);if(void 0===n.times){var t=[],r=[];Fu(n.keys,t,r,"value"),n.times=t,n.values=r}return void 0!==e.parse?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}var Zu,Ku={enabled:!1,files:{},add:function(n,e){!1!==this.enabled&&(this.files[n]=e)},get:function(n){if(!1!==this.enabled)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}},Ju=_((function n(e,t,r){y(this,n);var o=this,a=!1,i=0,v=0,c=void 0,l=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=r,this.itemStart=function(n){v++,!1===a&&void 0!==o.onStart&&o.onStart(n,i,v),a=!0},this.itemEnd=function(n){i++,void 0!==o.onProgress&&o.onProgress(n,i,v),i===v&&(a=!1,void 0!==o.onLoad&&o.onLoad())},this.itemError=function(n){void 0!==o.onError&&o.onError(n)},this.resolveURL=function(n){return c?c(n):n},this.setURLModifier=function(n){return c=n,this},this.addHandler=function(n,e){return l.push(n,e),this},this.removeHandler=function(n){var e=l.indexOf(n);return-1!==e&&l.splice(e,2),this},this.getHandler=function(n){for(var e=0,t=l.length;e<t;e+=2){var r=l[e],o=l[e+1];if(r.global&&(r.lastIndex=0),r.test(n))return o}return null}})),Qu=new Ju,nf=function(){function n(e){y(this,n),this.manager=void 0!==e?e:Qu,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}return _(n,[{key:"load",value:function(){}},{key:"loadAsync",value:function(n,e){var t=this;return new Promise((function(r,o){t.load(n,r,e,o)}))}},{key:"parse",value:function(){}},{key:"setCrossOrigin",value:function(n){return this.crossOrigin=n,this}},{key:"setWithCredentials",value:function(n){return this.withCredentials=n,this}},{key:"setPath",value:function(n){return this.path=n,this}},{key:"setResourcePath",value:function(n){return this.resourcePath=n,this}},{key:"setRequestHeader",value:function(n){return this.requestHeader=n,this}}]),n}(),ef={},tf=function(n){U(t,n);var e=z(t);function t(n,r){var o;return y(this,t),(o=e.call(this,n)).response=r,o}return _(t)}(C(Error)),rf=function(n){U(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return _(t,[{key:"load",value:function(n,e,t,r){var o=this;void 0===n&&(n=""),void 0!==this.path&&(n=this.path+n),n=this.manager.resolveURL(n);var a=Ku.get(n);if(void 0!==a)return this.manager.itemStart(n),setTimeout((function(){e&&e(a),o.manager.itemEnd(n)}),0),a;if(void 0===ef[n]){ef[n]=[],ef[n].push({onLoad:e,onProgress:t,onError:r});var i=new Request(n,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),v=this.mimeType,c=this.responseType;fetch(i).then((function(e){if(200===e.status||0===e.status){if(0===e.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),"undefined"===typeof ReadableStream||void 0===e.body||void 0===e.body.getReader)return e;var t=ef[n],r=e.body.getReader(),o=e.headers.get("Content-Length"),a=o?parseInt(o):0,i=0!==a,v=0,c=new ReadableStream({start:function(n){!function e(){r.read().then((function(r){var o=r.done,c=r.value;if(o)n.close();else{v+=c.byteLength;for(var l=new ProgressEvent("progress",{lengthComputable:i,loaded:v,total:a}),s=0,u=t.length;s<u;s++){var f=t[s];f.onProgress&&f.onProgress(l)}n.enqueue(c),e()}}))}()}});return new Response(c)}throw new tf('fetch for "'.concat(e.url,'" responded with ').concat(e.status,": ").concat(e.statusText),e)})).then((function(n){switch(c){case"arraybuffer":return n.arrayBuffer();case"blob":return n.blob();case"document":return n.text().then((function(n){return(new DOMParser).parseFromString(n,v)}));case"json":return n.json();default:if(void 0===v)return n.text();var e=/charset="?([^;"\s]*)"?/i.exec(v),t=e&&e[1]?e[1].toLowerCase():void 0,r=new TextDecoder(t);return n.arrayBuffer().then((function(n){return r.decode(n)}))}})).then((function(e){Ku.add(n,e);var t=ef[n];delete ef[n];for(var r=0,o=t.length;r<o;r++){var a=t[r];a.onLoad&&a.onLoad(e)}})).catch((function(e){var t=ef[n];if(void 0===t)throw o.manager.itemError(n),e;delete ef[n];for(var r=0,a=t.length;r<a;r++){var i=t[r];i.onError&&i.onError(e)}o.manager.itemError(n)})).finally((function(){o.manager.itemEnd(n)})),this.manager.itemStart(n)}else ef[n].push({onLoad:e,onProgress:t,onError:r})}},{key:"setResponseType",value:function(n){return this.responseType=n,this}},{key:"setMimeType",value:function(n){return this.mimeType=n,this}}]),t}(nf),of=function(n){U(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return _(t,[{key:"load",value:function(n,e,t,r){var o=this,a=new rf(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(n,(function(t){try{e(o.parse(JSON.parse(t)))}catch(a){r?r(a):console.error(a),o.manager.itemError(n)}}),t,r)}},{key:"parse",value:function(n){for(var e=[],t=0;t<n.length;t++){var r=Yu.parse(n[t]);e.push(r)}return e}}]),t}(nf),af=function(n){U(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return _(t,[{key:"load",value:function(n,e,t,r){var o=this,a=[],i=new Hl,v=new rf(this.manager);v.setPath(this.path),v.setResponseType("arraybuffer"),v.setRequestHeader(this.requestHeader),v.setWithCredentials(o.withCredentials);var c=0;function l(l){v.load(n[l],(function(n){var t=o.parse(n,!0);a[l]={width:t.width,height:t.height,format:t.format,mipmaps:t.mipmaps},6===(c+=1)&&(1===t.mipmapCount&&(i.minFilter=Yn),i.image=a,i.format=t.format,i.needsUpdate=!0,e&&e(i))}),t,r)}if(Array.isArray(n))for(var s=0,u=n.length;s<u;++s)l(s);else v.load(n,(function(n){var t=o.parse(n,!0);if(t.isCubemap){for(var r=t.mipmaps.length/t.mipmapCount,v=0;v<r;v++){a[v]={mipmaps:[]};for(var c=0;c<t.mipmapCount;c++)a[v].mipmaps.push(t.mipmaps[v*t.mipmapCount+c]),a[v].format=t.format,a[v].width=t.width,a[v].height=t.height}i.image=a}else i.image.width=t.width,i.image.height=t.height,i.mipmaps=t.mipmaps;1===t.mipmapCount&&(i.minFilter=Yn),i.format=t.format,i.needsUpdate=!0,e&&e(i)}),t,r);return i}}]),t}(nf),vf=function(n){U(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return _(t,[{key:"load",value:function(n,e,t,r){void 0!==this.path&&(n=this.path+n),n=this.manager.resolveURL(n);var o=this,a=Ku.get(n);if(void 0!==a)return o.manager.itemStart(n),setTimeout((function(){e&&e(a),o.manager.itemEnd(n)}),0),a;var i=ur("img");function v(){l(),Ku.add(n,this),e&&e(this),o.manager.itemEnd(n)}function c(e){l(),r&&r(e),o.manager.itemError(n),o.manager.itemEnd(n)}function l(){i.removeEventListener("load",v,!1),i.removeEventListener("error",c,!1)}return i.addEventListener("load",v,!1),i.addEventListener("error",c,!1),"data:"!==n.slice(0,5)&&void 0!==this.crossOrigin&&(i.crossOrigin=this.crossOrigin),o.manager.itemStart(n),i.src=n,i}}]),t}(nf),cf=function(n){U(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return _(t,[{key:"load",value:function(n,e,t,r){var o=new $a,a=new vf(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);var i=0;function v(t){a.load(n[t],(function(n){o.images[t]=n,6===++i&&(o.needsUpdate=!0,e&&e(o))}),void 0,r)}for(var c=0;c<n.length;++c)v(c);return o}}]),t}(nf),lf=function(n){U(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return _(t,[{key:"load",value:function(n,e,t,r){var o=this,a=new ml,i=new rf(this.manager);return i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setPath(this.path),i.setWithCredentials(o.withCredentials),i.load(n,(function(n){var t=o.parse(n);t&&(void 0!==t.image?a.image=t.image:void 0!==t.data&&(a.image.width=t.width,a.image.height=t.height,a.image.data=t.data),a.wrapS=void 0!==t.wrapS?t.wrapS:Gn,a.wrapT=void 0!==t.wrapT?t.wrapT:Gn,a.magFilter=void 0!==t.magFilter?t.magFilter:Yn,a.minFilter=void 0!==t.minFilter?t.minFilter:Yn,a.anisotropy=void 0!==t.anisotropy?t.anisotropy:1,void 0!==t.encoding&&(a.encoding=t.encoding),void 0!==t.flipY&&(a.flipY=t.flipY),void 0!==t.format&&(a.format=t.format),void 0!==t.type&&(a.type=t.type),void 0!==t.mipmaps&&(a.mipmaps=t.mipmaps,a.minFilter=Kn),1===t.mipmapCount&&(a.minFilter=Yn),void 0!==t.generateMipmaps&&(a.generateMipmaps=t.generateMipmaps),a.needsUpdate=!0,e&&e(a,t))}),t,r),a}}]),t}(nf),sf=function(n){U(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return _(t,[{key:"load",value:function(n,e,t,r){var o=new Cr,a=new vf(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(n,(function(n){o.image=n,o.needsUpdate=!0,void 0!==e&&e(o)}),t,r),o}}]),t}(nf),uf=function(n){U(t,n);var e=z(t);function t(n){var r,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return y(this,t),(r=e.call(this)).isLight=!0,r.type="Light",r.color=new wr(n),r.intensity=o,r}return _(t,[{key:"dispose",value:function(){}},{key:"copy",value:function(n,e){return P(w(t.prototype),"copy",this).call(this,n,e),this.color.copy(n.color),this.intensity=n.intensity,this}},{key:"toJSON",value:function(n){var e=P(w(t.prototype),"toJSON",this).call(this,n);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}]),t}(Ao),ff=function(n){U(t,n);var e=z(t);function t(n,r,o){var a;return y(this,t),(a=e.call(this,n,o)).isHemisphereLight=!0,a.type="HemisphereLight",a.position.copy(Ao.DefaultUp),a.updateMatrix(),a.groundColor=new wr(r),a}return _(t,[{key:"copy",value:function(n,e){return P(w(t.prototype),"copy",this).call(this,n,e),this.groundColor.copy(n.groundColor),this}}]),t}(uf),pf=new po,df=new Or,mf=new Or,hf=function(){function n(e){y(this,n),this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new ir(512,512),this.map=null,this.mapPass=null,this.matrix=new po,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new ri,this._frameExtents=new ir(1,1),this._viewportCount=1,this._viewports=[new Tr(0,0,1,1)]}return _(n,[{key:"getViewportCount",value:function(){return this._viewportCount}},{key:"getFrustum",value:function(){return this._frustum}},{key:"updateMatrices",value:function(n){var e=this.camera,t=this.matrix;df.setFromMatrixPosition(n.matrixWorld),e.position.copy(df),mf.setFromMatrixPosition(n.target.matrixWorld),e.lookAt(mf),e.updateMatrixWorld(),pf.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(pf),t.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),t.multiply(pf)}},{key:"getViewport",value:function(n){return this._viewports[n]}},{key:"getFrameExtents",value:function(){return this._frameExtents}},{key:"dispose",value:function(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}},{key:"copy",value:function(n){return this.camera=n.camera.clone(),this.bias=n.bias,this.radius=n.radius,this.mapSize.copy(n.mapSize),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"toJSON",value:function(){var n={};return 0!==this.bias&&(n.bias=this.bias),0!==this.normalBias&&(n.normalBias=this.normalBias),1!==this.radius&&(n.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(n.mapSize=this.mapSize.toArray()),n.camera=this.camera.toJSON(!1).object,delete n.camera.matrix,n}}]),n}(),xf=function(n){U(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this,new Ha(50,1,.5,500))).isSpotLightShadow=!0,n.focus=1,n}return _(t,[{key:"updateMatrices",value:function(n){var e=this.camera,r=2*$t*n.angle*this.focus,o=this.mapSize.width/this.mapSize.height,a=n.distance||e.far;r===e.fov&&o===e.aspect&&a===e.far||(e.fov=r,e.aspect=o,e.far=a,e.updateProjectionMatrix()),P(w(t.prototype),"updateMatrices",this).call(this,n)}},{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.focus=n.focus,this}}]),t}(hf),gf=function(n){U(t,n);var e=z(t);function t(n,r){var o,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Math.PI/3,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;return y(this,t),(o=e.call(this,n,r)).isSpotLight=!0,o.type="SpotLight",o.position.copy(Ao.DefaultUp),o.updateMatrix(),o.target=new Ao,o.distance=a,o.angle=i,o.penumbra=v,o.decay=c,o.map=null,o.shadow=new xf,o}return _(t,[{key:"power",get:function(){return this.intensity*Math.PI},set:function(n){this.intensity=n/Math.PI}},{key:"dispose",value:function(){this.shadow.dispose()}},{key:"copy",value:function(n,e){return P(w(t.prototype),"copy",this).call(this,n,e),this.distance=n.distance,this.angle=n.angle,this.penumbra=n.penumbra,this.decay=n.decay,this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}}]),t}(uf),yf=new po,bf=new Or,_f=new Or,Uf=function(n){U(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this,new Ha(90,1,.5,500))).isPointLightShadow=!0,n._frameExtents=new ir(4,2),n._viewportCount=6,n._viewports=[new Tr(2,1,1,1),new Tr(0,1,1,1),new Tr(3,1,1,1),new Tr(1,1,1,1),new Tr(3,0,1,1),new Tr(1,0,1,1)],n._cubeDirections=[new Or(1,0,0),new Or(-1,0,0),new Or(0,0,1),new Or(0,0,-1),new Or(0,1,0),new Or(0,-1,0)],n._cubeUps=[new Or(0,1,0),new Or(0,1,0),new Or(0,1,0),new Or(0,1,0),new Or(0,0,1),new Or(0,0,-1)],n}return _(t,[{key:"updateMatrices",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=this.camera,r=this.matrix,o=n.distance||t.far;o!==t.far&&(t.far=o,t.updateProjectionMatrix()),bf.setFromMatrixPosition(n.matrixWorld),t.position.copy(bf),_f.copy(t.position),_f.add(this._cubeDirections[e]),t.up.copy(this._cubeUps[e]),t.lookAt(_f),t.updateMatrixWorld(),r.makeTranslation(-bf.x,-bf.y,-bf.z),yf.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(yf)}}]),t}(hf),wf=function(n){U(t,n);var e=z(t);function t(n,r){var o,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;return y(this,t),(o=e.call(this,n,r)).isPointLight=!0,o.type="PointLight",o.distance=a,o.decay=i,o.shadow=new Uf,o}return _(t,[{key:"power",get:function(){return 4*this.intensity*Math.PI},set:function(n){this.intensity=n/(4*Math.PI)}},{key:"dispose",value:function(){this.shadow.dispose()}},{key:"copy",value:function(n,e){return P(w(t.prototype),"copy",this).call(this,n,e),this.distance=n.distance,this.decay=n.decay,this.shadow=n.shadow.clone(),this}}]),t}(uf),Sf=function(n){U(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this,new hi(-5,5,5,-5,.5,500))).isDirectionalLightShadow=!0,n}return _(t)}(hf),kf=function(n){U(t,n);var e=z(t);function t(n,r){var o;return y(this,t),(o=e.call(this,n,r)).isDirectionalLight=!0,o.type="DirectionalLight",o.position.copy(Ao.DefaultUp),o.updateMatrix(),o.target=new Ao,o.shadow=new Sf,o}return _(t,[{key:"dispose",value:function(){this.shadow.dispose()}},{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}}]),t}(uf),Mf=function(n){U(t,n);var e=z(t);function t(n,r){var o;return y(this,t),(o=e.call(this,n,r)).isAmbientLight=!0,o.type="AmbientLight",o}return _(t)}(uf),zf=function(n){U(t,n);var e=z(t);function t(n,r){var o,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:10,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:10;return y(this,t),(o=e.call(this,n,r)).isRectAreaLight=!0,o.type="RectAreaLight",o.width=a,o.height=i,o}return _(t,[{key:"power",get:function(){return this.intensity*this.width*this.height*Math.PI},set:function(n){this.intensity=n/(this.width*this.height*Math.PI)}},{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.width=n.width,this.height=n.height,this}},{key:"toJSON",value:function(n){var e=P(w(t.prototype),"toJSON",this).call(this,n);return e.object.width=this.width,e.object.height=this.height,e}}]),t}(uf),Cf=function(){function n(){y(this,n),this.isSphericalHarmonics3=!0,this.coefficients=[];for(var e=0;e<9;e++)this.coefficients.push(new Or)}return _(n,[{key:"set",value:function(n){for(var e=0;e<9;e++)this.coefficients[e].copy(n[e]);return this}},{key:"zero",value:function(){for(var n=0;n<9;n++)this.coefficients[n].set(0,0,0);return this}},{key:"getAt",value:function(n,e){var t=n.x,r=n.y,o=n.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.282095),e.addScaledVector(a[1],.488603*r),e.addScaledVector(a[2],.488603*o),e.addScaledVector(a[3],.488603*t),e.addScaledVector(a[4],t*r*1.092548),e.addScaledVector(a[5],r*o*1.092548),e.addScaledVector(a[6],.315392*(3*o*o-1)),e.addScaledVector(a[7],t*o*1.092548),e.addScaledVector(a[8],.546274*(t*t-r*r)),e}},{key:"getIrradianceAt",value:function(n,e){var t=n.x,r=n.y,o=n.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.886227),e.addScaledVector(a[1],1.023328*r),e.addScaledVector(a[2],1.023328*o),e.addScaledVector(a[3],1.023328*t),e.addScaledVector(a[4],.858086*t*r),e.addScaledVector(a[5],.858086*r*o),e.addScaledVector(a[6],.743125*o*o-.247708),e.addScaledVector(a[7],.858086*t*o),e.addScaledVector(a[8],.429043*(t*t-r*r)),e}},{key:"add",value:function(n){for(var e=0;e<9;e++)this.coefficients[e].add(n.coefficients[e]);return this}},{key:"addScaledSH",value:function(n,e){for(var t=0;t<9;t++)this.coefficients[t].addScaledVector(n.coefficients[t],e);return this}},{key:"scale",value:function(n){for(var e=0;e<9;e++)this.coefficients[e].multiplyScalar(n);return this}},{key:"lerp",value:function(n,e){for(var t=0;t<9;t++)this.coefficients[t].lerp(n.coefficients[t],e);return this}},{key:"equals",value:function(n){for(var e=0;e<9;e++)if(!this.coefficients[e].equals(n.coefficients[e]))return!1;return!0}},{key:"copy",value:function(n){return this.set(n.coefficients)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"fromArray",value:function(n){for(var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=this.coefficients,r=0;r<9;r++)t[r].fromArray(n,e+3*r);return this}},{key:"toArray",value:function(){for(var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=this.coefficients,r=0;r<9;r++)t[r].toArray(n,e+3*r);return n}}],[{key:"getBasisAt",value:function(n,e){var t=n.x,r=n.y,o=n.z;e[0]=.282095,e[1]=.488603*r,e[2]=.488603*o,e[3]=.488603*t,e[4]=1.092548*t*r,e[5]=1.092548*r*o,e[6]=.315392*(3*o*o-1),e[7]=1.092548*t*o,e[8]=.546274*(t*t-r*r)}}]),n}(),Tf=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Cf,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return y(this,t),(n=e.call(this,void 0,o)).isLightProbe=!0,n.sh=r,n}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.sh.copy(n.sh),this}},{key:"fromJSON",value:function(n){return this.intensity=n.intensity,this.sh.fromArray(n.sh),this}},{key:"toJSON",value:function(n){var e=P(w(t.prototype),"toJSON",this).call(this,n);return e.object.sh=this.sh.toArray(),e}}]),t}(uf),Rf=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this,n)).textures={},r}return _(t,[{key:"load",value:function(n,e,t,r){var o=this,a=new rf(o.manager);a.setPath(o.path),a.setRequestHeader(o.requestHeader),a.setWithCredentials(o.withCredentials),a.load(n,(function(t){try{e(o.parse(JSON.parse(t)))}catch(a){r?r(a):console.error(a),o.manager.itemError(n)}}),t,r)}},{key:"parse",value:function(n){var e=this.textures;function r(n){return void 0===e[n]&&console.warn("THREE.MaterialLoader: Undefined texture",n),e[n]}var o=t.createMaterialFromType(n.type);if(void 0!==n.uuid&&(o.uuid=n.uuid),void 0!==n.name&&(o.name=n.name),void 0!==n.color&&void 0!==o.color&&o.color.setHex(n.color),void 0!==n.roughness&&(o.roughness=n.roughness),void 0!==n.metalness&&(o.metalness=n.metalness),void 0!==n.sheen&&(o.sheen=n.sheen),void 0!==n.sheenColor&&(o.sheenColor=(new wr).setHex(n.sheenColor)),void 0!==n.sheenRoughness&&(o.sheenRoughness=n.sheenRoughness),void 0!==n.emissive&&void 0!==o.emissive&&o.emissive.setHex(n.emissive),void 0!==n.specular&&void 0!==o.specular&&o.specular.setHex(n.specular),void 0!==n.specularIntensity&&(o.specularIntensity=n.specularIntensity),void 0!==n.specularColor&&void 0!==o.specularColor&&o.specularColor.setHex(n.specularColor),void 0!==n.shininess&&(o.shininess=n.shininess),void 0!==n.clearcoat&&(o.clearcoat=n.clearcoat),void 0!==n.clearcoatRoughness&&(o.clearcoatRoughness=n.clearcoatRoughness),void 0!==n.iridescence&&(o.iridescence=n.iridescence),void 0!==n.iridescenceIOR&&(o.iridescenceIOR=n.iridescenceIOR),void 0!==n.iridescenceThicknessRange&&(o.iridescenceThicknessRange=n.iridescenceThicknessRange),void 0!==n.transmission&&(o.transmission=n.transmission),void 0!==n.thickness&&(o.thickness=n.thickness),void 0!==n.attenuationDistance&&(o.attenuationDistance=n.attenuationDistance),void 0!==n.attenuationColor&&void 0!==o.attenuationColor&&o.attenuationColor.setHex(n.attenuationColor),void 0!==n.fog&&(o.fog=n.fog),void 0!==n.flatShading&&(o.flatShading=n.flatShading),void 0!==n.blending&&(o.blending=n.blending),void 0!==n.combine&&(o.combine=n.combine),void 0!==n.side&&(o.side=n.side),void 0!==n.shadowSide&&(o.shadowSide=n.shadowSide),void 0!==n.opacity&&(o.opacity=n.opacity),void 0!==n.transparent&&(o.transparent=n.transparent),void 0!==n.alphaTest&&(o.alphaTest=n.alphaTest),void 0!==n.depthTest&&(o.depthTest=n.depthTest),void 0!==n.depthWrite&&(o.depthWrite=n.depthWrite),void 0!==n.colorWrite&&(o.colorWrite=n.colorWrite),void 0!==n.stencilWrite&&(o.stencilWrite=n.stencilWrite),void 0!==n.stencilWriteMask&&(o.stencilWriteMask=n.stencilWriteMask),void 0!==n.stencilFunc&&(o.stencilFunc=n.stencilFunc),void 0!==n.stencilRef&&(o.stencilRef=n.stencilRef),void 0!==n.stencilFuncMask&&(o.stencilFuncMask=n.stencilFuncMask),void 0!==n.stencilFail&&(o.stencilFail=n.stencilFail),void 0!==n.stencilZFail&&(o.stencilZFail=n.stencilZFail),void 0!==n.stencilZPass&&(o.stencilZPass=n.stencilZPass),void 0!==n.wireframe&&(o.wireframe=n.wireframe),void 0!==n.wireframeLinewidth&&(o.wireframeLinewidth=n.wireframeLinewidth),void 0!==n.wireframeLinecap&&(o.wireframeLinecap=n.wireframeLinecap),void 0!==n.wireframeLinejoin&&(o.wireframeLinejoin=n.wireframeLinejoin),void 0!==n.rotation&&(o.rotation=n.rotation),1!==n.linewidth&&(o.linewidth=n.linewidth),void 0!==n.dashSize&&(o.dashSize=n.dashSize),void 0!==n.gapSize&&(o.gapSize=n.gapSize),void 0!==n.scale&&(o.scale=n.scale),void 0!==n.polygonOffset&&(o.polygonOffset=n.polygonOffset),void 0!==n.polygonOffsetFactor&&(o.polygonOffsetFactor=n.polygonOffsetFactor),void 0!==n.polygonOffsetUnits&&(o.polygonOffsetUnits=n.polygonOffsetUnits),void 0!==n.dithering&&(o.dithering=n.dithering),void 0!==n.alphaToCoverage&&(o.alphaToCoverage=n.alphaToCoverage),void 0!==n.premultipliedAlpha&&(o.premultipliedAlpha=n.premultipliedAlpha),void 0!==n.visible&&(o.visible=n.visible),void 0!==n.toneMapped&&(o.toneMapped=n.toneMapped),void 0!==n.userData&&(o.userData=n.userData),void 0!==n.vertexColors&&("number"===typeof n.vertexColors?o.vertexColors=n.vertexColors>0:o.vertexColors=n.vertexColors),void 0!==n.uniforms)for(var a in n.uniforms){var i=n.uniforms[a];switch(o.uniforms[a]={},i.type){case"t":o.uniforms[a].value=r(i.value);break;case"c":o.uniforms[a].value=(new wr).setHex(i.value);break;case"v2":o.uniforms[a].value=(new ir).fromArray(i.value);break;case"v3":o.uniforms[a].value=(new Or).fromArray(i.value);break;case"v4":o.uniforms[a].value=(new Tr).fromArray(i.value);break;case"m3":o.uniforms[a].value=(new vr).fromArray(i.value);break;case"m4":o.uniforms[a].value=(new po).fromArray(i.value);break;default:o.uniforms[a].value=i.value}}if(void 0!==n.defines&&(o.defines=n.defines),void 0!==n.vertexShader&&(o.vertexShader=n.vertexShader),void 0!==n.fragmentShader&&(o.fragmentShader=n.fragmentShader),void 0!==n.glslVersion&&(o.glslVersion=n.glslVersion),void 0!==n.extensions)for(var v in n.extensions)o.extensions[v]=n.extensions[v];if(void 0!==n.size&&(o.size=n.size),void 0!==n.sizeAttenuation&&(o.sizeAttenuation=n.sizeAttenuation),void 0!==n.map&&(o.map=r(n.map)),void 0!==n.matcap&&(o.matcap=r(n.matcap)),void 0!==n.alphaMap&&(o.alphaMap=r(n.alphaMap)),void 0!==n.bumpMap&&(o.bumpMap=r(n.bumpMap)),void 0!==n.bumpScale&&(o.bumpScale=n.bumpScale),void 0!==n.normalMap&&(o.normalMap=r(n.normalMap)),void 0!==n.normalMapType&&(o.normalMapType=n.normalMapType),void 0!==n.normalScale){var c=n.normalScale;!1===Array.isArray(c)&&(c=[c,c]),o.normalScale=(new ir).fromArray(c)}return void 0!==n.displacementMap&&(o.displacementMap=r(n.displacementMap)),void 0!==n.displacementScale&&(o.displacementScale=n.displacementScale),void 0!==n.displacementBias&&(o.displacementBias=n.displacementBias),void 0!==n.roughnessMap&&(o.roughnessMap=r(n.roughnessMap)),void 0!==n.metalnessMap&&(o.metalnessMap=r(n.metalnessMap)),void 0!==n.emissiveMap&&(o.emissiveMap=r(n.emissiveMap)),void 0!==n.emissiveIntensity&&(o.emissiveIntensity=n.emissiveIntensity),void 0!==n.specularMap&&(o.specularMap=r(n.specularMap)),void 0!==n.specularIntensityMap&&(o.specularIntensityMap=r(n.specularIntensityMap)),void 0!==n.specularColorMap&&(o.specularColorMap=r(n.specularColorMap)),void 0!==n.envMap&&(o.envMap=r(n.envMap)),void 0!==n.envMapIntensity&&(o.envMapIntensity=n.envMapIntensity),void 0!==n.reflectivity&&(o.reflectivity=n.reflectivity),void 0!==n.refractionRatio&&(o.refractionRatio=n.refractionRatio),void 0!==n.lightMap&&(o.lightMap=r(n.lightMap)),void 0!==n.lightMapIntensity&&(o.lightMapIntensity=n.lightMapIntensity),void 0!==n.aoMap&&(o.aoMap=r(n.aoMap)),void 0!==n.aoMapIntensity&&(o.aoMapIntensity=n.aoMapIntensity),void 0!==n.gradientMap&&(o.gradientMap=r(n.gradientMap)),void 0!==n.clearcoatMap&&(o.clearcoatMap=r(n.clearcoatMap)),void 0!==n.clearcoatRoughnessMap&&(o.clearcoatRoughnessMap=r(n.clearcoatRoughnessMap)),void 0!==n.clearcoatNormalMap&&(o.clearcoatNormalMap=r(n.clearcoatNormalMap)),void 0!==n.clearcoatNormalScale&&(o.clearcoatNormalScale=(new ir).fromArray(n.clearcoatNormalScale)),void 0!==n.iridescenceMap&&(o.iridescenceMap=r(n.iridescenceMap)),void 0!==n.iridescenceThicknessMap&&(o.iridescenceThicknessMap=r(n.iridescenceThicknessMap)),void 0!==n.transmissionMap&&(o.transmissionMap=r(n.transmissionMap)),void 0!==n.thicknessMap&&(o.thicknessMap=r(n.thicknessMap)),void 0!==n.sheenColorMap&&(o.sheenColorMap=r(n.sheenColorMap)),void 0!==n.sheenRoughnessMap&&(o.sheenRoughnessMap=r(n.sheenRoughnessMap)),o}},{key:"setTextures",value:function(n){return this.textures=n,this}}],[{key:"createMaterialFromType",value:function(n){return new{ShadowMaterial:yu,SpriteMaterial:Vc,RawShaderMaterial:bu,ShaderMaterial:Va,PointsMaterial:Ol,MeshPhysicalMaterial:Uu,MeshStandardMaterial:_u,MeshPhongMaterial:wu,MeshToonMaterial:Su,MeshNormalMaterial:ku,MeshLambertMaterial:Mu,MeshDepthMaterial:bc,MeshDistanceMaterial:_c,MeshBasicMaterial:Qo,MeshMatcapMaterial:zu,LineDashedMaterial:Cu,LineBasicMaterial:Ml,Material:Jo}[n]}}]),t}(nf),Df=function(){function n(){y(this,n)}return _(n,null,[{key:"decodeText",value:function(n){if("undefined"!==typeof TextDecoder)return(new TextDecoder).decode(n);for(var e="",t=0,r=n.length;t<r;t++)e+=String.fromCharCode(n[t]);try{return decodeURIComponent(escape(e))}catch(o){return e}}},{key:"extractUrlBase",value:function(n){var e=n.lastIndexOf("/");return-1===e?"./":n.slice(0,e+1)}},{key:"resolveURL",value:function(n,e){return"string"!==typeof n||""===n?"":(/^https?:\/\//i.test(e)&&/^\//.test(n)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(n)||/^data:.*,.*$/i.test(n)||/^blob:.*$/i.test(n)?n:e+n)}}]),n}(),Pf=function(n){U(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).isInstancedBufferGeometry=!0,n.type="InstancedBufferGeometry",n.instanceCount=1/0,n}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.instanceCount=n.instanceCount,this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"toJSON",value:function(){var n=P(w(t.prototype),"toJSON",this).call(this,this);return n.instanceCount=this.instanceCount,n.isInstancedBufferGeometry=!0,n}}]),t}(ba),jf=function(n){U(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return _(t,[{key:"load",value:function(n,e,t,r){var o=this,a=new rf(o.manager);a.setPath(o.path),a.setRequestHeader(o.requestHeader),a.setWithCredentials(o.withCredentials),a.load(n,(function(t){try{e(o.parse(JSON.parse(t)))}catch(a){r?r(a):console.error(a),o.manager.itemError(n)}}),t,r)}},{key:"parse",value:function(n){var e={},t={};function r(n,r){if(void 0!==e[r])return e[r];var o=n.interleavedBuffers[r],a=function(n,e){if(void 0!==t[e])return t[e];var r=n.arrayBuffers[e],o=new Uint32Array(r).buffer;return t[e]=o,o}(n,o.buffer),i=sr(o.type,a),v=new Gc(i,o.stride);return v.uuid=o.uuid,e[r]=v,v}var o=n.isInstancedBufferGeometry?new Pf:new ba,a=n.data.index;if(void 0!==a){var i=sr(a.type,a.array);o.setIndex(new ta(i,1))}var v=n.data.attributes;for(var c in v){var l=v[c],s=void 0;if(l.isInterleavedBufferAttribute){var u=r(n.data,l.data);s=new qc(u,l.itemSize,l.offset,l.normalized)}else{var f=sr(l.type,l.array);s=new(l.isInstancedBufferAttribute?yl:ta)(f,l.itemSize,l.normalized)}void 0!==l.name&&(s.name=l.name),void 0!==l.usage&&s.setUsage(l.usage),void 0!==l.updateRange&&(s.updateRange.offset=l.updateRange.offset,s.updateRange.count=l.updateRange.count),o.setAttribute(c,s)}var p=n.data.morphAttributes;if(p)for(var d in p){for(var m=p[d],h=[],x=0,g=m.length;x<g;x++){var y=m[x],b=void 0;if(y.isInterleavedBufferAttribute){var _=r(n.data,y.data);b=new qc(_,y.itemSize,y.offset,y.normalized)}else{var U=sr(y.type,y.array);b=new ta(U,y.itemSize,y.normalized)}void 0!==y.name&&(b.name=y.name),h.push(b)}o.morphAttributes[d]=h}n.data.morphTargetsRelative&&(o.morphTargetsRelative=!0);var w=n.data.groups||n.data.drawcalls||n.data.offsets;if(void 0!==w)for(var S=0,k=w.length;S!==k;++S){var M=w[S];o.addGroup(M.start,M.count,M.materialIndex)}var z=n.data.boundingSphere;if(void 0!==z){var C=new Or;void 0!==z.center&&C.fromArray(z.center),o.boundingSphere=new oo(C,z.radius)}return n.name&&(o.name=n.name),n.userData&&(o.userData=n.userData),o}}]),t}(nf),Ff=function(n){U(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return _(t,[{key:"load",value:function(n,e,t,r){var o=this,a=""===this.path?Df.extractUrlBase(n):this.path;this.resourcePath=this.resourcePath||a;var i=new rf(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(n,(function(t){var a=null;try{a=JSON.parse(t)}catch(v){return void 0!==r&&r(v),void console.error("THREE:ObjectLoader: Can't parse "+n+".",v.message)}var i=a.metadata;void 0!==i&&void 0!==i.type&&"geometry"!==i.type.toLowerCase()?o.parse(a,e):console.error("THREE.ObjectLoader: Can't load "+n)}),t,r)}},{key:"loadAsync",value:function(){var n=R(j().mark((function n(e,t){var r,o,a,i,v,c;return j().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return r=this,o=""===this.path?Df.extractUrlBase(e):this.path,this.resourcePath=this.resourcePath||o,(a=new rf(this.manager)).setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),n.next=9,a.loadAsync(e,t);case 9:if(i=n.sent,v=JSON.parse(i),void 0!==(c=v.metadata)&&void 0!==c.type&&"geometry"!==c.type.toLowerCase()){n.next=14;break}throw new Error("THREE.ObjectLoader: Can't load "+e);case 14:return n.next=16,r.parseAsync(v);case 16:return n.abrupt("return",n.sent);case 17:case"end":return n.stop()}}),n,this)})));return function(e,t){return n.apply(this,arguments)}}()},{key:"parse",value:function(n,e){var t=this.parseAnimations(n.animations),r=this.parseShapes(n.shapes),o=this.parseGeometries(n.geometries,r),a=this.parseImages(n.images,(function(){void 0!==e&&e(c)})),i=this.parseTextures(n.textures,a),v=this.parseMaterials(n.materials,i),c=this.parseObject(n.object,o,v,i,t),l=this.parseSkeletons(n.skeletons,c);if(this.bindSkeletons(c,l),void 0!==e){var s=!1;for(var u in a)if(a[u].data instanceof HTMLImageElement){s=!0;break}!1===s&&e(c)}return c}},{key:"parseAsync",value:function(){var n=R(j().mark((function n(e){var t,r,o,a,i,v,c,l;return j().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t=this.parseAnimations(e.animations),r=this.parseShapes(e.shapes),o=this.parseGeometries(e.geometries,r),n.next=5,this.parseImagesAsync(e.images);case 5:return a=n.sent,i=this.parseTextures(e.textures,a),v=this.parseMaterials(e.materials,i),c=this.parseObject(e.object,o,v,i,t),l=this.parseSkeletons(e.skeletons,c),this.bindSkeletons(c,l),n.abrupt("return",c);case 12:case"end":return n.stop()}}),n,this)})));return function(e){return n.apply(this,arguments)}}()},{key:"parseShapes",value:function(n){var e={};if(void 0!==n)for(var t=0,r=n.length;t<r;t++){var o=(new Ts).fromJSON(n[t]);e[o.uuid]=o}return e}},{key:"parseSkeletons",value:function(n,e){var t={},r={};if(e.traverse((function(n){n.isBone&&(r[n.uuid]=n)})),void 0!==n)for(var o=0,a=n.length;o<a;o++){var i=(new gl).fromJSON(n[o],r);t[i.uuid]=i}return t}},{key:"parseGeometries",value:function(n,e){var t={};if(void 0!==n)for(var r=new jf,o=0,a=n.length;o<a;o++){var i=void 0,v=n[o];switch(v.type){case"BufferGeometry":case"InstancedBufferGeometry":i=r.parse(v);break;default:v.type in gu?i=gu[v.type].fromJSON(v,e):console.warn('THREE.ObjectLoader: Unsupported geometry type "'.concat(v.type,'"'))}i.uuid=v.uuid,void 0!==v.name&&(i.name=v.name),!0===i.isBufferGeometry&&void 0!==v.userData&&(i.userData=v.userData),t[v.uuid]=i}return t}},{key:"parseMaterials",value:function(n,e){var t={},r={};if(void 0!==n){var o=new Rf;o.setTextures(e);for(var a=0,i=n.length;a<i;a++){var v=n[a];void 0===t[v.uuid]&&(t[v.uuid]=o.parse(v)),r[v.uuid]=t[v.uuid]}}return r}},{key:"parseAnimations",value:function(n){var e={};if(void 0!==n)for(var t=0;t<n.length;t++){var r=n[t],o=Yu.parse(r);e[o.uuid]=o}return e}},{key:"parseImages",value:function(n,e){var t,r=this,o={};function a(n){if("string"===typeof n){var e=n;return function(n){return r.manager.itemStart(n),t.load(n,(function(){r.manager.itemEnd(n)}),void 0,(function(){r.manager.itemError(n),r.manager.itemEnd(n)}))}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)?e:r.resourcePath+e)}return n.data?{data:sr(n.type,n.data),width:n.width,height:n.height}:null}if(void 0!==n&&n.length>0){var i=new Ju(e);(t=new vf(i)).setCrossOrigin(this.crossOrigin);for(var v=0,c=n.length;v<c;v++){var l=n[v],s=l.url;if(Array.isArray(s)){for(var u=[],f=0,p=s.length;f<p;f++){var d=a(s[f]);null!==d&&(d instanceof HTMLImageElement?u.push(d):u.push(new ml(d.data,d.width,d.height)))}o[l.uuid]=new kr(u)}else{var m=a(l.url);o[l.uuid]=new kr(m)}}}return o}},{key:"parseImagesAsync",value:function(){var n=R(j().mark((function n(e){var t,r,o,a,i,v,c,l,s,u,f,p,d,m,h;return j().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(i=function(){return i=R(j().mark((function n(e){var r,a;return j().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if("string"!==typeof e){n.next=8;break}return a=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(r=e)?r:t.resourcePath+r,n.next=5,o.loadAsync(a);case 5:return n.abrupt("return",n.sent);case 8:if(!e.data){n.next=12;break}return n.abrupt("return",{data:sr(e.type,e.data),width:e.width,height:e.height});case 12:return n.abrupt("return",null);case 13:case"end":return n.stop()}}),n)}))),i.apply(this,arguments)},a=function(n){return i.apply(this,arguments)},t=this,r={},!(void 0!==e&&e.length>0)){n.next=33;break}(o=new vf(this.manager)).setCrossOrigin(this.crossOrigin),v=0,c=e.length;case 8:if(!(v<c)){n.next=33;break}if(l=e[v],s=l.url,!Array.isArray(s)){n.next=26;break}u=[],f=0,p=s.length;case 14:if(!(f<p)){n.next=23;break}return d=s[f],n.next=18,a(d);case 18:null!==(m=n.sent)&&(m instanceof HTMLImageElement?u.push(m):u.push(new ml(m.data,m.width,m.height)));case 20:f++,n.next=14;break;case 23:r[l.uuid]=new kr(u),n.next=30;break;case 26:return n.next=28,a(l.url);case 28:h=n.sent,r[l.uuid]=new kr(h);case 30:v++,n.next=8;break;case 33:return n.abrupt("return",r);case 34:case"end":return n.stop()}}),n,this)})));return function(e){return n.apply(this,arguments)}}()},{key:"parseTextures",value:function(n,e){function t(n,e){return"number"===typeof n?n:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",n),e[n])}var r={};if(void 0!==n)for(var o=0,a=n.length;o<a;o++){var i=n[o];void 0===i.image&&console.warn('THREE.ObjectLoader: No "image" specified for',i.uuid),void 0===e[i.image]&&console.warn("THREE.ObjectLoader: Undefined image",i.image);var v=e[i.image],c=v.data,l=void 0;Array.isArray(c)?(l=new $a,6===c.length&&(l.needsUpdate=!0)):(l=c&&c.data?new ml:new Cr,c&&(l.needsUpdate=!0)),l.source=v,l.uuid=i.uuid,void 0!==i.name&&(l.name=i.name),void 0!==i.mapping&&(l.mapping=t(i.mapping,Ef)),void 0!==i.offset&&l.offset.fromArray(i.offset),void 0!==i.repeat&&l.repeat.fromArray(i.repeat),void 0!==i.center&&l.center.fromArray(i.center),void 0!==i.rotation&&(l.rotation=i.rotation),void 0!==i.wrap&&(l.wrapS=t(i.wrap[0],If),l.wrapT=t(i.wrap[1],If)),void 0!==i.format&&(l.format=i.format),void 0!==i.type&&(l.type=i.type),void 0!==i.encoding&&(l.encoding=i.encoding),void 0!==i.minFilter&&(l.minFilter=t(i.minFilter,Of)),void 0!==i.magFilter&&(l.magFilter=t(i.magFilter,Of)),void 0!==i.anisotropy&&(l.anisotropy=i.anisotropy),void 0!==i.flipY&&(l.flipY=i.flipY),void 0!==i.premultiplyAlpha&&(l.premultiplyAlpha=i.premultiplyAlpha),void 0!==i.unpackAlignment&&(l.unpackAlignment=i.unpackAlignment),void 0!==i.userData&&(l.userData=i.userData),r[i.uuid]=l}return r}},{key:"parseObject",value:function(n,e,t,r,o){var a,i,v;function c(n){return void 0===e[n]&&console.warn("THREE.ObjectLoader: Undefined geometry",n),e[n]}function l(n){if(void 0!==n){if(Array.isArray(n)){for(var e=[],r=0,o=n.length;r<o;r++){var a=n[r];void 0===t[a]&&console.warn("THREE.ObjectLoader: Undefined material",a),e.push(t[a])}return e}return void 0===t[n]&&console.warn("THREE.ObjectLoader: Undefined material",n),t[n]}}function s(n){return void 0===r[n]&&console.warn("THREE.ObjectLoader: Undefined texture",n),r[n]}switch(n.type){case"Scene":a=new Nc,void 0!==n.background&&(Number.isInteger(n.background)?a.background=new wr(n.background):a.background=s(n.background)),void 0!==n.environment&&(a.environment=s(n.environment)),void 0!==n.fog&&("Fog"===n.fog.type?a.fog=new Ac(n.fog.color,n.fog.near,n.fog.far):"FogExp2"===n.fog.type&&(a.fog=new Lc(n.fog.color,n.fog.density))),void 0!==n.backgroundBlurriness&&(a.backgroundBlurriness=n.backgroundBlurriness);break;case"PerspectiveCamera":a=new Ha(n.fov,n.aspect,n.near,n.far),void 0!==n.focus&&(a.focus=n.focus),void 0!==n.zoom&&(a.zoom=n.zoom),void 0!==n.filmGauge&&(a.filmGauge=n.filmGauge),void 0!==n.filmOffset&&(a.filmOffset=n.filmOffset),void 0!==n.view&&(a.view=Object.assign({},n.view));break;case"OrthographicCamera":a=new hi(n.left,n.right,n.top,n.bottom,n.near,n.far),void 0!==n.zoom&&(a.zoom=n.zoom),void 0!==n.view&&(a.view=Object.assign({},n.view));break;case"AmbientLight":a=new Mf(n.color,n.intensity);break;case"DirectionalLight":a=new kf(n.color,n.intensity);break;case"PointLight":a=new wf(n.color,n.intensity,n.distance,n.decay);break;case"RectAreaLight":a=new zf(n.color,n.intensity,n.width,n.height);break;case"SpotLight":a=new gf(n.color,n.intensity,n.distance,n.angle,n.penumbra,n.decay);break;case"HemisphereLight":a=new ff(n.color,n.groundColor,n.intensity);break;case"LightProbe":a=(new Tf).fromJSON(n);break;case"SkinnedMesh":i=c(n.geometry),v=l(n.material),a=new pl(i,v),void 0!==n.bindMode&&(a.bindMode=n.bindMode),void 0!==n.bindMatrix&&a.bindMatrix.fromArray(n.bindMatrix),void 0!==n.skeleton&&(a.skeleton=n.skeleton);break;case"Mesh":i=c(n.geometry),v=l(n.material),a=new La(i,v);break;case"InstancedMesh":i=c(n.geometry),v=l(n.material);var u=n.count,f=n.instanceMatrix,p=n.instanceColor;(a=new kl(i,v,u)).instanceMatrix=new yl(new Float32Array(f.array),16),void 0!==p&&(a.instanceColor=new yl(new Float32Array(p.array),p.itemSize));break;case"LOD":a=new vl;break;case"Line":a=new Pl(c(n.geometry),l(n.material));break;case"LineLoop":a=new Il(c(n.geometry),l(n.material));break;case"LineSegments":a=new El(c(n.geometry),l(n.material));break;case"PointCloud":case"Points":a=new Bl(c(n.geometry),l(n.material));break;case"Sprite":a=new rl(l(n.material));break;case"Group":a=new zc;break;case"Bone":a=new dl;break;default:a=new Ao}if(a.uuid=n.uuid,void 0!==n.name&&(a.name=n.name),void 0!==n.matrix?(a.matrix.fromArray(n.matrix),void 0!==n.matrixAutoUpdate&&(a.matrixAutoUpdate=n.matrixAutoUpdate),a.matrixAutoUpdate&&a.matrix.decompose(a.position,a.quaternion,a.scale)):(void 0!==n.position&&a.position.fromArray(n.position),void 0!==n.rotation&&a.rotation.fromArray(n.rotation),void 0!==n.quaternion&&a.quaternion.fromArray(n.quaternion),void 0!==n.scale&&a.scale.fromArray(n.scale)),void 0!==n.castShadow&&(a.castShadow=n.castShadow),void 0!==n.receiveShadow&&(a.receiveShadow=n.receiveShadow),n.shadow&&(void 0!==n.shadow.bias&&(a.shadow.bias=n.shadow.bias),void 0!==n.shadow.normalBias&&(a.shadow.normalBias=n.shadow.normalBias),void 0!==n.shadow.radius&&(a.shadow.radius=n.shadow.radius),void 0!==n.shadow.mapSize&&a.shadow.mapSize.fromArray(n.shadow.mapSize),void 0!==n.shadow.camera&&(a.shadow.camera=this.parseObject(n.shadow.camera))),void 0!==n.visible&&(a.visible=n.visible),void 0!==n.frustumCulled&&(a.frustumCulled=n.frustumCulled),void 0!==n.renderOrder&&(a.renderOrder=n.renderOrder),void 0!==n.userData&&(a.userData=n.userData),void 0!==n.layers&&(a.layers.mask=n.layers),void 0!==n.children)for(var d=n.children,m=0;m<d.length;m++)a.add(this.parseObject(d[m],e,t,r,o));if(void 0!==n.animations)for(var h=n.animations,x=0;x<h.length;x++){var g=h[x];a.animations.push(o[g])}if("LOD"===n.type){void 0!==n.autoUpdate&&(a.autoUpdate=n.autoUpdate);for(var y=n.levels,b=0;b<y.length;b++){var _=y[b],U=a.getObjectByProperty("uuid",_.object);void 0!==U&&a.addLevel(U,_.distance)}}return a}},{key:"bindSkeletons",value:function(n,e){0!==Object.keys(e).length&&n.traverse((function(n){if(!0===n.isSkinnedMesh&&void 0!==n.skeleton){var t=e[n.skeleton];void 0===t?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",n.skeleton):n.bind(t,n.bindMatrix)}}))}}]),t}(nf),Ef={UVMapping:Fn,CubeReflectionMapping:En,CubeRefractionMapping:In,EquirectangularReflectionMapping:On,EquirectangularRefractionMapping:Ln,CubeUVReflectionMapping:An},If={RepeatWrapping:Nn,ClampToEdgeWrapping:Gn,MirroredRepeatWrapping:Bn},Of={NearestFilter:qn,NearestMipmapNearestFilter:Vn,NearestMipmapLinearFilter:Hn,LinearFilter:Yn,LinearMipmapNearestFilter:$n,LinearMipmapLinearFilter:Kn},Lf=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this,n)).isImageBitmapLoader=!0,"undefined"===typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"===typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),r.options={premultiplyAlpha:"none"},r}return _(t,[{key:"setOptions",value:function(n){return this.options=n,this}},{key:"load",value:function(n,e,t,r){void 0===n&&(n=""),void 0!==this.path&&(n=this.path+n),n=this.manager.resolveURL(n);var o=this,a=Ku.get(n);if(void 0!==a)return o.manager.itemStart(n),setTimeout((function(){e&&e(a),o.manager.itemEnd(n)}),0),a;var i={};i.credentials="anonymous"===this.crossOrigin?"same-origin":"include",i.headers=this.requestHeader,fetch(n,i).then((function(n){return n.blob()})).then((function(n){return createImageBitmap(n,Object.assign(o.options,{colorSpaceConversion:"none"}))})).then((function(t){Ku.add(n,t),e&&e(t),o.manager.itemEnd(n)})).catch((function(e){r&&r(e),o.manager.itemError(n),o.manager.itemEnd(n)})),o.manager.itemStart(n)}}]),t}(nf),Af=function(){function n(){y(this,n)}return _(n,null,[{key:"getContext",value:function(){return void 0===Zu&&(Zu=new(window.AudioContext||window.webkitAudioContext)),Zu}},{key:"setContext",value:function(n){Zu=n}}]),n}(),Nf=function(n){U(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return _(t,[{key:"load",value:function(n,e,t,r){var o=this,a=new rf(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(n,(function(t){try{var a=t.slice(0);Af.getContext().decodeAudioData(a,(function(n){e(n)}))}catch(i){r?r(i):console.error(i),o.manager.itemError(n)}}),t,r)}}]),t}(nf),Gf=function(n){U(t,n);var e=z(t);function t(n,r){var o,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;y(this,t),(o=e.call(this,void 0,a)).isHemisphereLightProbe=!0;var i=(new wr).set(n),v=(new wr).set(r),c=new Or(i.r,i.g,i.b),l=new Or(v.r,v.g,v.b),s=Math.sqrt(Math.PI),u=s*Math.sqrt(.75);return o.sh.coefficients[0].copy(c).add(l).multiplyScalar(s),o.sh.coefficients[1].copy(c).sub(l).multiplyScalar(u),o}return _(t)}(Tf),Bf=function(n){U(t,n);var e=z(t);function t(n){var r,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;y(this,t),(r=e.call(this,void 0,o)).isAmbientLightProbe=!0;var a=(new wr).set(n);return r.sh.coefficients[0].set(a.r,a.g,a.b).multiplyScalar(2*Math.sqrt(Math.PI)),r}return _(t)}(Tf),qf=new po,Vf=new po,Wf=new po,Hf=function(){function n(){y(this,n),this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Ha,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Ha,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}return _(n,[{key:"update",value:function(n){var e=this._cache;if(e.focus!==n.focus||e.fov!==n.fov||e.aspect!==n.aspect*this.aspect||e.near!==n.near||e.far!==n.far||e.zoom!==n.zoom||e.eyeSep!==this.eyeSep){e.focus=n.focus,e.fov=n.fov,e.aspect=n.aspect*this.aspect,e.near=n.near,e.far=n.far,e.zoom=n.zoom,e.eyeSep=this.eyeSep,Wf.copy(n.projectionMatrix);var t,r,o=e.eyeSep/2,a=o*e.near/e.focus,i=e.near*Math.tan(Yt*e.fov*.5)/e.zoom;Vf.elements[12]=-o,qf.elements[12]=o,t=-i*e.aspect+a,r=i*e.aspect+a,Wf.elements[0]=2*e.near/(r-t),Wf.elements[8]=(r+t)/(r-t),this.cameraL.projectionMatrix.copy(Wf),t=-i*e.aspect-a,r=i*e.aspect-a,Wf.elements[0]=2*e.near/(r-t),Wf.elements[8]=(r+t)/(r-t),this.cameraR.projectionMatrix.copy(Wf)}this.cameraL.matrixWorld.copy(n.matrixWorld).multiply(Vf),this.cameraR.matrixWorld.copy(n.matrixWorld).multiply(qf)}}]),n}(),Xf=function(){function n(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];y(this,n),this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}return _(n,[{key:"start",value:function(){this.startTime=Yf(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}},{key:"stop",value:function(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}},{key:"getElapsedTime",value:function(){return this.getDelta(),this.elapsedTime}},{key:"getDelta",value:function(){var n=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){var e=Yf();n=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=n}return n}}]),n}();function Yf(){return("undefined"===typeof performance?Date:performance).now()}var $f=new Or,Zf=new Ir,Kf=new Or,Jf=new Or,Qf=function(n){U(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).type="AudioListener",n.context=Af.getContext(),n.gain=n.context.createGain(),n.gain.connect(n.context.destination),n.filter=null,n.timeDelta=0,n._clock=new Xf,n}return _(t,[{key:"getInput",value:function(){return this.gain}},{key:"removeFilter",value:function(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}},{key:"getFilter",value:function(){return this.filter}},{key:"setFilter",value:function(n){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=n,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}},{key:"getMasterVolume",value:function(){return this.gain.gain.value}},{key:"setMasterVolume",value:function(n){return this.gain.gain.setTargetAtTime(n,this.context.currentTime,.01),this}},{key:"updateMatrixWorld",value:function(n){P(w(t.prototype),"updateMatrixWorld",this).call(this,n);var e=this.context.listener,r=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose($f,Zf,Kf),Jf.set(0,0,-1).applyQuaternion(Zf),e.positionX){var o=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime($f.x,o),e.positionY.linearRampToValueAtTime($f.y,o),e.positionZ.linearRampToValueAtTime($f.z,o),e.forwardX.linearRampToValueAtTime(Jf.x,o),e.forwardY.linearRampToValueAtTime(Jf.y,o),e.forwardZ.linearRampToValueAtTime(Jf.z,o),e.upX.linearRampToValueAtTime(r.x,o),e.upY.linearRampToValueAtTime(r.y,o),e.upZ.linearRampToValueAtTime(r.z,o)}else e.setPosition($f.x,$f.y,$f.z),e.setOrientation(Jf.x,Jf.y,Jf.z,r.x,r.y,r.z)}}]),t}(Ao),np=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this)).type="Audio",r.listener=n,r.context=n.context,r.gain=r.context.createGain(),r.gain.connect(n.getInput()),r.autoplay=!1,r.buffer=null,r.detune=0,r.loop=!1,r.loopStart=0,r.loopEnd=0,r.offset=0,r.duration=void 0,r.playbackRate=1,r.isPlaying=!1,r.hasPlaybackControl=!0,r.source=null,r.sourceType="empty",r._startedAt=0,r._progress=0,r._connected=!1,r.filters=[],r}return _(t,[{key:"getOutput",value:function(){return this.gain}},{key:"setNodeSource",value:function(n){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=n,this.connect(),this}},{key:"setMediaElementSource",value:function(n){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(n),this.connect(),this}},{key:"setMediaStreamSource",value:function(n){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(n),this.connect(),this}},{key:"setBuffer",value:function(n){return this.buffer=n,this.sourceType="buffer",this.autoplay&&this.play(),this}},{key:"play",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;if(!0!==this.isPlaying){if(!1!==this.hasPlaybackControl){this._startedAt=this.context.currentTime+n;var e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}console.warn("THREE.Audio: this Audio has no playback control.")}else console.warn("THREE.Audio: Audio is already playing.")}},{key:"pause",value:function(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}},{key:"stop",value:function(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}},{key:"connect",value:function(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(var n=1,e=this.filters.length;n<e;n++)this.filters[n-1].connect(this.filters[n]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}},{key:"disconnect",value:function(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(var n=1,e=this.filters.length;n<e;n++)this.filters[n-1].disconnect(this.filters[n]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}},{key:"getFilters",value:function(){return this.filters}},{key:"setFilters",value:function(n){return n||(n=[]),!0===this._connected?(this.disconnect(),this.filters=n.slice(),this.connect()):this.filters=n.slice(),this}},{key:"setDetune",value:function(n){if(this.detune=n,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}},{key:"getDetune",value:function(){return this.detune}},{key:"getFilter",value:function(){return this.getFilters()[0]}},{key:"setFilter",value:function(n){return this.setFilters(n?[n]:[])}},{key:"setPlaybackRate",value:function(n){if(!1!==this.hasPlaybackControl)return this.playbackRate=n,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}},{key:"getPlaybackRate",value:function(){return this.playbackRate}},{key:"onEnded",value:function(){this.isPlaying=!1}},{key:"getLoop",value:function(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}},{key:"setLoop",value:function(n){if(!1!==this.hasPlaybackControl)return this.loop=n,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}},{key:"setLoopStart",value:function(n){return this.loopStart=n,this}},{key:"setLoopEnd",value:function(n){return this.loopEnd=n,this}},{key:"getVolume",value:function(){return this.gain.gain.value}},{key:"setVolume",value:function(n){return this.gain.gain.setTargetAtTime(n,this.context.currentTime,.01),this}}]),t}(Ao),ep=new Or,tp=new Ir,rp=new Or,op=new Or,ap=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this,n)).panner=r.context.createPanner(),r.panner.panningModel="HRTF",r.panner.connect(r.gain),r}return _(t,[{key:"disconnect",value:function(){P(w(t.prototype),"disconnect",this).call(this),this.panner.disconnect(this.gain)}},{key:"getOutput",value:function(){return this.panner}},{key:"getRefDistance",value:function(){return this.panner.refDistance}},{key:"setRefDistance",value:function(n){return this.panner.refDistance=n,this}},{key:"getRolloffFactor",value:function(){return this.panner.rolloffFactor}},{key:"setRolloffFactor",value:function(n){return this.panner.rolloffFactor=n,this}},{key:"getDistanceModel",value:function(){return this.panner.distanceModel}},{key:"setDistanceModel",value:function(n){return this.panner.distanceModel=n,this}},{key:"getMaxDistance",value:function(){return this.panner.maxDistance}},{key:"setMaxDistance",value:function(n){return this.panner.maxDistance=n,this}},{key:"setDirectionalCone",value:function(n,e,t){return this.panner.coneInnerAngle=n,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=t,this}},{key:"updateMatrixWorld",value:function(n){if(P(w(t.prototype),"updateMatrixWorld",this).call(this,n),!0!==this.hasPlaybackControl||!1!==this.isPlaying){this.matrixWorld.decompose(ep,tp,rp),op.set(0,0,1).applyQuaternion(tp);var e=this.panner;if(e.positionX){var r=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(ep.x,r),e.positionY.linearRampToValueAtTime(ep.y,r),e.positionZ.linearRampToValueAtTime(ep.z,r),e.orientationX.linearRampToValueAtTime(op.x,r),e.orientationY.linearRampToValueAtTime(op.y,r),e.orientationZ.linearRampToValueAtTime(op.z,r)}else e.setPosition(ep.x,ep.y,ep.z),e.setOrientation(op.x,op.y,op.z)}}}]),t}(np),ip=function(){function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2048;y(this,n),this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}return _(n,[{key:"getFrequencyData",value:function(){return this.analyser.getByteFrequencyData(this.data),this.data}},{key:"getAverageFrequency",value:function(){for(var n=0,e=this.getFrequencyData(),t=0;t<e.length;t++)n+=e[t];return n/e.length}}]),n}(),vp=function(){function n(e,t,r){var o,a,i;switch(y(this,n),this.binding=e,this.valueSize=r,t){case"quaternion":o=this._slerp,a=this._slerpAdditive,i=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*r),this._workIndex=5;break;case"string":case"bool":o=this._select,a=this._select,i=this._setAdditiveIdentityOther,this.buffer=new Array(5*r);break;default:o=this._lerp,a=this._lerpAdditive,i=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*r)}this._mixBufferRegion=o,this._mixBufferRegionAdditive=a,this._setIdentity=i,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}return _(n,[{key:"accumulate",value:function(n,e){var t=this.buffer,r=this.valueSize,o=n*r+r,a=this.cumulativeWeight;if(0===a){for(var i=0;i!==r;++i)t[o+i]=t[i];a=e}else{var v=e/(a+=e);this._mixBufferRegion(t,o,0,v,r)}this.cumulativeWeight=a}},{key:"accumulateAdditive",value:function(n){var e=this.buffer,t=this.valueSize,r=t*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,r,0,n,t),this.cumulativeWeightAdditive+=n}},{key:"apply",value:function(n){var e=this.valueSize,t=this.buffer,r=n*e+e,o=this.cumulativeWeight,a=this.cumulativeWeightAdditive,i=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,o<1){var v=e*this._origIndex;this._mixBufferRegion(t,r,v,1-o,e)}a>0&&this._mixBufferRegionAdditive(t,r,this._addIndex*e,1,e);for(var c=e,l=e+e;c!==l;++c)if(t[c]!==t[c+e]){i.setValue(t,r);break}}},{key:"saveOriginalState",value:function(){var n=this.binding,e=this.buffer,t=this.valueSize,r=t*this._origIndex;n.getValue(e,r);for(var o=t,a=r;o!==a;++o)e[o]=e[r+o%t];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}},{key:"restoreOriginalState",value:function(){var n=3*this.valueSize;this.binding.setValue(this.buffer,n)}},{key:"_setAdditiveIdentityNumeric",value:function(){for(var n=this._addIndex*this.valueSize,e=n+this.valueSize,t=n;t<e;t++)this.buffer[t]=0}},{key:"_setAdditiveIdentityQuaternion",value:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}},{key:"_setAdditiveIdentityOther",value:function(){for(var n=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize,t=0;t<this.valueSize;t++)this.buffer[e+t]=this.buffer[n+t]}},{key:"_select",value:function(n,e,t,r,o){if(r>=.5)for(var a=0;a!==o;++a)n[e+a]=n[t+a]}},{key:"_slerp",value:function(n,e,t,r){Ir.slerpFlat(n,e,n,e,n,t,r)}},{key:"_slerpAdditive",value:function(n,e,t,r,o){var a=this._workIndex*o;Ir.multiplyQuaternionsFlat(n,a,n,e,n,t),Ir.slerpFlat(n,e,n,e,n,a,r)}},{key:"_lerp",value:function(n,e,t,r,o){for(var a=1-r,i=0;i!==o;++i){var v=e+i;n[v]=n[v]*a+n[t+i]*r}}},{key:"_lerpAdditive",value:function(n,e,t,r,o){for(var a=0;a!==o;++a){var i=e+a;n[i]=n[i]+n[t+a]*r}}}]),n}(),cp="\\[\\]\\.:\\/",lp=new RegExp("[\\[\\]\\.:\\/]","g"),sp="[^\\[\\]\\.:\\/]",up="[^"+cp.replace("\\.","")+"]",fp=new RegExp("^"+/((?:WC+[\/:])*)/.source.replace("WC",sp)+/(WCOD+)?/.source.replace("WCOD",up)+/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",sp)+/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",sp)+"$"),pp=["material","materials","bones","map"],dp=function(){function n(e,t,r){y(this,n);var o=r||mp.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,o)}return _(n,[{key:"getValue",value:function(n,e){this.bind();var t=this._targetGroup.nCachedObjects_,r=this._bindings[t];void 0!==r&&r.getValue(n,e)}},{key:"setValue",value:function(n,e){for(var t=this._bindings,r=this._targetGroup.nCachedObjects_,o=t.length;r!==o;++r)t[r].setValue(n,e)}},{key:"bind",value:function(){for(var n=this._bindings,e=this._targetGroup.nCachedObjects_,t=n.length;e!==t;++e)n[e].bind()}},{key:"unbind",value:function(){for(var n=this._bindings,e=this._targetGroup.nCachedObjects_,t=n.length;e!==t;++e)n[e].unbind()}}]),n}(),mp=function(){function n(e,t,r){y(this,n),this.path=t,this.parsedPath=r||n.parseTrackName(t),this.node=n.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}return _(n,[{key:"_getValue_unavailable",value:function(){}},{key:"_setValue_unavailable",value:function(){}},{key:"_getValue_direct",value:function(n,e){n[e]=this.targetObject[this.propertyName]}},{key:"_getValue_array",value:function(n,e){for(var t=this.resolvedProperty,r=0,o=t.length;r!==o;++r)n[e++]=t[r]}},{key:"_getValue_arrayElement",value:function(n,e){n[e]=this.resolvedProperty[this.propertyIndex]}},{key:"_getValue_toArray",value:function(n,e){this.resolvedProperty.toArray(n,e)}},{key:"_setValue_direct",value:function(n,e){this.targetObject[this.propertyName]=n[e]}},{key:"_setValue_direct_setNeedsUpdate",value:function(n,e){this.targetObject[this.propertyName]=n[e],this.targetObject.needsUpdate=!0}},{key:"_setValue_direct_setMatrixWorldNeedsUpdate",value:function(n,e){this.targetObject[this.propertyName]=n[e],this.targetObject.matrixWorldNeedsUpdate=!0}},{key:"_setValue_array",value:function(n,e){for(var t=this.resolvedProperty,r=0,o=t.length;r!==o;++r)t[r]=n[e++]}},{key:"_setValue_array_setNeedsUpdate",value:function(n,e){for(var t=this.resolvedProperty,r=0,o=t.length;r!==o;++r)t[r]=n[e++];this.targetObject.needsUpdate=!0}},{key:"_setValue_array_setMatrixWorldNeedsUpdate",value:function(n,e){for(var t=this.resolvedProperty,r=0,o=t.length;r!==o;++r)t[r]=n[e++];this.targetObject.matrixWorldNeedsUpdate=!0}},{key:"_setValue_arrayElement",value:function(n,e){this.resolvedProperty[this.propertyIndex]=n[e]}},{key:"_setValue_arrayElement_setNeedsUpdate",value:function(n,e){this.resolvedProperty[this.propertyIndex]=n[e],this.targetObject.needsUpdate=!0}},{key:"_setValue_arrayElement_setMatrixWorldNeedsUpdate",value:function(n,e){this.resolvedProperty[this.propertyIndex]=n[e],this.targetObject.matrixWorldNeedsUpdate=!0}},{key:"_setValue_fromArray",value:function(n,e){this.resolvedProperty.fromArray(n,e)}},{key:"_setValue_fromArray_setNeedsUpdate",value:function(n,e){this.resolvedProperty.fromArray(n,e),this.targetObject.needsUpdate=!0}},{key:"_setValue_fromArray_setMatrixWorldNeedsUpdate",value:function(n,e){this.resolvedProperty.fromArray(n,e),this.targetObject.matrixWorldNeedsUpdate=!0}},{key:"_getValue_unbound",value:function(n,e){this.bind(),this.getValue(n,e)}},{key:"_setValue_unbound",value:function(n,e){this.bind(),this.setValue(n,e)}},{key:"bind",value:function(){var e=this.node,t=this.parsedPath,r=t.objectName,o=t.propertyName,a=t.propertyIndex;if(e||(e=n.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,e){if(r){var i=t.objectIndex;switch(r){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(var v=0;v<e.length;v++)if(e[v].name===i){i=v;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.map)return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);e=e.material.map;break;default:if(void 0===e[r])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[r]}if(void 0!==i){if(void 0===e[i])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[i]}}var c=e[o];if(void 0!==c){var l=this.Versioning.None;this.targetObject=e,void 0!==e.needsUpdate?l=this.Versioning.NeedsUpdate:void 0!==e.matrixWorldNeedsUpdate&&(l=this.Versioning.MatrixWorldNeedsUpdate);var s=this.BindingType.Direct;if(void 0!==a){if("morphTargetInfluences"===o){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==e.morphTargetDictionary[a]&&(a=e.morphTargetDictionary[a])}s=this.BindingType.ArrayElement,this.resolvedProperty=c,this.propertyIndex=a}else void 0!==c.fromArray&&void 0!==c.toArray?(s=this.BindingType.HasFromToArray,this.resolvedProperty=c):Array.isArray(c)?(s=this.BindingType.EntireArray,this.resolvedProperty=c):this.propertyName=o;this.getValue=this.GetterByBindingType[s],this.setValue=this.SetterByBindingTypeAndVersioning[s][l]}else{var u=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+u+"."+o+" but it wasn't found.",e)}}else console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.")}},{key:"unbind",value:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}],[{key:"create",value:function(e,t,r){return e&&e.isAnimationObjectGroup?new n.Composite(e,t,r):new n(e,t,r)}},{key:"sanitizeNodeName",value:function(n){return n.replace(/\s/g,"_").replace(lp,"")}},{key:"parseTrackName",value:function(n){var e=fp.exec(n);if(null===e)throw new Error("PropertyBinding: Cannot parse trackName: "+n);var t={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},r=t.nodeName&&t.nodeName.lastIndexOf(".");if(void 0!==r&&-1!==r){var o=t.nodeName.substring(r+1);-1!==pp.indexOf(o)&&(t.nodeName=t.nodeName.substring(0,r),t.objectName=o)}if(null===t.propertyName||0===t.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+n);return t}},{key:"findNode",value:function(n,e){if(void 0===e||""===e||"."===e||-1===e||e===n.name||e===n.uuid)return n;if(n.skeleton){var t=n.skeleton.getBoneByName(e);if(void 0!==t)return t}if(n.children){var r=function n(t){for(var r=0;r<t.length;r++){var o=t[r];if(o.name===e||o.uuid===e)return o;var a=n(o.children);if(a)return a}return null}(n.children);if(r)return r}return null}}]),n}();mp.Composite=dp,mp.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},mp.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},mp.prototype.GetterByBindingType=[mp.prototype._getValue_direct,mp.prototype._getValue_array,mp.prototype._getValue_arrayElement,mp.prototype._getValue_toArray],mp.prototype.SetterByBindingTypeAndVersioning=[[mp.prototype._setValue_direct,mp.prototype._setValue_direct_setNeedsUpdate,mp.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[mp.prototype._setValue_array,mp.prototype._setValue_array_setNeedsUpdate,mp.prototype._setValue_array_setMatrixWorldNeedsUpdate],[mp.prototype._setValue_arrayElement,mp.prototype._setValue_arrayElement_setNeedsUpdate,mp.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[mp.prototype._setValue_fromArray,mp.prototype._setValue_fromArray_setNeedsUpdate,mp.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];var hp=function(){function n(){y(this,n),this.isAnimationObjectGroup=!0,this.uuid=Zt(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;var e={};this._indicesByUUID=e;for(var t=0,r=arguments.length;t!==r;++t)e[arguments[t].uuid]=t;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};var o=this;this.stats={objects:{get total(){return o._objects.length},get inUse(){return this.total-o.nCachedObjects_}},get bindingsPerObject(){return o._bindings.length}}}return _(n,[{key:"add",value:function(){for(var n=this._objects,e=this._indicesByUUID,t=this._paths,r=this._parsedPaths,o=this._bindings,a=o.length,i=void 0,v=n.length,c=this.nCachedObjects_,l=0,s=arguments.length;l!==s;++l){var u=arguments[l],f=u.uuid,p=e[f];if(void 0===p){p=v++,e[f]=p,n.push(u);for(var d=0,m=a;d!==m;++d)o[d].push(new mp(u,t[d],r[d]))}else if(p<c){i=n[p];var h=--c,x=n[h];e[x.uuid]=p,n[p]=x,e[f]=h,n[h]=u;for(var g=0,y=a;g!==y;++g){var b=o[g],_=b[h],U=b[p];b[p]=_,void 0===U&&(U=new mp(u,t[g],r[g])),b[h]=U}}else n[p]!==i&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c}},{key:"remove",value:function(){for(var n=this._objects,e=this._indicesByUUID,t=this._bindings,r=t.length,o=this.nCachedObjects_,a=0,i=arguments.length;a!==i;++a){var v=arguments[a],c=v.uuid,l=e[c];if(void 0!==l&&l>=o){var s=o++,u=n[s];e[u.uuid]=l,n[l]=u,e[c]=s,n[s]=v;for(var f=0,p=r;f!==p;++f){var d=t[f],m=d[s],h=d[l];d[l]=m,d[s]=h}}}this.nCachedObjects_=o}},{key:"uncache",value:function(){for(var n=this._objects,e=this._indicesByUUID,t=this._bindings,r=t.length,o=this.nCachedObjects_,a=n.length,i=0,v=arguments.length;i!==v;++i){var c=arguments[i],l=c.uuid,s=e[l];if(void 0!==s)if(delete e[l],s<o){var u=--o,f=n[u],p=--a,d=n[p];e[f.uuid]=s,n[s]=f,e[d.uuid]=u,n[u]=d,n.pop();for(var m=0,h=r;m!==h;++m){var x=t[m],g=x[u],y=x[p];x[s]=g,x[u]=y,x.pop()}}else{var b=--a,_=n[b];b>0&&(e[_.uuid]=s),n[s]=_,n.pop();for(var U=0,w=r;U!==w;++U){var S=t[U];S[s]=S[b],S.pop()}}}this.nCachedObjects_=o}},{key:"subscribe_",value:function(n,e){var t=this._bindingsIndicesByPath,r=t[n],o=this._bindings;if(void 0!==r)return o[r];var a=this._paths,i=this._parsedPaths,v=this._objects,c=v.length,l=this.nCachedObjects_,s=new Array(c);r=o.length,t[n]=r,a.push(n),i.push(e),o.push(s);for(var u=l,f=v.length;u!==f;++u){var p=v[u];s[u]=new mp(p,n,e)}return s}},{key:"unsubscribe_",value:function(n){var e=this._bindingsIndicesByPath,t=e[n];if(void 0!==t){var r=this._paths,o=this._parsedPaths,a=this._bindings,i=a.length-1,v=a[i];e[n[i]]=t,a[t]=v,a.pop(),o[t]=o[i],o.pop(),r[t]=r[i],r.pop()}}}]),n}(),xp=function(){function n(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t.blendMode;y(this,n),this._mixer=e,this._clip=t,this._localRoot=r,this.blendMode=o;for(var a=t.tracks,i=a.length,v=new Array(i),c={endingStart:nt,endingEnd:nt},l=0;l!==i;++l){var s=a[l].createInterpolant(null);v[l]=s,s.settings=c}this._interpolantSettings=c,this._interpolants=v,this._propertyBindings=new Array(i),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=$e,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}return _(n,[{key:"play",value:function(){return this._mixer._activateAction(this),this}},{key:"stop",value:function(){return this._mixer._deactivateAction(this),this.reset()}},{key:"reset",value:function(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}},{key:"isRunning",value:function(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}},{key:"isScheduled",value:function(){return this._mixer._isActiveAction(this)}},{key:"startAt",value:function(n){return this._startTime=n,this}},{key:"setLoop",value:function(n,e){return this.loop=n,this.repetitions=e,this}},{key:"setEffectiveWeight",value:function(n){return this.weight=n,this._effectiveWeight=this.enabled?n:0,this.stopFading()}},{key:"getEffectiveWeight",value:function(){return this._effectiveWeight}},{key:"fadeIn",value:function(n){return this._scheduleFading(n,0,1)}},{key:"fadeOut",value:function(n){return this._scheduleFading(n,1,0)}},{key:"crossFadeFrom",value:function(n,e,t){if(n.fadeOut(e),this.fadeIn(e),t){var r=this._clip.duration,o=n._clip.duration,a=o/r,i=r/o;n.warp(1,a,e),this.warp(i,1,e)}return this}},{key:"crossFadeTo",value:function(n,e,t){return n.crossFadeFrom(this,e,t)}},{key:"stopFading",value:function(){var n=this._weightInterpolant;return null!==n&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(n)),this}},{key:"setEffectiveTimeScale",value:function(n){return this.timeScale=n,this._effectiveTimeScale=this.paused?0:n,this.stopWarping()}},{key:"getEffectiveTimeScale",value:function(){return this._effectiveTimeScale}},{key:"setDuration",value:function(n){return this.timeScale=this._clip.duration/n,this.stopWarping()}},{key:"syncWith",value:function(n){return this.time=n.time,this.timeScale=n.timeScale,this.stopWarping()}},{key:"halt",value:function(n){return this.warp(this._effectiveTimeScale,0,n)}},{key:"warp",value:function(n,e,t){var r=this._mixer,o=r.time,a=this.timeScale,i=this._timeScaleInterpolant;null===i&&(i=r._lendControlInterpolant(),this._timeScaleInterpolant=i);var v=i.parameterPositions,c=i.sampleValues;return v[0]=o,v[1]=o+t,c[0]=n/a,c[1]=e/a,this}},{key:"stopWarping",value:function(){var n=this._timeScaleInterpolant;return null!==n&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(n)),this}},{key:"getMixer",value:function(){return this._mixer}},{key:"getClip",value:function(){return this._clip}},{key:"getRoot",value:function(){return this._localRoot||this._mixer._root}},{key:"_update",value:function(n,e,t,r){if(this.enabled){var o=this._startTime;if(null!==o){var a=(n-o)*t;a<0||0===t?e=0:(this._startTime=null,e=t*a)}e*=this._updateTimeScale(n);var i=this._updateTime(e),v=this._updateWeight(n);if(v>0){var c=this._interpolants,l=this._propertyBindings;if(this.blendMode===ot)for(var s=0,u=c.length;s!==u;++s)c[s].evaluate(i),l[s].accumulateAdditive(v);else for(var f=0,p=c.length;f!==p;++f)c[f].evaluate(i),l[f].accumulate(r,v)}}else this._updateWeight(n)}},{key:"_updateWeight",value:function(n){var e=0;if(this.enabled){e=this.weight;var t=this._weightInterpolant;if(null!==t){var r=t.evaluate(n)[0];e*=r,n>t.parameterPositions[1]&&(this.stopFading(),0===r&&(this.enabled=!1))}}return this._effectiveWeight=e,e}},{key:"_updateTimeScale",value:function(n){var e=0;if(!this.paused){e=this.timeScale;var t=this._timeScaleInterpolant;if(null!==t)e*=t.evaluate(n)[0],n>t.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e)}return this._effectiveTimeScale=e,e}},{key:"_updateTime",value:function(n){var e=this._clip.duration,t=this.loop,r=this.time+n,o=this._loopCount,a=t===Ze;if(0===n)return-1===o?r:a&&1===(1&o)?e-r:r;if(t===Ye){-1===o&&(this._loopCount=0,this._setEndings(!0,!0,!1));n:{if(r>=e)r=e;else{if(!(r<0)){this.time=r;break n}r=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:n<0?-1:1})}}else{if(-1===o&&(n>=0?(o=0,this._setEndings(!0,0===this.repetitions,a)):this._setEndings(0===this.repetitions,!0,a)),r>=e||r<0){var i=Math.floor(r/e);r-=e*i,o+=Math.abs(i);var v=this.repetitions-o;if(v<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=n>0?e:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:n>0?1:-1});else{if(1===v){var c=n<0;this._setEndings(c,!c,a)}else this._setEndings(!1,!1,a);this._loopCount=o,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:i})}}else this.time=r;if(a&&1===(1&o))return e-r}return r}},{key:"_setEndings",value:function(n,e,t){var r=this._interpolantSettings;t?(r.endingStart=et,r.endingEnd=et):(r.endingStart=n?this.zeroSlopeAtStart?et:nt:tt,r.endingEnd=e?this.zeroSlopeAtEnd?et:nt:tt)}},{key:"_scheduleFading",value:function(n,e,t){var r=this._mixer,o=r.time,a=this._weightInterpolant;null===a&&(a=r._lendControlInterpolant(),this._weightInterpolant=a);var i=a.parameterPositions,v=a.sampleValues;return i[0]=o,v[0]=e,i[1]=o+n,v[1]=t,this}}]),n}(),gp=new Float32Array(1),yp=function(n){U(t,n);var e=z(t);function t(n){var r;return y(this,t),(r=e.call(this))._root=n,r._initMemoryManager(),r._accuIndex=0,r.time=0,r.timeScale=1,r}return _(t,[{key:"_bindAction",value:function(n,e){var t=n._localRoot||this._root,r=n._clip.tracks,o=r.length,a=n._propertyBindings,i=n._interpolants,v=t.uuid,c=this._bindingsByRootAndName,l=c[v];void 0===l&&(l={},c[v]=l);for(var s=0;s!==o;++s){var u=r[s],f=u.name,p=l[f];if(void 0!==p)++p.referenceCount,a[s]=p;else{if(void 0!==(p=a[s])){null===p._cacheIndex&&(++p.referenceCount,this._addInactiveBinding(p,v,f));continue}var d=e&&e._propertyBindings[s].binding.parsedPath;++(p=new vp(mp.create(t,f,d),u.ValueTypeName,u.getValueSize())).referenceCount,this._addInactiveBinding(p,v,f),a[s]=p}i[s].resultBuffer=p.buffer}}},{key:"_activateAction",value:function(n){if(!this._isActiveAction(n)){if(null===n._cacheIndex){var e=(n._localRoot||this._root).uuid,t=n._clip.uuid,r=this._actionsByClip[t];this._bindAction(n,r&&r.knownActions[0]),this._addInactiveAction(n,t,e)}for(var o=n._propertyBindings,a=0,i=o.length;a!==i;++a){var v=o[a];0===v.useCount++&&(this._lendBinding(v),v.saveOriginalState())}this._lendAction(n)}}},{key:"_deactivateAction",value:function(n){if(this._isActiveAction(n)){for(var e=n._propertyBindings,t=0,r=e.length;t!==r;++t){var o=e[t];0===--o.useCount&&(o.restoreOriginalState(),this._takeBackBinding(o))}this._takeBackAction(n)}}},{key:"_initMemoryManager",value:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;var n=this;this.stats={actions:{get total(){return n._actions.length},get inUse(){return n._nActiveActions}},bindings:{get total(){return n._bindings.length},get inUse(){return n._nActiveBindings}},controlInterpolants:{get total(){return n._controlInterpolants.length},get inUse(){return n._nActiveControlInterpolants}}}}},{key:"_isActiveAction",value:function(n){var e=n._cacheIndex;return null!==e&&e<this._nActiveActions}},{key:"_addInactiveAction",value:function(n,e,t){var r=this._actions,o=this._actionsByClip,a=o[e];if(void 0===a)a={knownActions:[n],actionByRoot:{}},n._byClipCacheIndex=0,o[e]=a;else{var i=a.knownActions;n._byClipCacheIndex=i.length,i.push(n)}n._cacheIndex=r.length,r.push(n),a.actionByRoot[t]=n}},{key:"_removeInactiveAction",value:function(n){var e=this._actions,t=e[e.length-1],r=n._cacheIndex;t._cacheIndex=r,e[r]=t,e.pop(),n._cacheIndex=null;var o=n._clip.uuid,a=this._actionsByClip,i=a[o],v=i.knownActions,c=v[v.length-1],l=n._byClipCacheIndex;c._byClipCacheIndex=l,v[l]=c,v.pop(),n._byClipCacheIndex=null,delete i.actionByRoot[(n._localRoot||this._root).uuid],0===v.length&&delete a[o],this._removeInactiveBindingsForAction(n)}},{key:"_removeInactiveBindingsForAction",value:function(n){for(var e=n._propertyBindings,t=0,r=e.length;t!==r;++t){var o=e[t];0===--o.referenceCount&&this._removeInactiveBinding(o)}}},{key:"_lendAction",value:function(n){var e=this._actions,t=n._cacheIndex,r=this._nActiveActions++,o=e[r];n._cacheIndex=r,e[r]=n,o._cacheIndex=t,e[t]=o}},{key:"_takeBackAction",value:function(n){var e=this._actions,t=n._cacheIndex,r=--this._nActiveActions,o=e[r];n._cacheIndex=r,e[r]=n,o._cacheIndex=t,e[t]=o}},{key:"_addInactiveBinding",value:function(n,e,t){var r=this._bindingsByRootAndName,o=this._bindings,a=r[e];void 0===a&&(a={},r[e]=a),a[t]=n,n._cacheIndex=o.length,o.push(n)}},{key:"_removeInactiveBinding",value:function(n){var e=this._bindings,t=n.binding,r=t.rootNode.uuid,o=t.path,a=this._bindingsByRootAndName,i=a[r],v=e[e.length-1],c=n._cacheIndex;v._cacheIndex=c,e[c]=v,e.pop(),delete i[o],0===Object.keys(i).length&&delete a[r]}},{key:"_lendBinding",value:function(n){var e=this._bindings,t=n._cacheIndex,r=this._nActiveBindings++,o=e[r];n._cacheIndex=r,e[r]=n,o._cacheIndex=t,e[t]=o}},{key:"_takeBackBinding",value:function(n){var e=this._bindings,t=n._cacheIndex,r=--this._nActiveBindings,o=e[r];n._cacheIndex=r,e[r]=n,o._cacheIndex=t,e[t]=o}},{key:"_lendControlInterpolant",value:function(){var n=this._controlInterpolants,e=this._nActiveControlInterpolants++,t=n[e];return void 0===t&&((t=new Lu(new Float32Array(2),new Float32Array(2),1,gp)).__cacheIndex=e,n[e]=t),t}},{key:"_takeBackControlInterpolant",value:function(n){var e=this._controlInterpolants,t=n.__cacheIndex,r=--this._nActiveControlInterpolants,o=e[r];n.__cacheIndex=r,e[r]=n,o.__cacheIndex=t,e[t]=o}},{key:"clipAction",value:function(n,e,t){var r=e||this._root,o=r.uuid,a="string"===typeof n?Yu.findByName(r,n):n,i=null!==a?a.uuid:n,v=this._actionsByClip[i],c=null;if(void 0===t&&(t=null!==a?a.blendMode:rt),void 0!==v){var l=v.actionByRoot[o];if(void 0!==l&&l.blendMode===t)return l;c=v.knownActions[0],null===a&&(a=c._clip)}if(null===a)return null;var s=new xp(this,a,e,t);return this._bindAction(s,c),this._addInactiveAction(s,i,o),s}},{key:"existingAction",value:function(n,e){var t=e||this._root,r=t.uuid,o="string"===typeof n?Yu.findByName(t,n):n,a=o?o.uuid:n,i=this._actionsByClip[a];return void 0!==i&&i.actionByRoot[r]||null}},{key:"stopAllAction",value:function(){for(var n=this._actions,e=this._nActiveActions-1;e>=0;--e)n[e].stop();return this}},{key:"update",value:function(n){n*=this.timeScale;for(var e=this._actions,t=this._nActiveActions,r=this.time+=n,o=Math.sign(n),a=this._accuIndex^=1,i=0;i!==t;++i){e[i]._update(r,n,o,a)}for(var v=this._bindings,c=this._nActiveBindings,l=0;l!==c;++l)v[l].apply(a);return this}},{key:"setTime",value:function(n){this.time=0;for(var e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(n)}},{key:"getRoot",value:function(){return this._root}},{key:"uncacheClip",value:function(n){var e=this._actions,t=n.uuid,r=this._actionsByClip,o=r[t];if(void 0!==o){for(var a=o.knownActions,i=0,v=a.length;i!==v;++i){var c=a[i];this._deactivateAction(c);var l=c._cacheIndex,s=e[e.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,s._cacheIndex=l,e[l]=s,e.pop(),this._removeInactiveBindingsForAction(c)}delete r[t]}}},{key:"uncacheRoot",value:function(n){var e=n.uuid,t=this._actionsByClip;for(var r in t){var o=t[r].actionByRoot[e];void 0!==o&&(this._deactivateAction(o),this._removeInactiveAction(o))}var a=this._bindingsByRootAndName[e];if(void 0!==a)for(var i in a){var v=a[i];v.restoreOriginalState(),this._removeInactiveBinding(v)}}},{key:"uncacheAction",value:function(n,e){var t=this.existingAction(n,e);null!==t&&(this._deactivateAction(t),this._removeInactiveAction(t))}}]),t}(Wt),bp=function(){function n(e){y(this,n),this.value=e}return _(n,[{key:"clone",value:function(){return new n(void 0===this.value.clone?this.value:this.value.clone())}}]),n}(),_p=0,Up=function(n){U(t,n);var e=z(t);function t(){var n;return y(this,t),(n=e.call(this)).isUniformsGroup=!0,Object.defineProperty(k(n),"id",{value:_p++}),n.name="",n.usage=jt,n.uniforms=[],n}return _(t,[{key:"add",value:function(n){return this.uniforms.push(n),this}},{key:"remove",value:function(n){var e=this.uniforms.indexOf(n);return-1!==e&&this.uniforms.splice(e,1),this}},{key:"setName",value:function(n){return this.name=n,this}},{key:"setUsage",value:function(n){return this.usage=n,this}},{key:"dispose",value:function(){return this.dispatchEvent({type:"dispose"}),this}},{key:"copy",value:function(n){this.name=n.name,this.usage=n.usage;var e=n.uniforms;this.uniforms.length=0;for(var t=0,r=e.length;t<r;t++)this.uniforms.push(e[t].clone());return this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),t}(Wt),wp=function(n){U(t,n);var e=z(t);function t(n,r){var o,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return y(this,t),(o=e.call(this,n,r)).isInstancedInterleavedBuffer=!0,o.meshPerAttribute=a,o}return _(t,[{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n),this.meshPerAttribute=n.meshPerAttribute,this}},{key:"clone",value:function(n){var e=P(w(t.prototype),"clone",this).call(this,n);return e.meshPerAttribute=this.meshPerAttribute,e}},{key:"toJSON",value:function(n){var e=P(w(t.prototype),"toJSON",this).call(this,n);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}]),t}(Gc),Sp=function(){function n(e,t,r,o,a){y(this,n),this.isGLBufferAttribute=!0,this.buffer=e,this.type=t,this.itemSize=r,this.elementSize=o,this.count=a,this.version=0}return _(n,[{key:"needsUpdate",set:function(n){!0===n&&this.version++}},{key:"setBuffer",value:function(n){return this.buffer=n,this}},{key:"setType",value:function(n,e){return this.type=n,this.elementSize=e,this}},{key:"setItemSize",value:function(n){return this.itemSize=n,this}},{key:"setCount",value:function(n){return this.count=n,this}}]),n}(),kp=function(){function n(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;y(this,n),this.ray=new fo(e,t),this.near=r,this.far=o,this.camera=null,this.layers=new ko,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}return _(n,[{key:"set",value:function(n,e){this.ray.set(n,e)}},{key:"setFromCamera",value:function(n,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(n.x,n.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(n.x,n.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}},{key:"intersectObject",value:function(n){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return zp(n,this,t,e),t.sort(Mp),t}},{key:"intersectObjects",value:function(n){for(var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=0,o=n.length;r<o;r++)zp(n[r],this,t,e);return t.sort(Mp),t}}]),n}();function Mp(n,e){return n.distance-e.distance}function zp(n,e,t,r){if(n.layers.test(e.layers)&&n.raycast(e,t),!0===r)for(var o=n.children,a=0,i=o.length;a<i;a++)zp(o[a],e,t,!0)}var Cp=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return y(this,n),this.radius=e,this.phi=t,this.theta=r,this}return _(n,[{key:"set",value:function(n,e,t){return this.radius=n,this.phi=e,this.theta=t,this}},{key:"copy",value:function(n){return this.radius=n.radius,this.phi=n.phi,this.theta=n.theta,this}},{key:"makeSafe",value:function(){var n=1e-6;return this.phi=Math.max(n,Math.min(Math.PI-n,this.phi)),this}},{key:"setFromVector3",value:function(n){return this.setFromCartesianCoords(n.x,n.y,n.z)}},{key:"setFromCartesianCoords",value:function(n,e,t){return this.radius=Math.sqrt(n*n+e*e+t*t),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(n,t),this.phi=Math.acos(Kt(e/this.radius,-1,1))),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),Tp=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return y(this,n),this.radius=e,this.theta=t,this.y=r,this}return _(n,[{key:"set",value:function(n,e,t){return this.radius=n,this.theta=e,this.y=t,this}},{key:"copy",value:function(n){return this.radius=n.radius,this.theta=n.theta,this.y=n.y,this}},{key:"setFromVector3",value:function(n){return this.setFromCartesianCoords(n.x,n.y,n.z)}},{key:"setFromCartesianCoords",value:function(n,e,t){return this.radius=Math.sqrt(n*n+t*t),this.theta=Math.atan2(n,t),this.y=e,this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),Rp=new ir,Dp=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ir(1/0,1/0),t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ir(-1/0,-1/0);y(this,n),this.isBox2=!0,this.min=e,this.max=t}return _(n,[{key:"set",value:function(n,e){return this.min.copy(n),this.max.copy(e),this}},{key:"setFromPoints",value:function(n){this.makeEmpty();for(var e=0,t=n.length;e<t;e++)this.expandByPoint(n[e]);return this}},{key:"setFromCenterAndSize",value:function(n,e){var t=Rp.copy(e).multiplyScalar(.5);return this.min.copy(n).sub(t),this.max.copy(n).add(t),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){return this.min.copy(n.min),this.max.copy(n.max),this}},{key:"makeEmpty",value:function(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}},{key:"isEmpty",value:function(){return this.max.x<this.min.x||this.max.y<this.min.y}},{key:"getCenter",value:function(n){return this.isEmpty()?n.set(0,0):n.addVectors(this.min,this.max).multiplyScalar(.5)}},{key:"getSize",value:function(n){return this.isEmpty()?n.set(0,0):n.subVectors(this.max,this.min)}},{key:"expandByPoint",value:function(n){return this.min.min(n),this.max.max(n),this}},{key:"expandByVector",value:function(n){return this.min.sub(n),this.max.add(n),this}},{key:"expandByScalar",value:function(n){return this.min.addScalar(-n),this.max.addScalar(n),this}},{key:"containsPoint",value:function(n){return!(n.x<this.min.x||n.x>this.max.x||n.y<this.min.y||n.y>this.max.y)}},{key:"containsBox",value:function(n){return this.min.x<=n.min.x&&n.max.x<=this.max.x&&this.min.y<=n.min.y&&n.max.y<=this.max.y}},{key:"getParameter",value:function(n,e){return e.set((n.x-this.min.x)/(this.max.x-this.min.x),(n.y-this.min.y)/(this.max.y-this.min.y))}},{key:"intersectsBox",value:function(n){return!(n.max.x<this.min.x||n.min.x>this.max.x||n.max.y<this.min.y||n.min.y>this.max.y)}},{key:"clampPoint",value:function(n,e){return e.copy(n).clamp(this.min,this.max)}},{key:"distanceToPoint",value:function(n){return Rp.copy(n).clamp(this.min,this.max).sub(n).length()}},{key:"intersect",value:function(n){return this.min.max(n.min),this.max.min(n.max),this}},{key:"union",value:function(n){return this.min.min(n.min),this.max.max(n.max),this}},{key:"translate",value:function(n){return this.min.add(n),this.max.add(n),this}},{key:"equals",value:function(n){return n.min.equals(this.min)&&n.max.equals(this.max)}}]),n}(),Pp=new Or,jp=new Or,Fp=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Or,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Or;y(this,n),this.start=e,this.end=t}return _(n,[{key:"set",value:function(n,e){return this.start.copy(n),this.end.copy(e),this}},{key:"copy",value:function(n){return this.start.copy(n.start),this.end.copy(n.end),this}},{key:"getCenter",value:function(n){return n.addVectors(this.start,this.end).multiplyScalar(.5)}},{key:"delta",value:function(n){return n.subVectors(this.end,this.start)}},{key:"distanceSq",value:function(){return this.start.distanceToSquared(this.end)}},{key:"distance",value:function(){return this.start.distanceTo(this.end)}},{key:"at",value:function(n,e){return this.delta(e).multiplyScalar(n).add(this.start)}},{key:"closestPointToPointParameter",value:function(n,e){Pp.subVectors(n,this.start),jp.subVectors(this.end,this.start);var t=jp.dot(jp),r=jp.dot(Pp)/t;return e&&(r=Kt(r,0,1)),r}},{key:"closestPointToPoint",value:function(n,e,t){var r=this.closestPointToPointParameter(n,e);return this.delta(t).multiplyScalar(r).add(this.start)}},{key:"applyMatrix4",value:function(n){return this.start.applyMatrix4(n),this.end.applyMatrix4(n),this}},{key:"equals",value:function(n){return n.start.equals(this.start)&&n.end.equals(this.end)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),Ep=new Or,Ip=function(n){U(t,n);var e=z(t);function t(n,r){var o;y(this,t),(o=e.call(this)).light=n,o.light.updateMatrixWorld(),o.matrix=n.matrixWorld,o.matrixAutoUpdate=!1,o.color=r;for(var a=new ba,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1],v=0,c=1;v<32;v++,c++){var l=v/32*Math.PI*2,s=c/32*Math.PI*2;i.push(Math.cos(l),Math.sin(l),1,Math.cos(s),Math.sin(s),1)}a.setAttribute("position",new ua(i,3));var u=new Ml({fog:!1,toneMapped:!1});return o.cone=new El(a,u),o.add(o.cone),o.update(),o}return _(t,[{key:"dispose",value:function(){this.cone.geometry.dispose(),this.cone.material.dispose()}},{key:"update",value:function(){this.light.updateMatrixWorld();var n=this.light.distance?this.light.distance:1e3,e=n*Math.tan(this.light.angle);this.cone.scale.set(e,e,n),Ep.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(Ep),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}]),t}(Ao),Op=new Or,Lp=new po,Ap=new po,Np=function(n){U(t,n);var e=z(t);function t(n){var r;y(this,t);for(var o=Gp(n),a=new ba,i=[],v=[],c=new wr(0,0,1),l=new wr(0,1,0),s=0;s<o.length;s++){var u=o[s];u.parent&&u.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),v.push(c.r,c.g,c.b),v.push(l.r,l.g,l.b))}a.setAttribute("position",new ua(i,3)),a.setAttribute("color",new ua(v,3));var f=new Ml({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});return(r=e.call(this,a,f)).isSkeletonHelper=!0,r.type="SkeletonHelper",r.root=n,r.bones=o,r.matrix=n.matrixWorld,r.matrixAutoUpdate=!1,r}return _(t,[{key:"updateMatrixWorld",value:function(n){var e=this.bones,r=this.geometry,o=r.getAttribute("position");Ap.copy(this.root.matrixWorld).invert();for(var a=0,i=0;a<e.length;a++){var v=e[a];v.parent&&v.parent.isBone&&(Lp.multiplyMatrices(Ap,v.matrixWorld),Op.setFromMatrixPosition(Lp),o.setXYZ(i,Op.x,Op.y,Op.z),Lp.multiplyMatrices(Ap,v.parent.matrixWorld),Op.setFromMatrixPosition(Lp),o.setXYZ(i+1,Op.x,Op.y,Op.z),i+=2)}r.getAttribute("position").needsUpdate=!0,P(w(t.prototype),"updateMatrixWorld",this).call(this,n)}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(El);function Gp(n){var e=[];!0===n.isBone&&e.push(n);for(var t=0;t<n.children.length;t++)e.push.apply(e,Gp(n.children[t]));return e}var Bp=function(n){U(t,n);var e=z(t);function t(n,r,o){var a;y(this,t);var i=new uu(r,4,2),v=new Qo({wireframe:!0,fog:!1,toneMapped:!1});return(a=e.call(this,i,v)).light=n,a.light.updateMatrixWorld(),a.color=o,a.type="PointLightHelper",a.matrix=a.light.matrixWorld,a.matrixAutoUpdate=!1,a.update(),a}return _(t,[{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}},{key:"update",value:function(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}]),t}(La),qp=new Or,Vp=new wr,Wp=new wr,Hp=function(n){U(t,n);var e=z(t);function t(n,r,o){var a;y(this,t),(a=e.call(this)).light=n,a.light.updateMatrixWorld(),a.matrix=n.matrixWorld,a.matrixAutoUpdate=!1,a.color=o;var i=new cu(r);i.rotateY(.5*Math.PI),a.material=new Qo({wireframe:!0,fog:!1,toneMapped:!1}),void 0===a.color&&(a.material.vertexColors=!0);var v=i.getAttribute("position"),c=new Float32Array(3*v.count);return i.setAttribute("color",new ta(c,3)),a.add(new La(i,a.material)),a.update(),a}return _(t,[{key:"dispose",value:function(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}},{key:"update",value:function(){var n=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{var e=n.geometry.getAttribute("color");Vp.copy(this.light.color),Wp.copy(this.light.groundColor);for(var t=0,r=e.count;t<r;t++){var o=t<r/2?Vp:Wp;e.setXYZ(t,o.r,o.g,o.b)}e.needsUpdate=!0}n.lookAt(qp.setFromMatrixPosition(this.light.matrixWorld).negate())}}]),t}(Ao),Xp=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:10,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:4473924,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:8947848;y(this,t),a=new wr(a),i=new wr(i);for(var v=o/2,c=r/o,l=r/2,s=[],u=[],f=0,p=0,d=-l;f<=o;f++,d+=c){s.push(-l,0,d,l,0,d),s.push(d,0,-l,d,0,l);var m=f===v?a:i;m.toArray(u,p),p+=3,m.toArray(u,p),p+=3,m.toArray(u,p),p+=3,m.toArray(u,p),p+=3}var h=new ba;h.setAttribute("position",new ua(s,3)),h.setAttribute("color",new ua(u,3));var x=new Ml({vertexColors:!0,toneMapped:!1});return(n=e.call(this,h,x)).type="GridHelper",n}return _(t,[{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(El),Yp=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:10,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:16,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:8,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:64,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4473924,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:8947848;y(this,t),v=new wr(v),c=new wr(c);var l=[],s=[];if(o>1)for(var u=0;u<o;u++){var f=u/o*(2*Math.PI),p=Math.sin(f)*r,d=Math.cos(f)*r;l.push(0,0,0),l.push(p,0,d);var m=1&u?v:c;s.push(m.r,m.g,m.b),s.push(m.r,m.g,m.b)}for(var h=0;h<a;h++)for(var x=1&h?v:c,g=r-r/a*h,b=0;b<i;b++){var _=b/i*(2*Math.PI),U=Math.sin(_)*g,w=Math.cos(_)*g;l.push(U,0,w),s.push(x.r,x.g,x.b),_=(b+1)/i*(2*Math.PI),U=Math.sin(_)*g,w=Math.cos(_)*g,l.push(U,0,w),s.push(x.r,x.g,x.b)}var S=new ba;S.setAttribute("position",new ua(l,3)),S.setAttribute("color",new ua(s,3));var k=new Ml({vertexColors:!0,toneMapped:!1});return(n=e.call(this,S,k)).type="PolarGridHelper",n}return _(t,[{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(El),$p=new Or,Zp=new Or,Kp=new Or,Jp=function(n){U(t,n);var e=z(t);function t(n,r,o){var a;y(this,t),(a=e.call(this)).light=n,a.light.updateMatrixWorld(),a.matrix=n.matrixWorld,a.matrixAutoUpdate=!1,a.color=o,void 0===r&&(r=1);var i=new ba;i.setAttribute("position",new ua([-r,r,0,r,r,0,r,-r,0,-r,-r,0,-r,r,0],3));var v=new Ml({fog:!1,toneMapped:!1});return a.lightPlane=new Pl(i,v),a.add(a.lightPlane),(i=new ba).setAttribute("position",new ua([0,0,0,0,0,1],3)),a.targetLine=new Pl(i,v),a.add(a.targetLine),a.update(),a}return _(t,[{key:"dispose",value:function(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}},{key:"update",value:function(){$p.setFromMatrixPosition(this.light.matrixWorld),Zp.setFromMatrixPosition(this.light.target.matrixWorld),Kp.subVectors(Zp,$p),this.lightPlane.lookAt(Zp),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Zp),this.targetLine.scale.z=Kp.length()}}]),t}(Ao),Qp=new Or,nd=new Wa,ed=function(n){U(t,n);var e=z(t);function t(n){var r;y(this,t);var o=new ba,a=new Ml({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],v=[],c={};function l(n,e){s(n),s(e)}function s(n){i.push(0,0,0),v.push(0,0,0),void 0===c[n]&&(c[n]=[]),c[n].push(i.length/3-1)}l("n1","n2"),l("n2","n4"),l("n4","n3"),l("n3","n1"),l("f1","f2"),l("f2","f4"),l("f4","f3"),l("f3","f1"),l("n1","f1"),l("n2","f2"),l("n3","f3"),l("n4","f4"),l("p","n1"),l("p","n2"),l("p","n3"),l("p","n4"),l("u1","u2"),l("u2","u3"),l("u3","u1"),l("c","t"),l("p","c"),l("cn1","cn2"),l("cn3","cn4"),l("cf1","cf2"),l("cf3","cf4"),o.setAttribute("position",new ua(i,3)),o.setAttribute("color",new ua(v,3)),(r=e.call(this,o,a)).type="CameraHelper",r.camera=n,r.camera.updateProjectionMatrix&&r.camera.updateProjectionMatrix(),r.matrix=n.matrixWorld,r.matrixAutoUpdate=!1,r.pointMap=c,r.update();var u=new wr(16755200),f=new wr(16711680),p=new wr(43775),d=new wr(16777215),m=new wr(3355443);return r.setColors(u,f,p,d,m),r}return _(t,[{key:"setColors",value:function(n,e,t,r,o){var a=this.geometry.getAttribute("color");a.setXYZ(0,n.r,n.g,n.b),a.setXYZ(1,n.r,n.g,n.b),a.setXYZ(2,n.r,n.g,n.b),a.setXYZ(3,n.r,n.g,n.b),a.setXYZ(4,n.r,n.g,n.b),a.setXYZ(5,n.r,n.g,n.b),a.setXYZ(6,n.r,n.g,n.b),a.setXYZ(7,n.r,n.g,n.b),a.setXYZ(8,n.r,n.g,n.b),a.setXYZ(9,n.r,n.g,n.b),a.setXYZ(10,n.r,n.g,n.b),a.setXYZ(11,n.r,n.g,n.b),a.setXYZ(12,n.r,n.g,n.b),a.setXYZ(13,n.r,n.g,n.b),a.setXYZ(14,n.r,n.g,n.b),a.setXYZ(15,n.r,n.g,n.b),a.setXYZ(16,n.r,n.g,n.b),a.setXYZ(17,n.r,n.g,n.b),a.setXYZ(18,n.r,n.g,n.b),a.setXYZ(19,n.r,n.g,n.b),a.setXYZ(20,n.r,n.g,n.b),a.setXYZ(21,n.r,n.g,n.b),a.setXYZ(22,n.r,n.g,n.b),a.setXYZ(23,n.r,n.g,n.b),a.setXYZ(24,e.r,e.g,e.b),a.setXYZ(25,e.r,e.g,e.b),a.setXYZ(26,e.r,e.g,e.b),a.setXYZ(27,e.r,e.g,e.b),a.setXYZ(28,e.r,e.g,e.b),a.setXYZ(29,e.r,e.g,e.b),a.setXYZ(30,e.r,e.g,e.b),a.setXYZ(31,e.r,e.g,e.b),a.setXYZ(32,t.r,t.g,t.b),a.setXYZ(33,t.r,t.g,t.b),a.setXYZ(34,t.r,t.g,t.b),a.setXYZ(35,t.r,t.g,t.b),a.setXYZ(36,t.r,t.g,t.b),a.setXYZ(37,t.r,t.g,t.b),a.setXYZ(38,r.r,r.g,r.b),a.setXYZ(39,r.r,r.g,r.b),a.setXYZ(40,o.r,o.g,o.b),a.setXYZ(41,o.r,o.g,o.b),a.setXYZ(42,o.r,o.g,o.b),a.setXYZ(43,o.r,o.g,o.b),a.setXYZ(44,o.r,o.g,o.b),a.setXYZ(45,o.r,o.g,o.b),a.setXYZ(46,o.r,o.g,o.b),a.setXYZ(47,o.r,o.g,o.b),a.setXYZ(48,o.r,o.g,o.b),a.setXYZ(49,o.r,o.g,o.b),a.needsUpdate=!0}},{key:"update",value:function(){var n=this.geometry,e=this.pointMap;nd.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),td("c",e,n,nd,0,0,-1),td("t",e,n,nd,0,0,1),td("n1",e,n,nd,-1,-1,-1),td("n2",e,n,nd,1,-1,-1),td("n3",e,n,nd,-1,1,-1),td("n4",e,n,nd,1,1,-1),td("f1",e,n,nd,-1,-1,1),td("f2",e,n,nd,1,-1,1),td("f3",e,n,nd,-1,1,1),td("f4",e,n,nd,1,1,1),td("u1",e,n,nd,.7,1.1,-1),td("u2",e,n,nd,-.7,1.1,-1),td("u3",e,n,nd,0,2,-1),td("cf1",e,n,nd,-1,0,1),td("cf2",e,n,nd,1,0,1),td("cf3",e,n,nd,0,-1,1),td("cf4",e,n,nd,0,1,1),td("cn1",e,n,nd,-1,0,-1),td("cn2",e,n,nd,1,0,-1),td("cn3",e,n,nd,0,-1,-1),td("cn4",e,n,nd,0,1,-1),n.getAttribute("position").needsUpdate=!0}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(El);function td(n,e,t,r,o,a,i){Qp.set(o,a,i).unproject(r);var v=e[n];if(void 0!==v)for(var c=t.getAttribute("position"),l=0,s=v.length;l<s;l++)c.setXYZ(v[l],Qp.x,Qp.y,Qp.z)}var rd,od,ad=new Nr,id=function(n){U(t,n);var e=z(t);function t(n){var r,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:16776960;y(this,t);var a=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),v=new ba;return v.setIndex(new ta(a,1)),v.setAttribute("position",new ta(i,3)),(r=e.call(this,v,new Ml({color:o,toneMapped:!1}))).object=n,r.type="BoxHelper",r.matrixAutoUpdate=!1,r.update(),r}return _(t,[{key:"update",value:function(n){if(void 0!==n&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&ad.setFromObject(this.object),!ad.isEmpty()){var e=ad.min,t=ad.max,r=this.geometry.attributes.position,o=r.array;o[0]=t.x,o[1]=t.y,o[2]=t.z,o[3]=e.x,o[4]=t.y,o[5]=t.z,o[6]=e.x,o[7]=e.y,o[8]=t.z,o[9]=t.x,o[10]=e.y,o[11]=t.z,o[12]=t.x,o[13]=t.y,o[14]=e.z,o[15]=e.x,o[16]=t.y,o[17]=e.z,o[18]=e.x,o[19]=e.y,o[20]=e.z,o[21]=t.x,o[22]=e.y,o[23]=e.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}}},{key:"setFromObject",value:function(n){return this.object=n,this.update(),this}},{key:"copy",value:function(n,e){return P(w(t.prototype),"copy",this).call(this,n,e),this.object=n.object,this}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(El),vd=function(n){U(t,n);var e=z(t);function t(n){var r,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:16776960;y(this,t);var a=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],v=new ba;return v.setIndex(new ta(a,1)),v.setAttribute("position",new ua(i,3)),(r=e.call(this,v,new Ml({color:o,toneMapped:!1}))).box=n,r.type="Box3Helper",r.geometry.computeBoundingSphere(),r}return _(t,[{key:"updateMatrixWorld",value:function(n){var e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),P(w(t.prototype),"updateMatrixWorld",this).call(this,n))}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(El),cd=function(n){U(t,n);var e=z(t);function t(n){var r,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:16776960;y(this,t);var i=a,v=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],c=new ba;c.setAttribute("position",new ua(v,3)),c.computeBoundingSphere(),(r=e.call(this,c,new Ml({color:i,toneMapped:!1}))).type="PlaneHelper",r.plane=n,r.size=o;var l=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],s=new ba;return s.setAttribute("position",new ua(l,3)),s.computeBoundingSphere(),r.add(new La(s,new Qo({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1}))),r}return _(t,[{key:"updateMatrixWorld",value:function(n){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),P(w(t.prototype),"updateMatrixWorld",this).call(this,n)}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}]),t}(Pl),ld=new Or,sd=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Or(0,0,1),o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Or(0,0,0),a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:16776960,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.2*a,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.2*v;return y(this,t),(n=e.call(this)).type="ArrowHelper",void 0===rd&&((rd=new ba).setAttribute("position",new ua([0,0,0,0,1,0],3)),(od=new bs(0,.5,1,5,1)).translate(0,-.5,0)),n.position.copy(o),n.line=new Pl(rd,new Ml({color:i,toneMapped:!1})),n.line.matrixAutoUpdate=!1,n.add(n.line),n.cone=new La(od,new Qo({color:i,toneMapped:!1})),n.cone.matrixAutoUpdate=!1,n.add(n.cone),n.setDirection(r),n.setLength(a,v,c),n}return _(t,[{key:"setDirection",value:function(n){if(n.y>.99999)this.quaternion.set(0,0,0,1);else if(n.y<-.99999)this.quaternion.set(1,0,0,0);else{ld.set(n.z,0,-n.x).normalize();var e=Math.acos(n.y);this.quaternion.setFromAxisAngle(ld,e)}}},{key:"setLength",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2*n,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.2*e;this.line.scale.set(1,Math.max(1e-4,n-e),1),this.line.updateMatrix(),this.cone.scale.set(t,e,t),this.cone.position.y=n,this.cone.updateMatrix()}},{key:"setColor",value:function(n){this.line.material.color.set(n),this.cone.material.color.set(n)}},{key:"copy",value:function(n){return P(w(t.prototype),"copy",this).call(this,n,!1),this.line.copy(n.line),this.cone.copy(n.cone),this}},{key:"dispose",value:function(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}]),t}(Ao),ud=function(n){U(t,n);var e=z(t);function t(){var n,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;y(this,t);var o=[0,0,0,r,0,0,0,0,0,0,r,0,0,0,0,0,0,r],a=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new ba;i.setAttribute("position",new ua(o,3)),i.setAttribute("color",new ua(a,3));var v=new Ml({vertexColors:!0,toneMapped:!1});return(n=e.call(this,i,v)).type="AxesHelper",n}return _(t,[{key:"setColors",value:function(n,e,t){var r=new wr,o=this.geometry.attributes.color.array;return r.set(n),r.toArray(o,0),r.toArray(o,3),r.set(e),r.toArray(o,6),r.toArray(o,9),r.set(t),r.toArray(o,12),r.toArray(o,15),this.geometry.attributes.color.needsUpdate=!0,this}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(El),fd=function(){function n(){y(this,n),this.type="ShapePath",this.color=new wr,this.subPaths=[],this.currentPath=null}return _(n,[{key:"moveTo",value:function(n,e){return this.currentPath=new hs,this.subPaths.push(this.currentPath),this.currentPath.moveTo(n,e),this}},{key:"lineTo",value:function(n,e){return this.currentPath.lineTo(n,e),this}},{key:"quadraticCurveTo",value:function(n,e,t,r){return this.currentPath.quadraticCurveTo(n,e,t,r),this}},{key:"bezierCurveTo",value:function(n,e,t,r,o,a){return this.currentPath.bezierCurveTo(n,e,t,r,o,a),this}},{key:"splineThru",value:function(n){return this.currentPath.splineThru(n),this}},{key:"toShapes",value:function(n){function e(n,e){for(var t=e.length,r=!1,o=t-1,a=0;a<t;o=a++){var i=e[o],v=e[a],c=v.x-i.x,l=v.y-i.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(i=e[a],c=-c,v=e[o],l=-l),n.y<i.y||n.y>v.y)continue;if(n.y===i.y){if(n.x===i.x)return!0}else{var s=l*(n.x-i.x)-c*(n.y-i.y);if(0===s)return!0;if(s<0)continue;r=!r}}else{if(n.y!==i.y)continue;if(v.x<=n.x&&n.x<=i.x||i.x<=n.x&&n.x<=v.x)return!0}}return r}var t,r,o,a=tu.isClockWise,i=this.subPaths;if(0===i.length)return[];var v=[];if(1===i.length)return r=i[0],(o=new Ts).curves=r.curves,v.push(o),v;var c=!a(i[0].getPoints());c=n?!c:c;var l,s,u=[],f=[],p=[],d=0;f[d]=void 0,p[d]=[];for(var m=0,h=i.length;m<h;m++)t=a(l=(r=i[m]).getPoints()),(t=n?!t:t)?(!c&&f[d]&&d++,f[d]={s:new Ts,p:l},f[d].s.curves=r.curves,c&&d++,p[d]=[]):p[d].push({h:r,p:l[0]});if(!f[0])return function(n){for(var e=[],t=0,r=n.length;t<r;t++){var o=n[t],a=new Ts;a.curves=o.curves,e.push(a)}return e}(i);if(f.length>1){for(var x=!1,g=0,y=0,b=f.length;y<b;y++)u[y]=[];for(var _=0,U=f.length;_<U;_++)for(var w=p[_],S=0;S<w.length;S++){for(var k=w[S],M=!0,z=0;z<f.length;z++)e(k.p,f[z].p)&&(_!==z&&g++,M?(M=!1,u[z].push(k)):x=!0);M&&u[_].push(k)}g>0&&!1===x&&(p=u)}for(var C=0,T=f.length;C<T;C++){o=f[C].s,v.push(o);for(var R=0,D=(s=p[C]).length;R<D;R++)o.holes.push(s[R].h)}return v}}]),n}(),pd=dd();function dd(){for(var n=new ArrayBuffer(4),e=new Float32Array(n),t=new Uint32Array(n),r=new Uint32Array(512),o=new Uint32Array(512),a=0;a<256;++a){var i=a-127;i<-27?(r[a]=0,r[256|a]=32768,o[a]=24,o[256|a]=24):i<-14?(r[a]=1024>>-i-14,r[256|a]=1024>>-i-14|32768,o[a]=-i-1,o[256|a]=-i-1):i<=15?(r[a]=i+15<<10,r[256|a]=i+15<<10|32768,o[a]=13,o[256|a]=13):i<128?(r[a]=31744,r[256|a]=64512,o[a]=24,o[256|a]=24):(r[a]=31744,r[256|a]=64512,o[a]=13,o[256|a]=13)}for(var v=new Uint32Array(2048),c=new Uint32Array(64),l=new Uint32Array(64),s=1;s<1024;++s){for(var u=s<<13,f=0;0===(8388608&u);)u<<=1,f-=8388608;u&=-8388609,f+=947912704,v[s]=u|f}for(var p=1024;p<2048;++p)v[p]=939524096+(p-1024<<13);for(var d=1;d<31;++d)c[d]=d<<23;c[31]=1199570944,c[32]=2147483648;for(var m=33;m<63;++m)c[m]=2147483648+(m-32<<23);c[63]=3347054592;for(var h=1;h<64;++h)32!==h&&(l[h]=1024);return{floatView:e,uint32View:t,baseTable:r,shiftTable:o,mantissaTable:v,exponentTable:c,offsetTable:l}}var md=Object.freeze({__proto__:null,toHalfFloat:function(n){Math.abs(n)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),n=Kt(n,-65504,65504),pd.floatView[0]=n;var e=pd.uint32View[0],t=e>>23&511;return pd.baseTable[t]+((8388607&e)>>pd.shiftTable[t])},fromHalfFloat:function(n){var e=n>>10;return pd.uint32View[0]=pd.mantissaTable[pd.offsetTable[e]+(1023&n)]+pd.exponentTable[e],pd.floatView[0]}});function hd(){console.error("THREE.ImmediateRenderObject has been removed.")}var xd=function(n){U(t,n);var e=z(t);function t(n,r,o){var a;return y(this,t),console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'),(a=e.call(this,n,r,o)).samples=4,a}return _(t)}(Rr),gd=function(n){U(t,n);var e=z(t);function t(n,r,o,a){return y(this,t),console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."),e.call(this,n,r,o,a)}return _(t)}(Dr),yd=function(n){U(t,n);var e=z(t);function t(n,r,o,a){return y(this,t),console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."),e.call(this,n,r,o,a)}return _(t)}(jr),bd=function(n){U(t,n);var e=z(t);function t(n,r,o,a,i,v){return y(this,t),console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."),e.call(this,n,r,o,a,i,v)}return _(t)}(Na),_d=function(n){U(t,n);var e=z(t);function t(n,r,o,a){return y(this,t),console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."),e.call(this,n,r,o,a)}return _(t)}(gs),Ud=function(n){U(t,n);var e=z(t);function t(n,r,o,a){return y(this,t),console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."),e.call(this,n,r,o,a)}return _(t)}(ys),wd=function(n){U(t,n);var e=z(t);function t(n,r,o,a,i,v,c){return y(this,t),console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."),e.call(this,n,r,o,a,i,v,c)}return _(t)}(_s),Sd=function(n){U(t,n);var e=z(t);function t(n,r,o,a,i,v,c,l){return y(this,t),console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."),e.call(this,n,r,o,a,i,v,c,l)}return _(t)}(bs),kd=function(n){U(t,n);var e=z(t);function t(n,r){return y(this,t),console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."),e.call(this,n,r)}return _(t)}(ws),Md=function(n){U(t,n);var e=z(t);function t(n,r){return y(this,t),console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."),e.call(this,n,r)}return _(t)}(au),zd=function(n){U(t,n);var e=z(t);function t(n,r){return y(this,t),console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."),e.call(this,n,r)}return _(t)}(vu),Cd=function(n){U(t,n);var e=z(t);function t(n,r,o,a){return y(this,t),console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."),e.call(this,n,r,o,a)}return _(t)}(xs),Td=function(n){U(t,n);var e=z(t);function t(n,r){return y(this,t),console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."),e.call(this,n,r)}return _(t)}(cu),Rd=function(n){U(t,n);var e=z(t);function t(n,r,o,a){return y(this,t),console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."),e.call(this,n,r,o,a)}return _(t)}(ii),Dd=function(n){U(t,n);var e=z(t);function t(n,r,o,a){return y(this,t),console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."),e.call(this,n,r,o,a)}return _(t)}(Us),Pd=function(n){U(t,n);var e=z(t);function t(n,r,o,a,i,v){return y(this,t),console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."),e.call(this,n,r,o,a,i,v)}return _(t)}(lu),jd=function(n){U(t,n);var e=z(t);function t(n,r){return y(this,t),console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."),e.call(this,n,r)}return _(t)}(su),Fd=function(n){U(t,n);var e=z(t);function t(n,r,o,a,i,v,c){return y(this,t),console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."),e.call(this,n,r,o,a,i,v,c)}return _(t)}(uu),Ed=function(n){U(t,n);var e=z(t);function t(n,r){return y(this,t),console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."),e.call(this,n,r)}return _(t)}(fu),Id=function(n){U(t,n);var e=z(t);function t(n,r,o,a,i){return y(this,t),console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."),e.call(this,n,r,o,a,i)}return _(t)}(pu),Od=function(n){U(t,n);var e=z(t);function t(n,r,o,a,i,v){return y(this,t),console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."),e.call(this,n,r,o,a,i,v)}return _(t)}(du),Ld=function(n){U(t,n);var e=z(t);function t(n,r,o,a,i){return y(this,t),console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."),e.call(this,n,r,o,a,i)}return _(t)}(mu);"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:F}})),"undefined"!==typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=F);var Ad=t(791),Nd=t.t(Ad,2),Gd=t(585);function Bd(n){var e,t=new Set,r=function(n,r){var o="function"===typeof n?n(e):n;if(o!==e){var a=e;e=r?o:Object.assign({},e,o),t.forEach((function(n){return n(e,a)}))}},o=function(){return e},a={setState:r,getState:o,subscribe:function(n,r,a){return r||a?function(n){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Object.is;console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");var i=r(e);function v(){var t=r(e);if(!a(i,t)){var o=i;n(i=t,o)}}return t.add(v),function(){return t.delete(v)}}(n,r,a):(t.add(n),function(){return t.delete(n)})},destroy:function(){return t.clear()}};return e=n(r,o,a),a}var qd="undefined"===typeof window||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent)?Ad.useEffect:Ad.useLayoutEffect;var Vd=t(258),Wd=t.n(Vd),Hd=t(545);function Xd(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(n,e){return n===e};if(n===e)return!0;if(!n||!e)return!1;var r=n.length;if(e.length!==r)return!1;for(var o=0;o<r;o++)if(!t(n[o],e[o]))return!1;return!0}var Yd=[];function $d(n,e){var t,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=f(Yd);try{for(a.s();!(t=a.n()).done;){var i=t.value;if(Xd(e,i.keys,i.equal)){if(r)return;if(Object.prototype.hasOwnProperty.call(i,"error"))throw i.error;if(Object.prototype.hasOwnProperty.call(i,"response"))return i.response;if(!r)throw i.promise}}}catch(c){a.e(c)}finally{a.f()}var v={keys:e,equal:o.equal,promise:n.apply(void 0,x(e)).then((function(n){return v.response=n})).then((function(){o.lifespan&&o.lifespan>0&&setTimeout((function(){var n=Yd.indexOf(v);-1!==n&&Yd.splice(n,1)}),o.lifespan)})).catch((function(n){return v.error=n}))};if(Yd.push(v),!r)throw v.promise}var Zd,Kd,Jd=["children","key","ref"],Qd=["children","key","ref"],nm=["args","attach"],em=["args","children"],tm=["args","children"],rm=["params"],om=function(n){return n&&n.isOrthographicCamera},am="undefined"!==typeof window&&(null!=(Zd=window.document)&&Zd.createElement||"ReactNative"===(null==(Kd=window.navigator)?void 0:Kd.product))?Ad.useLayoutEffect:Ad.useEffect;function im(n){var e=Ad.useRef(n);return am((function(){e.current=n}),[n]),e}function vm(n){var e=n.set;return am((function(){return e(new Promise((function(){return null}))),function(){return e(!1)}}),[e]),null}var cm=function(n){U(t,n);var e=z(t);function t(){var n;y(this,t);for(var r=arguments.length,o=new Array(r),a=0;a<r;a++)o[a]=arguments[a];return(n=e.call.apply(e,[this].concat(o))).state={error:!1},n}return _(t,[{key:"componentDidCatch",value:function(n){this.props.set(n)}},{key:"render",value:function(){return this.state.error?null:this.props.children}}]),t}(Ad.Component);cm.getDerivedStateFromError=function(){return{error:!0}};var lm="__default";function sm(n){var e="undefined"!==typeof window?window.devicePixelRatio:1;return Array.isArray(n)?Math.min(Math.max(n[0],e),n[1]):n}var um=function(n){var e;return null==(e=n.__r3f)?void 0:e.root.getState()},fm={obj:function(n){return n===Object(n)&&!fm.arr(n)&&"function"!==typeof n},fun:function(n){return"function"===typeof n},str:function(n){return"string"===typeof n},num:function(n){return"number"===typeof n},boo:function(n){return"boolean"===typeof n},und:function(n){return void 0===n},arr:function(n){return Array.isArray(n)},equ:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=t.arrays,o=void 0===r?"shallow":r,a=t.objects,i=void 0===a?"reference":a,v=t.strict,c=void 0===v||v;if(typeof n!==typeof e||!!n!==!!e)return!1;if(fm.str(n)||fm.num(n))return n===e;var l=fm.obj(n);if(l&&"reference"===i)return n===e;var s,u=fm.arr(n);if(u&&"reference"===o)return n===e;if((u||l)&&n===e)return!0;for(s in n)if(!(s in e))return!1;for(s in c?e:n)if(n[s]!==e[s])return!1;if(fm.und(s)){if(u&&0===n.length&&0===e.length)return!0;if(l&&0===Object.keys(n).length&&0===Object.keys(e).length)return!0;if(n!==e)return!1}return!0}};function pm(n){var e={nodes:{},materials:{}};return n&&n.traverse((function(n){n.name&&(e.nodes[n.name]=n),n.material&&!e.materials[n.material.name]&&(e.materials[n.material.name]=n.material)})),e}function dm(n,e){var t=n;return(null!=e&&e.primitive||!t.__r3f)&&(t.__r3f=u({type:"",root:null,previousAttach:null,memoizedProps:{},eventCount:0,handlers:{},objects:[],parent:null},e)),n}function mm(n,e){var t=n;if(e.includes("-")){var r=e.split("-"),o=r.pop();return t=r.reduce((function(n,e){return n[e]}),n),{target:t,key:o}}return{target:t,key:e}}var hm=/-\d+$/;function xm(n,e,t){if(fm.str(t)){if(hm.test(t)){var r=mm(n,t.replace(hm,"")),o=r.target,a=r.key;Array.isArray(o[a])||(o[a]=[])}var i=mm(n,t),v=i.target,c=i.key;e.__r3f.previousAttach=v[c],v[c]=e}else e.__r3f.previousAttach=t(n,e)}function gm(n,e,t){var r,o;if(fm.str(t)){var a=mm(n,t),i=a.target,v=a.key,c=e.__r3f.previousAttach;void 0===c?delete i[v]:i[v]=c}else null==(r=e.__r3f)||null==r.previousAttach||r.previousAttach(n,e);null==(o=e.__r3f)||delete o.previousAttach}function ym(n,e){e.children,e.key,e.ref;var t,o=r(e,Jd),a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=(a.children,a.key,a.ref,r(a,Qd)),v=arguments.length>3&&void 0!==arguments[3]&&arguments[3],l=null!=(t=null==n?void 0:n.__r3f)?t:{},s=Object.entries(o),f=[];if(v)for(var p=Object.keys(i),d=0;d<p.length;d++)o.hasOwnProperty(p[d])||s.unshift([p[d],lm+"remove"]);s.forEach((function(e){var t,r=c(e,2),a=r[0],v=r[1];if((null==(t=n.__r3f)||!t.primitive||"object"!==a)&&!fm.equ(v,i[a])){if(/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(a))return f.push([a,v,!0,[]]);var l=[];for(var s in a.includes("-")&&(l=a.split("-")),f.push([a,v,!1,l]),o){var u=o[s];s.startsWith("".concat(a,"-"))&&f.push([s,u,!1,s.split("-")])}}}));var m=u({},o);return l.memoizedProps&&l.memoizedProps.args&&(m.args=l.memoizedProps.args),l.memoizedProps&&l.memoizedProps.attach&&(m.attach=l.memoizedProps.attach),{memoized:m,changes:f}}function bm(n,e){var t,r,o,a,i=null!=(t=n.__r3f)?t:{},v=i.root,l=null!=(r=null==v||null==v.getState?void 0:v.getState())?r:{},s=(a=e)&&a.memoized&&a.changes?e:ym(n,e),u=s.memoized,f=s.changes,p=i.eventCount;n.__r3f&&(n.__r3f.memoizedProps=u);for(var d=0;d<f.length;d++){var h,y=c(f[d],4),b=y[0],_=y[1],U=y[2],w=y[3],S=n,k=S[b];if(w.length&&(k=w.reduce((function(n,e){return n[e]}),n),!k||!k.set)){var M=g(w.reverse()),z=M[0];S=M.slice(1).reverse().reduce((function(n,e){return n[e]}),n),b=z}if(_===lm+"remove")if(k&&k.constructor)_=m(k.constructor,x(null!=(h=u.args)?h:[]));else if(S.constructor){var C,T=m(S.constructor,x(null!=(C=S.__r3f.memoizedProps.args)?C:[]));_=T[k],T.dispose&&T.dispose()}else _=0;if(U)_?i.handlers[b]=_:delete i.handlers[b],i.eventCount=Object.keys(i.handlers).length;else if(k&&k.set&&(k.copy||k instanceof ko)){var R;if(Array.isArray(_))k.fromArray?k.fromArray(_):(R=k).set.apply(R,x(_));else if(k.copy&&_&&_.constructor&&k.constructor.name===_.constructor.name)k.copy(_);else if(void 0!==_){var D=k instanceof wr;!D&&k.setScalar?k.setScalar(_):k instanceof ko&&_ instanceof ko?k.mask=_.mask:k.set(_);0}}else S[b]=_,!l.linear&&S[b]instanceof Cr&&(S[b].encoding=lt);_m(n)}if(i.parent&&l.internal&&n.raycast&&p!==i.eventCount){var P=l.internal.interaction.indexOf(n);P>-1&&l.internal.interaction.splice(P,1),i.eventCount&&l.internal.interaction.push(n)}return f.length&&null!=(o=n.__r3f)&&o.parent&&Um(n),n}function _m(n){var e,t,r=null==(e=n.__r3f)||null==(t=e.root)||null==t.getState?void 0:t.getState();r&&0===r.internal.frames&&r.invalidate()}function Um(n){null==n.onUpdate||n.onUpdate(n)}function wm(n,e){n.manual||(om(n)?(n.left=e.width/-2,n.right=e.width/2,n.top=e.height/2,n.bottom=e.height/-2):n.aspect=e.width/e.height,n.updateProjectionMatrix(),n.updateMatrixWorld())}function Sm(n,e,t){var r=t.pop(),o=t.reduce((function(n,e){return n[e]}),n);return o[r]=e}function km(n){return(n.eventObject||n.object).uuid+"/"+n.index+n.instanceId}function Mm(n,e,t,r){var o=t.get(e);o&&(t.delete(e),0===t.size&&(n.delete(r),o.target.releasePointerCapture(r)))}function zm(n){function e(n){return n.filter((function(n){return["Move","Over","Enter","Out","Leave"].some((function(e){var t;return null==(t=n.__r3f)?void 0:t.handlers["onPointer"+e]}))}))}function t(e){var t,r=n.getState().internal,o=f(r.hovered.values());try{var a=function(){var n=t.value;if(!e.length||!e.find((function(e){return e.object===n.object&&e.index===n.index&&e.instanceId===n.instanceId}))){var o=n.eventObject.__r3f,a=null==o?void 0:o.handlers;if(r.hovered.delete(km(n)),null!=o&&o.eventCount){var i=u(u({},n),{},{intersections:e});null==a.onPointerOut||a.onPointerOut(i),null==a.onPointerLeave||a.onPointerLeave(i)}}};for(o.s();!(t=o.n()).done;)a()}catch(i){o.e(i)}finally{o.f()}}function r(n,e){for(var t=0;t<e.length;t++){var r=e[t].__r3f;null==r||null==r.handlers.onPointerMissed||r.handlers.onPointerMissed(n)}}return{handlePointer:function(o){switch(o){case"onPointerLeave":case"onPointerCancel":return function(){return t([])};case"onLostPointerCapture":return function(e){var r=n.getState().internal;"pointerId"in e&&r.capturedMap.has(e.pointerId)&&(r.capturedMap.delete(e.pointerId),t([]))}}return function(a){var i=n.getState(),v=i.onPointerMissed,c=i.internal;c.lastEvent.current=a;var l="onPointerMove"===o,s="onClick"===o||"onContextMenu"===o||"onDoubleClick"===o,p=function(e,t){for(var r=n.getState(),o=new Set,a=[],i=t?t(r.internal.interaction):r.internal.interaction,v=0;v<i.length;v++){var c=um(i[v]);c&&(c.raycaster.camera=void 0)}r.previousRoot||null==r.events.compute||r.events.compute(e,r);var l=i.flatMap((function(n){var t,r=um(n);return r&&r.events.enabled&&null!==r.raycaster.camera?(void 0===r.raycaster.camera&&(null==r.events.compute||r.events.compute(e,r,null==(t=r.previousRoot)?void 0:t.getState()),void 0===r.raycaster.camera&&(r.raycaster.camera=null)),r.raycaster.camera?r.raycaster.intersectObject(n,!0):[]):[]})).sort((function(n,e){var t=um(n.object),r=um(e.object);return t&&r&&r.events.priority-t.events.priority||n.distance-e.distance})).filter((function(n){var e=km(n);return!o.has(e)&&(o.add(e),!0)}));r.events.filter&&(l=r.events.filter(l,r));var s,p=f(l);try{for(p.s();!(s=p.n()).done;)for(var d=s.value,m=d.object;m;){var h;null!=(h=m.__r3f)&&h.eventCount&&a.push(u(u({},d),{},{eventObject:m})),m=m.parent}}catch(b){p.e(b)}finally{p.f()}if("pointerId"in e&&r.internal.capturedMap.has(e.pointerId)){var x,g=f(r.internal.capturedMap.get(e.pointerId).values());try{for(g.s();!(x=g.n()).done;){var y=x.value;o.has(km(y.intersection))||a.push(y.intersection)}}catch(b){g.e(b)}finally{g.f()}}return a}(a,l?e:void 0),d=s?function(e){var t=n.getState().internal,r=e.offsetX-t.initialClick[0],o=e.offsetY-t.initialClick[1];return Math.round(Math.sqrt(r*r+o*o))}(a):0;"onPointerDown"===o&&(c.initialClick=[a.offsetX,a.offsetY],c.initialHits=p.map((function(n){return n.eventObject}))),s&&!p.length&&d<=2&&(r(a,c.interaction),v&&v(a)),l&&t(p),function(e,r,o,a){var i=n.getState();e.length&&function(){var n,v={stopped:!1},c=f(e);try{var l=function(){var c=n.value,l=um(c.object)||i,s=l.raycaster,f=l.pointer,p=l.camera,d=l.internal,m=new Or(f.x,f.y,0).unproject(p),h=function(n){var e,t;return null!=(e=null==(t=d.capturedMap.get(n))?void 0:t.has(c.eventObject))&&e},g=function(n){var e={intersection:c,target:r.target};d.capturedMap.has(n)?d.capturedMap.get(n).set(c.eventObject,e):d.capturedMap.set(n,new Map([[c.eventObject,e]])),r.target.setPointerCapture(n)},y=function(n){var e=d.capturedMap.get(n);e&&Mm(d.capturedMap,c.eventObject,e,n)},b={};for(var _ in r){var U=r[_];"function"!==typeof U&&(b[_]=U)}var w=u(u(u({},c),b),{},{pointer:f,intersections:e,stopped:v.stopped,delta:o,unprojectedPoint:m,ray:s.ray,camera:p,stopPropagation:function(){var n="pointerId"in r&&d.capturedMap.get(r.pointerId);if((!n||n.has(c.eventObject))&&(w.stopped=v.stopped=!0,d.hovered.size&&Array.from(d.hovered.values()).find((function(n){return n.eventObject===c.eventObject})))){var o=e.slice(0,e.indexOf(c));t([].concat(x(o),[c]))}},target:{hasPointerCapture:h,setPointerCapture:g,releasePointerCapture:y},currentTarget:{hasPointerCapture:h,setPointerCapture:g,releasePointerCapture:y},nativeEvent:r});if(a(w),!0===v.stopped)return"break"};for(c.s();!(n=c.n()).done&&"break"!==l(););}catch(s){c.e(s)}finally{c.f()}}()}(p,a,d,(function(n){var e=n.eventObject,t=e.__r3f,i=null==t?void 0:t.handlers;if(null!=t&&t.eventCount)if(l){if(i.onPointerOver||i.onPointerEnter||i.onPointerOut||i.onPointerLeave){var v=km(n),u=c.hovered.get(v);u?u.stopped&&n.stopPropagation():(c.hovered.set(v,n),null==i.onPointerOver||i.onPointerOver(n),null==i.onPointerEnter||i.onPointerEnter(n))}null==i.onPointerMove||i.onPointerMove(n)}else{var f=i[o];f?s&&!c.initialHits.includes(e)||(r(a,c.interaction.filter((function(n){return!c.initialHits.includes(n)}))),f(n)):s&&c.initialHits.includes(e)&&r(a,c.interaction.filter((function(n){return!c.initialHits.includes(n)})))}}))}}}}var Cm={};var Tm,Rm=function(n){return!(null==n||!n.render)},Dm=Ad.createContext(null);function Pm(n,e){var t={callback:n};return e.add(t),function(){e.delete(t)}}var jm,Fm,Em=new Set,Im=new Set,Om=new Set,Lm=function(n){return Pm(n,Em)};function Am(n,e){if(n.size){var t,r=f(n.values());try{for(r.s();!(t=r.n()).done;){(0,t.value.callback)(e)}}catch(o){r.e(o)}finally{r.f()}}}function Nm(n,e){switch(n){case"before":return Am(Em,e);case"after":return Am(Im,e);case"tail":return Am(Om,e)}}function Gm(n,e,t){var r=e.clock.getDelta();for("never"===e.frameloop&&"number"===typeof n&&(r=n-e.clock.elapsedTime,e.clock.oldTime=e.clock.elapsedTime,e.clock.elapsedTime=n),jm=e.internal.subscribers,Tm=0;Tm<jm.length;Tm++)(Fm=jm[Tm]).ref.current(Fm.store.getState(),r,t);return!e.internal.priority&&e.gl.render&&e.gl.render(e.scene,e.camera),e.internal.frames=Math.max(0,e.internal.frames-1),"always"===e.frameloop?1:e.internal.frames}function Bm(){var n=Ad.useContext(Dm);if(!n)throw new Error("R3F: Hooks can only be used within the Canvas component!");return n}function qm(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(n){return n},e=arguments.length>1?arguments[1]:void 0;return Bm()(n,e)}function Vm(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=Bm(),r=t.getState().internal.subscribe,o=im(n);return am((function(){return r(o,e,t)}),[e,r,t]),null}function Wm(n,e){return function(t){var r=new t;n&&n(r);for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];return Promise.all(a.map((function(n){return new Promise((function(t,o){return r.load(n,(function(n){n.scene&&Object.assign(n,pm(n.scene)),t(n)}),e,(function(e){return o(new Error("Could not load ".concat(n,": ").concat(e.message,")")))}))}))})))}}function Hm(n,e,t,r){var o=Array.isArray(e)?e:[e],a=function(n,e,t){return $d(n,e,!1,t)}(Wm(t,r),[n].concat(x(o)),{equal:fm.equ});return Array.isArray(e)?a:a[0]}Hm.preload=function(n,e,t){var r=Array.isArray(e)?e:[e];return function(n,e,t){$d(n,e,!0,t)}(Wm(t),[n].concat(x(r)))},Hm.clear=function(n,e){var t=Array.isArray(e)?e:[e];return function(n){if(void 0===n||0===n.length)Yd.splice(0,Yd.length);else{var e=Yd.find((function(e){return Xd(n,e.keys,e.equal)}));if(e){var t=Yd.indexOf(e);-1!==t&&Yd.splice(t,1)}}}([n].concat(x(t)))};var Xm=new Map,Ym=function(n){var e,t,r,o=!1;function a(i){t=requestAnimationFrame(a),o=!0,e=0,Nm("before",i);var v,c=f(n.values());try{for(c.s();!(v=c.n()).done;){var l,s=v.value;!(r=s.store.getState()).internal.active||!("always"===r.frameloop||r.internal.frames>0)||null!=(l=r.gl.xr)&&l.isPresenting||(e+=Gm(i,r))}}catch(u){c.e(u)}finally{c.f()}if(Nm("after",i),0===e)return Nm("tail",i),o=!1,cancelAnimationFrame(t)}return{loop:a,invalidate:function e(t){var r,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(!t)return n.forEach((function(n){return e(n.store.getState())}),i);null!=(r=t.gl.xr)&&r.isPresenting||!t.internal.active||"never"===t.frameloop||(t.internal.frames=Math.min(60,t.internal.frames+i),o||(o=!0,requestAnimationFrame(a)))},advance:function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],r=arguments.length>2?arguments[2]:void 0,o=arguments.length>3?arguments[3]:void 0;if(t&&Nm("before",e),r)Gm(e,r,o);else{var a,i=f(n.values());try{for(i.s();!(a=i.n()).done;){var v=a.value;Gm(e,v.store.getState())}}catch(c){i.e(c)}finally{i.f()}}t&&Nm("after",e)}}}(Xm),$m=Ym.invalidate,Zm=Ym.advance,Km=function(n,e){function t(n,e,t){var o,a=e.args,i=void 0===a?[]:a,v=e.attach,c=r(e,nm),l="".concat(n[0].toUpperCase()).concat(n.slice(1));if("primitive"===n){if(void 0===c.object)throw new Error("R3F: Primitives without 'object' are invalid!");o=dm(c.object,{type:n,root:t,attach:v,primitive:!0})}else{var s=Cm[l];if(!s)throw new Error("R3F: ".concat(l," is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively"));if(!Array.isArray(i))throw new Error("R3F: The args prop must be an array!");o=dm(m(s,x(i)),{type:n,root:t,attach:v,memoizedProps:{args:i}})}return void 0===o.__r3f.attach&&(o instanceof ba?o.__r3f.attach="geometry":o instanceof Jo&&(o.__r3f.attach="material")),"inject"!==l&&bm(o,c),o}function o(n,e){var t,r,o=!1;e&&(null!=(t=e.__r3f)&&t.attach?xm(n,e,e.__r3f.attach):e.isObject3D&&n.isObject3D&&(n.add(e),o=!0),o||null==(r=n.__r3f)||r.objects.push(e),e.__r3f||dm(e,{}),e.__r3f.parent=n,Um(e),_m(e))}function a(n,e,t){var r=!1;if(e){var o,a;if(null!=(o=e.__r3f)&&o.attach)xm(n,e,e.__r3f.attach);else if(e.isObject3D&&n.isObject3D){e.parent=n,e.dispatchEvent({type:"added"});var i=n.children.filter((function(n){return n!==e})),v=i.indexOf(t);n.children=[].concat(x(i.slice(0,v)),[e],x(i.slice(v))),r=!0}r||null==(a=n.__r3f)||a.objects.push(e),e.__r3f||dm(e,{}),e.__r3f.parent=n,Um(e),_m(e)}}function i(n,e){var t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];n&&x(n).forEach((function(n){return v(e,n,t)}))}function v(n,e,t){if(e){var r,o,a;if(e.__r3f&&(e.__r3f.parent=null),null!=(r=n.__r3f)&&r.objects&&(n.__r3f.objects=n.__r3f.objects.filter((function(n){return n!==e}))),null!=(o=e.__r3f)&&o.attach)gm(n,e,e.__r3f.attach);else if(e.isObject3D&&n.isObject3D){var v;n.remove(e),null!=(v=e.__r3f)&&v.root&&function(n,e){var t=n.getState().internal;t.interaction=t.interaction.filter((function(n){return n!==e})),t.initialHits=t.initialHits.filter((function(n){return n!==e})),t.hovered.forEach((function(n,r){n.eventObject!==e&&n.object!==e||t.hovered.delete(r)})),t.capturedMap.forEach((function(n,r){Mm(t.capturedMap,e,n,r)}))}(e.__r3f.root,e)}var c,l=null==(a=e.__r3f)?void 0:a.primitive,s=void 0===t?null!==e.dispose&&!l:t;if(!l)i(null==(c=e.__r3f)?void 0:c.objects,e,s),i(e.children,e,s);e.__r3f&&(delete e.__r3f.root,delete e.__r3f.objects,delete e.__r3f.handlers,delete e.__r3f.memoizedProps,l||delete e.__r3f),s&&e.dispose&&"Scene"!==e.type&&(0,Hd.unstable_scheduleCallback)(Hd.unstable_IdlePriority,(function(){try{e.dispose()}catch(n){}})),_m(n)}}var l=function(){return console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.")},s=Wd()({createInstance:t,removeChild:v,appendChild:o,appendInitialChild:o,insertBefore:a,supportsMutation:!0,isPrimaryRenderer:!1,supportsPersistence:!1,supportsHydration:!1,noTimeout:-1,appendChildToContainer:function(n,e){if(e){var t=n.getState().scene;t.__r3f&&(t.__r3f.root=n,o(t,e))}},removeChildFromContainer:function(n,e){e&&v(n.getState().scene,e)},insertInContainerBefore:function(n,e,t){if(e&&t){var r=n.getState().scene;r.__r3f&&a(r,e,t)}},getRootHostContext:function(){return null},getChildHostContext:function(n){return n},finalizeInitialChildren:function(n){var e,t=null!=(e=null==n?void 0:n.__r3f)?e:{};return Boolean(t.handlers)},prepareUpdate:function(n,e,t,o){if(n.__r3f.primitive&&o.object&&o.object!==n)return[!0];var a=o.args,i=void 0===a?[]:a,v=(o.children,r(o,em)),c=t.args,l=void 0===c?[]:c,s=(t.children,r(t,tm));if(!Array.isArray(i))throw new Error("R3F: the args prop must be an array!");if(i.some((function(n,e){return n!==l[e]})))return[!0];var u=ym(n,v,s,!0);return u.changes.length?[!1,u]:null},commitUpdate:function(n,e,r,a,i,l){var s=c(e,2),u=s[0],p=s[1];u?function(n,e,r,a){var i,c=null==(i=n.__r3f)?void 0:i.parent;if(c){var l=t(e,r,n.__r3f.root);if(n.children){var s,u=f(n.children);try{for(u.s();!(s=u.n()).done;){var p=s.value;p.__r3f&&o(l,p)}}catch(d){u.e(d)}finally{u.f()}n.children=n.children.filter((function(n){return!n.__r3f}))}n.__r3f.objects.forEach((function(n){return o(l,n)})),n.__r3f.objects=[],v(c,n),o(c,l),l.raycast&&l.__r3f.eventCount&&l.__r3f.root.getState().internal.interaction.push(l),[a,a.alternate].forEach((function(n){null!==n&&(n.stateNode=l,n.ref&&("function"===typeof n.ref?n.ref(l):n.ref.current=l))}))}}(n,r,i,l):bm(n,p)},commitMount:function(n,e,t,r){var o,a=null!=(o=n.__r3f)?o:{};n.raycast&&a.handlers&&a.eventCount&&n.__r3f.root.getState().internal.interaction.push(n)},getPublicInstance:function(n){return n},prepareForCommit:function(){return null},preparePortalMount:function(n){return dm(n.getState().scene)},resetAfterCommit:function(){},shouldSetTextContent:function(){return!1},clearContainer:function(){return!1},hideInstance:function(n){var e,t=null!=(e=n.__r3f)?e:{},r=t.attach,o=t.parent;r&&o&&gm(o,n,r),n.isObject3D&&(n.visible=!1),_m(n)},unhideInstance:function(n,e){var t,r=null!=(t=n.__r3f)?t:{},o=r.attach,a=r.parent;o&&a&&xm(a,n,o),(n.isObject3D&&null==e.visible||e.visible)&&(n.visible=!0),_m(n)},createTextInstance:l,hideTextInstance:l,unhideTextInstance:l,getCurrentEventPriority:function(){return e?e():Gd.DefaultEventPriority},beforeActiveInstanceBlur:function(){},afterActiveInstanceBlur:function(){},detachDeletedInstance:function(){},now:"undefined"!==typeof performance&&fm.fun(performance.now)?performance.now:fm.fun(Date.now)?Date.now:function(){return 0},scheduleTimeout:fm.fun(setTimeout)?setTimeout:void 0,cancelTimeout:fm.fun(clearTimeout)?clearTimeout:void 0});return{reconciler:s,applyProps:bm}}(0,(function(){var n,e="undefined"!==typeof self&&self||"undefined"!==typeof window&&window;if(!e)return Gd.DefaultEventPriority;switch(null==(n=e.event)?void 0:n.type){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return Gd.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return Gd.ContinuousEventPriority;default:return Gd.DefaultEventPriority}})),Jm=Km.reconciler,Qm=Km.applyProps,nh={objects:"shallow",strict:!1},eh=function(n,e){var t="function"===typeof n?n(e):n;return Rm(t)?t:new Ec(u({powerPreference:"high-performance",canvas:e,antialias:!0,alpha:!0},n))};function th(n,e){if(e)return e;if(n instanceof HTMLCanvasElement&&n.parentElement){var t=n.parentElement.getBoundingClientRect();return{width:t.width,height:t.height,top:t.top,left:t.left}}return{width:0,height:0,top:0,left:0}}function rh(n){var t=Xm.get(n),o=null==t?void 0:t.fiber,a=null==t?void 0:t.store;t&&console.warn("R3F.createRoot should only be called once!");var i,v="function"===typeof reportError?reportError:console.error,l=a||function(n,e){var t=function(n){var e="function"===typeof n?Bd(n):n,t=function(){var n,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:e.getState,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Object.is,o=(0,Ad.useReducer)((function(n){return n+1}),0),a=c(o,2)[1],i=e.getState(),v=(0,Ad.useRef)(i),l=(0,Ad.useRef)(t),s=(0,Ad.useRef)(r),u=(0,Ad.useRef)(!1),f=(0,Ad.useRef)();void 0===f.current&&(f.current=t(i));var p=!1;(v.current!==i||l.current!==t||s.current!==r||u.current)&&(n=t(i),p=!r(f.current,n)),qd((function(){p&&(f.current=n),v.current=i,l.current=t,s.current=r,u.current=!1}));var d=(0,Ad.useRef)(i);qd((function(){var n=function(){try{var n=e.getState(),t=l.current(n);s.current(f.current,t)||(v.current=n,f.current=t,a())}catch(r){u.current=!0,a()}},t=e.subscribe(n);return e.getState()!==d.current&&n(),t}),[]);var m=p?n:f.current;return(0,Ad.useDebugValue)(m),m};return Object.assign(t,e),t[Symbol.iterator]=function(){console.warn("[useStore, api] = create() is deprecated and will be removed in v4");var n=[t,e];return{next:function(){var e=n.length<=0;return{value:n.shift(),done:e}}}},t}((function(t,r){var o=new Or,a=new Or,i=new Or;function v(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r().camera,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:a,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:r().size,v=t.width,c=t.height,l=t.top,s=t.left,u=v/c;e instanceof Or?i.copy(e):i.set.apply(i,x(e));var f=n.getWorldPosition(o).distanceTo(i);if(om(n))return{width:v/n.zoom,height:c/n.zoom,top:l,left:s,factor:1,distance:f,aspect:u};var p=n.fov*Math.PI/180,d=2*Math.tan(p/2)*f,m=d*(v/c);return{width:m,height:d,top:l,left:s,factor:v/m,distance:f,aspect:u}}var c=void 0,l=function(n){return t((function(e){return{performance:u(u({},e.performance),{},{current:n})}}))},s=new ir,f={set:t,get:r,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},xr:null,invalidate:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return n(r(),e)},advance:function(n,t){return e(n,t,r())},legacy:!1,linear:!1,flat:!1,scene:dm(new Nc),controls:null,clock:new Xf,pointer:s,mouse:s,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:function(){var n=r();c&&clearTimeout(c),n.performance.current!==n.performance.min&&l(n.performance.min),c=setTimeout((function(){return l(r().performance.max)}),n.performance.debounce)}},size:{width:0,height:0,top:0,left:0,updateStyle:!1},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:v},setEvents:function(n){return t((function(e){return u(u({},e),{},{events:u(u({},e.events),n)})}))},setSize:function(n,e,o,i,c){var l=r().camera,s={width:n,height:e,top:i||0,left:c||0,updateStyle:o};t((function(n){return{size:s,viewport:u(u({},n.viewport),v(l,a,s))}}))},setDpr:function(n){return t((function(e){var t=sm(n);return{viewport:u(u({},e.viewport),{},{dpr:t,initialDpr:e.viewport.initialDpr||t})}}))},setFrameloop:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"always",e=r().clock;e.stop(),e.elapsedTime=0,"never"!==n&&(e.start(),e.elapsedTime=0),t((function(){return{frameloop:n}}))},previousRoot:void 0,internal:{active:!1,priority:0,frames:0,lastEvent:Ad.createRef(),interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,subscribe:function(n,e,t){var o=r().internal;return o.priority=o.priority+(e>0?1:0),o.subscribers.push({ref:n,priority:e,store:t}),o.subscribers=o.subscribers.sort((function(n,e){return n.priority-e.priority})),function(){var t=r().internal;null!=t&&t.subscribers&&(t.priority=t.priority-(e>0?1:0),t.subscribers=t.subscribers.filter((function(e){return e.ref!==n})))}}}};return f})),r=t.getState(),o=r.size,a=r.viewport.dpr,i=r.camera;return t.subscribe((function(){var n=t.getState(),e=n.camera,r=n.size,v=n.viewport,c=n.gl,l=n.set;r===o&&v.dpr===a||(o=r,a=v.dpr,wm(e,r),c.setPixelRatio(v.dpr),c.setSize(r.width,r.height,r.updateStyle)),e!==i&&(i=e,l((function(n){return{viewport:u(u({},n.viewport),n.viewport.getCurrentViewport(e))}})))})),t.subscribe((function(e){return n(e)})),t}($m,Zm),s=o||Jm.createContainer(l,Gd.ConcurrentRoot,null,!1,null,"",v,null);t||Xm.set(n,{fiber:s,store:l});var f=!1;return{configure:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},o=t.gl,a=t.size,v=t.events,c=t.onCreated,s=t.shadows,p=void 0!==s&&s,d=t.linear,m=void 0!==d&&d,h=t.flat,x=void 0!==h&&h,g=t.legacy,y=void 0!==g&&g,b=t.orthographic,_=void 0!==b&&b,U=t.frameloop,w=void 0===U?"always":U,S=t.dpr,k=void 0===S?[1,2]:S,M=t.performance,z=t.raycaster,C=t.camera,T=t.onPointerMissed,R=l.getState(),D=R.gl;R.gl||R.set({gl:D=eh(o,n)});var P=R.raycaster;P||R.set({raycaster:P=new kp});var j=z||{},F=j.params,E=r(j,rm);if(fm.equ(E,P,nh)||Qm(P,u({},E)),fm.equ(F,P.params,nh)||Qm(P,{params:u(u({},P.params),F)}),!R.camera){var I=C instanceof Wa,O=I?C:_?new hi(0,0,0,0,.1,1e3):new Ha(75,0,.1,1e3);I||(O.position.z=5,C&&Qm(O,C),null!=C&&C.rotation||O.lookAt(0,0,0)),R.set({camera:O})}if(!R.xr){var L=function(n,e){var t=l.getState();"never"!==t.frameloop&&Zm(n,!0,t,e)},A=function(){var n=l.getState();n.gl.xr.enabled=n.gl.xr.isPresenting,n.gl.xr.setAnimationLoop(n.gl.xr.isPresenting?L:null),n.gl.xr.isPresenting||$m(n)},N={connect:function(){var n=l.getState().gl;n.xr.addEventListener("sessionstart",A),n.xr.addEventListener("sessionend",A)},disconnect:function(){var n=l.getState().gl;n.xr.removeEventListener("sessionstart",A),n.xr.removeEventListener("sessionend",A)}};D.xr&&N.connect(),R.set({xr:N})}if(D.shadowMap){var G=fm.boo(p);if(G&&D.shadowMap.enabled!==p||!fm.equ(p,D.shadowMap,nh)){var B=D.shadowMap.enabled;D.shadowMap.enabled=!!p,G?D.shadowMap.type=q:Object.assign(D.shadowMap,p),B!==D.shadowMap.enabled&&(D.shadowMap.needsUpdate=!0)}}Sm(e,y,["ColorManagement","legacyMode"]);var V=m?ct:lt,W=x?Cn:Pn;D.outputEncoding!==V&&(D.outputEncoding=V),D.toneMapping!==W&&(D.toneMapping=W),R.legacy!==y&&R.set((function(){return{legacy:y}})),R.linear!==m&&R.set((function(){return{linear:m}})),R.flat!==x&&R.set((function(){return{flat:x}})),!o||fm.fun(o)||Rm(o)||fm.equ(o,D,nh)||Qm(D,o),v&&!R.events.handlers&&R.set({events:v(l)}),k&&R.viewport.dpr!==sm(k)&&R.setDpr(k);var H=th(n,a);return fm.equ(H,R.size,nh)||R.setSize(H.width,H.height,H.updateStyle,H.top,H.left),R.frameloop!==w&&R.setFrameloop(w),R.onPointerMissed||R.set({onPointerMissed:T}),M&&!fm.equ(M,R.performance,nh)&&R.set((function(n){return{performance:u(u({},n.performance),M)}})),i=c,f=!0,this},render:function(e){return f||this.configure(),Jm.updateContainer(Ad.createElement(oh,{store:l,children:e,onCreated:i,rootElement:n}),s,null,(function(){})),l},unmount:function(){ah(n)}}}function oh(n){var e=n.store,t=n.children,r=n.onCreated,o=n.rootElement;return am((function(){var n=e.getState();n.set((function(n){return{internal:u(u({},n.internal),{},{active:!0})}})),r&&r(n),e.getState().events.connected||null==n.events.connect||n.events.connect(o)}),[]),Ad.createElement(Dm.Provider,{value:e},t)}function ah(n,e){var t=Xm.get(n),r=null==t?void 0:t.fiber;if(r){var o=null==t?void 0:t.store.getState();o&&(o.internal.active=!1),Jm.updateContainer(null,r,null,(function(){o&&setTimeout((function(){try{var t,r,a,i;null==o.events.disconnect||o.events.disconnect(),null==(t=o.gl)||null==(r=t.renderLists)||null==r.dispose||r.dispose(),null==(a=o.gl)||null==a.forceContextLoss||a.forceContextLoss(),null!=(i=o.gl)&&i.xr&&o.xr.disconnect(),function(n){for(var e in n.dispose&&"Scene"!==n.type&&n.dispose(),n)null==e.dispose||e.dispose(),delete n[e]}(o),Xm.delete(n),e&&e(n)}catch(v){}}),500)}))}}Jm.injectIntoDevTools({bundleType:0,rendererPackageName:"@react-three/fiber",version:Ad.version});Ad.unstable_act;function ih(){return ih=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},ih.apply(this,arguments)}var vh=t(494),ch=t.n(vh);function lh(n){var e=void 0===n?{debounce:0,scroll:!1,offsetSize:!1}:n,t=e.debounce,r=e.scroll,o=e.polyfill,a=e.offsetSize,i=o||("undefined"===typeof window?_((function n(){y(this,n)})):window.ResizeObserver);if(!i)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");var v=c((0,Ad.useState)({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),2),l=v[0],s=v[1],u=(0,Ad.useRef)({element:null,scrollContainers:null,resizeObserver:null,lastBounds:l}),f=t?"number"===typeof t?t:t.scroll:null,p=t?"number"===typeof t?t:t.resize:null,d=(0,Ad.useRef)(!1);(0,Ad.useEffect)((function(){return d.current=!0,function(){d.current=!1}}));var m=(0,Ad.useMemo)((function(){var n=function(){if(u.current.element){var n=u.current.element.getBoundingClientRect(),e={left:n.left,top:n.top,width:n.width,height:n.height,bottom:n.bottom,right:n.right,x:n.x,y:n.y};u.current.element instanceof HTMLElement&&a&&(e.height=u.current.element.offsetHeight,e.width=u.current.element.offsetWidth),Object.freeze(e),d.current&&!fh(u.current.lastBounds,e)&&s(u.current.lastBounds=e)}};return[n,p?ch()(n,p):n,f?ch()(n,f):n]}),[s,a,f,p]),h=c(m,3),x=h[0],g=h[1],b=h[2];function U(){u.current.scrollContainers&&(u.current.scrollContainers.forEach((function(n){return n.removeEventListener("scroll",b,!0)})),u.current.scrollContainers=null),u.current.resizeObserver&&(u.current.resizeObserver.disconnect(),u.current.resizeObserver=null)}function w(){u.current.element&&(u.current.resizeObserver=new i(b),u.current.resizeObserver.observe(u.current.element),r&&u.current.scrollContainers&&u.current.scrollContainers.forEach((function(n){return n.addEventListener("scroll",b,{capture:!0,passive:!0})})))}var S,k,M;return S=b,k=Boolean(r),(0,Ad.useEffect)((function(){if(k){var n=S;return window.addEventListener("scroll",n,{capture:!0,passive:!0}),function(){window.removeEventListener("scroll",n,!0)}}}),[S,k]),M=g,(0,Ad.useEffect)((function(){var n=M;return window.addEventListener("resize",n),function(){window.removeEventListener("resize",n)}}),[M]),(0,Ad.useEffect)((function(){U(),w()}),[r,b,g]),(0,Ad.useEffect)((function(){return U}),[]),[function(n){n&&n!==u.current.element&&(U(),u.current.element=n,u.current.scrollContainers=sh(n),w())},l,x]}function sh(n){var e=[];if(!n||n===document.body)return e;var t=window.getComputedStyle(n);return[t.overflow,t.overflowX,t.overflowY].some((function(n){return"auto"===n||"scroll"===n}))&&e.push(n),[].concat(e,x(sh(n.parentElement)))}var uh=["x","y","top","bottom","left","right","width","height"],fh=function(n,e){return uh.every((function(t){return n[t]===e[t]}))},ph=Object.defineProperty,dh=Object.defineProperties,mh=Object.getOwnPropertyDescriptors,hh=Object.getOwnPropertySymbols,xh=Object.prototype.hasOwnProperty,gh=Object.prototype.propertyIsEnumerable,yh=function(n,e,t){return e in n?ph(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t},bh=function(n,e){for(var t in e||(e={}))xh.call(e,t)&&yh(n,t,e[t]);if(hh){var r,o=f(hh(e));try{for(o.s();!(r=o.n()).done;){t=r.value;gh.call(e,t)&&yh(n,t,e[t])}}catch(a){o.e(a)}finally{o.f()}}return n};function _h(n,e,t){if(n){if(!0===t(n))return n;for(var r=e?n.return:n.child;r;){var o=_h(r,e,t);if(o)return o;r=e?null:r.sibling}}}function Uh(n){try{return Object.defineProperties(n,{_currentRenderer:{get:function(){return null},set:function(){}},_currentRenderer2:{get:function(){return null},set:function(){}}})}catch(e){return n}}var wh=Uh(Ad.createContext(null)),Sh=function(n){U(t,n);var e=z(t);function t(){return y(this,t),e.apply(this,arguments)}return _(t,[{key:"render",value:function(){return Ad.createElement(wh.Provider,{value:this._reactInternals},this.props.children)}}]),t}(Ad.Component),kh=Ad.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,Mh=kh.ReactCurrentOwner,zh=kh.ReactCurrentDispatcher;function Ch(){var n=Ad.useContext(wh);if(!n)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");var e=Ad.useId(),t=Ad.useMemo((function(){var t;return null!=(t=Mh.current)?t:_h(n,!1,(function(n){for(var t=n.memoizedState;t;){if(t.memoizedState===e)return!0;t=t.next}}))}),[n,e]);return t}var Th=[],Rh=new WeakMap;function Dh(){var n,e=Ch();Th.splice(0,Th.length),_h(e,!0,(function(n){var e,t=null==(e=n.type)?void 0:e._context;t&&t!==wh&&Th.push(Uh(t))}));var t,r=f(Th);try{for(r.s();!(t=r.n()).done;){var o=t.value,a=null==(n=zh.current)?void 0:n.readContext(o);Rh.set(o,a)}}catch(i){r.e(i)}finally{r.f()}return Ad.useMemo((function(){return Th.reduce((function(n,e){return function(t){return Ad.createElement(n,null,Ad.createElement(e.Provider,function(n,e){return dh(n,mh(e))}(bh({},t),{value:Rh.get(e)})))}}),(function(n){return Ad.createElement(Sh,bh({},n))}))}),[])}var Ph=["children","fallback","resize","style","gl","events","eventSource","eventPrefix","shadows","linear","flat","legacy","orthographic","frameloop","dpr","performance","raycaster","camera","onPointerMissed","onCreated"],jh={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function Fh(n){var e=zm(n).handlePointer;return{priority:1,enabled:!0,compute:function(n,e,t){e.pointer.set(n.offsetX/e.size.width*2-1,-n.offsetY/e.size.height*2+1),e.raycaster.setFromCamera(e.pointer,e.camera)},connected:void 0,handlers:Object.keys(jh).reduce((function(n,t){return u(u({},n),{},l({},t,e(t)))}),{}),connect:function(e){var t,r=n.getState(),o=r.set,a=r.events;null==a.disconnect||a.disconnect(),o((function(n){return{events:u(u({},n.events),{},{connected:e})}})),Object.entries(null!=(t=a.handlers)?t:[]).forEach((function(n){var t=c(n,2),r=t[0],o=t[1],a=c(jh[r],2),i=a[0],v=a[1];e.addEventListener(i,o,{passive:v})}))},disconnect:function(){var e,t=n.getState(),r=t.set,o=t.events;o.connected&&(Object.entries(null!=(e=o.handlers)?e:[]).forEach((function(n){var e=c(n,2),t=e[0],r=e[1];if(o&&o.connected instanceof HTMLElement){var a=c(jh[t],1)[0];o.connected.removeEventListener(a,r)}})),r((function(n){return{events:u(u({},n.events),{},{connected:void 0})}})))}}}var Eh=Ad.forwardRef((function(n,t){var o=n.children,a=n.fallback,i=n.resize,v=n.style,l=n.gl,s=n.events,f=void 0===s?Fh:s,p=n.eventSource,d=n.eventPrefix,m=n.shadows,h=n.linear,x=n.flat,g=n.legacy,y=n.orthographic,b=n.frameloop,_=n.dpr,U=n.performance,w=n.raycaster,S=n.camera,k=n.onPointerMissed,M=n.onCreated,z=r(n,Ph);Ad.useMemo((function(){return n=e,void(Cm=u(u({},Cm),n));var n}),[]);var C=Dh(),T=c(lh(u({scroll:!0,debounce:{scroll:50,resize:0}},i)),2),R=T[0],D=T[1],P=Ad.useRef(null),j=Ad.useRef(null),F=c(Ad.useState(null),2),E=F[0],I=F[1];Ad.useImperativeHandle(t,(function(){return P.current}));var O=im(k),L=c(Ad.useState(!1),2),A=L[0],N=L[1],G=c(Ad.useState(!1),2),B=G[0],q=G[1];if(A)throw A;if(B)throw B;var V=Ad.useRef(null);D.width>0&&D.height>0&&E&&(V.current||(V.current=rh(E)),V.current.configure({gl:l,events:f,shadows:m,linear:h,flat:x,legacy:g,orthographic:y,frameloop:b,dpr:_,performance:U,raycaster:w,camera:S,size:D,onPointerMissed:function(){return null==O.current?void 0:O.current.apply(O,arguments)},onCreated:function(n){var e;null==n.events.connect||n.events.connect(p?(e=p)&&e.hasOwnProperty("current")?p.current:p:j.current),d&&n.setEvents({compute:function(n,e){var t=n[d+"X"],r=n[d+"Y"];e.pointer.set(t/e.size.width*2-1,-r/e.size.height*2+1),e.raycaster.setFromCamera(e.pointer,e.camera)}}),null==M||M(n)}}),V.current.render(Ad.createElement(C,null,Ad.createElement(cm,{set:q},Ad.createElement(Ad.Suspense,{fallback:Ad.createElement(vm,{set:N})},o))))),am((function(){I(P.current)}),[]),Ad.useEffect((function(){if(E)return function(){return ah(E)}}),[E]);var W=p?"none":"auto";return Ad.createElement("div",ih({ref:j,style:u({position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:W},v)},z),Ad.createElement("div",{ref:R,style:{width:"100%",height:"100%"}},Ad.createElement("canvas",{ref:P,style:{display:"block"}},a)))})),Ih=Ad.forwardRef((function(n,e){return Ad.createElement(Sh,null,Ad.createElement(Eh,ih({},n,{ref:e})))})),Oh=t(250),Lh=function(n){var e,t=new Set,r=function(n,r){var o="function"===typeof n?n(e):n;if(!Object.is(o,e)){var a=e;e=(null!=r?r:"object"!==typeof o)?o:Object.assign({},e,o),t.forEach((function(n){return n(e,a)}))}},o=function(){return e},a={setState:r,getState:o,subscribe:function(n){return t.add(n),function(){return t.delete(n)}},destroy:function(){console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),t.clear()}};return e=n(r,o,a),a},Ah=function(n){return n?Lh(n):Lh},Nh=t(327).useSyncExternalStoreWithSelector,Gh=!1;var Bh=function(n){"function"!==typeof n&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");var e="function"===typeof n?Ah(n):n,t=function(n,t){return function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.getState,t=arguments.length>2?arguments[2]:void 0;t&&!Gh&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),Gh=!0);var r=Nh(n.subscribe,n.getState,n.getServerState||n.getState,e,t);return(0,Ad.useDebugValue)(r),r}(e,n,t)};return Object.assign(t,e),t},qh=function(n){return n?Bh(n):Bh},Vh=qh((function(n,e){return{currentShader:Math.floor(600*Math.random())+1,information:!1,total:0,songPlaying:!1,songStartTime:0,songStatus:"off",startSong:function(){return n((function(n){return{songStatus:"playing"}})),n((function(n){return{songStartTime:Date.now()}})),n((function(n){return{songPlaying:!0}})),e().songStartTime},getSongTime:function(){return e().songStartTime},setSongOn:function(){},setSongOff:function(){n((function(n){return{songStartTime:0}}))},setCurrentShader:function(e){n((function(n){return{currentShader:e}}))},activateInformation:function(){n((function(n){return{information:!0}}))},deactivateInformation:function(){n((function(n){return{information:!1}}))},setTotal:function(e){n((function(n){return{total:e}}))}}})),Wh="\n\n    float sdNumHorizontal(vec2 p)\n    {\n        vec2 newUv = p;\n        newUv.x += 0.125;\n        newUv.y -= 0.25;\n        vec2 uv1 = newUv;\n        vec2 uv2 = newUv;\n        uv1 = Rot(uv1, PI * 0.5);\n        uv1 /= .5;\n        uv1 -= 1.;\n\n        uv2 = Rot(uv2, -PI* .5);\n        uv2 /= .5;\n        uv2 -= 1.;\n        float shape1 = sdEqTriangle(uv1, 0.15);\n        shape1 = 1. - smoothstep(0.1, 0.11, shape1);\n\n        float shape2 = sdBox(vec2(uv1.x + 0.5, uv1.y+0.75), vec2(0.33, 0.2815));\n        shape2 = 1. - smoothstep(0.1, 0.11, shape2);\n\n        float shape3 = sdEqTriangle(vec2(uv2.x, uv2.y-0.5), 0.15);\n        shape3 = 1. - smoothstep(0.1, 0.11, shape3);\n\n        return shape1 + shape2 + shape3;\n    }\n\n    float sdNumVertical(vec2 p){\n        vec2 newUv = p;\n        newUv.x += 0.125;\n        newUv.y -= 0.25;\n        vec2 uv1 = newUv;\n        vec2 uv3 = newUv;\n        vec2 uv4 = newUv;\n        uv1 = Rot(uv1, PI * 0.5);\n        uv1 /= .5;\n        uv1 -= 1.;\n\n        uv3 = Rot(uv3, PI * 1.5);\n        uv3 /= .5;\n        uv3 -= 1.;\n        uv3.x -= 0.2;\n        uv3.y += 0.1;\n\n        uv4 = Rot(uv4, PI * 1.5);\n        uv4 /= .5;\n        uv4 -= 1.;\n        uv4.y += 0.1;\n        uv4.x -= 0.52;\n\n        float shape1 = sdEqTriangle(vec2(uv1.x + 0.36125, uv1.y-0.01), 0.125);\n        shape1 = 1. - smoothstep(0.1, 0.11, shape1);\n\n        float shape4 = sdEqTriangle(vec2(uv3.x, uv3.y), 0.14);\n        shape4 = 1. - smoothstep(0.1, 0.11, shape4);\n\n        float shape5 = sdBox(vec2(uv1.x + 0.859, uv1.y+0.442), vec2(0.35, 0.325));\n        shape5 = 1. - smoothstep(0.1, 0.11, shape5);\n\n        float shape6 = sdEqTriangle(vec2(uv4), 0.14);\n        shape6 = 1. - smoothstep(0.1, 0.11, shape6);\n\n        float tri = ((shape4 + shape6 + shape1 ) );\n        float sq = sdBox(vec2(uv1.x + 0.859, uv1.y +0.442), vec2(0.3));\n        sq = 1. - smoothstep(0.1, 0.11, sq);\n        float shape7 = sdBox(vec2(uv1.x + 0.859, uv1.y+0.442), vec2(0.3));\n        shape7 = 1. - smoothstep(0.1, 0.11, shape7);\n\n        return tri ;\n    }\n\n    float numNine(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float triRB = sdEqTriangle(vec2(p3.x - 0.635, p3.y-0.265), 0.14);\n        triRB = 1. - smoothstep(0.1, 0.11, triRB);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeNine = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4 + triRB;\n\n        return shapeNine;\n    }\n\n    float numEight(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float triRB = sdEqTriangle(vec2(p3.x - 0.635, p3.y-0.265), 0.14);\n        triRB = 1. - smoothstep(0.1, 0.11, triRB);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        // shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeEight = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4;\n\n        return shapeEight;\n    }\n\n    float numSeven(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float triRB = sdEqTriangle(vec2(p3.x - 0.635, p3.y-0.265), 0.14);\n        triRB = 1. - smoothstep(0.1, 0.11, triRB);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeSeven = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4 + triR + triRB;\n\n        return shapeSeven;\n    }\n\n    float numSix(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        // shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeSix = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4;\n\n        return shapeSix;\n    }\n\n    float numFive(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeFive = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4;\n\n        return shapeFive;\n    }\n\n    float numFour(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float triRT = sdEqTriangle(vec2(p3.x + 0.79, p3.y-0.265), 0.14);\n        triRT = 1. - smoothstep(0.1, 0.11, triRT);\n\n        float triRB = sdEqTriangle(vec2(p3.x - 0.635, p3.y-0.265), 0.14);\n        triRB = 1. - smoothstep(0.1, 0.11, triRB);\n\n        float triLT = sdEqTriangle(vec2(p4.x - 0.79, p4.y-0.265), 0.14);\n        triLT = 1. - smoothstep(0.1, 0.11, triLT);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeFour = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4 + triRT + triRB + triLT;\n\n        return shapeFour;\n    }\n\n    float numThree(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeThree = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4;\n\n        return shapeThree;\n    }\n\n    float numTwo(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        // shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        shapevertical4 *= 0.1;\n        \n        float shapeTwo = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4;\n\n        return shapeTwo;\n    }\n\n    float numOne(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float triRT = sdEqTriangle(vec2(p3.x + 0.79, p3.y-0.265), 0.14);\n        triRT = 1. - smoothstep(0.1, 0.11, triRT);\n\n        float triRB = sdEqTriangle(vec2(p3.x - 0.635, p3.y-0.265), 0.14);\n        triRB = 1. - smoothstep(0.1, 0.11, triRB);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        \n        float shapeOne = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4 + triR + triRT + triRB;\n\n        return shapeOne;\n    }\n\n    float numZero(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        // shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        \n        float shapeZero = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4 + triR + triL;\n\n        return shapeZero;\n    }\n\n    float sdZero(vec2 p)\n    {\n        vec2 p2 = p;\n        p2 *= 4.;\n        vec2 p3 = p2;\n        p3 = Rot(p3, PI);\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        float z1 = sdArc(vec2(p2.x - 2., p2.y - 2.4), vec2(a * 0.7, a * 0.7), .36, b * 0.85 );\n        float z2 = sdArc(vec2(p3.x+1., p3.y+0.61), vec2(a * 0.7, a * 0.7), .36, b * 0.85 );\n        z1 = 1. - smoothstep(0.01, 0.02, z1);\n        z2 = 1. - smoothstep(0.01, 0.02, z2);\n        float z3=sdRoundedBox((vec2(p.x+0.088, p.y)), vec2(0.082, 0.275), vec4(0.075));\n        float z4=sdRoundedBox((vec2(p.x-0.088, p.y)), vec2(0.082, 0.275), vec4(0.075));\n        return z1 + z2 + z3 + z4;\n    }\n\n    float sdOne(vec2 p)\n    {\n        p.x -= 0.15;\n        vec2 vUv2 = p;\n        p = p * 2. - 0.5;\n        vUv2 = Rot(vUv2, PI * -0.25);\n        float x1 = sdRoundedBox(vec2(p.x + 0.275, p.y), vec2(0.17, 0.85), vec4(0.1, 0.1, 0.1, 0.1));\n        float x2 = sdRoundedBox(vec2(vUv2.x + 0.24, vUv2.y + 0.05), vec2(0.07, 0.2), vec4(0.1, 0.075, 0.1, 0.075));\n        return x1 + x2;\n    }\n\n    float sdTwo(vec2 p)\n    {\n        p.x += 0.1;\n        vec2 p2 = p;\n        p = p * 2. - 0.5;\n        vec2 p3 = p;\n        p3 = p3 * 2. - 1.;\n        p3.x -= 0.5;\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        p3 = Rot(p3, PI * 1.85);\n        float x1 = sdArc(vec2(p3.x - 0.1, p3.y - 0.15), vec2(a * 0.8, a * 0.8), .35, b * 0.84 );\n        x1 = smoothstep(0.01, 0.02, x1);\n        p2 = Rot(p2, PI * -0.22);\n        float x2 = sdRoundedBox(vec2(p2.x - 0.122, p2.y - 0.05), vec2(0.075, 0.35), vec4(0.2, 0.1, 0.1, 0.1));\n        float x3 = sdRoundedBox(vec2(p.x - 0.25, p.y + 0.335), vec2(0.5, 0.155), vec4(0.1, 0.1, 0.1, 0.1));\n        return 1. - x1 + x2 + x3;\n    }\n\n    float sdThree(vec2 p)\n    {\n        p = p * 2. - 0.5;\n        p *= 1.2;\n        p.y += 0.125;\n        p = Rot(p, PI * -0.5);\n        p = p * 2. - 1.;\n        vec2 p2 = p;\n        vec2 p3 = p;\n        p2 = Rot(p2, PI * -0.7);\n        p3 = Rot(p3, PI * -0.7 * 2.);\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n\n        float x1 = sdArc(vec2(p.x, p.y), vec2(a * 0.8, a * 0.8), .45, b * 0.85 );\n        float x2 = sdArc(vec2(p.x + 0.9, p.y), vec2(a * 0.8, a * 0.8), .45, b * 0.85 );\n        float x3 = sdArc(vec2(p2.x - 1.2, p2.y - 0.39), vec2(a * 0.1, a * 0.1), .45, b * 0.85 );\n        float x4 = sdArc(vec2(p3.x - 0.43, p3.y - 1.99), vec2(a * 0.1, a * 0.1), .45, b * 0.85 );\n\n        x1 = 1. - smoothstep(0.01, 0.02, x1);\n        x2 = 1. - smoothstep(0.01, 0.02, x2);\n        x3 = 1. - smoothstep(0.01, 0.02, x3);\n        x4 = 1. - smoothstep(0.01, 0.02, x4);\n\n        return x1 + x2 + x3 + x4;\n    }\n\n    float sdFour(vec2 p)\n    {\n        float f1 = sdRoundedBox(vec2(p.x + 0.125, p.y - 0.09), vec2(0.07, 0.25), vec4(0.075));\n        float f2 = sdRoundedBox(vec2(p.x - 0.05, p.y + 0.), vec2(0.07, 0.425), vec4(0.075));\n        float f3 = sdRoundedBox(vec2(p.x + 0.00125, p.y - 0.0), vec2(0.3, 0.07), vec4(0.075));\n        return f1 + f2 + f3;\n    }\n\n    float sdFive(vec2 p)\n    {\n        p = p * 1.05;\n        p.x -= 0.05;\n        p.y -= 0.02;\n        float f1=sdRoundedBox((vec2(p.x+0.01, p.y-0.17)), vec2(0.275, 0.08), vec4(0.075));\n        float f2=sdRoundedBox((vec2(p.x + 0.03, p.y+0.17)), vec2(0.225, 0.08), vec4(0.075));\n        float f3=sdRoundedBox((vec2(p.x + 0.03, p.y+0.005)), vec2(0.245, 0.08), vec4(0.075));\n        float f4=sdRoundedBox((vec2(p.x+0.112, p.y-0.09)), vec2(0.08, 0.225), vec4(0.075));\n        vec2 p2 = p;\n        p2 = Rot(p2, PI * -0.5);\n        p2 *=4.;\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        float f5 = sdArc(vec2(p2.x - 2.35, p2.y - 2.09), vec2(a * 0.5, a * 0.5), .36, b * 0.85 );\n        f5 = 1. - smoothstep(0.0, 0.02, f5);\n        return f1 + f2 + f3 + f4 + f5;\n    }\n\n    float sdSix(vec2 p)\n    {\n        vec2 p2 = p;\n        vec2 p4 = p2;\n        p2 *= 4.;\n        vec2 p3 = p2;\n        p3 = Rot(p3, PI);\n        // p4 = Rot(p4, PI * 0.125);\n        p4 *= 4.;\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        float s1 = sdArc(vec2(p2.x - 2., p2.y - 1.7), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float s2 = sdArc(vec2(p3.x+1., p3.y+0.65), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float s3 = sdArc(vec2(p4.x - 1.945, p4.y - 2.35), vec2(a * 0.4, a * 0.4), .36, b * 0.82 );\n        s1 = 1. - smoothstep(0.01, 0.02, s1);\n        s2 = 1. - smoothstep(0.01, 0.02, s2);\n        s3 = 1. - smoothstep(0.01, 0.02, s3);\n        float s4=sdRoundedBox((vec2(p.x+0.092, p.y-0.035)), vec2(0.0725, 0.275), vec4(0.075));\n        return s1 + s2 + s3 + s4;\n    }\n\n    float sdSeven(vec2 p)\n    {\n        vec2 p2 = p;\n        float s1 = sdRoundedBox((vec2(p.x+0.01, p.y-0.17)), vec2(0.275, 0.08), vec4(0.075));\n        p2 = Rot(p2, PI * -0.127);\n        float s2 = sdRoundedBox((vec2(p2.x-0.016, p2.y+0.001)), vec2(0.08, 0.44), vec4(0.075));\n        return s1 + s2;\n    }\n\n    float sdEight(vec2 p)\n    {\n        p *= 4.;\n        vec2 p2 = p;\n        p2 = Rot(p2, PI);\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        float e1 = sdArc(vec2(p.x - 2., p.y - 1.7), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float e2 = sdArc(vec2(p2.x+1., p2.y+0.65), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float e3 = sdArc(vec2(p.x - 2., p.y - 2.45), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float e4 = sdArc(vec2(p2.x+1., p2.y+1.5 * 0.95), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        e1 = 1. - smoothstep(0.01, 0.02, e1);\n        e2 = 1. - smoothstep(0.01, 0.02, e2);\n        e3 = 1. - smoothstep(0.01, 0.02, e3);\n        e4 = 1. - smoothstep(0.01, 0.02, e4);\n        return e1 + e2 + e3 + e4;\n    }\n\n    float sdNine(vec2 p)\n    {\n        p = Rot(p, PI);\n        vec2 p2 = p;\n        vec2 p4 = p2;\n        p2 *= 4.;\n        vec2 p3 = p2;\n        p3 = Rot(p3, PI);\n        // p4 = Rot(p4, PI * 0.125);\n        p4 *= 4.;\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        float n1 = sdArc(vec2(p2.x - 2., p2.y - 1.7), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float n2 = sdArc(vec2(p3.x+1., p3.y+0.65), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float n3 = sdArc(vec2(p4.x - 1.945, p4.y - 2.35), vec2(a * 0.4, a * 0.4), .36, b * 0.82 );\n        n1 = 1. - smoothstep(0.01, 0.02, n1);\n        n2 = 1. - smoothstep(0.01, 0.02, n2);\n        n3 = 1. - smoothstep(0.01, 0.02, n3);\n        float n4=sdRoundedBox((vec2(p.x+0.092, p.y-0.035)), vec2(0.0725, 0.275), vec4(0.075));\n        return n1 + n2 + n3 + n4;\n    }\n",Hh="\n    // #ifdef GL_ES\n    // precision highp float;\n    // #endif\n\n    precision highp float;\n\n    varying vec2 vUv;\n    #define PI 3.14159265359\n    #define TWO_PI 6.28318530718\n    uniform float u_time;\n    uniform vec2 u_resolution;\n    uniform vec2 u_mouse;\n",Xh="\n//iquilezles.org/articls/distfunctions2d\nfloat sdRoundedBox(vec2 p, vec2 b, vec4 r)\n{\n    //p - point\n    //b - size of box\n    //r - round box - top right, bottom right, top left, bottom left\n    p = p * 2.0 - 1.;\n    r.xy = (p.x > 0.0) ? r.xy : r.zw;\n    r.x = (p.y > 0.0) ? r.x : r.y;\n    vec2 q = abs(p)-b+r.x;\n    float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n    return 1. - smoothstep(0.01, 0.015, v);\n}\n\nfloat sdSpiral(vec2 p, float w, float k)\n{\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float n = floor(0.5/w + (log2(r/w)*k-a)/TWO_PI);\n    float ra = w * exp2((a+TWO_PI * (min(n+0., 0.) - 0.5))/k);\n    float rb = w * exp2((a+TWO_PI * (min(n+1., 0.) - 0.5))/k);\n    float d = min(abs(r-ra), abs(r-rb));\n    float spiral = min(d, length(p + vec2(w, 0.0)));\n    return 1. - smoothstep(0.01, 0.011, spiral);\n}\n\nfloat sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n{\n    //x - thickness\n    float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n    float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n    return (c - a);\n    \n}\n\nfloat sdBoxOutline(vec2 p, vec2 b)\n{\n    //p - point \n    //b -\n    p = p * 2.0 - 1.; \n    vec2 d = abs(p) - b;\n    float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n    float y = length(max(d, 0.0)) + min(max(d.x + 0.05, d.y + 0.05), 0.0);\n    // x = 1. - smoothstep(0.01, 0.02, x);\n    // y = 1. - smoothstep(0.01, 0.02, y);\n    return 1.  - smoothstep(0.01, 0.2, y / x);\n}\n\nfloat rect( vec2 vUv, float height, float width)\n{\n    float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.001, vUv.x);\n    float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.001, 1. - vUv.x);\n    float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.001, 1. - vUv.y);\n    float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.001, vUv.y);\n    // return left * right * top * bottom;\n    float x = left * right * top * bottom;\n    // float y = x ;\n    return x;\n}\n\nfloat rectOutline(vec2 vUv, float height, float width)\n{\n    float y = rect(vUv, height, width);\n    float x = rect(vUv, height + 0.01, width + 0.01);\n    return x - y;\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    //p - point \n    //b -\n    p = p * 2.0 - 1.; \n    vec2 d = abs(p) - b;\n    float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n    return smoothstep(0.01, 0.012, x);\n}\n\nfloat quadraticBezier (float x, vec2 a){\n    // adapted from BEZMATH.PS (1993)\n    // by Don Lancaster, SYNERGETICS Inc. \n    // http://www.tinaja.com/text/bezmath.html\n  \n    float epsilon = 0.00001;\n    a.x = clamp(a.x,0.0,1.0); \n    a.y = clamp(a.y,0.0,1.0); \n    if (a.x == 0.5){\n      a += epsilon;\n    }\n    \n    // solve t from x (an inverse operation)\n    float om2a = 1.0 - 2.0 * a.x;\n    float t = (sqrt(a.x*a.x + om2a*x) - a.x)/om2a;\n    float y = (1.0-2.0*a.y)*(t*t) + (2.0*a.y)*t;\n    return y;\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise2D(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat IterateMandelbrot( in vec2 c )\n{\n    const float B = 256.0;\n\n    float n = 0.0;\n    vec2 z  = vec2(0.);\n    for( int i=0; i<120; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c; // z = z\xb2 + c\n        if( dot(z,z)>(B*B) ) break;\n        n += 1.0 * u_time;\n    }\n\n    // float sn = n - log(log(length(z))/log(B))/log(2.0); // smooth iteration count\n    float sn = n - log2(log2(dot(z,z))) + 4.0;  // equivalent optimized smooth iteration count\n    \n    return sn;\n}\n\nfloat plot(vec2 p, float line, float thickness)\n{\n    return smoothstep(line - thickness, line, p.y) -\n           smoothstep(line, line + thickness, p.y);\n}\n\nfloat sdCircle(vec2 p, float r)\n{\n    p = p * 2.0 - 1.;\n    float x = length(p) - r;\n    return 1. - smoothstep(0.01, 0.03, x);\n}\n\nfloat sdCircleOutline(vec2 p, float r)\n{\n    p = p * 2.0 - 1.;\n    float x = length(p) - r;\n    float y = length(p) - r + 0.05;\n    float x1 = 1. - smoothstep(0.01, 0.03, x);\n    float y1 = 1. - smoothstep(0.01, 0.03, y);\n    return x1 - y1;\n}\n\nfloat circle(vec2 vUv, float radius)\n{\n    vec2 dist = vUv - vec2(0.5);\n    return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n}\n\nfloat cirOutline(vec2 vUv, float r)\n{\n    vec2 dist = vUv - vec2(0.5);\n    float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n    // float b = 1. - smoothstep(r + 0.01 - ((r + 0.01)), r + 0.01 + ((r + 0.02)), dot(dist, dist) * 4.);\n    float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.01), r + 0.01 + ((r + 0.011) * 0.012), dot(dist, dist) * 4.);\n    return b - a;\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n    float v = length(pa - ba * h);\n    return 1. - smoothstep(0.01, 0.015, v);\n}\n\nvec2 Rot(vec2 vUv, float a){\n    vUv -= 0.5;\n    vUv = mat2(cos(a), -sin(a),\n            sin(a), cos(a)) * vUv;\n    vUv += 0.5;\n    return vUv;\n}\n\nfloat ndot(vec2 a, vec2 b)\n{\n    return a.x * b.x - a.y * b.y;\n}\n\nfloat sdRhombus(vec2 p, vec2 b)\n{\n    p = abs(p);\n    float h = clamp(ndot(b-2. *p, b) / dot(b, b), -1., 1.);\n    float d = length(p - 0.5* b*vec2(1.0-h, 1.0+h));\n    return d * sign(p.x * b.y + p.y * b.x - b.x*b.y);\n}\n\nfloat dot2(vec2 a)\n{\n    return dot(a.x, a.y);\n}\n\nfloat trapezoid(vec2 p, float r1, float r2, float he)\n{\n    vec2 k1 = vec2(r2, he);\n    vec2 k2 = vec2(r2-r1, 2.0 * he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x, (p.y<0.)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2 * clamp(dot(k1-p,k2)/dot2(k2), 0., 1.);\n    float s = (cb.x < 0. && ca.y<0.)? -1.: 1.;\n    return s*sqrt(min(dot(ca, ca),dot(cb, cb)));\n}\n\nfloat sdEqTriangle(vec2 p, float size)\n{\n    p = p / size;\n    float k = sqrt(3.);\n    p.x = abs(p.x) - 1.;\n    p.y = p.y + 1.0/k;\n    if(p.x+k*p.y > 0.)\n    {\n        p = vec2(p.x-k*p.y, -k*p.x-p.y)/2.0; \n    }\n    p.x -= clamp(p.x, -2., 0.);\n    return -length(p) * sign(p.y);\n}\n\nfloat sdEqTriangleOutline(vec2 p, float size)\n{\n    float x = 1. - sdEqTriangle(p, size);\n    float y = 1. - sdEqTriangle(p, size + 0.025);\n    x = smoothstep(0.01, 0.021, x);\n    y = smoothstep(0.01, 0.021, y);\n    return y - x;\n}\n\nfloat sdArc(vec2 p, vec2 sc, float ra, float rb){\n    //sc is arc's aperture\n    p.x = abs(p.x);\n    sc = vec2(sin(sc.x), cos(sc.y));\n    if (sc.y * p.x > sc.x * p.y){\n        return length(p - sc*ra) - rb;\n    }\n    else {\n        return abs(length(p) - ra) - rb;\n    }\n}\n\nfloat sdTriIsosceles(vec2 p, vec2 q)\n{\n    p = Rot(p, PI);\n    p.x = abs(p.x);\n    vec2 a = p - q * clamp(dot(p,q)/dot(q,q), 0.0, 1.0);\n    vec2 b = p - q * vec2( clamp(p.x/q.x, 0., 1.), 1.);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a,a), s*(p.x*q.y-p.y*q.x)), \n                vec2(dot(b,b), s*(p.y-q.y)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdHexagram(vec2 p, float r)\n{\n    vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy, p), 0.0) * k.xy;\n    p -= 2.0 * min(dot(k.yx, p), 0.0) * k.yx;\n    p -= vec2(clamp(p.x, r*k.z, r*k.w), r);\n    return length(p) * sign(p.y);\n}\n\nfloat sdEgg(vec2 p, float ra, float rb)\n{\n    float k = sqrt(3.);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y < 0.0) ? length(vec2(p.x, p.y)) - r :\n            (k * (p.x + r) < p.y) ? length(vec2(p.x, p.y - k * r)) :\n            length(vec2(p.x + r, p.y)) -2.0 * r) - rb;\n}\n\nfloat sdPolygon(vec2 p, int sides, float scale)\n{\n    p = p * 2. - 1.;\n    float angle = atan(p.x, p.y) + PI;\n    float radius = TWO_PI/float(sides);\n    float d = cos(floor(.5 + angle/ radius) * radius - angle) * length(p);\n    return 1. - smoothstep(scale, scale + 0.01, d); \n}\n\nfloat sdPolygonOutline(vec2 p, int sides, float scale)\n{\n    float x = sdPolygon(p, sides, scale);\n    float y = sdPolygon(p, sides, scale + 0.05);\n    return y - x;\n}\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod(Pi0, 289.0);\n    Pi1 = mod(Pi1, 289.0);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 / 7.0;\n    vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 / 7.0;\n    vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n    return 2.2 * n_xyz;\n}\n\nfloat Sphere_SDF(vec3 point, float radius)\n{\n    return length(point) - radius;\n}\n\nfloat Box_SDF(vec3 point, vec3 size)\n{\n    vec3 q = abs(point) - size;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat Plane_SDF(vec3 point, vec3 normal, float h)\n{\n    return dot(point, normal) + h;\n}\n\nfloat Smooth_Difference_SDF(float shape1, float shape2, float value) \n{\n    float h = clamp(0.5 - 0.5 * (shape2 + shape1) / value, 0., 1.);\n    return mix(shape2, -shape1, h) + value * h * (1. - h);\n}\n\nfloat Smooth_Union_SDF( float shape1, float shape2, float value)\n{\n    float h = clamp( 0.5 + 0.5 * (shape2 - shape1)/value, 0., 1.);\n    return mix(shape2, shape1, h) - value * h * (1. - h);\n}\n\nfloat Smooth_Intersection_SDF(float shape1, float shape2, float value)\n{\n    float h = clamp(0.5 - 0.5 * (shape2 - shape1)/ value, 0., 1.);\n    return mix(shape2, shape1, h) + value * h * (1. - h);\n}\n\n",Yh=t(184),$h=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Zh(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$h,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Kh=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Jh(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Kh,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qh=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Qh,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ex=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ex,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ox(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ax=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ix(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ax,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ux=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ux,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var px=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:px,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _x=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Ux(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_x,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Sx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Mx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float circleSDF(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float circleSDF2(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float circleSDF3(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float circleSDF4(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float circleSDF5(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float circleSDF6(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float stroke(float x, float s, float w){\n        float d = step(s, x+w*.5) -\n                  step(s, x-w*.5);\n        return clamp(d, 0., 1.);\n    }\n    \n    \n    \n    void main(){\n        vec3 color = vec3(0.);\n    \n        color.rg += stroke(circleSDF(vec2(vUv.x + .125, vUv.y - 0.08)), 0.2, 0.03);\n        color.b += stroke(circleSDF2(vec2(vUv.x + .3 - .05, vUv.y - .2)), 0.2, 0.03);\n        color += stroke(circleSDF(vec2(vUv.x , vUv.y - .2)), 0.2, 0.03);\n        color.g += stroke(circleSDF(vec2(vUv.x - .124, vUv.y - .08)), 0.2, 0.03);\n        color.r += stroke(circleSDF(vec2(vUv.x  - .4 + .15, vUv.y - .2)), 0.2, 0.03);;\n        //color += stroke(circleSDF6(vec2(vUv)), 0.5, 0.02);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Cx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Tx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    void main(){\n        vec3 color = vec3(0.);\n        color.gb += vUv.x - (sin(u_time) ) * 0.35;\n        color.gb *= vUv.y - (sin(u_time) ) * 0.35;\n        color.gb -= 0.1;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Rx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Tx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Dx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n\n// 2D Random\nfloat random(in vec2 st){\n    return fract(sin(dot(st.xy,\n                vec2(12.9898,78.233)))\n            *43758.5453123);\n        }\n\nfloat noise(in vec2 st){\n    vec2 i=floor(st);\n    vec2 f=fract(st);\n    \n    // Four corners in 2D of a tile\n    float a=random(i);\n    float b=random(i+vec2(1.,0.));\n    float c=random(i+vec2(0.,1.));\n    float d=random(i+vec2(1.,1.));\n    \n    // Smooth Interpolation\n    \n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u=f*f*(3.-2.*f);\n    // u = smoothstep(0.,1.,f);\n    \n    // Mix 4 coorners percentages\n    return mix(a,b,u.x)+\n    (c-a)*u.y*(1.-u.x)+\n    (d-b)*u.x*u.y;\n}\n\nvoid main(){\n    vec3 color = vec3(0.);\n    vec2 pos = vec2(vUv * 5.);\n    float n = step(noise(pos + u_time), vUv.x);\n    float x = cnoise(vec3(n * vUv.y * u_time));\n    color += x * n - abs(sin(u_time));\n    color *= x + n + abs(sin(u_time));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Px(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Dx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float plot(vec2 vUv){\n        return smoothstep(0.02, 0.0, abs(vUv.y - vUv.x));\n    }\n    \n    float plot2(vec2 vUv){\n        return smoothstep(.02,0.,abs(1. - vUv.y-vUv.x));\n    }\n    \n    \n    void main(){\n        float y = (sin(vUv.x) + abs(cos(u_time)) - 0.5);\n        vec3 color = vec3(y);\n        float pct = plot(vUv);\n        float pct2=plot2(vUv);\n        color = (0.5 - pct) * color + pct* vec3(1., 0., 0.);\n        color+=(0.5 - pct2)*color+pct2*vec3(1.,0.,0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Fx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ex=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // float plot(vec2 st){\n//     return smoothstep(0.02, 0.0, abs(st.y - st.x));\n// }\n\nfloat plot2(vec2 st, float pct){\n    return smoothstep(pct - 0.02, pct, st.y) - \n            smoothstep(pct, pct + 0.02, st.y);\n}\n\n// float plot(vec2 vUv, float pct){\n//     return smoothstep(pct-0.02, pct, vUv.y) - \n//            smoothstep(pct, pct+0.02, vUv.y);\n// }\n\nvoid main(){\n    //float y = vUv.x;\n    //float y2 = pow(vUv.x, 20.0);\n    //float y2 = sqrt(vUv.x * PI);\n    //float y = smoothstep(vUv, y);\n    float y2 = smoothstep(0.01, 0.9, abs(vUv.x * sin(u_time)));\n\n    vec3 color = vec3(y2);\n\n    float pct2 = plot2(vUv, y2);\n    color = (1.0 - pct2) * color + pct2 * vec3(1., 0., 0.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Ix(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ex,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ox=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float plot( vec2 st, float pct){\n        return smoothstep(pct - 0.02, pct, st.y) - \n               smoothstep(pct, pct + 0.02, st.y);\n    }\n    \n    void main(){\n        float y = abs(sin((vUv.x * PI) + u_time) * 0.5) ;\n        y /= abs(cos((vUv.y * PI) + u_time) * 0.5);\n        vec3 color = vec3(tan(y + u_time));\n        gl_FragColor = vec4(color, 0.2);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Lx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ox,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ax=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    void main(){\n        float y = smoothstep(0.2, 0.5, vUv.x) - smoothstep(0.5, 0.8, vUv.x);\n        y+= smoothstep(0.2, 0.5, vUv.y) - smoothstep(0.5, 0.8, vUv.y);\n        y -= abs(cos(u_time * 0.5));\n        vec3 color = vec3(abs(sin(y + u_time)));\n        color.x = sin(u_time);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Nx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ax,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Gx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    void main(){\n        float y = step(distance(abs(sin(u_time)), abs(sin(PI))), vUv.x);\n        float x = step(distance(abs(sin(u_time)), abs(cos(PI))), vUv.y);\n        vec3 color = vec3(y * x);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Bx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Gx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    void main(){\n        //float y=step(.5,vUv.x);\n        float y = step(abs(sin(u_time * 0.2)),vUv.y);\n        float x =step(abs(cos(u_time * 0.8)),vUv.x);\n        float z =step(abs(sin(u_time * 0.5)),vUv.y);\n    \n    \n        vec3 color=vec3(y, x, z);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Vx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Wx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float plot(vec2 st,float pct){\n        return abs(smoothstep(pct-.1,pct,st.y)-\n        smoothstep(pct,pct+.1,st.y));\n    }\n    \n    void main(){\n        float y = smoothstep(0.01, 0.99, vUv.x);\n        float x=smoothstep(.01,.99,vUv.y);\n        vec3 color = vec3(0.);\n    \n        float pct = plot(sin(vUv * u_time * PI),sin(y * u_time * 0.5 * PI));\n        float pct2 =plot(cos(vUv * u_time),cos(x * u_time * 0.5));\n    \n        color = (1. - pct) * color + pct * vec3(0., 1., 0.);\n        color *=(1.-pct2)*color+pct2*vec3(0.,1.,0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Hx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Wx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Xx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float plot(vec2 vUv, float pct){\n        return smoothstep(pct-0.01, pct, vUv.y) - \n                smoothstep(pct, pct + 0.1, vUv.y);\n    }\n    \n    \n    void main(){\n        float y = smoothstep(0.1 + abs(atan(u_time)), 0.9 - abs(atan(u_time)) , 0.5 + abs(tan(vUv.x * 20. * abs(cos(u_time * 0.25)))));\n        float x = smoothstep(0.9 - abs(atan(u_time)), 0.1 + abs(atan(u_time)),0.5 +  abs(tan(vUv.y * 20. *abs(cos(u_time * 0.25)))));\n        vec3 color = vec3(y * x);\n    \n        float pct = plot(vUv, (y * x) );\n        color = (1.0 - pct) * color + pct * vec3(0., 1., 0.);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Yx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Xx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $x=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    void main(){\n        float y = step(vUv.x, abs(cos((vUv.y + u_time))) * abs(cos((vUv.y + u_time) * 1.)) * abs(sin(vUv.y + u_time)) * abs(sin((vUv.y + u_time) * 2.)));\n        vec3  color = vec3(y);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Zx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$x,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Kx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    void main(){\n        float y = mod(cos(vUv.y * u_time) + 1., cos(PI +PI +sin(u_time)));\n        float x = mod(cos(vUv.x * u_time) + 1., cos(PI + PI +sin(u_time)));\n        vec3 color = vec3(y-x, x/y, x*y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Jx(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Kx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qx=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 getRadialUv(vec2 vUv){\n        float angle = atan(vUv.x, vUv.y);\n        vec2 radialUv = vec2(0.);\n        radialUv.x = angle/(PI * 2. ) + .9 *abs(cos(u_time));\n        radialUv.y = 1. - pow(1. - length(vUv), 4.);\n        return radialUv;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv -= 0.5;\n        vec2 radialUv = getRadialUv(vUv);\n        vec2 color = vec2(radialUv);\n        gl_FragColor = vec4(color, 1., 0.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ng(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Qx,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Exponential impulse iquilezles.org\nfloat expImpulse(float x, float k){\n    float h = k*x;\n    return h* exp(1.-h);\n}\n\n//sinc curve original iquilezles.org\n// float sinc(float x,float k)\n// {\n//     float a=PI*((k*x-1.);\n//     return sin(a)/a;\n// }\n\n//Sinc curve  - modified\nfloat sinc(float x, float k){\n    float a = PI * ((k*x - 0.5));\n    return abs(sin(a))/ abs(cos(a));\n}\n\nvoid main(){\n    // float y = expImpulse(vUv.x, vUv.y / sin(u_time * 0.02) * 10.0);\n    float y=sinc(sin(vUv.y * 20.), sin(u_time * 0.25));\n    float x=sinc(sin(vUv.x * 20.), sin(u_time * 0.25));\n    vec3 color = vec3(cos(y) + sin(x));\n    gl_FragColor = vec4(y * x + vUv.x, vUv.y, 0.5, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:eg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float plot(vec2 st, float pct){\n        return  smoothstep( pct-0.02, pct, st.y) -\n                smoothstep( pct, pct+0.02, st.y);\n      }\n      \n      void main(){\n          float y = 0.1 * cos((10.0 * vUv.x) + (5. *  u_time));\n          float line = smoothstep(1. - clamp(distance(y + (sin(vUv.y)), 0.5) * 1., 0., 1.), 1., 0.99);\n          float line2 = smoothstep(1. - clamp(distance(y + (cos(vUv.y)), 0.5) * 1., 0., 1.), 1., 0.99);\n          vec3 color = vec3(line + line2);\n      \n          float pct = plot(vUv, sin(line));\n          color = (1. - line) * color + sin(pct) * vec3(0., 0., 0.);\n      \n          gl_FragColor = vec4(color, 1.);\n      }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function og(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ag=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float sinc(float x, float k){\n        float a = PI * ((k * x) - 1.);\n        return sin(a)/a;\n    }\n    \n    //plot function from bookofshaders.com\n    float plot(vec2 vUv, float pct){\n        return smoothstep(pct - 0.01, pct, vUv.y) -\n               smoothstep(pct, pct + 0.1, vUv.y);\n    }\n    \n    \n    void main(){\n        float y = sinc(u_time, vUv.x);\n        vec3 color = vec3(y);\n        float pct = plot(vUv * 1.75 -0.5, y);\n        color = vec3(1. - pct);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ig(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ag,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float sinc(float x,float k){\n        float a=PI*((k*x)-1.);\n        return sin(a)/a;\n    }\n    \n    //exponential impulse iquilezles.org\n    float expImpulse(float x,float k)\n    {\n        float h=k*x;\n        return h*exp(1.-h);\n    }\n    float expImpulse2(float x,float k)\n    {\n        float h=(k + 0.25)*x;\n        return h*exp(1.-h);\n    }\n    float expImpulse3(float x,float k)\n    {\n        float h=(k + 0.5)*x;\n        return h*exp(1.-h);\n    }\n    \n    //plot function from bookofshaders.com\n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-.01,pct,vUv.y)-\n        smoothstep(pct,pct+.1,vUv.y);\n    }\n    \n    void main(){\n        float y=expImpulse(u_time,clamp(vUv.x, 0.0, 1.0));\n        float x=expImpulse2(u_time,clamp(vUv.x, 0.0, 1.0));\n        float z=expImpulse3(u_time,clamp(vUv.x,0.,1.));\n    \n        vec3 color=vec3(y);\n        float pct=plot(vUv*1.75-.5,y);\n        float pct2=plot(vUv*1.75-.5,x);\n        float pct3=plot(vUv*1.75-.5,z);\n        color=vec3(1.-pct);\n        color*=vec3(1.-pct2);\n        color*=vec3(1.-pct3);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float plot(vec2 st, float pct){\n        return  smoothstep( pct-0.02, pct, st.y) -\n                smoothstep( pct, pct+0.02, st.y);\n      }\n      \n      void main(){\n          float a = sin(vUv.x * u_time) * 0.25 + 0.5;//sin\n          float b = cos(vUv.x * u_time) * 0.25 + 0.5;//cos\n      \n          vec3 color = vec3(1.0);\n      \n          float pct = plot(vUv, a);\n          float pct2 = plot(vUv, b);\n      \n          color *= (1.0 - pct) * color + pct * vec3(1.0, 0.0, 0.0);\n          color *= (1.0 - pct2) * color + pct2 * vec3(0.0, 0.0, 1.0);\n          \n          gl_FragColor = vec4(color, 1.);\n      }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ug=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float plot(vec2 st, float pct){\n        return  smoothstep( pct-0.02, pct, st.y) -\n                smoothstep( pct, pct+0.02, st.y);\n      }\n      \n      //parabola iquilezles.org\n      float parabola( float x, float k ){\n          return pow(4.0 * x * (1.0 - x), k);\n      }\n      \n      \n      void main(){\n          float y = parabola(vUv.x, 2. + (sin(u_time)));\n          float x = parabola(vUv.x, 4. + (sin(u_time)));\n          float z = parabola(vUv.x, 8. + (sin(u_time)));\n          vec3 color = vec3(0.);\n      \n          float pct = plot(vUv, y);\n          float pct2 = plot(vUv, x);\n          float pct3 = plot(vUv, z);\n      \n          color = (1.0-pct)*color+pct*vec3(0.0,1.0,0.0);\n          color += (1.0-pct2)*color+pct2*vec3(1.0,0.0,0.0);\n          color += (1.0-pct3)*color+pct3*vec3(0.0,0.0,1.0);\n      \n          gl_FragColor = vec4(color, 1.);\n      }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ug,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //plot function bookofshaders\n    float plot(vec2 st, float pct){\n        return  smoothstep( pct-0.02, pct, st.y) -\n                smoothstep( pct, pct+0.02, st.y);\n    }\n    \n    //easing functions easings.net/#easeInElastic\n    float easeInElastic(float x){\n        float y = (2.0 * PI) / 3.;\n        return (1.0 - pow(2., 10. * x - 10.) * sin((x * 10. - 10.75) * y - (u_time * u_time * (0.25)))) ;\n    }\n    \n    void main(){\n        float y = easeInElastic(vUv.x) - 0.5;\n    \n        vec3 color = vec3(y);\n    \n        float pct = plot(vUv, y);\n        color = pct * vec3(0., 1., 0.);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //plot function bookofshaders\nfloat plotY(vec2 st, float pct){\n    return  smoothstep( pct-0.2, pct, st.y + 0.5) -\n            smoothstep( pct, pct+0.2, st.y + 0.5);\n  }\n  \n  float plotX(vec2 st, float pct){\n    return  smoothstep( pct-0.2, pct, st.x + 0.5) -\n            smoothstep( pct, pct+0.2, st.x + 0.5);\n  }\n  \n  //easing functions easings.net/#easeInElastic\n  float easeInElastic(float x){\n      float y = (2.0 * PI) / 3.;\n      return (1.0 - pow(2., 10. * x - 10.) * sin((x * 10. - 10.75) * y - (u_time * 2.0 ))) ;\n  }\n  \n  void main(){\n      float y =  easeInElastic(vUv.x) - 0.25;\n      float x =  easeInElastic(vUv.y) - 0.25;\n      float z = easeInElastic(1. - vUv.x) - 0.5;\n      float a = easeInElastic(1. - vUv.y) - 0.5;\n  \n      vec3 color = vec3(y);\n  \n      float pct = plotY(vUv, y + 0.25);\n      float pct2 = plotX(vUv, x + 0.25);\n      float pct3 = plotY(vUv, z);\n      float pct4 = plotX(vUv, a);\n  \n      color = pct * vec3(1., 0., 0.);\n      color *= pct2 * vec3(1., 1., 0.);\n      //color *= pct3 * vec3(0., 1., 0.);\n      //color += pct4 * vec3(1., 0., 0.);\n  \n      gl_FragColor = vec4(color, 1.);\n  }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders plot function\nfloat plot(vec2 st,float pct){\n    return smoothstep(pct-.8,pct,st.y)-\n    smoothstep(pct,pct+.8,st.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(atan(vUv.x - 0.5, vUv.y - 0.5) * u_time * sin(u_time * 0.5));\n    float x = sin(vUv.x);\n    float y = sin(vUv.y);\n    vec3 color = vec3(x);\n    color += vec3(y);\n\n    //float pct = plot(vUv, y);\n    //color += pct * vec3(0.0, 1.0, 1.0);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //sinc curve iquilezles.org\nfloat sinc(float x,float k){\n    float a=PI*((k*x)-1.);\n    return sin(a)/a ;\n}\n\n//plot function bookofshaders\nfloat plot(vec2 st, float pct){\n  \n  return  smoothstep( pct-0.02, pct, st.x + 0.5) -\n          smoothstep( pct, pct+0.2, st.x + 0.5);\n}\n\nfloat plot2(vec2 st, float pct){\n  \n  return  smoothstep( pct-0.02, pct, st.y + 0.5) -\n          smoothstep( pct, pct+0.2, st.y + 0.5);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vUv -= 0.5; \n    float y = sinc((vUv.y - 0.5 * PI), u_time  * 0.5);\n    float x = sinc((vUv.x - 0.5 * PI), u_time  * 0.5);\n    \n    vec3 color = vec3(0.);\n\n    float pct = plot(vUv - 0.5, y);\n    float pct2 = plot2(vUv - 0.5, x);\n\n    color += pct * vec3(1., 0., 0.);\n    color *= pct2 * vec3(1., 0., 0.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _g=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //plot function bookofshaders\nfloat plotY(vec2 st, float pct){\n    return  smoothstep( pct-0.02, pct, st.y +2.5) -\n            smoothstep( pct, pct+0.25, st.y + 2.5);\n  }\n  \n  //easing functions easings.net/#easeInElastic\n  float easeInElastic(float x){\n      float y = (2.0 * PI) / 3.;\n      return (1.0 - pow(2., 10. * x - 10.) * sin((x * 10. - 10.75) * y - (u_time * 1.5 ))) ;\n  }\n  \n  void main(){\n      vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.7);\n      vUv *= 2.75;\n      float y = easeInElastic(abs(sin(vUv.x)) * 1.25);\n      float x = easeInElastic(abs(cos(vUv.y)) * 1.25);\n  \n      vec3 color = vec3(0.);\n  \n      float pct = plotY(vUv, y * x);\n      color += pct  * vec3(0., 1., 1.);\n  \n      gl_FragColor = vec4(color, 1.);\n  }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Ug(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_g,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //plot function bookofshaders\nfloat plotY(vec2 st, float pct){\n    return  smoothstep( pct-.02, pct, st.y + 0.5) -\n            smoothstep( pct, pct+.25, st.y + 0.5);\n  }\n  \n  float plotX(vec2 st, float pct){\n    return  smoothstep( pct-.02, pct, st.x + 0.5) -\n            smoothstep( pct, pct+.25, st.x + 0.5);\n  }\n  \n  \n  //easing functions easings.net/#easeInElastic\n  float easeInElastic(float x){\n      float y = (2.0 * PI) / 3.;\n      return (1.0 - pow(2., 10. * x - 10.) * cos((x * 10. - 10.75) * y - (u_time * 2.0 ))) ;\n  }\n  \n  float easeInElastic2(float x){\n      float y = (2.0 * PI) / 3.;\n      return (1.0 - pow(2., 10. * x - 10.) * sin((x * 10. - 10.75) * y - (u_time * 2.0 ))) ;\n  }\n  \n  void main(){\n      vec2 vUv = vec2(vUv.x, vUv.y);\n      vUv *= 0.5;\n      vUv += 0.3;\n  \n      float y =  easeInElastic(vUv.x);\n      float x =  easeInElastic2(vUv.y);\n  \n      vec3 color = vec3(y);\n  \n      float pct = 1. -plotY(vUv, y);\n      float pct2 = 1. - plotX(vUv, x);\n    \n      color = pct * vec3(1., 0., 0.);\n      color += pct2 * vec3(1., 0., 0.);\n  \n      gl_FragColor = vec4(color, 1.);\n  }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Sg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec3 colorA = vec3(0.788, 0.262, 0.250);\nvec3 colorB = vec3(0.250, 0.474, 0.788);\n\nfloat easeInQuad(float x){\n    return x * x;\n}\n\nvoid main(){\n    vec3 color = vec3(0.);\n    float pct = easeInQuad(vUv.x);\n    pct += sin(u_time);\n    color = mix(colorA, colorB, pct);\n    color -= mix(colorB, colorA, pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Mg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec3 colorA = vec3(0.149,0.141,0.912);\nvec3 colorB = vec3(1.000,0.833,0.224);\n\nfloat plot (vec2 st, float pct){\n  return  smoothstep( pct-0.01, pct, st.y) -\n          smoothstep( pct, pct+0.01, st.y);\n}\n\n//bookofshaders\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 3.0;\n    vec3 color = vec3(0.0);\n    color = rgb2hsb(vec3(vUv.x, vUv.y, abs(sin(u_time * 0.5))));\n    color -= rgb2hsb(vec3(vUv.x, vUv.y, abs(cos(u_time * 0.5))));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Cg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Tg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 centeredUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    centeredUv *= 10.0;\n    float t = u_time * .05;\n    //vUv += M;\n    centeredUv *= Rot(t * 10.0);\n    vec3 color = vec3(0.);\n    float angle = dot(sin(centeredUv.y), sin(centeredUv.x));\n    float radius = length(centeredUv) * 200.0;\n    color = 1. - hsb2rgb(vec3((angle * abs(tan(sin(u_time * 0.25)))) - 0.25, radius, 1.));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Rg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Tg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Dg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb(in vec3 c){\n    vec3 rgb=clamp(abs(mod(c.x*6.+vec3(3.8,1.,7.),\n6.)-3.)-1.,\n0.,\n1.);\nrgb=rgb*rgb*(3.-2.*rgb);\nreturn c.z*mix(vec3(1.),rgb,c.y);\n}\n\nmat2 Rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid main(){\n    vec2 centeredUv=vec2(vUv.x-.5,vUv.y-.5);\n    centeredUv*=10.;\n    float t=u_time*.05;\n    centeredUv*=Rot(t*10.);\n    vec3 color=vec3(0.);\n    float angle=abs(tan(dot(abs(cos(centeredUv.x)), abs(sin(centeredUv.y)))) * abs(cos(u_time * 0.5)));\n    float radius=length(centeredUv)*2000.;\n    color=1. - hsb2rgb(vec3((angle/(TWO_PI /3.))+.5,radius, 1.));\n    gl_FragColor=vec4(color.x , color.y, color.z ,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Pg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Dg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    mat2 Rot(float a){\n        float s=sin(a);\n        float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n    void main(){\n        vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n        vUv *= 25.0;\n        float t = u_time * 0.25;\n        vUv*=Rot(t*1.);\n        vec3 color=vec3(0.);\n        float angle=abs(tan(dot(abs(cos(vUv.x)),abs(sin(vUv.y))))*abs(cos(u_time*.25)));\n        float radius=length(vUv) * 0.5;\n        color = vec3(((angle * radius)/ PI) + (cos(u_time)), tan(radius * angle) , tan(radius * angle));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Fg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Eg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 10.0;\n    float t = u_time * .05;\n    vUv *= Rot(t * 10.0);\n    vec3 color = vec3(0.);\n    float angle = dot(sin(vUv.y), sin(vUv.x));\n    float radius = length(vUv) * 2.0;\n    color = 1. - hsb2rgb(vec3((angle * abs(tan(sin(u_time * 0.5)))), abs(tan(angle + u_time)) , u_time * 0.5));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Ig(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Eg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Og=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv -= 0.5;\n        vUv *= 10.0;\n        float t = u_time * .05;\n        vUv *= Rot(t * 5.0);\n        vec3 color = vec3(0.);\n        float radius = length(tan(vUv + (sin(vUv.y))) * 0.08);\n        color = vec3(tan(vUv.x + cos(vUv.y + u_time)), tan(1. - vUv.x + cos(vUv.y + u_time)), tan(vUv.x + cos(vUv.y + u_time)));\n        vec3 newColor = vec3(color.x * radius, color.y * radius, color.z * radius);\n        gl_FragColor = vec4(newColor, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Lg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Og,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ag=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 10.0;\n    float t = u_time * .05;\n    vUv *= Rot(t * 10.0);\n    vec3 color = vec3(0.);\n    float angle = dot(cos(vUv.y), cos(vUv.x));\n    float radius = length(vUv) * 200.0;\n    color = vec3(vUv.x * angle, vUv.y * angle, 1.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Ng(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ag,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Gg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //plot function bookofshaders\nfloat plotY(vec2 st, float pct){\n    return  smoothstep( pct-.5, pct, st.y + 0.5) -\n            smoothstep( pct, pct+.5, st.y + 0.5);\n  }\n  \n  //  Function from I\xf1igo Quiles\n  //  https://www.shadertoy.com/view/MsS3Wc\n  vec3 hsb2rgb( in vec3 c ){\n      vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                               6.0)-3.0)-1.0,\n                       0.0,\n                       1.0 );\n      rgb = rgb*rgb*(3.0-2.0*rgb);\n      return c.z * mix(vec3(1.0), rgb, c.y);\n  }\n  \n  \n  \n  //easing functions easings.net/#easeInElastic\n  float easeInElastic(float x){\n      float y = (sin( - u_time * 0.25)) / 3.;\n      return pow(2., 10. * x - 10.) * cos((x * 10. - 10.75) * y - (u_time * 0.5)) ;\n  }\n  \n  \n  void main(){\n      vec2 vUv = vec2(vUv.x - 1.5 , vUv.y - 1.5 );\n      vUv *= 1.0;\n      //vec3 color = vec3(0.);\n      float angle = dot(sin(vUv.y), cos(vUv.x));\n      float radius = length(vUv) * 2.0;\n  \n      float y =  easeInElastic(vUv.x * angle * radius);\n  \n      vec3 color = vec3(y);\n  \n      float pct =plotY(vUv, y * radius * angle);\n    \n      color = hsb2rgb(vec3(y + cos(u_time), y + cos(u_time), y * pct));\n  \n      gl_FragColor = vec4(color, 1.);\n  }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Bg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Gg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv -= 0.5;\n        vUv *= 5.0;\n        float t = u_time * .05;\n        vUv *= Rot(t * 5.0);\n        vUv *= length(vUv * sin(t));\n        vec3 color = vec3(0.);\n        float radius = length(cos((vUv * sin(u_time)) + (cos(vUv.y))) * 0.08);\n        color = vec3(tan(vUv.x + cos(vUv.y + u_time)), tan(1. - vUv.x + cos(vUv.y + u_time)), tan(vUv.x + cos(vUv.y + u_time)));\n        vec3 newColor = vec3(color.x * radius * abs(cos(u_time)), color.y * radius * abs(sin(u_time)), color.z * radius );\n        gl_FragColor = vec4(newColor, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Vg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Wg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //plot function from book of shaders\nfloat plot(vec2 st, float pct){\n    return  smoothstep( pct-1.5, pct, st.y) -\n            smoothstep( pct, pct+1.5, st.y);\n  }\n  \n  float plot2(vec2 st, float pct){\n    return  smoothstep( pct-1., pct, st.x) -\n            smoothstep( pct, pct+1., st.x);\n  }\n  \n  mat2 Rot(float a){\n      float s = sin(a);\n      float c = cos(a);\n      return mat2(c, -s, s, c);\n  }\n  \n  void main(){\n      vec2 vUv = vec2(vUv.x -0.5, vUv.y - 0.5);\n      vUv *= 10.0;\n      float t = u_time * .05;\n      vUv *= Rot(t * 5.0);\n      float a = sin(vUv.x + u_time * (atan(sin(u_time + vUv.x), vUv.y)));//sin\n      //float b = cos(vUv.y * (dot(cos(u_time * vUv.y), vUv.y)));//cos\n  \n      vec3 color = vec3(0.);\n  \n      float pct = plot(vUv, a);\n      //float pct2 = plot2(vUv, b);\n      float radius = length(cos((vUv * sin(u_time)) + (cos(vUv.y))) * 0.08);\n      color = (1.0 - pct) * color + pct * vec3(vUv.x, vUv.y, 1.);\n      \n      // vec3 newColor = vec3(color.x * radius * abs(cos(u_time)), color.y * radius * abs(sin(u_time)), color.z * radius );\n      //gl_FragColor = vec4(newColor, 1.);\n  \n      //color = (1.0 - pct) * color + pct * vec3(1.0, 0.0, 0.0);\n      //color *= (1.0 - pct2) * color + pct2 * vec3(0.0, 0.0, 1.0);\n      \n      gl_FragColor = vec4(color, 1.);\n  }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Hg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Wg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Xg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    mat2 Rot(float a){\n        float s=sin(a);\n        float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n    \n    //  Function from I\xf1igo Quiles\n    //  https://www.shadertoy.com/view/MsS3Wc\n    vec3 hsb2rgb(in vec3 c){\n        vec3 rgb=clamp(abs(mod(c.x*6.+vec3(3.8,1.,7.),\n    6.)-3.)-1.,\n    0.,\n    1.);\n    rgb=rgb*rgb*(3.-2.*rgb);\n    return c.z*mix(vec3(1.),rgb,c.y);\n    }\n    \n    //pixel deck\n    vec2 rotate(vec2 vUv, float a){\n        vUv = mat2(cos(a), - sin(a), sin(a), cos(a)) * vUv * 0.5;\n        return vUv;\n    }\n    float stroke(float x, float s, float w){\n        float d = step(s, x + w * 0.5) - \n                    step(s, x -w * 0.5);\n        return clamp(d, 0., 1.);\n    }\n    float fill(float x, float size){\n        return 1. - step(size, x);\n    }\n    float rectSDF(vec2 vUv, vec2 s){\n        vUv = vUv * 2. - 1.;\n        return max(abs(vUv.x/s.x), abs(vUv.y/s.y));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x , vUv.y );\n        vUv -= 0.5;\n        vUv *= 6.25;\n        vUv = rotate(vUv, radians(180. * (u_time * u_time) ));\n        float y = 0.;\n        vec3 color = vec3(y);\n        y = fill(rectSDF(vUv, vec2(1.5)), 1.5);\n        y -= 1. - stroke(vUv.x, 0.9, 0.1);\n        y -= 1. - stroke(vUv.y,0.9, 0.1);\n        color = vec3(y);\n        gl_FragColor = vec4(color.x + (sin(u_time * 0.1)), color.y + (sin(u_time * 0.2)), color.z + (cos(u_time * 0.1)), 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Yg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Xg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $g=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 5.0;\n    float t = u_time * .05;\n    vUv *= Rot(t * 10.0);\n    vec3 color = vec3(0.);\n    float angle = dot(cos(vUv.y * sin(u_time * 0.25)), cos(vUv.x * sin(u_time * 0.25)));\n    float radius = length(vUv);\n    color = 1. - hsb2rgb(vec3((angle * abs(tan(sin(u_time * 0.5)))) * radius, abs(tan(angle + u_time)) , radius * angle * u_time - 0.5));\n    gl_FragColor = vec4(1. - color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Zg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$g,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Kg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //pixeldeck\nfloat starSDF(vec2 vUv, int V, float s){\n    //vUv = vUv * 5. - 2.5;\n    float a  = atan(vUv.y, vUv.x)/TWO_PI;\n    float seg = a * float(V);\n    a = ((floor(seg) + 0.5)/ float(V) + mix(s, -s, step(.5, fract(seg)))) * TWO_PI;\n    return abs(dot(vec2(cos(a), sin(a)), vUv));\n}\n\n//  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y-0.5);\n    vUv *= 5.;\n    vec3 color = vec3(0.);\n    float t = u_time * .1;\n    vUv *= Rot(t * 10.0);\n    float s = starSDF(vUv.yx, 5, .1);\n    color += 1. - step(.7, s);\n    //color *= 1. - step(.7, s);\n    float angle = dot(cos(vUv.y * sin(u_time * 0.25)), cos(vUv.x * sin(u_time * 0.25)));\n    float radius = length(vUv);\n    color *= 1. - hsb2rgb(vec3((angle * abs(tan(sin(u_time * 0.25)))), abs(tan(angle + u_time)) , (u_time) * 0.25));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Jg(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Kg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qg=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// //Rectangle function\nfloat createRect(in vec2 vUv, in vec2 start, in vec2 dim){\n    vec2 bottomLeft = step(start, vUv);\n    vec2 topRight = step(1. - start -dim, 1.0 - vUv);\n    float pct = bottomLeft.x * bottomLeft.y * topRight.x * topRight.y;\n    return pct;\n}\n\nfloat circleSDF(vec2 vUv){\n    return length(vUv - 0.5) * 2.;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x + 0.48, vUv.y + 0.48);\n    vUv *= 10.;\n    float angle = dot(sin(vUv.y - 0.5), sin(vUv.x - 0.5));\n    // float radius = length((vUv * 2.0 - 0.5) );\n    float barX = step(0.4, mod(vUv.x * 10.0 - 0.2, 1.0)) * step(0.8, mod(vUv.y * 10.0, 1.0));\n    float barY = step(0.8, mod(vUv.x * 10.0, 1.0)) * step(0.4, mod(vUv.y * 10.0 - 0.2, 1.0));\n    float strength = barX + barY;\n    float circle = step(circleSDF(vUv), 1.0);\n    vec3 color = vec3(strength);\n    float radius = length(cos((vUv * sin(u_time)) + (cos(vUv.y))) * 0.08);\n    color *= vec3(tan(vUv.x + cos(vUv.y + u_time)), tan(1. - vUv.x + cos(vUv.y + u_time)), tan(vUv.x + cos(vUv.y + u_time)));\n    vec3 newColor = vec3(color.x + atan(0.5 * u_time) * radius * (sin(u_time )), color.y + atan(0.5 * u_time) * radius * (cos(u_time)), color.z * radius );\n    newColor -= strength;\n    gl_FragColor = vec4(newColor, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ny(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Qg,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ey=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Rectangle function\nfloat createRect(in vec2 vUv, in vec2 start, in vec2 dim){\n    vec2 bottomLeft = step(start, vUv);\n    vec2 topRight = step(1. - start -dim, 1.0 - vUv);\n    float pct = bottomLeft.x * bottomLeft.y * topRight.x * topRight.y;\n    return pct;\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 3.0;\n    float t = u_time * .75;\n    vUv *= Rot(t);\n    float y = createRect(vUv, vec2(-0.62, 0.0), vec2(1.5, 0.25));\n    float x = createRect(vUv, vec2(0.0, -0.62), vec2(0.25, 1.5));\n    float shape = x - y;\n    vec3 color = vec3(shape);\n    float angle = dot(atan(vUv.y * sin(u_time * 0.25)), atan(vUv.x * sin(u_time * 0.25)));\n    float radius = length(vUv - 0.5) * 20.;\n    color *= vec3(sin(color.x * (sin(u_time * sin(radius)))), sin(color.y * (cos(u_time * sin(radius)))), sin(color.z * (sin(u_time * sin(radius)))));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ty(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ey,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ry=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n//pixel deck\nfloat circleSDF(vec2 vUv){\n    return length(vUv - 0.5) * 2.;\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 2.0;\n    float t = u_time * .75;\n    vUv *= Rot(t);\n    float circle = circleSDF(vUv + 0.5);\n    float angle = dot(vUv.y, vUv.x);\n    float radius = length(vUv) * 100.0;\n    vec3 color = vec3(0.);\n    color = hsb2rgb(vec3((angle/TWO_PI * (u_time)) , sin(radius * sin(u_time * 0.25)), 1.0));\n    color -=  tan(circle);\n    gl_FragColor = vec4(color.x, color.y, color.z, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function oy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ry,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ay=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n//pixel deck\nfloat circleSDF(vec2 vUv){\n    return length(vUv - 0.5) * 2.;\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 2.0;\n    float t = u_time * .75;\n    vUv *= Rot(t);\n    float circle = circleSDF(vUv + 0.5);\n    float angle = dot(vUv.y, vUv.x);\n    float radius = length(vUv) * 1000.0;\n    //vec3 color = vec3(0.);\n    \n    vec3 color =  vec3(tan(circle));\n    color += hsb2rgb(vec3(atan(circle,angle * radius/TWO_PI) *1. -  abs(cos(u_time * 0.25))));\n    gl_FragColor = vec4(color.x + sin(u_time), color.y - sin(u_time), color.z + cos(u_time), 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function iy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ay,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vy=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb(in vec3 c){\n    vec3 rgb=clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),\n            6.)-3.)-1.,\n            0.,\n            1.);\n    rgb=rgb*rgb*(3.-2.*rgb);\n    return c.z*mix(vec3(1.),rgb,c.y);\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\n//pixel deck\nfloat circleSDF(vec2 vUv){\n    return length(vUv-.5)*2.;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv - 0.5);\n    vUv *= 3.0;\n    float angle=atan(vUv.y,vUv.x);\n    float radius=length(vUv)*5.;\n    float circle=circleSDF(vUv+.5);\n    vec3 color=vec3(tan(circle + u_time));\n    color += 1. - hsb2rgb(vec3(atan(radius, angle)  + sin(u_time), atan(radius,angle)+cos(u_time), atan(radius,angle) +cos(u_time)));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vy,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ly=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //pixel deck\nfloat circleSDF(vec2 vUv){\n    return length(vUv - 0.5) * 2.;\n}\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv-0.25);\n    vUv *= 2.0;\n    float angle = dot(vUv.y , vUv.x);\n    float radius = length(vUv- 0.5) * 10.0;\n    vec3 color = vec3 (cos(vUv.x), sin(vUv.y + u_time* 0.2), 0.);\n    color *= vec3(step(circleSDF(vUv), 1.9));\n    color *= hsb2rgb(vec3(u_time + radius * sin(vUv.x + vUv.y), u_time + radius, u_time + radius));\n    gl_FragColor = vec4(color , 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ly,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uy=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n//book of shaders\nfloat plot (vec2 st, float pct){\n  return  smoothstep( pct-0.5, pct, st.y) -\n          smoothstep( pct, pct+0.5, st.y);\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv - 0.5);\n    vUv *= 4.0 + sin(u_time);\n    float t = u_time * .75;\n    vUv *= Rot(t);\n    vec3 color = vec3(0.);\n    color += 1. - hsb2rgb(vec3(cos(vUv.x * vUv.y), u_time * PI, 1.0));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uy,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var py=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    void main(){\n        //vec2 vUv = vec2(vUv);\n        vec3 color = vec3(0.);\n        // float left = step(0.1, vUv.x);\n        // float bottom = step(0.1, vUv.y);\n        vec2 bordersBottomLeft = step(vec2(0.1 * abs(sin(u_time * 0.75))), vUv);\n        vec2 bordersTopRight = step(vec2(0.1 * abs(sin(u_time * 0.75))), 1.0 - vUv);\n        float pct = bordersBottomLeft.x * bordersBottomLeft.y * bordersTopRight.x * bordersTopRight.y;\n        color = vec3(pct);\n        gl_FragColor = vec4(vec3(vUv.x * color.x, vUv.y * color.y, color.z), 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:py,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var my=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rect(vec2 vUv, vec2 s){\n        vec2 bl = step(vec2(s), vUv);\n        vec2 tr = step(vec2(s), 1. - vUv);\n        return bl.x * bl.y * tr.x * tr.y;\n    }\n    \n    void main(){\n        //vec2 vUv = vec2(vUv - 0.5);\n        vec3 color = vec3(vUv.x * vUv.y);\n        // vec2 bl = step(vec2(0.5), vUv);\n        // vec2 tr = step(vec2(0.1), 1. - vUv);\n        // float pct = bl.x * bl.y * tr.x * tr.y;\n        // float pct2 = 1. - (bl.x  * bl.y * tr.x * tr.y);\n        // color *= vec3(pct2);\n        // color += vec3(pct);\n        float pct = rect(vec2(vUv.x + 0.25 * sin(u_time), vUv.y + 0.25 * cos(u_time)), vec2(0.25));\n        float pct2 = rect(vec2(vUv.x - 0.25 * cos(u_time), vUv.y - 0.25 * sin(u_time)), vec2(0.25));\n        vec3 finalColor = vec3(pct * abs(cos(u_time)), pct * 0.2,  pct * 0.8);\n        finalColor += vec3(pct2 * abs(sin(u_time)), pct2 * 0.8, 0.2);\n        color = finalColor;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:my,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xy=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rect(vec2 vUv, vec2 s){\n        vec2 bl = step(vec2(s), vUv);\n        vec2 tr = step(vec2(s), 1. - vUv);\n        return bl.x * bl.y * tr.x * tr.y;\n    }\n    \n    //pixel deck\n    float fill(float x, float size){\n        return 1. - step(size, x);\n    }\n    //pixel deck\n    //triangle SDF\n    float triSDF(vec2 vUv){\n        vUv = (vUv * 2. - 1.) * 2.;\n        return max(abs(vUv.x) * 0.866025 + vUv.y * 0.5, -vUv.y * 0.5);\n    } \n    \n    void main(){\n        //vec2 vUv = vec2(vUv - 0.5);\n        vec3 color = vec3(vUv.x * vUv.y);\n        float pct = fill(triSDF(vec2(vUv.x + 0.25 * sin(u_time * 0.5), vUv.y + 0.25 * cos(u_time* 0.5))), 0.35);\n        float pct2 = fill(triSDF(vec2(vUv.x + 0.25 * cos(u_time* 0.5), vUv.y - 0.25 * sin(u_time* 0.5))), 0.35);\n        float pct3 = fill(triSDF(vec2(vUv.x - 0.25 * cos(u_time* 0.5), vUv.y + 0.25 * sin(u_time* 0.5))), 0.35);\n        float pct4 = fill(triSDF(vec2(vUv.x + 0. * sin(u_time* 0.5), vUv.y + 0. * cos(u_time* 0.5))), 0.35);\n        vec3 finalColor = vec3(pct * abs(sin(u_time)), pct * 0.2,  pct * 0.8);\n        finalColor += vec3(pct2 * abs(sin(u_time)), pct2 * 0.8, pct2 * 0.1);\n        finalColor += vec3(pct3 * abs(sin(u_time)), pct3 * 0.4, pct3 * 0.3);\n        finalColor += vec3(pct4 * abs(cos(u_time)), pct4 * 0.2, pct4 * 0.5);\n        color = finalColor;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xy,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yy=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float triSDF(vec2 vUv){\n        vUv=(vUv*2.-1.)*2.;\n        return max(abs(vUv.x)*.866025+vUv.y*.5,-vUv.y*.5);\n    }\n    \n    //rotation function\n    mat2 Rot(float a){\n        float s=sin(a);\n        float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n    \n    void main(){\n        vec2 newvUv = vec2(vUv + 1.5 );\n    \n        newvUv *= 20.25;\n        float t=sin(u_time*.75);\n        \n        vec3 color=vec3(0.);\n        float pct = triSDF(vec2(vUv.x,vUv.y));\n        color = vec3(pct, pct, pct);\n        color.xy*=Rot(t);\n        color.yz*=Rot(t);\n        color.xz*=Rot(t);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function by(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yy,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _y=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //pixel deck\nfloat fill(float x, float size){\n    return 1. - step(size, x);\n}\n//pixel deck\n//triangle SDF\nfloat triSDF(vec2 vUv){\n    vUv = (vUv * 2. - 1.) * 2.;\n    return max(abs(vUv.x) * 0.866025 + vUv.y * 0.5, -vUv.y * 0.5);\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv - 0.5);\n    vUv *= 2.0;\n    float t = u_time * .75;\n    vUv *= Rot(t);\n    vec3 color = vec3(0.);\n    float tri = fill(triSDF(vUv + 0.5), 1.0);\n    float tri2 = fill(triSDF(vUv + 0.3), 1.25);\n    float tri3 = fill(triSDF(vec2(vUv.x + 0.15, vUv.y + 0.25)), 1.);\n    color = vec3(abs(sin(tri + u_time * vUv.x)), abs(cos(tri + u_time + vUv.y)), (sin(tri + 0.2 + u_time)));\n    vec3 finalColor = vec3(vUv, 1.);\n    vec3 color2 = vec3(tri2);\n    vec3 color3 = vec3(tri3);\n    finalColor += color;\n    finalColor *= color2;\n    finalColor -= color3;\n    gl_FragColor = vec4(finalColor, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Uy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_y,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wy=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //pixel deck\nfloat fill(float x, float size){\n    return 1. - step(size, x);\n}\n//pixel deck\n//triangle SDF\nfloat triSDF(vec2 vUv){\n    vUv = (vUv * 2. - 1.) * 2.;\n    return max(abs(vUv.x) * 0.866025 + vUv.y * 0.5, -vUv.y * 0.5);\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n//  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vec3 color = vec3(0.);\n    float angle = dot(vUv.y , vUv.x);\n    float radius = length(vUv- 0.5) * 10.0;\n    float tri = 1. - fill(triSDF(vUv), 0.5);\n    float tri2 = fill(triSDF(vec2(vUv.x, vUv.y + 0.1)), 0.4);\n    float tri3 = 1. - fill(triSDF(vec2(vUv.x, vUv.y + 0.2)), 0.3);\n    float shape = float(tri + tri2 * tri3);\n    color = vec3(shape);\n    color += hsb2rgb(vec3(u_time + radius * sin(vUv.x - 0.25 + vUv.y), u_time + radius, u_time + radius));\n    gl_FragColor = vec4(vec3(shape, shape + color.y, shape), 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Sy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wy,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ky=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rect(vec2 size, vec2 vUv){\n        vec2 bl = step(size, vUv);\n        vec2 tr = step(size, 1. - vUv);\n        return bl.x * bl.y * tr.x * tr.y;\n    }\n    \n    //rotation function\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x - 0.75, vUv.y - 0.5);\n        vUv *= 5.0;\n        float t = u_time;\n        vUv *= Rot(t);\n        vec3 color = vec3(0.);\n        float pct = rect(vec2(0.3, 0.49), vUv + sin(u_time));\n        float pct2 = rect(vec2(0.3, 0.49), vec2(vUv.x, vUv.y + 0.5 )+ cos(u_time));\n        float pct3 = rect(vec2(0.49, 0.3), vec2(vUv.x, vUv.y + 0.5 )+ cos(u_time));\n        float pct4 = rect(vec2(0.49, 0.3), vUv + sin(u_time));\n        float pct5 = rect(vec2(0.3, 0.49), vec2(vUv.x, vUv.y + 1.) + sin(u_time));\n        float pct6 = rect(vec2(0.49, 0.3), vec2(vUv.x, vUv.y + 1.) + sin(u_time));\n        color = vec3(0.);\n        color.g += pct;\n        color.r += pct2;\n        color.r += pct3;\n        color.g += pct4;\n        color.b += pct5;\n        color.b += pct6;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function My(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ky,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zy=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main(){\n    vec3 color = vec3(0.);\n    //a\n    float pct = smoothstep(0.1, 0.15, distance(vUv, vec2(0.8 * cos(u_time), 1. * abs(sin(u_time)))));\n    float pct2 = smoothstep(0.1, 0.15, distance(vUv, vec2(0.5, 1. * abs(cos(u_time)))));\n    float pct3 = smoothstep(0.1, 0.15, distance(vUv, vec2(0.2, 1. * abs(sin(u_time)))));\n    color = vec3(pct);\n    color *= vec3(pct2);\n    color *= vec3(pct3);\n\n    color.x = sin(color.x * u_time * 0.25);\n    color.y = sin(color.y * u_time * 0.25);\n    color.z = sin(color.z * u_time * 0.25); \n    // //b\n    // vec2 vUv = vec2(vUv) - 0.5;\n    // float pct = length(vUv);\n    // color = vec3(pct);\n\n    // //c\n    // vec2 vUv = vec2(vUv) - 0.5;\n    // float pct = sqrt(vUv.x * vUv.x + vUv.y * vUv.y);\n    // color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Cy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zy,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ty=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    void main(){\n        float y = step(distance(vUv, vec2(0.5, 0.5)), 0.5);\n        float x = 1. - step(distance(vUv, vec2(0.5, 0.5)), 0.49);\n        float cir1 = step(distance(vUv, vec2(0.74, 0.49)), 0.25);\n        float cir2 = step(distance(vUv, vec2(0.25, 0.52)), 0.24);\n        x+=step(vUv.y,.5);\n        vec3 color = vec3(y * x);\n        color += vec3(cir1);\n        color -= vec3(cir2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Ry(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ty,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Dy=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //circle sdf\nfloat circ(vec2 vUv, vec2 pos, float size){\n    return 1. - step(size, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    float y1 = circ(vUv, vec2(0.1, 1. * abs(sin(u_time * 0.9))), 0.05);\n    float y2 = circ(vUv, vec2(0.2, 1. * abs(sin(u_time * 0.85))), 0.05);\n    float y3 = circ(vUv, vec2(0.3, 1. * abs(sin(u_time * 0.80))), 0.05);\n    float y4 = circ(vUv, vec2(0.4, 1. * abs(sin(u_time * 0.75))), 0.05);\n    float y5 = circ(vUv, vec2(0.5, 1. * abs(sin(u_time * 0.70))), 0.05);\n    float y6 = circ(vUv, vec2(0.6, 1. * abs(sin(u_time * 0.65))), 0.05);\n    float y7 = circ(vUv, vec2(0.7, 1. * abs(sin(u_time * 0.60))), 0.05);\n    float y8 = circ(vUv, vec2(0.8, 1. * abs(sin(u_time * 0.55))), 0.05);\n    float y9 = circ(vUv, vec2(0.9, 1. * abs(sin(u_time * 0.50))), 0.05);\n\n    vec3 color = vec3(y1 + y2 + y3 + y4 + y5 + y6 + y7 + y8 + y9);\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Py(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Dy,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jy=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //circle sdf\nfloat circ(vec2 vUv,vec2 pos,float size){\n    return 1.-step(size,distance(vUv,pos));\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y) - 0.5;\n    vUv *= 2.0;\n    float y1=circ(vUv,vec2(.5*(sin(u_time*.1 * 2.)),.5*(cos(u_time*.1))),.05);\n    float y2=circ(vUv,vec2(.5*(sin(u_time*.2* 2.)),.5*(cos(u_time*.2))),.05);\n    float y3=circ(vUv,vec2(.5*(sin(u_time*.3* 2.)),.5*(cos(u_time*.3))),.05);\n    float y4=circ(vUv,vec2(.5*(sin(u_time*.4* 2.)),.5*(cos(u_time*.4))),.05);\n    float y5=circ(vUv,vec2(.5*(sin(u_time*.5* 2.)),.5*(cos(u_time*.5))),.05);\n    float y6=circ(vUv,vec2(.5*(sin(u_time*.6* 2.)),.5*(cos(u_time*.6))),.05);\n    float y7=circ(vUv,vec2(.5*(sin(u_time*.7* 2.)),.5*(cos(u_time*.7))),.05);\n    float y8=circ(vUv,vec2(.5*(sin(u_time*.8* 2.)),.5*(cos(u_time*.8))),.05);\n    float y9=circ(vUv,vec2(.5*(sin(u_time*.9* 2.)),.5*(cos(u_time*.9))),.05);\n    float y10=circ(vUv,vec2(.5*(sin(u_time*1.0*2.)),.5*(cos(u_time*1.0))),.05);\n    float y11=circ(vUv,vec2(.5*(sin(u_time*1.1*2.)),.5*(cos(u_time*1.1))),.05);\n    float y12=circ(vUv,vec2(.5*(sin(u_time*1.2*2.)),.5*(cos(u_time*1.2))),.05);\n    float y13=circ(vUv,vec2(.5*(sin(u_time*1.3*2.)),.5*(cos(u_time*1.3))),.05);\n    float y14=circ(vUv,vec2(.5*(sin(u_time*1.4*2.)),.5*(cos(u_time*1.4))),.05);\n    float y15=circ(vUv,vec2(.5*(sin(u_time*1.5*2.)),.5*(cos(u_time*1.5))),.05);\n    float y16=circ(vUv,vec2(.5*(sin(u_time*1.6*2.)),.5*(cos(u_time*1.6))),.05);\n    float y17=circ(vUv,vec2(.5*(sin(u_time*1.7*2.)),.5*(cos(u_time*1.7))),.05);\n    float y18=circ(vUv,vec2(.5*(sin(u_time*1.8*2.)),.5*(cos(u_time*1.8))),.05);\n    float y19=circ(vUv,vec2(.5*(sin(u_time*1.9*2.)),.5*(cos(u_time*1.9))),.05);\n    float y20=circ(vUv,vec2(.5*(sin(u_time*2.0*2.)),.5*(cos(u_time*2.0))),.05);\n    \n    vec3 color=vec3(y1 + y2 + y3 + y4 + y5 + y6 + y7 + y8 + y9 + y10 + y11 + y12 + y13 + y14 + y15 + y16 + y17 + y18 + y19 + y20);\n    \n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Fy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jy,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ey=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //circle sdf\nfloat circ(vec2 vUv,vec2 pos,float size){\n    return 1.-step(size,distance(vUv,pos));\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y)-.5;\n    vUv*=2.;\n    float y1=circ(vUv,vec2(0.,0.),abs(cos(u_time * .1)));\n    float y2=circ(vUv,vec2(0.,0.),abs(cos(u_time * .2)));\n    float y3=circ(vUv,vec2(0.,0.),abs(cos(u_time * .3)));\n    float y4=circ(vUv,vec2(0.,0.),abs(cos(u_time * .4)));\n    float y5=circ(vUv,vec2(0.,0.),abs(cos(u_time * .5)));\n    float y6=circ(vUv,vec2(0.,0.),abs(cos(u_time * .6)));\n    float y7=circ(vUv,vec2(0.,0.),abs(cos(u_time * .7)));\n    float y8=circ(vUv,vec2(0.,0.),abs(cos(u_time * .8)));\n    float y9=circ(vUv,vec2(0.,0.),abs(cos(u_time * .9)));\n\n    vec3 color=vec3(0.);\n    color.b-=y1 * y9 / abs(sin(u_time));\n    color.r-=y2 * y8 / abs(sin(u_time));\n    color.g-=y3 * y7 / abs(sin(u_time));\n    color.r+=y4 * y6 / abs(sin(u_time));\n    color.b+=y5 * y1 / abs(sin(u_time));\n    color.g-=y6 * y4 / abs(sin(u_time));\n    color.b+=y7 * y3 / abs(sin(u_time));\n    color.r-=y8 * y2 / abs(sin(u_time));\n    color.g+=y9 * y1 / abs(sin(u_time));\n    \n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Iy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ey,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Oy=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n\n//circle sdf\nfloat circ(vec2 vUv, vec2 pos, float size){\n    return 1. - step(size, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 1.5;\n    vec3 color = vec3(0.);\n    float c1 = circ(vUv, vec2(0.5 * sin(u_time * 1.10), 0.5 * cos(u_time -1.10)), 0.025);\n    float c2 = circ(vUv, vec2(0.5 * sin(u_time * 1.15), 0.5 * cos(u_time -1.15)), 0.025);\n    float c3 = circ(vUv, vec2(0.5 * sin(u_time * 1.20), 0.5 * cos(u_time -1.20)), 0.025);\n    float c4 = circ(vUv, vec2(0.5 * sin(u_time * 1.25), 0.5 * cos(u_time -1.25)), 0.025);\n    float c5 = circ(vUv, vec2(0.5 * sin(u_time * 1.30), 0.5 * cos(u_time -1.30)), 0.025);\n    float c6 = circ(vUv, vec2(0.5 * sin(u_time * 1.35), 0.5 * cos(u_time -1.35)), 0.025);\n    float c7 = circ(vUv, vec2(0.5 * sin(u_time * 1.40), 0.5 * cos(u_time -1.40)), 0.025);\n    float c8 = circ(vUv, vec2(0.5 * sin(u_time * 1.45), 0.5 * cos(u_time -1.45)), 0.025);\n    float c9 = circ(vUv, vec2(0.5 * sin(u_time * 1.50), 0.5 * cos(u_time -1.50)), 0.025);\n    float c10 = circ(vUv, vec2(0.5 * sin(u_time * 1.55), 0.5 * cos(u_time - 1.55)), 0.025);\n    float c11 = circ(vUv, vec2(0.5 * sin(u_time * 1.60), 0.5 * cos(u_time - 1.60)), 0.025);\n    float c12 = circ(vUv, vec2(0.5 * sin(u_time * 1.65), 0.5 * cos(u_time - 1.65)), 0.025);\n    float c13 = circ(vUv, vec2(0.5 * sin(u_time * 1.70), 0.5 * cos(u_time - 1.70)), 0.025);\n    float c14 = circ(vUv, vec2(0.5 * sin(u_time * 1.75), 0.5 * cos(u_time - 1.75)), 0.025);\n    float c15 = circ(vUv, vec2(0.5 * sin(u_time * 1.80), 0.5 * cos(u_time - 1.80)), 0.025);\n    float c16 = circ(vUv, vec2(0.5 * sin(u_time * 1.85), 0.5 * cos(u_time - 1.85)), 0.025);\n    float c17 = circ(vUv, vec2(0.5 * sin(u_time * 1.90), 0.5 * cos(u_time - 1.90)), 0.025);\n    float c18 = circ(vUv, vec2(0.5 * sin(u_time * 1.95), 0.5 * cos(u_time - 1.95)), 0.025);\n    float c19 = circ(vUv, vec2(0.5 * sin(u_time * 2.00), 0.5 * cos(u_time - 2.00)), 0.025);\n    float c20 = circ(vUv, vec2(0.5 * sin(u_time * 2.05), 0.5 * cos(u_time - 2.05)), 0.025);\n    float c21 = circ(vUv, vec2(0.5 * sin(u_time * 2.10), 0.5 * cos(u_time - 2.10)), 0.025);\n    float c22 = circ(vUv, vec2(0.5 * sin(u_time * 2.15), 0.5 * cos(u_time - 2.15)), 0.025);\n    float c23 = circ(vUv, vec2(0.5 * sin(u_time * 2.20), 0.5 * cos(u_time - 2.20)), 0.025);\n    float c24 = circ(vUv, vec2(0.5 * sin(u_time * 2.25), 0.5 * cos(u_time - 2.25)), 0.025);\n    float c25 = circ(vUv, vec2(0.5 * sin(u_time * 2.30), 0.5 * cos(u_time - 2.30)), 0.025);\n    float c26 = circ(vUv, vec2(0.5 * sin(u_time * 2.35), 0.5 * cos(u_time - 2.35)), 0.025);\n    float c27 = circ(vUv, vec2(0.5 * sin(u_time * 2.40), 0.5 * cos(u_time - 2.40)), 0.025);\n    float c28 = circ(vUv, vec2(0.5 * sin(u_time * 2.45), 0.5 * cos(u_time - 2.45)), 0.025);\n    float c29 = circ(vUv, vec2(0.5 * sin(u_time * 2.50), 0.5 * cos(u_time - 2.50)), 0.025);\n    float c30 = circ(vUv, vec2(0.5 * sin(u_time * 2.55), 0.5 * cos(u_time - 2.55)), 0.025);\n    float c31 = circ(vUv, vec2(0.5 * sin(u_time * 2.60), 0.5 * cos(u_time - 2.60)), 0.025);\n    float c32 = circ(vUv, vec2(0.5 * sin(u_time * 2.65), 0.5 * cos(u_time - 2.65)), 0.025);\n    float c33 = circ(vUv, vec2(0.5 * sin(u_time * 2.70), 0.5 * cos(u_time - 2.70)), 0.025);\n    float c34 = circ(vUv, vec2(0.5 * sin(u_time * 2.75), 0.5 * cos(u_time - 2.75)), 0.025);\n    float c35 = circ(vUv, vec2(0.5 * sin(u_time * 2.80), 0.5 * cos(u_time - 2.80)), 0.025);\n    float c36 = circ(vUv, vec2(0.5 * sin(u_time * 2.85), 0.5 * cos(u_time - 2.85)), 0.025);\n    float c37 = circ(vUv, vec2(0.5 * sin(u_time * 2.90), 0.5 * cos(u_time - 2.90)), 0.025);\n    float c38 = circ(vUv, vec2(0.5 * sin(u_time * 2.95), 0.5 * cos(u_time - 2.95)), 0.025);\n    float c39 = circ(vUv, vec2(0.5 * sin(u_time * 3.00), 0.5 * cos(u_time - 3.00)), 0.025);\n    float c40 = circ(vUv, vec2(0.5 * sin(u_time * 3.05), 0.5 * cos(u_time - 3.05)), 0.025);\n    float c41 = circ(vUv, vec2(0.5 * sin(u_time * 3.10), 0.5 * cos(u_time - 3.10)), 0.025);\n    float c42 = circ(vUv, vec2(0.5 * sin(u_time * 3.15), 0.5 * cos(u_time - 3.15)), 0.025);\n    float c43 = circ(vUv, vec2(0.5 * sin(u_time * 3.20), 0.5 * cos(u_time - 3.20)), 0.025);\n    float c44 = circ(vUv, vec2(0.5 * sin(u_time * 3.25), 0.5 * cos(u_time - 3.25)), 0.025);\n    float c45 = circ(vUv, vec2(0.5 * sin(u_time * 3.30), 0.5 * cos(u_time - 3.30)), 0.025);\n    float c46 = circ(vUv, vec2(0.5 * sin(u_time * 3.35), 0.5 * cos(u_time - 3.35)), 0.025);\n    float c47 = circ(vUv, vec2(0.5 * sin(u_time * 3.40), 0.5 * cos(u_time - 3.40)), 0.025);\n    float c48 = circ(vUv, vec2(0.5 * sin(u_time * 3.45), 0.5 * cos(u_time - 3.45)), 0.025);\n    float c49 = circ(vUv, vec2(0.5 * sin(u_time * 3.50), 0.5 * cos(u_time - 3.50)), 0.025);\n    float c50 = circ(vUv, vec2(0.5 * sin(u_time * 3.55), 0.5 * cos(u_time - 3.55)), 0.025);\n    color.rg += c1 + c2 + c3 + c4 + c5 + c6 + c7 + c8 + c9 + c10 +\n             c11 + c12 + c13 + c14 + c15 + c16 + c17 + c18 + c19 + c20 +\n             c21 + c22 + c23 + c24 + c25 + c26 + c27 + c28 + c29 + c30 +\n             c31 + c32 + c33 + c34 + c35 + c36 + c37 + c38 + c39 + c40 +\n             c41 + c42 + c43 + c44 + c45 + c46 + c47 + c48 + c49 + c50;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Ly(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Oy,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ay=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5. - 2.5;\n    float t = u_time;\n    vUv *= Rot(t);\n    float d1 = length( min(abs(vec2(vUv.x + sin(u_time), vUv.y * cos(u_time)) + 0.15 * 1.1)-.1,0.));\n    float d2 = length( min(abs(vec2(vUv.x * sin(u_time), vUv.y + cos(u_time)) - 0.25 * 2.1)-.1,0.));\n    float d3 = length( min(abs(vec2(vUv.x + sin(u_time), vUv.y * cos(u_time)) + 0.35 * 3.1)-.1,0.));\n    float d4 = length( min(abs(vec2(vUv.x * sin(u_time), vUv.y + cos(u_time)) - 0.45 * 4.1)-.1,0.));\n    float d5 = length( min(abs(vec2(vUv.x + sin(u_time), vUv.y * cos(u_time)) + 0.55 * 5.1)-.1,0.));\n    float d6 = length( min(abs(vec2(vUv.x * sin(u_time), vUv.y + cos(u_time)) - 0.65 * 6.1)-.1,0.));\n    float d7 = length( min(abs(vec2(vUv.x + sin(u_time), vUv.y * cos(u_time)) + 0.75 * 7.1)-.1,0.));\n    float d8 = length( min(abs(vec2(vUv.x * sin(u_time), vUv.y + cos(u_time)) - 0.85 * 8.1)-.1,0.));\n    //d = length( max(abs(vUv)-.3,0.) );\n    vec3 color = vec3(0.);\n    color = vec3(fract(d1 * 10.));\n    color += vec3(fract(d2 * 10.));\n    color += vec3(fract(d3 * 10.));\n    color += vec3(fract(d4 * 10.));\n    color += vec3(fract(d5 * 10.));\n    color += vec3(fract(d6 * 10.));\n    color += vec3(fract(d7 * 10.));\n    color += vec3(fract(d8 * 10.));\n    //color = vec3(step(0.3, d) * step(d, 0.4));\n    //color = vec3(smoothstep(0.3, 0.4, d) * smoothstep(0.6, 0.5, d));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Ny(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ay,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Gy=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * 4. -2.;\n        float d1 = step(0.05, length(abs(vec2(vUv.x + sin(u_time * 1.0 * 1.2) - 0.0, vUv.y + cos(u_time *  1.0 * 1.2) - 0.0)) - 0.25));\n        float d2 = step(0.05, length(abs(vec2(vUv.x + cos(u_time * 1.1 * 1.2) - 0.0, vUv.y + sin(u_time *  1.1 * 1.2) - 0.0)) - 0.25));\n        float d3 = step(0.05, length(abs(vec2(vUv.x + cos(u_time * 1.2 * 1.2) - 0.1, vUv.y + sin(u_time *  1.2 * 1.2) - 0.1)) - 0.25));\n        float d4 = step(0.05, length(abs(vec2(vUv.x + sin(u_time * 1.3 * 1.2) - 0.1, vUv.y + cos(u_time *  1.3 * 1.2) - 0.1)) - 0.25));\n        float d5 = step(0.05, length(abs(vec2(vUv.x + cos(u_time * 1.4 * 1.2) + 0.1, vUv.y + sin(u_time *  1.4 * 1.2) + 0.1)) - 0.25));\n        float d6 = step(0.05, length(abs(vec2(vUv.x + sin(u_time * 1.5 * 1.2) + 0.1, vUv.y + cos(u_time *  1.5 * 1.2) + 0.1)) - 0.25));\n        float d7 = step(0.05, length(abs(vec2(vUv.x + cos(u_time * 1.6 * 1.2) + 0.1, vUv.y + sin(u_time *  1.6 * 1.2) - 0.1)) - 0.25));\n        float d8 = step(0.05, length(abs(vec2(vUv.x + sin(u_time * 1.7 * 1.2) + 0.1, vUv.y + cos(u_time *  1.7 * 1.2) - 0.1)) - 0.25));\n        float d9 = step(0.05, length(abs(vec2(vUv.x + cos(u_time * 1.8 * 1.2) - 0.1, vUv.y + sin(u_time *  1.8 * 1.2) + 0.1)) - 0.25));\n        float d10 = step(0.05, length(abs(vec2(vUv.x +sin(u_time * 1.9 * 1.2) - 0.1, vUv.y + cos(u_time *  1.9 * 1.2) + 0.1)) - 0.25));\n    \n        vec3 color = vec3(0.);\n        color = vec3(d1 * d2 * d3 * d4 * d5 * d6 * d7 * d8 * d9 * d10);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function By(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Gy,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qy=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * 4. -2.;\n        float d1 = step(0.1*  abs(sin(2.0 * u_time)), length(abs(vec2(vUv.x - 1.50, vUv.y + cos(u_time *  3.0 * 0.75))) - 0.25));\n        float d2 = step(0.1*  abs(sin(2.1 * u_time)), length(abs(vec2(vUv.x - 1.25, vUv.y + cos(u_time *  3.1 * 0.75))) - 0.25));\n        float d3 = step(0.1*  abs(sin(2.2 * u_time)), length(abs(vec2(vUv.x - 1.00, vUv.y + cos(u_time *  3.2 * 0.75))) - 0.25));\n        float d4 = step(0.1*  abs(sin(2.3 * u_time)), length(abs(vec2(vUv.x - 0.75, vUv.y + cos(u_time *  3.3 * 0.75))) - 0.25));\n        float d5 = step(0.1*  abs(sin(2.4 * u_time)), length(abs(vec2(vUv.x - 0.50, vUv.y + cos(u_time *  3.4 * 0.75))) - 0.25));\n        float d6 = step(0.1*  abs(sin(2.5 * u_time)), length(abs(vec2(vUv.x - 0.25, vUv.y + cos(u_time *  3.5 * 0.75))) - 0.25));\n        float d7 = step(0.1*  abs(sin(2.6 * u_time)), length(abs(vec2(vUv.x + 0.00, vUv.y + cos(u_time *  3.6 * 0.75))) - 0.25));\n        float d8 = step(0.1*  abs(sin(2.7 * u_time)), length(abs(vec2(vUv.x + 0.25, vUv.y + cos(u_time *  3.7 * 0.75))) - 0.25));\n        float d9 = step(0.1*  abs(sin(2.8 * u_time)), length(abs(vec2(vUv.x + 0.50, vUv.y + cos(u_time *  3.8 * 0.75))) - 0.25));\n        float d10 =step(0.1*  abs(sin(2.9 * u_time)), length(abs(vec2(vUv.x + 0.75, vUv.y + cos(u_time *  3.9 * 0.75))) - 0.25));\n        float d11 =step(0.1*  abs(sin(3.0 * u_time)), length(abs(vec2(vUv.x + 1.00, vUv.y + cos(u_time *  4.0 * 0.75))) - 0.25));\n        float d12 =step(0.1*  abs(sin(3.1 * u_time)), length(abs(vec2(vUv.x + 1.25, vUv.y + cos(u_time *  4.1 * 0.75))) - 0.25));\n        float d13 =step(0.1*  abs(sin(3.2 * u_time)), length(abs(vec2(vUv.x + 1.50, vUv.y + cos(u_time *  4.2 * 0.75))) - 0.25));\n    \n        vec3 color = vec3(0.);\n        color = 1. - vec3(d1 * d2 * d3 * d4 * d5 * d6 * d7 * d8 * d9 * d10 * d11 * d12 * d13);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Vy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qy,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Wy=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //rotation function\nmat2 RotClock(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nmat2 RotCounter(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    float t=u_time*.25 - 0.5;\n    \n    vec3 color = vec3(0.);\n    \n    vec2 pos = vec2(0.5 - vUv.x, 0.5 - vUv.y);\n    pos*=RotClock(t*1.)*2.;\n    float r=length(pos)*2.;\n    float a=atan(pos.y,pos.x);\n    \n    vec2 pos2=vec2(.28-vUv.x,.72-vUv.y);\n    pos2*= RotCounter(t*1.)*2.;\n    float r2=length(pos2)*2.;\n    float a2=atan(pos2.y,pos2.x);\n\n    vec2 pos3=vec2(.78-vUv.x,.64-vUv.y);\n    pos3*=RotCounter(t*1.)*2.;\n    float r3=length(pos3)*2.;\n    float a3=atan(pos3.y,pos3.x);\n\n    vec2 pos4=vec2(.55-vUv.x,.19-vUv.y);\n    pos4*=RotCounter(t*1.)*2.;\n    float r4=length(pos4)*2.;\n    float a4=atan(pos4.y,pos4.x);\n    \n    \n    float f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;\n    float f2=smoothstep(-.5,1.,cos(a2*10.))*.2+.5;\n    float f3=smoothstep(-.5,1.,cos(a3*10.))*.2+.5;\n    float f4=smoothstep(-.5,1.,cos(a4*10.))*.2+.5;\n\n    vec3 d1=vec3(1.-smoothstep(f, f + 0.02, r));\n    vec3 d2=vec3(1.-smoothstep(f2,f2+.02,r2));\n    vec3 d3=vec3(1.-smoothstep(f3,f3+.02,r3));\n    vec3 d4=vec3(1.-smoothstep(f4,f4+.02,r4));\n\n    color = d1;\n    color += d2;\n    color += d3;\n    color+=d4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Hy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Wy,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Xy=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //rotation function\nmat2 RotClock(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid main(){\n    vec3 color = vec3(0.);\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. -1.;\n\n    vec2 pos=vec2(vUv.x,vUv.y * abs(cos(u_time * 0.5)));\n    vec2 pos2=vec2(vUv.x * abs(sin(u_time)),vUv.y);\n    vec2 pos3=vec2(vUv.x * abs(cos(u_time)),vUv.y);\n    float t=u_time*.25-.5;\n    pos*=RotClock(t*1.);\n    pos2*=RotClock(t*1.);\n    pos3*=RotClock(t*1.);\n    \n    int tri = 3;\n    int quad= 4;\n    int pent =5;\n    int hex = 6;\n    float a = atan(pos.x, pos.y) + PI ;\n    float a2=atan(pos2.x,pos2.y)+PI;\n    float a3=atan(pos3.x,pos3.y)+PI;\n    float r3=TWO_PI/float(tri) ;\n    float r4=TWO_PI/float(quad);\n    float r6=TWO_PI/float(hex) ;\n    float d3=cos(floor(.5+a/r3)*r3 - a)*(length(vUv)) * 3.0;\n    float d4=cos(floor(.5+a2/r4)*r4 - a2)*(length(vUv)) * 1.0;\n    float d6=cos(floor(.5+a3/r6)*r6 - a3)*(length(vUv)) * 0.5;\n    float shape3= (1.-smoothstep(.4,.41,d3));\n    float shape4= (1.-smoothstep(.4,.41,d4));\n    float shape6= (1.-smoothstep(.4,.41,d6));\n    //shape = vec3(d);\n    color.xz += shape3 - 0.1;\n    color.y += shape4;\n    color.z += shape6;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Yy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Xy,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $y=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * 2. - 1.;\n        vec3 color = vec3(0.);\n        float d = length((vec2((vUv.x) - (sin(u_time/2.)), (vUv.y) - cos(u_time/2.))) );\n        d *= atan(d, d);\n        d *= step(0.05, d);\n        float d2=length((vec2((vUv.x) - (cos(u_time/2.)),(vUv.y) - sin(u_time/2.))) );\n        d2*=atan(d2, d2);\n        d2*=step(.05,d2);\n        color = vec3(d / vUv.x, d +  vUv.y, 0.5);\n        color += vec3(d2 / vUv.x, d2 + vUv.y, 0.5);\n        color *= vec3(d);\n        color *= vec3(d2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Zy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$y,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ky=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = vUv * 3.0 - 1.5;\n        float t = u_time * u_time;\n        vUv *= Rot(t);\n        float r = length(vec2(vUv.x, vUv.y));\n        float a = atan(vUv.x, vUv.y);\n        float f = cos(a * 3.);\n        float shape = 1. - smoothstep(f, f + 0.02, r);\n        color = vec3(shape * vUv.x, shape * vUv.y, shape * vUv.x * vUv.y);  \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Jy(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ky,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qy=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n        float t = u_time * 0.75;\n        vUv *= Rot(t);\n        vec3 color = vec3(0.);\n        int N = 3;\n        float a  = dot(vUv.x, vUv.y) * TWO_PI * 1. - sin(u_time + TWO_PI);\n        float r = PI/(float(N) * 1.  - (sin(u_time)));\n        float d = cos(floor(.5 + a / r) * r - a) * length(vUv);\n        float shape = 1.0 - smoothstep(.05, 0.9, d);\n        color = vec3(shape * vUv.x + shape, shape * vUv.y + shape, shape);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Qy,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec3 color = vec3(0.);\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 4. -2.;\n        float t = u_time * 0.75;\n        vUv *= Rot(t);\n        int sides = 3;\n        float a = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/float(sides);\n        float shape = cos(floor(.5 + a/r) * r -a) * length(vUv + atan(sin(u_time * 0.5)));\n        float shape2 = cos(floor(.5 + a/r) * r -a) * length(vUv + atan(cos(u_time * 0.75)));\n        float shape3 = cos(floor(.5 + a/r) * r -a) * length(vUv + atan(sin(u_time * 0.6)));\n        float str = 1.0 - smoothstep(.2, .41, shape);\n        float str2 = 1.0 - smoothstep(.2, .41, shape2);\n        float str3 = 1.0 - smoothstep(.2, .41, shape3);\n        color = vec3(str, str, vUv.y * str * vUv.x);\n        color += vec3(str2, vUv.y * str2 * vUv.x, str2);\n        color += vec3(vUv.y * str3 * vUv.x, str3, str3);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:eb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 6. - 3.;\n        float a  = atan(vUv.x + cos(u_time) * 2.0, vUv.y + sin(u_time) * 2.0) + (sin(u_time * 0.5) * 3.0);\n        float r = TWO_PI/3.;\n        float d = sin(floor(.8 + a/r) * r -a ) * length(vUv);\n        float shape = 1.0 - smoothstep(.4, .41, d);\n        vec3 color = vec3(0.);\n        color = vec3(shape - 0.2, shape - 0.5, shape + 0.3);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ob(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ab=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //rotation function\nmat2 Rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 3. - 1.5;\n    float t=u_time*.25;\n    vUv*=Rot(t*1.);\n    vec3 color = vec3(0.);\n    float r = sin(vUv.x * TWO_PI);\n    float s = cos(vUv.y * TWO_PI);\n    float q = cos(vUv.y * TWO_PI * sin(u_time * 0.5));\n    float p = sin(vUv.x * TWO_PI * sin(u_time * 0.5));\n    float str = r * s + q  + p;\n    float shape = smoothstep(.8, .81, str);\n    color = vec3(shape);\n    color *= q;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ib(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ab,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //rotation function\nmat2 Rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vUv = vUv * 2. - 1.;\n    vec2 r1=abs(vUv);\n    r1*=Rot(sin(u_time) );\n    vec2 r2=abs(vUv);\n    r2*=Rot(sin(u_time * .25) );\n    vec2 r3=abs(vUv);\n    r3*=Rot(sin(u_time * .50) );\n    vec2 r4=abs(vUv);\n    r4*=Rot(sin(u_time * .75) );\n    vec2 r5=abs(vUv);\n    r5*=Rot(sin(u_time * 1.25) );\n    float s1=max(r1.x,r1.y);\n    float s2=max(r2.x,r2.y);\n    float s3=max(r3.x,r3.y);\n    float s4=max(r4.x,r4.y);\n    float s5=max(r5.x,r5.y);\n    float shape1=step(.4,s1);\n    float shape2=step(s2,.5);\n    float shape3=step(.6,s3);\n    float shape4=step(s4,.3);\n    float shape5=step(.2,s5);\n    vec3 color = vec3(0.);\n    color = vec3(shape1 * shape2);\n    color += vec3(shape3);\n    color += vec3(shape4);\n    color *= vec3(shape5);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    mat2 Rot(float a){\n        float s=sin(a);\n        float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * (6. * sin(u_time * 0.5)) - (3. * sin(u_time * 0.5));\n        vec2 r1=vUv;\n        r1*=Rot(sin(-u_time * 0.5 * 3.));\n        vec2 r2=vUv;\n        r2*=Rot(sin(u_time * 0.4 * 3.));\n        vec2 r3=vUv;\n        r3*=Rot(sin(u_time * 0.6 * 3.));\n        vec2 r4=vUv;\n        r4*=Rot(sin(-u_time * 0.3 * 3.));\n        vec2 r5=vUv;\n        r5*=Rot(sin(u_time * 0.2 * 3.));\n        vec2 r6=vUv;\n        r6*=Rot(sin(-u_time * 0.1 * 3.));\n        vec3 color = vec3(0.);\n        int N = 6;\n        float a1=atan(r1.x,r1.y);\n        float a2=atan(r2.x,r2.y);\n        float a3=atan(r3.x,r3.y);\n        float a4=atan(r4.x,r4.y);\n        float a5=atan(r5.x,r5.y);\n        float a6=atan(r6.x,r6.y);\n        float b = 6.28319 / float(N);\n        vec3 shape1=vec3(smoothstep(.5, .51, cos(floor(.5 + a1/b) * b - a1) * length(vec2(vUv.x,vUv.y))));\n        vec3 shape2=vec3(smoothstep(1.1,1.11,cos(floor(.5+a2/b)*b-a2)*length(vec2(vUv.x,vUv.y))));\n        vec3 shape3=vec3(smoothstep(.1,.11,cos(floor(.5+a3/b)*b-a3)*length(vec2(vUv.x,vUv.y))));\n        vec3 shape4=vec3(smoothstep(1.5,1.51,cos(floor(.5+a4/b)*b-a4)*length(vec2(vUv.x,vUv.y))));\n        vec3 shape5=vec3(smoothstep(2.1,2.11,cos(floor(.5+a5/b)*b-a5)*length(vec2(vUv.x,vUv.y))));\n        vec3 shape6=vec3(smoothstep(2.51,2.51,cos(floor(.5+a6/b)*b-a6)*length(vec2(vUv.x,vUv.y))));\n        color = shape3;\n        color -= shape1;\n        color += shape2;\n        color -= shape4;\n        color += shape5;\n        color -= shape6;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ub=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 4. - 2.;\n        vec3 color = vec3(0.);\n        float cir1 = circle(vec2(vUv.x + sin(u_time * 1.0), vUv.y - 1.00), 0.0125);\n        float cir2 = circle(vec2(vUv.x + sin(u_time * 1.1), vUv.y - 0.75), 0.0125);\n        float cir3 = circle(vec2(vUv.x + sin(u_time * 1.2), vUv.y - 0.50), 0.0125);\n        float cir4 = circle(vec2(vUv.x + sin(u_time * 1.3), vUv.y - 0.25), 0.0125);\n        float cir5 = circle(vec2(vUv.x + sin(u_time * 1.4), vUv.y - 0.00), 0.0125);\n        float cir6 = circle(vec2(vUv.x + sin(u_time * 1.5), vUv.y + 0.25), 0.0125);\n        float cir7 = circle(vec2(vUv.x + sin(u_time * 1.6), vUv.y + 0.50), 0.0125);\n        float cir8 = circle(vec2(vUv.x + sin(u_time * 1.7), vUv.y + 0.75), 0.0125);\n        float cir9 = circle(vec2(vUv.x + sin(u_time * 1.8), vUv.y + 1.00), 0.0125);\n    \n        float cirv1 = circle(vec2(vUv.x  - 1.00, vUv.y  + sin(u_time * 1.0)), 0.0125);\n        float cirv2 = circle(vec2(vUv.x  - 0.75, vUv.y  + sin(u_time * 1.1)), 0.0125);\n        float cirv3 = circle(vec2(vUv.x  - 0.50, vUv.y  + sin(u_time * 1.2)), 0.0125);\n        float cirv4 = circle(vec2(vUv.x  - 0.25, vUv.y  + sin(u_time * 1.3)), 0.0125);\n        float cirv5 = circle(vec2(vUv.x  - 0.00, vUv.y  + sin(u_time * 1.4)), 0.0125);\n        float cirv6 = circle(vec2(vUv.x  + 0.25, vUv.y  + sin(u_time * 1.5)), 0.0125);\n        float cirv7 = circle(vec2(vUv.x  + 0.50, vUv.y  + sin(u_time * 1.6)), 0.0125);\n        float cirv8 = circle(vec2(vUv.x  + 0.75, vUv.y  + sin(u_time * 1.7)), 0.0125);\n        float cirv9 = circle(vec2(vUv.x  + 1.00, vUv.y  + sin(u_time * 1.8)), 0.0125);\n        color = vec3(cir1 + cir2 + cir3 + cir4 + cir5 + cir6 + cir7 + cir8 + cir9);\n        color += vec3(cirv1 + cirv2 + cirv3 + cirv4 + cirv5 + cirv6 + cirv7 + cirv8 + cirv9);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ub,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec2 pos = vec2(0.5) - vec2(vUv.x + 0.3, vUv.y);\n        vec2 pos2 = vec2(0.5) - vec2(vUv.x, vUv.y);\n        vec2 pos3 = vec2(0.5) - vec2(vUv.x - 0.3, vUv.y);\n        vec2 pos4 = vec2(0.5) - vec2(vUv.x + 0.3, vUv.y + 0.3);\n        vec2 pos5 = vec2(0.5) - vec2(vUv.x, vUv.y + 0.3);\n        vec2 pos6 = vec2(0.5) - vec2(vUv.x - 0.3, vUv.y + 0.3);\n        vec2 pos7 = vec2(0.5) - vec2(vUv.x + 0.3, vUv.y - 0.3);\n        vec2 pos8 = vec2(0.5) - vec2(vUv.x, vUv.y - 0.3);\n        vec2 pos9 = vec2(0.5) - vec2(vUv.x - 0.3, vUv.y - 0.3);\n        vec3 color = vec3(0.);\n        float t = u_time * 0.75;\n        pos *= Rot(t);\n        pos2 *= Rot(t * 1.5);\n        pos3 *= Rot(t * 2.0);\n        pos4 *= Rot(t * 2.5);\n        pos5 *= Rot(t * 3.0);\n        pos6 *= Rot(t * 3.5);\n        pos7 *= Rot(t * 2.0);\n        pos8 *= Rot(t * 3.5);\n        pos9 *= Rot(t * 3.0);\n        float r1 = length(pos) * 7.0;\n        float r2 = length(pos2) * 7.0;\n        float r3 = length(pos3) * 7.0;\n        float r4 = length(pos4) * 7.0;\n        float r5 = length(pos5) * 7.0;\n        float r6 = length(pos6) * 7.0;\n        float r7 = length(pos7) * 7.0;\n        float r8 = length(pos8) * 7.0;\n        float r9 = length(pos9) * 7.0;\n        float a = atan(pos.y, pos.x);\n        float a2 = atan(pos2.y, pos2.x);\n        float a3 = atan(pos3.y, pos3.x);\n        float a4 = atan(pos4.y, pos4.x);\n        float a5 = atan(pos5.y, pos5.x);\n        float a6 = atan(pos6.y, pos6.x);\n        float a7 = atan(pos7.y, pos7.x);\n        float a8 = atan(pos8.y, pos8.x);\n        float a9 = atan(pos9.y, pos9.x);\n        float f = cos(a * 3.);\n        float f2 = cos(a2 * 3.);\n        float f3 = cos(a3 * 3.);\n        float f4 = cos(a4 * 3.);\n        float f5 = cos(a5 * 3.);\n        float f6 = cos(a6 * 3.);\n        float f7 = cos(a7 * 3.);\n        float f8 = cos(a8 * 3.);\n        float f9 = cos(a9 * 3.);\n        float shape = 1. - smoothstep(f, f + 0.02, r1);\n        float shape2 = 1. - smoothstep(f2, f2 + 0.02, r2);\n        float shape3 = 1. - smoothstep(f3, f3 + 0.02, r3);\n        float shape4 = 1. - smoothstep(f4, f4 + 0.02, r4);\n        float shape5 = 1. - smoothstep(f5, f5 + 0.02, r5);\n        float shape6 = 1. - smoothstep(f6, f6 + 0.02, r6);\n        float shape7 = 1. - smoothstep(f7, f7 + 0.02, r7);\n        float shape8 = 1. - smoothstep(f8, f8 + 0.02, r8);\n        float shape9 = 1. - smoothstep(f9, f9 + 0.02, r9);\n        color = vec3(shape + shape2 + shape3 + shape4 + shape5 + shape6 + shape7 + shape8 + shape9);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function db(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //box sdf book of shaders\nfloat box(vec2 vUv, vec2 size){\n    size = vec2(0.5) - size * 0.5;\n    vec2 uv = smoothstep(size, size + vec2(0.001), vUv);\n    uv *= smoothstep(size, size + vec2(0.001), vec2(1.0) - vUv);\n    return uv.x * uv.y;\n}\n\n//cross sdf book of shaders\nfloat cross1(vec2 vUv, float size){\n    return box(vUv, vec2(size, size/4.)) + box(vUv, vec2(size/4., size));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vUv = vUv * 2. - 0.5;\n    vec3 color = vec3(0.);\n    vec2 translate = vec2((sin(u_time)), abs(cos(u_time)));\n    vUv += translate * 0.5;\n    float shape = cross1(vUv, 0.5);\n    color = vec3(shape);\n    color += vec3(vUv.x, vUv.y, 0.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //box sdf book of shaders\nfloat box(vec2 vUv, vec2 size){\n    size = vec2(0.5) - size * 0.5;\n    vec2 uv = smoothstep(size, size + vec2(0.001), vUv);\n    uv *= smoothstep(size, size + vec2(0.001), vec2(1.0) - vUv);\n    return uv.x * uv.y;\n}\n\n//cross sdf book of shaders\nfloat cross1(vec2 vUv, float size){\n    return box(vUv, vec2(size, size/4.)) + box(vUv, vec2(size/4., size));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 newUv = vUv;\n    vUv = vUv * 3. - 1.;\n    newUv = newUv * 3. - 1.;\n    vec2 translate = vec2(cos(u_time), sin(u_time));\n    vUv += translate;\n    //newUv += translate;\n    vec3 color = vec3(0.);\n    float shape = cross1(newUv, 0.5);\n    color = vec3(vUv, 0.);\n    color += vec3(shape);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //box sdf book of shaders\nfloat box(vec2 vUv, vec2 size){\n    size = vec2(0.5) - size * 0.5;\n    vec2 uv = smoothstep(size, size + vec2(0.001), vUv);\n    uv *= smoothstep(size, size + vec2(0.001), vec2(1.0) - vUv);\n    return uv.x * uv.y;\n}\n\n//cross sdf book of shaders\nfloat cross1(vec2 vUv, float size){\n    return box(vUv, vec2(size, size/4.)) + box(vUv, vec2(size/4., size));\n}\n\n//rotation 2d book of shaders\nmat2 rotate2d(float angle){\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vec2 newUv = vUv;\n    vUv = vUv * 2. - 0.5;\n    newUv = newUv * 2. - 1.;\n    newUv = rotate2d(cos(u_time) * PI) * newUv;\n    newUv += vec2(0.5);\n    vec3 color = vec3(0.);\n    float shape = cross1(newUv, 0.5);\n    float shape2 = cross1(vec2(newUv.x, newUv.y - 0.65), 0.5);\n    float shape3 = cross1(vec2(newUv.x, newUv.y + 0.65), 0.5);\n    float shape4 = cross1(vec2(newUv.x - 0.65, newUv.y), 0.5);\n    float shape5 = cross1(vec2(newUv.x + 0.65, newUv.y), 0.5);\n    color = vec3(shape + shape2 + shape3 + shape4 + shape5);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _b=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //box sdf book of shaders\nfloat box(vec2 vUv,vec2 size){\n    size=vec2(.5)-size*.5;\n    vec2 uv=smoothstep(size,size+vec2(.001),vUv);\n    uv*=smoothstep(size,size+vec2(.001),vec2(1.)-vUv);\n    return uv.x*uv.y;\n}\n\n//cross sdf book of shaders\nfloat crossSDF(vec2 vUv,float size){\n    return box(vUv,vec2(size,size/4.))+box(vUv,vec2(size/4.,size));\n}\n\n//rotation 2d book of shaders\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n//scale 2d book of shaders\nmat2 scale(vec2 s){\n    return mat2(s.x, 0.0,\n                0.0, s.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vec2 newUv = vUv;\n    newUv = newUv * 2. - 1.;\n    newUv = rotate2d(sin(u_time) * PI) * newUv;\n    newUv += vec2(0.5);\n    newUv -= vec2(0.5);\n    newUv = scale(vec2(sin(u_time) + 1.)) * newUv;\n    newUv += vec2(0.5);\n    //vUv = rotate2d(sin(u_time) * PI) * vUv;\n    vec3 color = vec3(0.);\n    float shape = crossSDF(newUv, 0.5);\n    color += vec3(shape);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Ub(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_b,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // YUV to RGB matrix book of shaders\nmat3 yuv2rgb=mat3(1.,0.,1.13983,\n    1.,-.39465,-.58060,\n    1.,2.03211,0.);\n\n// RGB to YUV matrix book of shaders\nmat3 rgb2yuv=mat3(.2126,.7152,.0722,\n    -.09991,-.33609,.43600,\n    .615,-.5586,-.05639);\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv -= 0.5;\n    vUv *= 4.0;\n    float cir = 1. - smoothstep(1.0, 1.01, distance(vec2(vUv.x + 0.5, vUv.y + 0.5), vec2(0.5)));\n    vec3 color = rgb2yuv * vec3(sin(u_time), vUv.x + sin(u_time), vUv.y + cos(u_time));\n    color *= vec3(cir);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Sb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float cir(vec2 vUv,vec2 pos,float s){\n        return 1.-smoothstep(s,s+.01,distance(vUv,pos));\n    }\n    \n    mat2 scale(vec2 s){\n        return mat2(s.x, 0.0,\n                    0.0, s.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 0.5;\n        vec2 newUv = vUv;\n        newUv -= vec2(0.5);\n        newUv = scale(vec2(sin((u_time * 1.5) + 1.0/1.5) + 2.0)) * newUv;\n        newUv += vec2(0.5);\n    \n        vec2 newUv2=vUv;\n        newUv2-=vec2(.5);\n        newUv2=scale(vec2(sin((u_time * 1.5) + 2.0/1.5) +2.))*newUv2;\n        newUv2+=vec2(.5);\n    \n        vec2 newUv3=vUv;\n        newUv3-=vec2(.5);\n        newUv3=scale(vec2(sin((u_time * 1.5) + 3.0/1.5) +2.))*newUv3;\n        newUv3+=vec2(.5);\n    \n        vec2 newUv4=vUv;\n        newUv4-=vec2(.5);\n        newUv4=scale(vec2(sin((u_time * 1.5) + 4.0/1.5) +2.))*newUv4;\n        newUv4+=vec2(.5);\n    \n        vec2 newUv5=vUv;\n        newUv5-=vec2(.5);\n        newUv5=scale(vec2(sin((u_time * 1.5) + 5.0/1.5) +2.))*newUv5;\n        newUv5+=vec2(.5);\n    \n        vec3 color = vec3(0.);\n        float c1=cir(newUv ,vec2(-0.2,.5),.1);\n        float c2=cir(newUv2,vec2(.15,.5),.1);\n        float c3=cir(newUv3,vec2(.5,.5),.1);\n        float c4=cir(newUv4,vec2(0.85,.5),.1);\n        float c5=cir(newUv5,vec2(1.2,.5),.1);\n        color = vec3(c1 + c2 + c3 + c4 + c5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Mb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    mat2 Rot(float x){\n        return mat2(cos(x), -sin(x),\n                    sin(x), cos(x));\n    }\n    \n    mat2 Scale(vec2 s){\n        return mat2(s.x, 0.0,\n                    0.0, s.y);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * 2. - 0.5;\n        vec3 color = vec3(0.);\n    \n        vec2 newUv = vUv;\n        newUv -= vec2(0.5);\n        newUv = Scale(vec2(sin(u_time) )) * newUv;\n        newUv += vec2(0.5);\n        \n        vec2 newUv2 = vUv;\n        newUv2 -= vec2(0.5);\n        newUv2 = Scale(vec2((sin(u_time) + 1.25))) * newUv2;\n        newUv2 += vec2(0.5);\n        \n        vec2 newUv3 = vUv;\n        newUv3 -= vec2(0.5);\n        newUv3 = Scale(vec2((sin(u_time) + 1.5))) * newUv3;\n        newUv3 += vec2(0.5);\n    \n        vec2 newUv4 = vUv;\n        newUv4 -= vec2(0.5);\n        newUv4 = Scale(vec2((sin(u_time) + 1.85))) * newUv4;\n        newUv4 += vec2(0.5);\n    \n        vec2 newUv5 = vUv;\n        newUv5 -= vec2(0.5);\n        newUv5 = Scale(vec2((sin(u_time) + 1.95))) * newUv5;\n        newUv5 += vec2(0.5);\n    \n        vec2 newUv6 = vUv;\n        newUv6 -= vec2(0.5);\n        newUv6 = Scale(vec2((sin(u_time) + 1.0))) * newUv6;\n        newUv6 += vec2(0.5);\n    \n        float shape = Cir(newUv, vec2(0.5), 0.5) - Cir(newUv, vec2(0.5), 0.45);\n        float shape2 = Cir(newUv2, vec2(0.5), 0.4) - Cir(newUv2, vec2(0.5), 0.35);\n        float shape3 = Cir(newUv3, vec2(0.5), 0.3) - Cir(newUv3, vec2(0.5), 0.25);\n        float shape4 = Cir(newUv4, vec2(0.5), 0.2) - Cir(newUv4, vec2(0.5), 0.15);\n        float shape5 = Cir(newUv5, vec2(0.5), 0.6) - Cir(newUv5, vec2(0.5), 0.55);\n        float shape6 = Cir(newUv6, vec2(0.5), 0.7) - Cir(newUv6, vec2(0.5), 0.65);\n        \n    \n        color = vec3(shape + shape2 + shape3 + shape4 + shape5 + shape6);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Cb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Tb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    mat2 rotate2d(float angle){\n        return mat2(cos(angle), -sin(angle),\n                    sin(angle), cos(angle));\n    }\n    \n    float box(vec2 vUv, vec2 size){\n        vUv = vUv * 2. - 1.0;\n        size = vec2(0.5) - size * 0.5;\n        vUv = rotate2d(cos(u_time) * PI) * vUv;\n        vUv += vec2(0.5);\n        vec2 sdf = smoothstep(size, size+vec2(0.01), vUv);\n        sdf *= smoothstep(size, size+vec2(0.01), vec2(1.0) - vUv);\n        vec2 newUv = vUv; \n        newUv -= vec2(0.5);\n        newUv = rotate2d(sin(u_time) * PI) * newUv;\n        newUv += vec2(0.5);\n        vec2 sdf2 = smoothstep(size, size + vec2(0.01), newUv);\n        sdf2 *= smoothstep(size, size + vec2(0.01), vec2(1.0) - newUv);\n        return (sdf.x * sdf.y) + (sdf2.x * sdf2.y);\n    }\n    \n    float shape(vec2 vUv, float size){\n        return box(vUv, vec2(size, size/8.)) +\n               box(vUv, vec2(size/8., size));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float x = shape(vUv, 1.5);\n        color = vec3(x, x * sin(u_time), x*cos(u_time));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Rb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Tb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Db=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //box sdf\nfloat box(vec2 vUv, vec2 size){\n    size = vec2(0.5) - size * 0.5;\n    vec2 sdf = smoothstep(size, size+vec2(0.01), vUv);\n    sdf *= smoothstep(size, size+vec2(0.01), vec2(1.0) - vUv);\n    return sdf.x * sdf.y;\n}\n\nfloat Cir(vec2 vUv, vec2 pos, float size){\n    return (1. - smoothstep(size, size + 0.01, distance(vUv, pos))) * smoothstep(size/2., size/2. + 0.01, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.25, vUv.y - 0.5);\n    vUv = vUv * 2.0;\n    vec3 color = vec3(0.);\n    vec2 onevUv = vec2(vUv.x + 0.36, vUv.y);\n    onevUv.y += abs(sin(u_time * 0.75 + 0.1));\n    float oneShape = box(onevUv, vec2(0.09, 0.3));\n    color = vec3(oneShape);\n    vec2 twovUv = vec2(vUv.x, vUv.y);\n    twovUv.y += abs(sin(u_time * 0.75));\n    float twoShape = Cir(twovUv, vec2(0.4, 0.5), 0.15);\n    color += vec3(twoShape);\n    vec2 threevUv = vec2(vUv);\n    threevUv.y += abs(sin(u_time * 0.75 - 0.1));\n    float threeShape = Cir(threevUv, vec2(0.76, 0.5), 0.15);\n    color += vec3(threeShape + cos(u_time), threeShape, threeShape + sin(u_time));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Pb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Db,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 newUv = vec2(vUv);\n        newUv.x += abs(sin(u_time * 0.45))/ 5.5 - 0.1;\n        // newUv.y += abs(sin(u_time * 0.75))/ 50. - 0.1;\n        float shape1 = cir(vUv, vec2(0.35, 0.7), 0.1);\n        float shape2 = cir(newUv, vec2(0.35, 0.7), 0.05);\n        float shape3 = cir(vUv, vec2(0.65, 0.7), 0.1);\n        float shape4 = cir(newUv, vec2(0.65, 0.7), 0.05);\n        float shape5 = cir(vUv, vec2(0.5, 0.35), 0.2);\n        float shape6 = cir(vUv, vec2(0.5, 0.3), 0.2);\n        color = vec3(shape1);\n        color -= vec3(shape2);\n        color += vec3(shape3);\n        color -= vec3(shape4);\n        color += vec3(shape5);\n        color -= vec3(shape6);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Fb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Eb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    void main(){\n        vec2 vUv = vec2(vUv);\n        vec3 color=vec3(0.);\n    \n        vec2 uv1=vUv;\n        uv1=uv1*2.-.5;\n        vec2 t1=vec2(cos(u_time*PI*.100),sin(u_time*PI*.480));\n        uv1+=t1*.75;\n    \n        vec2 uv2=vUv;\n        uv2=uv2*2.-.5;\n        vec2 t2=vec2(cos(u_time*PI*.120),sin(u_time*PI*.460));\n        uv2+=t2*.75;\n    \n        vec2 uv3=vUv;\n        uv3=uv3*2.-.5;\n        vec2 t3=vec2(cos(u_time*PI*.140),sin(u_time*PI*.440));\n        uv3+=t3*.75;\n    \n        vec2 uv4=vUv;\n        uv4=uv4*2.-.5;\n        vec2 t4=vec2(cos(u_time*PI*.160),sin(u_time*PI*.420));\n        uv4+=t4*.75;\n    \n        vec2 uv5=vUv;\n        uv5=uv5*2.-.5;\n        vec2 t5=vec2(cos(u_time*PI*.180),sin(u_time*PI*.400));\n        uv5+=t5*.75;\n    \n        vec2 uv6=vUv;\n        uv6=uv6*2.-.5;\n        vec2 t6=vec2(cos(u_time*PI*.200),sin(u_time*PI*.380));\n        uv6+=t6*.75;\n    \n        vec2 uv7=vUv;\n        uv7=uv7*2.-.5;\n        vec2 t7=vec2(cos(u_time*PI*.220),sin(u_time*PI*.360));\n        uv7+=t7*.75;\n    \n        vec2 uv8=vUv;\n        uv8=uv8*2.-.5;\n        vec2 t8=vec2(cos(u_time*PI*.240),sin(u_time*PI*.340));\n        uv8+=t8*.75;\n    \n        vec2 uv9=vUv;\n        uv9=uv9*2.-.5;\n        vec2 t9=vec2(cos(u_time*PI*.260),sin(u_time*PI*.320));\n        uv9+=t9*.75;\n    \n        vec2 uv10=vUv;\n        uv10=uv10*2.-.5;\n        vec2 t10=vec2(cos(u_time*PI*.280),sin(u_time*PI*.300));\n        uv10+=t10*.75;\n    \n        vec2 uv11=vUv;\n        uv11=uv11*2.-.5;\n        vec2 t11=vec2(cos(u_time*PI*.300),sin(u_time*PI*.280));\n        uv11+=t11*.75;\n    \n        vec2 uv12=vUv;\n        uv12=uv12*2.-.5;\n        vec2 t12=vec2(cos(u_time*PI*.320),sin(u_time*PI*.260));\n        uv12+=t12*.75;\n    \n        vec2 uv13=vUv;\n        uv13=uv13*2.-.5;\n        vec2 t13=vec2(cos(u_time*PI*.340),sin(u_time*PI*.240));\n        uv13+=t13*.75;\n    \n        vec2 uv14=vUv;\n        uv14=uv14*2.-.5;\n        vec2 t14=vec2(cos(u_time*PI*.360),sin(u_time*PI*.220));\n        uv14+=t14*.75;\n    \n        vec2 uv15=vUv;\n        uv15=uv15*2.-.5;\n        vec2 t15=vec2(cos(u_time*PI*.380),sin(u_time*PI*.200));\n        uv15+=t15*.75;\n    \n        vec2 uv16=vUv;\n        uv16=uv16*2.-.5;\n        vec2 t16=vec2(cos(u_time*PI*.400),sin(u_time*PI*.180));\n        uv16+=t16*.75;\n    \n        vec2 uv17=vUv;\n        uv17=uv17*2.-.5;\n        vec2 t17=vec2(cos(u_time*PI*.420),sin(u_time*PI*.160));\n        uv17+=t17*.75;\n    \n        vec2 uv18=vUv;\n        uv18=uv18*2.-.5;\n        vec2 t18=vec2(cos(u_time*PI*.440),sin(u_time*PI*.140));\n        uv18+=t18*.75;\n    \n        vec2 uv19=vUv;\n        uv19=uv19*2.-.5;\n        vec2 t19=vec2(cos(u_time*PI*.460),sin(u_time*PI*.120));\n        uv19+=t19*.75;\n    \n        vec2 uv20=vUv;\n        uv20=uv20*2.-.5;\n        vec2 t20=vec2(cos(u_time*PI*.480),sin(u_time*PI*.100));\n        uv20+=t20*.75;\n        \n        float c1= Cir(uv1,vec2(.5,.5),.05);\n        float c2= Cir(uv2,vec2(.5,.5),.05);\n        float c3= Cir(uv3,vec2(.5,.5),.05);\n        float c4= Cir(uv4,vec2(.5,.5),.05);\n        float c5= Cir(uv5,vec2(.5,.5),.05);\n        float c6= Cir(uv6,vec2(.5,.5),.05);\n        float c7= Cir(uv7,vec2(.5,.5),.05);\n        float c8= Cir(uv8,vec2(.5,.5),.05);\n        float c9= Cir(uv9,vec2(.5,.5),.05);\n        float c10=Cir(uv10,vec2(.5,.5),.05);\n        float c11=Cir(uv11,vec2(.5,.5),.05);\n        float c12=Cir(uv12,vec2(.5,.5),.05);\n        float c13=Cir(uv13,vec2(.5,.5),.05);\n        float c14=Cir(uv14,vec2(.5,.5),.05);\n        float c15=Cir(uv15,vec2(.5,.5),.05);\n        float c16=Cir(uv16,vec2(.5,.5),.05);\n        float c17=Cir(uv17,vec2(.5,.5),.05);\n        float c18=Cir(uv18,vec2(.5,.5),.05);\n        float c19=Cir(uv19,vec2(.5,.5),.05);\n        float c20=Cir(uv20,vec2(.5,.5),.05);\n    \n    \n        color += vec3(c1+c2+c3+c4+c5 \n                      +c6+c7+c8+c9+c10+\n                      c11+c12+c13+c14+c15+\n                      +c16+c17+c18+c19+c20);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Ib(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Eb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ob=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //triangle\nfloat Tri(vec2 vUv, float size){\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI / 3.;\n    float d = cos(floor(.5 + a/r) * r - a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\n//rotate\nmat2 Rot(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\n//Cir\nfloat Cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n\n    vec2 t1vUv = vUv;\n    t1vUv=Rot(sin(u_time * 0.25)*PI)*t1vUv;\n    float t1 = Tri(t1vUv, 0.1) - Tri(t1vUv, 0.075);\n    \n    vec2 t2vUv = vUv;\n    t2vUv = Rot(PI) * t2vUv;\n    t2vUv = Rot(sin(u_time * 0.25) * PI) * t2vUv;\n    float t2 = Tri(vec2(t2vUv.x, t2vUv.y), 0.1) - Tri(vec2(t2vUv.x, t2vUv.y), 0.075);\n\n    float c = Cir(vUv, vec2(0.0), 0.3) - Cir(vUv, vec2(0.0), 0.275);\n    color = vec3(t1 + t2);\n    color += vec3(c);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Lb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ob,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ab=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float Shape(vec2 vUv, float x){\n        vec2 pos = vec2(0.5) - vUv;\n        float r = length(pos) * 2.5;\n        float a = atan(pos.y, pos.x);\n        float f = abs(cos(a * 4.) * sin(u_time * x));\n        return 1. - smoothstep(f, f + 0.02, r);\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 uv1 = vUv;\n        uv1 -= vec2(0.5);\n        uv1 = Rot(sin(u_time * PI * 0.5)) * uv1;\n        uv1 += vec2(0.5);\n    \n        vec2 uv2 = vUv;\n        uv2 -= vec2(0.5);\n        uv2 = Rot(sin(u_time * PI * 0.45)) * uv2;\n        uv2 += vec2(0.5);\n    \n        vec2 uv3 = vUv;\n        uv3 -= vec2(0.5);\n        uv3 = Rot(sin(u_time * PI * 0.4)) * uv3;\n        uv3 += vec2(0.5);\n        float s1 = Shape(uv1, 0.5);\n        float s2 = Shape(uv2, 0.61);\n        float s3 = Shape(uv3, 0.71);\n        color.r = s1 * abs(sin(u_time));\n        color.g = s2 * abs(cos(u_time));\n        color.b = s3;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Nb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ab,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Gb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    float Tri(vec2 vUv, float size){\n        float a = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/3.;\n        float d = cos(floor(.5 + a/r) * r -a) * length(vUv);\n        return 1. - smoothstep(size, size + 0.01, d);\n    }\n    \n    void main(){\n        vec3 color = vec3(0.);\n        vec2 vUv = vec2(vUv.x - 0.1, vUv.y + 0.1);\n        vUv = vUv * 9. - 4.5;\n    \n        //vUv -= vec2(1.5);\n        //vUv = Rot(PI * 0.75 + u_time) * vUv;\n        //vUv += vec2(1.5);\n    \n        vec2 rotUv1 = vUv;\n    \n        vec2 rotUv2 = Rot((PI)) * vUv;\n        rotUv2.y  = rotUv2.y + 0.22 ;\n        rotUv2.x = rotUv2.x + 0.45;\n    \n        vec2 rotUv3 = Rot((PI)) * vUv;\n        rotUv3.y  = rotUv3.y + 0.22;\n        rotUv3.x = rotUv3.x - 0.45;\n    \n        vec2 rotUv4 =  vUv;\n        rotUv4.x = rotUv4.x - 0.9 / abs(sin(u_time));\n    \n        vec2 rotUv5 =  vUv;\n        rotUv5.x = rotUv5.x + 0.9;\n    \n        vec2 rotUv6 = Rot(PI) * vUv;\n        rotUv6.y = rotUv6.y + 0.95;\n        \n        vec2 rotUv7 =  vUv;\n        rotUv7.x = rotUv7.x + 0.45;\n        rotUv7.y = rotUv7.y - 0.725;\n    \n        vec2 rotUv8 =  vUv;\n        rotUv8.x = rotUv8.x - 0.45;\n        rotUv8.y = rotUv8.y - 0.725;\n    \n        vec2 rotUv9 = Rot((PI)) * vUv;\n        rotUv9.y  = rotUv9.y + 0.22;\n        rotUv9.x = rotUv9.x - 1.35;\n    \n        vec2 rotUv10 = vUv;\n        rotUv10.x = rotUv10.x + 1.8;\n    \n        vec2 rotUv11 = Rot(PI) * vUv;\n        rotUv11.x = rotUv11.x - 0.9;\n        rotUv11.y = rotUv11.y + 0.95;\n    \n        vec2 rotUv12 = vUv;\n        rotUv12.x = rotUv12.x + 1.35 / abs(sin(u_time));\n        rotUv12.y = rotUv12.y - .725;\n    \n        vec2 rotUv13 = vUv;\n        rotUv13.y = rotUv13.y - 1.45 / abs(sin(u_time));\n    \n        vec2 rotUv14 = vUv;\n        rotUv14.y = rotUv14.y - 1.45;\n        rotUv14.x = rotUv14.x + 0.9;\n    \n        vec2 rotUv15 = Rot(PI) * vUv;\n        rotUv15.y = rotUv15.y + 1.675;\n        rotUv15.x = rotUv15.x - 0.45;\n    \n        vec2 rotUv16 = vUv;\n        rotUv16.y = rotUv16.y - 2.18;\n        rotUv16.x = rotUv16.x + 0.44;\n    \n        vec2 translate1 = vec2(cos(u_time), sin(u_time));\n        //rotUv16 += translate1 * 0.1;\n    \n        // rotUv1 =  vec2(rotUv1.x  + sin(u_time), rotUv1.y  + cos(u_time));\n        // rotUv2 =  vec2(rotUv2.x  + sin(u_time), rotUv2.y  + cos(u_time));\n        // rotUv3 =  vec2(rotUv3.x  + sin(u_time), rotUv3.y  + cos(u_time));\n        // rotUv4 =  vec2(rotUv4.x  + sin(u_time), rotUv4.y  + cos(u_time));\n        // rotUv5 =  vec2(rotUv5.x  + sin(u_time), rotUv5.y  + cos(u_time));\n        // rotUv6 =  vec2(rotUv6.x  + sin(u_time), rotUv6.y  + cos(u_time));\n        // rotUv7 =  vec2(rotUv7.x  + sin(u_time), rotUv7.y  + cos(u_time));\n        // rotUv8 =  vec2(rotUv8.x  + sin(u_time), rotUv8.y  + cos(u_time));\n        // rotUv9 =  vec2(rotUv9.x  + sin(u_time), rotUv9.y  + cos(u_time));\n        // rotUv10 = vec2(rotUv10.x + sin(u_time), rotUv10.y + cos(u_time));\n        // rotUv11 = vec2(rotUv11.x + sin(u_time), rotUv11.y + cos(u_time));\n        // rotUv12 = vec2(rotUv12.x + sin(u_time), rotUv12.y + cos(u_time));\n        // rotUv13 = vec2(rotUv13.x + sin(u_time), rotUv13.y + cos(u_time));\n        // rotUv14 = vec2(rotUv14.x + sin(u_time), rotUv14.y + cos(u_time));\n        // rotUv15 = vec2(rotUv15.x + sin(u_time), rotUv15.y + cos(u_time));\n        // rotUv16 = vec2(rotUv16.x + sin(u_time), rotUv16.y + cos(u_time));\n    \n        float tri1 = Tri(rotUv1, 0.2);\n        float tri2 = Tri(rotUv2, 0.2);\n        float tri3 = Tri(rotUv3, 0.2);\n        float tri4 = Tri(rotUv4, 0.2);\n        float tri5 = Tri(rotUv5, 0.2);\n        float tri6 = Tri(rotUv6, 0.2);\n        float tri7 = Tri(rotUv7, 0.2);\n        float tri8 = Tri(rotUv8, 0.2);\n        float tri9 = Tri(rotUv9, 0.2);\n        float tri10 = Tri(rotUv10, 0.2);\n        float tri11 = Tri(rotUv11, 0.2);\n        float tri12 = Tri(rotUv12, 0.2);\n        float tri13 = Tri(rotUv13, 0.2);\n        float tri14 = Tri(rotUv14, 0.2);\n        float tri15 = Tri(rotUv15, 0.2);\n        float tri16 = Tri(rotUv16, 0.2);\n    \n        color = vec3(tri1 + tri2 + tri3 + tri4 + tri5 + tri6 + tri7 + tri8 + tri9 + tri10 + tri11 + tri12 + tri13 + tri14 + tri15 + tri16);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Bb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Gb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    float SquareIn(vec2 vUv, float size){\n        float a  = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/4.;\n        float d = cos(floor(.5 + a/r) * r-a) * length(vUv);\n        return (1.0 - smoothstep(size, size + 0.01, d)) - (1. - smoothstep(size - (size * 0.1), size - (size * 0.1) + 0.01, d));\n    }\n    \n    void main(){\n        vec3 color = vec3(0.);\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n    \n        vec2 uv1 = vUv;\n        uv1 = Rot(sin(u_time * 0.25) * PI) * uv1;\n    \n        vec2 uv2 = vUv;\n        uv2 = Rot(cos(u_time * 0.25) * PI) * uv2;\n    \n        vec2 uv3 = vUv;\n        uv3 = Rot(sin(u_time * 0.35) * PI) * uv3;\n    \n        vec2 uv4 = vUv;\n        uv4 = Rot(cos(u_time * 0.35) * PI) * uv4;\n    \n        vec2 uv5 = vUv;\n        uv5 = Rot(sin(u_time * 0.45) * PI) * uv5;\n    \n        vec2 uv6 = vUv;\n        uv6 = Rot(cos(u_time * 0.45) * PI) * uv6;\n    \n        vec2 uv7 = vUv;\n        uv7 = Rot(sin(u_time * 0.50) * PI) * uv7;\n    \n        vec2 uv8 = vUv;\n        uv8 = Rot(cos(u_time * 0.50) * PI) * uv8;\n    \n        float s1 = SquareIn(uv1, 0.5);\n        float s2 = SquareIn(uv2, 0.5);\n    \n        float s3 = SquareIn(uv3, 0.25);\n        float s4 = SquareIn(uv4, 0.25);\n    \n        float s5 = SquareIn(uv5, 0.75);\n        float s6 = SquareIn(uv6, 0.75);\n    \n        float s7 = SquareIn(uv7, 0.125);\n        float s8 = SquareIn(uv8, 0.125);\n    \n        color = vec3(s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Vb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Wb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float shape(vec2 vUv){\n        float r = length(vUv);\n        float a  = atan(vUv.x, vUv.y);\n        float f = cos(a * dot(vUv.x,vUv.y));\n        return 1. - smoothstep(f, f + 0.01, r);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), - sin(a),\n                    sin(a), cos(a));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 4. - 2.;\n        vec3 color = vec3(0.);\n        vec2 cirUv1 = vUv;\n        cirUv1 = Rot(sin(0.25) * PI) * cirUv1;\n        vec2 cirUv2 = vUv;\n        cirUv2 = Rot(-sin(0.25) * PI) * cirUv2;\n        vec2 cirUv3 = vUv;\n        float s1 = shape(vUv);\n        float c1 = cir(vec2(cirUv1.x * 1.25, cirUv1.y * 2.5), vec2(0.35, -0.95), 0.5);\n        float c1p = cir(vec2(cirUv1.x * 1.25, cirUv1.y * 2.5), vec2(0.35, -0.95), 0.025);\n        float c2 = cir(vec2(cirUv2.x * 1.25, cirUv2.y * 2.5), vec2(-0.35, -0.95), 0.5);\n        float c2p = cir(vec2(cirUv2.x * 1.25, cirUv2.y * 2.5), vec2(-0.35, -0.95), 0.025);\n        float c3 = cir(vUv, vec2(-0.05, -0.5), 0.01);\n        float c4 = cir(vUv, vec2(0.05, -0.5), 0.01);\n        float c5 = cir(vec2(cirUv3.x / 2.0, cirUv3.y * 2.0), vec2(0., -1.45), 0.1);\n        color.g = (s1 - c1 - c2 - c3 - c4 - c5 + c1p + c2p) * abs(sin(u_time));\n        color.b = (s1-c1-c2 - c3 - c4 -c5 + c1p + c2p) * abs(cos(u_time));\n        color.r = 0.;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Hb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Wb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Xb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    float Box(vec2 vUv, vec2 size){\n        size = vec2(0.5) - size * 0.5;\n        vec2 box = smoothstep(size, size + vec2(0.01), vUv);\n        box *= smoothstep(size, size + vec2(0.01), vec2(1.0)- vUv);\n        return box.x * box.y;\n    }\n    \n    float Cross(vec2 vUv, float size){\n        return Box(vUv, vec2(size, size/4.)) + \n               Box(vUv, vec2(size/4., size));\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 0.5;\n        vec3 color = vec3(0.);\n        vUv -= vec2(0.5);\n        vUv = Rot(sin(u_time) * PI) * vUv;\n        vUv += vec2(0.5);\n        float c1 = Cir(vUv, vec2(0.5), 0.45);\n        float c2 = 1. - Cir(vUv, vec2(0.5), 0.75);\n        float b1 = Cross(vUv, 1.);\n        color = vec3(c1 + c2 - b1);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Yb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Xb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $b=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    mat2 Scale(vec2 s){\n        return mat2(s.x, 0.0,\n                    0.0, s.y);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * 2. + 0.5;\n        vec3 color = vec3(0.);\n    \n        vec2 uv1 = vUv;\n        uv1 = uv1 - 0.5;\n        uv1 = Scale(vec2((sin(u_time * 0.25 * vUv *  vUv)) + 1.0 )) * uv1;\n        uv1 = uv1 + 0.5;\n    \n        vec2 uv2 = vUv;\n        uv2 = uv2 - 0.5;\n        uv2 = Scale(vec2((sin(u_time * 0.45 * vUv *  vUv)) + 1.0 )) * uv2;\n        uv2 = uv2 + 0.5;\n    \n        vec2 uv3 = vUv;\n        uv3 = uv3 - 0.5;\n        uv3 = Scale(vec2((sin(u_time * 0.65 * vUv * vUv)) + 1.0 )) * uv3;\n        uv3 = uv3 + 0.5;\n    \n        vec2 uv4 = vUv;\n        uv4 = uv4 - 0.5;\n        uv4 = Scale(vec2((sin(u_time * 0.85 * vUv * vUv)) + 1.0 )) * uv4;\n        uv4 = uv4 + 0.5;\n    \n        vec2 uv5 = vUv;\n        uv5 = uv5 - 0.5;\n        uv5 = Scale(vec2((sin(u_time * 1.05 * vUv * vUv)) + 1.0 )) * uv5;\n        uv5 = uv5 + 0.5;\n    \n        vec2 uv6 = vUv;\n        uv6 = uv6 - 0.5;\n        uv6 = Scale(vec2((sin(u_time * 1.25 * vUv * vUv)) + 1.0 )) * uv6;\n        uv6 = uv6 + 0.5;\n        \n        float c1 = Cir(uv1, vec2(0.5), 0.1);\n        float c2 = Cir(uv2, vec2(0.5), 0.1);\n        float c3 = Cir(uv3, vec2(0.5), 0.1);\n        float c4 = Cir(uv4, vec2(0.5), 0.1);\n        float c5 = Cir(uv5, vec2(0.5), 0.1);\n        float c6 = Cir(uv6, vec2(0.5), 0.1);\n    \n        color.g = c1 + c2 * cos(u_time);\n        color.b = c3 + c4 * sin(u_time);\n        color.r = c5 + c6 * cos(u_time);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Zb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$b,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Kb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float Box(vec2 vUv,vec2 size){\n        size=vec2(.5)-size*.5;\n        vec2 box=smoothstep(size,size+vec2(.01),vUv);\n        box*=smoothstep(size,size+vec2(.01),vec2(1.)-vUv);\n        return box.x*box.y;\n    }\n    \n    float Cross(vec2 vUv,float size){\n        return Box(vUv,vec2(size,size/4.))+\n        Box(vUv,vec2(size/4.,size));\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a),-sin(a),\n        sin(a),cos(a));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 6. - 3.;\n        vec3 color = vec3(0.);\n    \n        vec2 uv1=vUv;\n        uv1=vec2(uv1.x+tan(u_time *1.0),uv1.y);\n        uv1-=vec2(.5);\n        uv1=Rot(sin(u_time)*PI)*uv1;\n        uv1+=vec2(.5);\n    \n        vec2 uv2=vUv;\n        uv2=vec2(uv2.x+tan(u_time *1.1),uv2.y + 0.25);\n        uv2-=vec2(.5);\n        uv2=Rot(sin(u_time)*PI)*uv2;\n        uv2+=vec2(.5);\n    \n        vec2 uv3=vUv;\n        uv3=vec2(uv3.x+tan(u_time *1.2),uv3.y - 0.25);\n        uv3-=vec2(.5);\n        uv3=Rot(sin(u_time)*PI)*uv3;\n        uv3+=vec2(.5);\n    \n        vec2 uv4=vUv;\n        uv4=vec2(uv4.x+tan(u_time *1.3),uv4.y + 0.50);\n        uv4-=vec2(.5);\n        uv4=Rot(sin(u_time)*PI)*uv4;\n        uv4+=vec2(.5);\n    \n        vec2 uv5=vUv;\n        uv5=vec2(uv5.x+tan(u_time *1.4),uv5.y - 0.50);\n        uv5-=vec2(.5);\n        uv5=Rot(sin(u_time)*PI)*uv5;\n        uv5+=vec2(.5);\n    \n        vec2 uv6=vUv;\n        uv6=vec2(uv6.x+tan(u_time*1.5),uv6.y + 0.75);\n        uv6-=vec2(.5);\n        uv6=Rot(sin(u_time)*PI)*uv6;\n        uv6+=vec2(.5);\n    \n        vec2 uv7=vUv;\n        uv7=vec2(uv7.x+tan(u_time*1.6),uv7.y - 0.75);\n        uv7-=vec2(.5);\n        uv7=Rot(sin(u_time)*PI)*uv7;\n        uv7+=vec2(.5);\n    \n        vec2 uv8=vUv;\n        uv8=vec2(uv8.x+tan(u_time*1.7),uv8.y + 1.00);\n        uv8-=vec2(.5);\n        uv8=Rot(sin(u_time)*PI)*uv8;\n        uv8+=vec2(.5);\n    \n        vec2 uv9=vUv;\n        uv9=vec2(uv9.x+tan(u_time*1.8),uv9.y-1.0);\n        uv9-=vec2(.5);\n        uv9=Rot(sin(u_time)*PI)*uv9;\n        uv9+=vec2(.5);\n    \n        vec2 uv11=vUv;\n        uv11=vec2(uv11.x+.00,uv11.y+tan(u_time*1.0));\n        uv11-=vec2(.5);\n        uv11=Rot(sin(u_time)*PI)*uv11;\n        uv11+=vec2(.5);\n    \n        vec2 uv12=vUv;\n        uv12=vec2(uv12.x+.25,uv12.y+tan(u_time*1.1));\n        uv12-=vec2(.5);\n        uv12=Rot(sin(u_time)*PI)*uv12;\n        uv12+=vec2(.5);\n    \n        vec2 uv13=vUv;\n        uv13=vec2(uv13.x-.25,uv13.y+tan(u_time*1.2));\n        uv13-=vec2(.5);\n        uv13=Rot(sin(u_time)*PI)*uv13;\n        uv13+=vec2(.5);\n    \n        vec2 uv14=vUv;\n        uv14=vec2(uv14.x+.50,uv14.y+tan(u_time*1.3));\n        uv14-=vec2(.5);\n        uv14=Rot(sin(u_time)*PI)*uv14;\n        uv14+=vec2(.5);\n    \n        vec2 uv15=vUv;\n        uv15=vec2(uv15.x-.50,uv15.y+tan(u_time*1.4));\n        uv15-=vec2(.5);\n        uv15=Rot(sin(u_time)*PI)*uv15;\n        uv15+=vec2(.5);\n    \n        vec2 uv16=vUv;\n        uv16=vec2(uv16.x+.75,uv16.y+tan(u_time*1.5));\n        uv16-=vec2(.5);\n        uv16=Rot(sin(u_time)*PI)*uv16;\n        uv16+=vec2(.5);\n    \n        vec2 uv17=vUv;\n        uv17=vec2(uv17.x-.75,uv17.y+tan(u_time*1.6));\n        uv17-=vec2(.5);\n        uv17=Rot(sin(u_time)*PI)*uv17;\n        uv17+=vec2(.5);\n    \n        vec2 uv18=vUv;\n        uv18=vec2(uv18.x+1.,uv18.y+tan(u_time*1.7));\n        uv18-=vec2(.5);\n        uv18=Rot(sin(u_time)*PI)*uv18;\n        uv18+=vec2(.5);\n    \n        vec2 uv19=vUv;\n        uv19=vec2(uv19.x-1.,uv19.y+tan(u_time*1.8));\n        uv19-=vec2(.5);\n        uv19=Rot(sin(u_time)*PI)*uv19;\n        uv19+=vec2(.5);\n    \n        float c1=Cross(uv1,.2);\n        float c2=Cross(uv2,.2);\n        float c3=Cross(uv3,.2);\n        float c4=Cross(uv4,.2);\n        float c5=Cross(uv5,.2);\n        float c6=Cross(uv6,.2);\n        float c7=Cross(uv7,.2);\n        float c8=Cross(uv8,.2);\n        float c9=Cross(uv9,.2);\n    \n        float c11=Cross(uv11,.2);\n        float c12=Cross(uv12,.2);\n        float c13=Cross(uv13,.2);\n        float c14=Cross(uv14,.2);\n        float c15=Cross(uv15,.2);\n        float c16=Cross(uv16,.2);\n        float c17=Cross(uv17,.2);\n        float c18=Cross(uv18,.2);\n        float c19=Cross(uv19,.2);\n        \n        color = vec3(c1+c2+c3+c4+c5+c6+c7+c8+c9+\n                     c11+c12+c13+c14+c15+c16+c17+c18+c19);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Jb(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Kb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qb=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float Cir(vec2 vUv, vec2 pos, float size){\n        float x = 1. - smoothstep(size, size+0.01, distance(vUv, pos));\n        float y = 1. - smoothstep(size * 0.95, (size * 0.95)+0.01, distance(vUv, pos));\n        return x - y;\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    float Box(vec2 vUv, vec2 size){\n        vec2 box = smoothstep(size, size+vec2(0.01), vUv);\n        box *= smoothstep(size, size+vec2(0.01), 1.0 - vUv);\n        return box.x * box.y;\n    }\n    \n    float Tri(vec2 vUv, float size){\n        float a = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/3.0;\n        float d = cos(floor(.5 + a/r) * r-a) * length(vUv);\n        return 1.0 - smoothstep(size, size+0.01, d);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y-0.1);\n        //vUv = vUv * 2. - 0.5;\n        vec3 color = vec3(0.);\n        vec2 cirUv = vUv;\n        cirUv = vec2(cirUv.x, cirUv.y+0.05);\n        float c1 = Cir(cirUv, vec2(0.5), 0.35);\n        vec2 starUv = vUv;\n        starUv = starUv * 2. - 1.;\n        starUv = vec2(starUv.x, starUv.y-0.15);\n        vec2 starUv2 = vUv;\n        starUv2 = starUv2 * 2. - 1.;\n        starUv2 = vec2(starUv2.x, starUv2.y+0.125);\n        vec2 starUv3 = vUv;\n        starUv3 = starUv3 * 2. - 1.;\n        vec2 boxUv = vUv;\n        boxUv = boxUv * 2. - 0.5;\n        boxUv = vec2(boxUv.x, boxUv.y+0.25);\n        float s1 = Tri(starUv, 0.1);\n        float s2 = Tri(starUv2, 0.14);\n        float s3 = Tri(starUv3, 0.12);\n        float s4 = Box(boxUv, vec2(0.45, 0.3) );\n        color = vec3(c1 + s1 + s2 + s3 + s4);\n        gl_FragColor =  vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function n_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Qb,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var e_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float Box(vec2 vUv, vec2 size){\n        vec2 b = smoothstep(size, size+0.01, vUv);\n        b *= smoothstep(size, size+0.01, 1. - vUv);\n        return b.x * b.y;\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size+0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 boxUv = vUv;\n        boxUv -= vec2(0.5);\n        boxUv = Rot((u_time) *0.5) * boxUv;\n        boxUv += vec2(0.5);\n        \n        vec2 cirUv2=vUv;\n        vec2 translate2=vec2(sin(u_time * 2.0),cos(u_time * 2.0));\n        cirUv2+=translate2*0.15;\n    \n        vec2 cirUv3=vUv;\n        vec2 translate3=vec2(0.,cos(u_time*2.));\n        cirUv3+=translate3*.3;\n    \n        vec2 cirUv4=vUv;\n        vec2 translate4=vec2(sin(u_time*2.),0.);\n        cirUv4+=translate4*.3;\n    \n        float box1 = Box(boxUv, vec2(0.15));\n        float box2 = Box(boxUv, vec2(0.14));\n        float cir2 = Cir(cirUv2, vec2(0.5, 0.5), 0.05);\n        float cir3=  Cir(cirUv3,vec2(.5,.5),.05);\n        float cir4=  Cir(cirUv4,vec2(.5,.5),.05);\n    \n        color = vec3(box2 - box1);\n        color += cir2;\n        color += cir3; \n        color += cir4;\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function t_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:e_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var r_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float BoxBorder(vec2 vUv, vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n        b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        float box1 = b.x * b.y;\n        vec2 b2 = smoothstep(size - vec2(0.01), (size - vec2(0.01)) + vec2(0.01), vUv);\n        b2 *=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1. - vUv);\n        float box2 = b2.x * b2.y;\n        return box2 - box1;\n    }\n    \n    float CirBorder(vec2 vUv, vec2 pos, float size){\n        float a = 1.  - smoothstep(size, size + 0.01, distance(vUv, pos));\n        float b = 1. - smoothstep(size - 0.01, size, distance(vUv, pos));\n        return a - b;\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n    \n        vec2 uv1 = vUv;\n        uv1-=vec2(0.5);\n        uv1=Rot(sin(u_time)*PI)*uv1;\n        uv1+=vec2(0.5);\n    \n        vec2 uv2=vUv;\n        uv2-=vec2(.5);\n        uv2=Rot(sin(u_time * 1.02)*PI)*uv2;\n        uv2+=vec2(.5);\n    \n        vec2 uv3=vUv;\n        uv3-=vec2(.5);\n        uv3=Rot(sin(u_time * 1.04)*PI)*uv3;\n        uv3+=vec2(.5);\n    \n        vec2 uv4=vUv;\n        uv4-=vec2(.5);\n        uv4=Rot(sin(u_time*1.06)*PI)*uv4;\n        uv4+=vec2(.5);\n    \n        vec2 uv5=vUv;\n        uv5-=vec2(.5);\n        uv5=Rot(sin(u_time*1.08)*PI)*uv5;\n        uv5+=vec2(.5);\n    \n        vec3 color = vec3(0.);\n        float b1 = BoxBorder(uv1, vec2(0.25));\n        float c1 = CirBorder(vUv, vec2(0.5), 0.25);\n        float b2=BoxBorder(uv2,vec2(.3));\n        float c2=CirBorder(vUv,vec2(.5),.2);\n        float b3=BoxBorder(uv3,vec2(.35));\n        float c3=CirBorder(vUv,vec2(.5),.15);\n        float b4=BoxBorder(uv4,vec2(.40));\n        float c4=CirBorder(vUv,vec2(.5),.1);\n        float b5=BoxBorder(uv5,vec2(.45));\n        float c5=CirBorder(vUv,vec2(.5),.05);\n        color = vec3(b1 + c1 + b2 + c2 + b3 + c3 + b4 + c4 + b5 + c5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function o_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:r_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var a_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float Box(vec2 vUv, vec2 size){\n        vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n        b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        return b.x * b.y;\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size+0.01, distance(vUv, pos));\n    }\n    \n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                 sin(a), cos(a)) * vec2(vUv.x * cos(u_time * 0.25), vUv.y * sin(u_time * 0.25));\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 5.);\n        vUv = Rot(vUv, PI * 0.25 * u_time);\n        color = vec3(vUv, 0.0);\n        color = vec3(Cir(vUv, vec2(0.5), 0.2));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function i_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:a_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var v_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size+0.01, distance(vUv, pos));\n    }\n    \n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Rot(vUv, PI * u_time * 0.25);\n        vUv = Tile(vUv, 10.5);\n        float c = Cir(vUv, vec2(0.5), 0.25);\n        color += vec3(c * abs(sin(u_time)), c * abs(cos(u_time)), c * abs(sin(u_time)));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function c_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:v_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var l_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile(vec2 vUv, float z){\n        vUv *= z;\n        return fract(vUv);\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 5.);\n        vUv = Rot(vUv, PI * u_time * 0.25);\n        color = vec3(BoxBorder(vUv, vec2(0.05)));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function s_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:l_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var u_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        vUv = fract(vUv);\n        return vUv;\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv -= 0.5;\n        vUv = vUv * sin(u_time * 0.25);\n        //vUv = Rot(vUv, cos(u_time) + PI + 2.0) * vUv;\n        vec3 color = vec3(0.);\n    \n        vec2 boxUv = vUv;\n        boxUv = Tile(boxUv, 3.0);\n        boxUv=Rot(boxUv, sin(u_time * 0.5)*PI);\n        float box = BoxBorder(boxUv, vec2(0.25));\n    \n        vec2 boxUv2=vUv;\n        boxUv2=Tile(vec2(boxUv2.x - 1.5, boxUv2.y - 1.5),3.);\n        boxUv2=Rot(boxUv2,cos(u_time * 0.5)*PI);\n        float box2=BoxBorder(boxUv2,vec2(.25));\n    \n    \n        color = vec3(box + box2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function f_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:u_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var p_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile(vec2 vUv,float zoom){\n        vUv*=zoom;\n        vUv.x+=(step(1.,mod(vUv.y,2.))*.5) * sin(u_time);\n    \n        \n        //vUv.y-=step(1.,mod(vUv.x,2.));\n        // vUv.y += step(1., mod(vUv.x, 4.0)) * sin(u_time);\n        //vUv.y += cos(u_time);\n        return fract(vUv);\n    }\n    \n    vec2 Tile2(vec2 vUv,float zoom){\n        vUv*=zoom;\n        vUv.x+=(step(1.,mod(vUv.y,2.))*.5) * sin(u_time);\n        \n        //vUv.y-=step(1.,mod(vUv.x,2.));\n        // vUv.y += step(1., mod(vUv.x, 4.0)) * sin(u_time);\n        //vUv.y += cos(u_time);\n        return fract(vUv);\n    }\n    \n    \n    \n    float Tri(vec2 vUv,float size){\n        vUv-=.5;\n        float a=atan(vUv.x,vUv.y)+PI;\n        float r=TWO_PI/3.;\n        float d=cos(floor(.5+a/r)*r-a)*length(vUv);\n        return 1.-smoothstep(size,size+.01,d);\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2;\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vec3 color=vec3(0.);\n        \n        vec2 newUv=vUv;\n        newUv.y+=cos(u_time*.1);\n        newUv=Tile(newUv,6.);\n        float t1=Tri(newUv,.25);\n    \n        vec2 newUv2=vUv;\n        newUv2 = Rot(newUv2, (PI));\n        newUv2.y += cos(u_time * 0.1);\n        newUv2 =Tile2(newUv2,6.);\n        float t2=Tri(newUv2,.25);\n    \n        color=vec3(t1+t2);\n        \n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function d_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:p_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var m_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        //vUv.x-=step(1.,mod(vUv.y,2.))+u_time;\n        vUv.x += step(1., mod(vUv.y, 2.0)) * (0.5 + u_time);\n        \n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile2(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > .5){\n            if(fract(vUv.y * .5)>.5){\n                vUv.x+= fract(t) * 2.;\n    \n            }else{\n                vUv.x-= fract(t) * 2.;\n            }\n            //vUv = Rot(vUv, PI * 0.5);\n        } else {\n            if(fract(vUv.x*.5) > .5){\n                vUv.y += fract(t) * 2.;\n            } else {\n                vUv.y -= fract(t) * 2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float Tri(vec2 vUv, float size){\n        vUv -= 0.5;\n        float a = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/3.0;\n        float d = cos(floor(.5 + a/r) * r-a) * length(vUv);\n        return 1.0 - smoothstep(size, size+0.01, d);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile2(vUv, 10.0, 0.25);\n        float c1 = Cir(vUv, vec2(0.5), 0.25);\n    \n        vec2 newUv = vUv;\n        newUv = Rot(vUv, sin(u_time + 2.0) * PI);\n        float t1 = Tri(newUv, 0.1);\n        \n        color = vec3(c1 - t1);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function h_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:m_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var x_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float Box(vec2 vUv, vec2 size){\n        vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n        b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        return b.x * b.y;\n    }\n    \n    vec2 Tiles(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        //vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        float t=u_time*speed;\n        if(fract(t)>.5){\n            if(fract(vUv.y*8.)>.5){\n                vUv.x+=fract(t)*2.;\n                \n            }else{\n                vUv.x-=fract(t)*2.;\n            }\n            //vUv = Rot(vUv, PI * 0.5);\n        }else{\n            if(fract(vUv.x * 8.)>.5){\n                vUv.y+=fract(t)*2.;\n            }else{\n                vUv.y-=fract(t)*2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tiles(vUv, 2., 0.25);\n        float b1 = Box(vUv, vec2(0.25));\n        color = vec3(b1);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function g_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:x_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var y_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        //vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        vUv = fract(vUv);\n        return vUv;\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Truchet(vec2 vUv){\n        vUv *= 2.0;\n        float index = 0.0;\n        index += step(1., mod(vUv.x, 2.0));\n        index += step(1., mod(vUv.y, 2.0)) * 2.0;\n        vUv = fract(vUv);\n        if(index == 1.0){\n            vUv = Rot(vUv, PI * 0.5 * sin(u_time));\n        } else if (index == 2.0){\n            vUv = Rot(vUv, PI * -0.5 * sin(u_time));\n        } else if (index == 3.0){\n            vUv = Rot(vUv, PI);\n        }\n        return vUv;\n    }\n    \n    float Box(vec2 vUv, vec2 size){\n        vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n        b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        return b.x * b.y;\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size+0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 c1 = vec3(Cir(vUv, vec2(0.5), 0.35));\n        vUv = Rot(vUv, (u_time * 0.25));\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 3.);\n        vUv = Truchet(vUv);\n        vec3 pattern = vec3(step(vUv.x,vUv.y));\n        \n        color = c1 * pattern;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function b_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:y_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var __=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    vec2 Translate(vec2 vUv){\n        vUv.x = vUv.x + sin(u_time) * 0.25;\n        vUv.y = vUv.y + cos(u_time) * 0.25;\n        return vUv;\n    }\n    \n    vec2 Translate2(vec2 vUv){\n        vUv.x = vUv.x + cos(u_time) * 0.25;\n        vUv.y = vUv.y + sin(u_time) * 0.25;\n        return vUv;\n    }\n    \n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        float index = 0.0;\n        index += step(1., mod(vUv.x, 2.0));\n        index += step(1., mod(vUv.y, 2.0)) * 2.0;\n        vUv = fract(vUv);\n        if(index == 1.0){\n            vUv = Translate(vUv);\n        } else if (index == 2.0){\n            vUv = Translate2(vUv);\n        } else if (index == 3.0){\n            vUv = Translate(vUv);\n        } else{\n            vUv = Translate2(vUv);\n        }\n        vUv = fract(vUv);\n        return vUv;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 5.0);\n        float c = Cir(vUv, vec2(0.5), 0.15);\n        color = vec3(c);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function U_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:__,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var w_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        //vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float angle){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(angle), -sin(angle),\n    //                sin(angle), cos(angle)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        float x = 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n        float y = 1. - smoothstep(size * 0.25, (size * 0.25) + 0.01, distance(vUv, pos));\n        return x - y;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 uv1 = vUv;\n        uv1=Rot(vUv,(u_time*PI * 0.15));\n        uv1 = Tile(uv1, 3.0);\n        float pattern1 = Cir(uv1, vec2(0.5), (0.005 + abs(sin(u_time * 0.5)/1.)));\n        color = vec3(pattern1 * abs(sin(u_time * 0.25)), pattern1 * abs(cos(u_time * 0.25)), 1.0);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function S_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:w_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var k_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile(vec2 vUv, float zoom){\n        vUv -= 0.5;\n        vUv *= zoom + sin(u_time / 1.0);\n        vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        return fract(vUv);\n    }\n    \n    \n    float Tri(vec2 vUv,float size){\n        vUv-=.5;\n        \n        float a=atan(vUv.x,vUv.y)+PI;\n        float r=TWO_PI/3.;\n        float d=cos(floor(.5+a/r)*r-a)*length(vUv);\n        float s1 = 1. - smoothstep(size,size+.01,d);\n        return s1;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 5.0);\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, -sin(PI + u_time));\n        vUv=Rot(vUv,sin(PI+u_time));\n        float s1 = Tri(vUv, 0.25);\n        float s2 = Tri(newUv,.1);\n        color = vec3(s1 - s2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function M_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:k_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var z_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        vUv.x += step(1., mod(vUv.y, 2.0)) * (0.5 + u_time);\n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float angle){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(angle), -sin(angle),\n    //                sin(angle), cos(angle)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile2(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > .5){\n            if(fract(vUv.y * .5)>.5){\n                vUv.x+= fract(t) * 2.;\n                vUv.x-= sin(u_time);\n            }else{\n                vUv.x-= fract(t) * 2.;\n                vUv.x+= cos(u_time);\n            }\n        } else {\n            if(fract(vUv.x*.5) > .5){\n                vUv.y += fract(t) * 2.;\n                vUv.y -= sin(u_time);\n            } else {\n                vUv.y -= fract(t) * 2.;\n                vUv.y += cos(u_time);\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float Box(vec2 vUv, vec2 size){\n        vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n        b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        float b1 = b.x * b.y;\n        vec2 bb = smoothstep(size-0.05, (size-0.05) + vec2(0.01), vUv);\n        bb *= smoothstep(size-0.05, (size-0.05) + vec2(0.01), 1. - vUv);\n        float b2 = bb.x * bb.y;\n        return b2 - b1;\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile2(vUv, 8.0, 0.1);\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, (sin(u_time + 2.0) * PI * 2.0) * 0.25);\n        float box = Box(newUv, vec2(0.025));\n        float cir = Cir(vUv, vec2(0.5), 0.25);\n        color = vec3(box + cir);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function C_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:z_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var T_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 Tile1(vec2 vUv, float z){\n        vUv *= z;\n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n       float x = 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n       float y = 1. - smoothstep((size + 0.02), (size + 0.02) + 0.01, distance(vUv, pos));\n       return y - x;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        vUv = Tile1(vUv, 4.0);\n        vec2 newUv = vUv;\n        vUv = Rot(vUv, -sin(u_time * 0.5) * PI);\n        float p1 = Cir(vUv, vec2(0.5), 0.25);\n        float p2 = Cir(vUv, vec2(0.275, 0.5), 0.25);\n        float p3 = Cir(vUv, vec2(0.725, 0.5), 0.25);\n        float p4 = Cir(vUv, vec2(0.5, 0.275), 0.25);\n        float p5 = Cir(vUv, vec2(0.5, 0.725), 0.25);\n        vec3 pattern1 = vec3(p1 + p2 + p3 + p4 + p5);\n        \n        \n        newUv = Rot(newUv, sin(u_time * 0.5) * PI);\n        float p6 = Cir(newUv, vec2(0.5), 0.1);\n        float p7 = Cir(newUv, vec2(0.29, 0.5), 0.1);\n        float p8 = Cir(newUv, vec2(0.71, 0.5), 0.1);\n        float p9 = Cir(newUv, vec2(0.5, 0.29), 0.1);\n        float p10 = Cir(newUv, vec2(0.5, 0.71), 0.1);\n        vec3 pattern2 = vec3(p6 + p7 + p8 + p9 + p10);\n    \n        color = pattern1;\n        color += pattern2;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function R_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:T_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var D_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float BoxBorder(vec2 vUv,vec2 size){\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2 - box1;\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile(vec2 vUv, float z){\n        vUv *= z;\n        vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        return fract(vUv);\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 4.0);\n    \n        vec2 uv1 = vUv;\n        uv1 = Rot(uv1, PI * (0.5 * sin(u_time)));\n        float b = BoxBorder(uv1, vec2(0.15));\n        color = vec3(b);\n    \n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, PI * (0.25 * sin(u_time)));\n        float b2 = BoxBorder(uv2, vec2(0.15));\n        color += vec3(b2);\n    \n        vec2 uv3 = vUv;\n        uv3 = Rot(uv3, PI * (0.125 * sin(u_time)));\n        float b3 = BoxBorder(uv3, vec2(0.15));\n        color += vec3(b3);\n    \n        vec2 uv4 = vUv;\n        uv4 = Rot(uv4, PI * ((0.125/2.0) * sin(u_time)));\n        float b4 = BoxBorder(uv4, vec2(0.15));\n        color += vec3(b4);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function P_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:D_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var j_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        //vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        return fract(vUv);\n    }\n    \n    //PIXEL SPIRIT\n    float Stroke(float x, float s, float w){\n        float d = smoothstep(s, s+0.01, x + w * 0.5) - smoothstep (s, s + 0.01,x-w * 0.5);\n        return clamp(d, 0., 1.);\n    }\n    \n    float Flip(float v, float pct){\n        return mix(v, 1. - v, pct);\n    }\n    \n    float Cir(vec2 vUv){\n        return length(vUv - 0.5) * 2.;\n    }\n    \n    vec3 Bridge(vec3 c, float d, float s, float w){\n        c *= 1. - Stroke(d, s, w * 2.);\n        return c + Stroke(d, s, w);\n    }\n    //PIXEL SPIRIT\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    \n    void main(){\n        vec3 color = vec3(0.);\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        //vUv = vUv * 2.0 - 0.5;\n        vUv = Tile(vUv, 2.0);\n        vUv.x = Flip(vUv.x, step(0.5, vUv.y));\n        vec2 offset =  vec2(.15/2.0, .0);\n        vec2 offset2 =  vec2(.45/2.0, .0);\n        vUv = Rot(vUv, sin(u_time));\n        float l = Cir(vUv + offset);\n        float r = Cir(vUv - offset);\n        float b = Cir(vUv + offset2);\n        float t = Cir(vUv - offset2);\n        color += Stroke(l, .4/2.0, .075/2.0);\n        color = Bridge(color, r, .4/2.0, .075/2.0);\n        //color += Stroke(b, .4, .075);\n        color = Bridge(color, b, .4/2.0, .075/2.0);\n        color = Bridge(color, t, .4/2.0, .075/2.0);\n        //color = Bridge(color, t, .4, .075);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function F_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:j_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var E_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile1(vec2 vUv, float zoom){\n        vUv *= zoom;\n        return fract(vUv);\n    }\n    \n    vec2 Tile2(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > .5){\n            if(fract(vUv.y * .5)>.5){\n                vUv.x+= fract(t) * 2.;\n            }else{\n                vUv.x-= fract(t) * 2.; \n            }\n        } else {\n            if(fract(vUv.x*.5) > .5){\n                vUv.y += fract(t) * 2.;  \n            } else {\n                vUv.y -= fract(t) * 2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    float Square(vec2 vUv, vec2 size){\n        vec2 s = smoothstep(size, size + vec2(0.01), vUv);\n        s *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        return s.x * s.y;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 uv1 = vUv;\n        uv1 = Tile2(uv1, 5.0, 0.1);\n        uv1 =  Rot(uv1, sin(u_time) * PI);\n        float c1 = Cir(uv1, vec2(0.5), 0.25);\n        float s1 = Square(uv1, vec2(0.25));\n        float c2 = Cir(uv1, vec2(0.5), 0.125);\n        vec3 shape1 = vec3(s1 -c1 + c2);\n        color = shape1;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function I_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:E_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var O_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 Tile(vec2 vUv, float zoom, float speed){\n        vUv*=zoom;\n        float t=u_time*speed;\n        if(fract(t)>.5){\n            if(fract(vUv.y*.5)>.5){\n                vUv.x+=fract(t)*2.;\n            }else{\n                vUv.x-=fract(t)*2.;\n            }\n        }else{\n            if(fract(vUv.x*.5)>.5){\n                vUv.y+=fract(t)*2.;\n            }else{\n                vUv.y-=fract(t)*2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    mat2 Scale(vec2 s){\n        return mat2(s.x, 0.0,\n                    0.0, s.y);\n    }\n    \n    float CirOutline(vec2 vUv, vec2 pos, float size){\n        float outer = 1. - smoothstep((size + 0.025), (size + 0.025) + 0.01, distance(vUv, pos));\n        float inner = 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n        return outer - inner;\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 uv1 = vUv;\n        vec2 uv2 = vUv;\n        uv1 = Tile(uv1, 4.0, 0.25);\n        uv2 = Tile(uv2,4., 0.25);\n        uv2 -= vec2(0.5);\n        uv2 = Scale(vec2(sin(u_time * 1.5) + 1.65)) * uv2;\n        uv2+=vec2(.5);\n        float c1 = CirOutline(uv1, vec2(0.5), 0.475);\n        float c2 = Cir(uv2, vec2(0.5), 0.25);\n        color = vec3(c1 + c2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function L_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:O_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var A_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float BoxBorder(vec2 vUv,vec2 size){\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.05),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.05),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    vec2 Tile(vec2 vUv,float zoom,float speed){\n        vUv*=zoom;\n        float t=u_time*speed;\n        if(fract(t)>.5){\n            if(fract(vUv.y*.5)>.5){\n                vUv.x+=fract(t)*2.;\n            }else{\n                vUv.x-=fract(t)*2.;\n            }\n        }else{\n            if(fract(vUv.x*.5)>.5){\n                vUv.y+=fract(t)*2.;\n            }else{\n                vUv.y-=fract(t)*2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.025),(size+.025)+.01,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.01,distance(vUv,pos));\n        return outer-inner;\n    }\n    \n    float Cir(vec2 vUv,vec2 pos,float size){\n        return 1.-smoothstep(size,size+.01,distance(vUv,pos));\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Rot(vUv, PI * 0.25);\n        vUv = Tile(vUv, 4.0, 0.125);\n        vec2 uv1 = vUv;\n        uv1 = Rot(vUv, sin(u_time) * PI);\n        float b1 = BoxBorder(uv1, vec2(0.15));\n        float c1=CirOutline(vUv,vec2(.5),.475);\n        float c2=Cir(vUv,vec2(.5),.25);\n        float c3=Cir(vUv,vec2(.5),.25 /2.0);\n        vec3 shape = vec3(b1 + c1 + c2 - c3);\n        color = shape;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function N_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:A_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var G_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float BoxBorder(vec2 vUv,vec2 size){\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    vec2 Tile(vec2 vUv,float zoom,float speed){\n        vUv*=zoom;\n        float t=u_time*speed;\n        if(fract(t)>.5){\n            if(fract(vUv.y*.5)>.5){\n                vUv.x+=fract(t)*2.;\n            }else{\n                vUv.x-=fract(t)*2.;\n            }\n        }else{\n            if(fract(vUv.x*.5)>.5){\n                vUv.y+=fract(t)*2.;\n            }else{\n                vUv.y-=fract(t)*2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.025),(size+.025)+.01,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.01,distance(vUv,pos));\n        return outer-inner;\n    }\n    \n    float Cir(vec2 vUv,vec2 pos,float size){\n        return 1.-smoothstep(size,size+.01,distance(vUv,pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 translate = vec2(cos(u_time), sin(u_time));\n        vUv = Tile(vUv, 4.0, 0.25);\n        float c1 = CirOutline(vUv, vec2(0.5), 0.47);\n        float b1 = BoxBorder(vUv, vec2(0.));\n        vUv += vec2(translate.x * 0.25, translate.y * 0.25 + 0.25);\n        \n        float s1 = Cir(vUv, vec2(0.5, 0.75), 0.25);\n        float s2 = Cir(vUv, vec2(0.5, 0.25), 0.25);\n        \n        float shape = s1;\n        color = vec3(c1);\n        color += shape;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function B_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:G_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var q_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        return fract(vUv);\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.025),(size+.025)+.01,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.01,distance(vUv,pos));\n        return outer-inner;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv -= 0.5;\n        vUv = Tile(vUv, 5.0 * sin(u_time * 0.05 * 2.0));\n        float c1 = CirOutline(vUv, vec2(0.5,0.75), 0.25);\n        float c2 = CirOutline(vUv, vec2(0.75,0.75), 0.25);\n        float c3 = CirOutline(vUv, vec2(0.5,0.5), 0.25);\n        float c4 = CirOutline(vUv, vec2(0.75,0.5), 0.25);\n        float c5 = CirOutline(vUv, vec2(0.5,0.25), 0.25);\n        float c6 = CirOutline(vUv, vec2(0.25,0.75), 0.25);\n        float c7 = CirOutline(vUv, vec2(0.25,0.25), 0.25);\n        float c8 = CirOutline(vUv, vec2(0.25,0.75), 0.25);\n        float c9 = CirOutline(vUv, vec2(0.25,0.5), 0.25);\n        float c10 =CirOutline(vUv, vec2(0.75,0.25), 0.25);\n        color = vec3(c1+c2+c3+c4+c5+c6+c7+c8+c9+c10);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function V_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:q_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var W_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        return fract(vUv);\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        vec2 b=smoothstep(size,size+vec2(.02),vUv);\n        b*=smoothstep(size,size+vec2(.02),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.02),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.02),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = Rot(vUv, sin(u_time * 0.05) * PI);\n        vUv -= 0.5;\n        vUv = Tile(vUv, 3.0 + sin(u_time * 0.5));\n        vec3 color = vec3(0.);\n        vec2 uv1 = vUv;\n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, PI * 0.25);\n        vec2 uv3 = uv1;\n        vec2 uv4 = uv2;\n        vec2 uv5 = uv1;\n        vec2 uv6 = uv2;\n        uv3.x += 0.25;\n        uv4.x += 0.25;\n        uv4.y -= 0.25;\n        uv5.x -= 0.25;\n        uv6.x -= 0.25;\n        uv6.y += 0.25;\n        float b1 = BoxBorder(uv1, vec2(0.2));\n        float b2 = BoxBorder(uv2, vec2(0.2));\n        float b3 = BoxBorder(uv3, vec2(0.2));\n        float b4 = BoxBorder(uv4, vec2(0.2));\n        float b5 = BoxBorder(uv5, vec2(0.2));\n        float b6 = BoxBorder(uv6, vec2(0.2));\n        vec3 shape1 = vec3(b1 + b2);\n        vec3 shape2 = vec3(b3 + b4);\n        vec3 shape3 = vec3(b5 + b6);\n        color = shape1 + shape2 + shape3;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function H_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:W_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var X_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float random = rand(vUv);\n        color = vec3(random);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Y_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:X_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float random(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(14.29384023894, 89.28340928374))));\n    }\n    \n    vec2 truchetPattern(vec2 vUv, float index){\n        index = fract((index - 0.5) * 2.0);\n        if(index > 0.75 *sin(u_time * 0.1) ){\n            vUv = vec2(1.0) - vUv;\n        } else if (index > 0.5 *sin(u_time * 0.1)){\n            vUv = vec2(1.0- vUv.x , vUv.y);\n        } else if (index > 0.25 * sin(u_time * 0.1)){\n            vUv = 1.0 - vec2(1.0 - vUv.x, vUv.y);\n        }\n        return vUv;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv *= 8.0;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = truchetPattern(fpos , random(ipos));\n        float pattern = smoothstep(tile.x-0.3,tile.x,tile.y)-\n                smoothstep(tile.x,tile.x+0.3,tile.y);\n        float circles = (step(length(tile),0.6) -\n                  step(length(tile),0.4) ) +\n                 (step(length(tile-vec2(1.)),0.6) -\n                  step(length(tile-vec2(1.)),0.4) );\n        color = vec3(circles);\n        //color = vec3(fpos, 0.0);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Z_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var K_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders random function\nfloat random(vec2 vUv){\n    return fract(sin(dot(vUv.xy,\n                vec2(12.9898,78.233)))*\n            43758.5453123 - fract(u_time));\n        }\n\nvec2 Tile2(vec2 vUv,float zoom,float speed){\n    vUv*=zoom;\n    float t=u_time*speed;\n    if(fract(t)>.5){\n        if(fract(vUv.y*.5)>.5){\n            vUv.x+=fract(t)*2.;\n        }else{\n            vUv.x-=fract(t)*2.;\n        }\n    }else{\n        if(fract(vUv.x*.5)>.5){\n            vUv.y+=fract(t)*2.;\n        }else{\n            vUv.y-=fract(t)*2.;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv=Tile2(vUv,5.,0.0001);\n    vec3 color=vec3(0.);\n    vUv *= 10.;\n    vec2 i = floor(vUv);\n    vec2 f = fract(vUv);\n    \n    float shape = random((i));\n    \n    color = vec3(shape+sin(u_time), shape-cos(u_time), 0.);\n    \n    gl_FragColor = vec4(color, random(i));\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function J_(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:K_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Q_=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float random(vec2 vUv){\n        return fract(sin(dot(vUv.xy,\n                vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    //book of shaders\n    vec2 truchet(vec2 vUv, float index){\n        index = fract((index - 0.5) * 2.0);\n        if(index > 0.75){\n            vUv = vec2(1.0) - vUv;\n        } else if (index > 0.5){\n            vUv = vec2(1.0 - vUv.x, vUv.y);\n        } else if (index > 0.25){\n            vUv = 1.0 - vec2(1.0 - vUv.x, vUv.y);\n        }\n        return vUv;\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.125),(size+.125)+.01,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.01,distance(vUv,pos));\n        return outer-inner;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0);\n        vUv *= 5.0;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = truchet(fpos, random(ipos));\n        float y = CirOutline(tile, vec2(0.5), 0.35);\n        y *= smoothstep(tile.x-.3,tile.x,abs(tile.y + sin(u_time)))-\n            smoothstep(tile.x,tile.x+.3,abs(tile.y + cos(u_time)));\n        color = vec3(y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Q_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    float rand (float x){\n        return fract(sin(x) * 1000000.0);\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.025) * rand(15.5),(size+.085)+.01,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.01 ,distance(vUv ,pos ));\n        return outer-inner;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = Rot(vUv, sin(u_time * 5000.) * PI );\n        vec3 color = vec3(0.);\n        float cir = CirOutline(vUv, vec2(0.5), 0.25);\n        color = vec3(cir);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:eU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rand (float x){\n        return fract(sin(x) * 100000.0);\n    }\n    \n    float Plot(vec2 vUv, float x){\n        return smoothstep(x - (0.01), x, vUv.y) -\n               smoothstep(x, x + (0.02), vUv.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv;\n        float y = 1. - rand(vUv.x + (u_time * 0.000005) );\n        float pct = Plot(vUv, y);\n        vec3 color = vec3(0.);\n        color = vec3(pct);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function oU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(12.4859, 75.2389234))) * 45687.28934720);\n    }\n    \n    float rand2(float x){\n        return fract(sin(x) * 10000.0);\n    }\n    \n    //book of shaders\n    float pattern(vec2 vUv, vec2 v, float t){\n        vec2 p = floor(vUv + v);\n        return step(t, rand2(100. + p * 0.00001) + rand2(p.x) * 0.5);\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n        vec3 color = vec3(0.);\n    \n        vec2 grid = vec2(20.0, 15.0);\n        vUv *= grid;\n    \n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n    \n        vec2 vel = vec2(u_time * (rand2(1.0)) * max(grid.x, grid.y));\n        vel *= vec2(0.0, 1.0) * rand2(1.0 + ipos.x);\n    \n        vec2 offset = vec2(0., 0.);\n        color.g = pattern(vUv + offset, vel, rand2(0.2) * 0.9);\n    \n        color *= step(0.5, fpos.x);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function iU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:aU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(12.4859, 75.2389234))) * 45687.28934720);\n    }\n    \n    float rand2(float x){\n        return fract(sin(x) * 10000.0);\n    }\n    \n    //book of shaders\n    float pattern(vec2 vUv, vec2 v, float t){\n        vec2 p = floor(vUv + v);\n        return step(t, rand2(100. + p * 0.00001) + rand2(p.x) * 0.1);\n    }\n    \n    float pattern2(vec2 vUv, vec2 v, float t){\n        vec2 p = floor(vUv + v);\n        return step(t, rand2(100. + p * 0.00001) + rand2(p.y) * 0.1);\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n        vec3 color = vec3(0.);\n    \n        vec2 grid = vec2(50.0, 50.0) ;\n        vUv *= grid;\n    \n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n    \n        vec2 vel = vec2(u_time * (rand2(10.0)) * max(grid.y, grid.x));\n        vel *= vec2(-1., 0.0) * rand2(1.0 + ipos.y);\n    \n        vec2 vel2 = vec2(u_time * (rand2(10.0)) * max(grid.y, grid.x));\n        vel2 *= vec2(0.0, 1.0) * rand2(1.0 + ipos.x);\n    \n        vec2 offset = vec2(0., 0.);\n        color.r = pattern(vUv + offset, vel, rand2(0.1) * 0.5);\n        color.g = pattern2(vUv + offset, vel2, rand2(0.1) * 0.15);\n    \n        color *= 1. - step(0.99999999, fpos.y);\n        color += step(0.99999, fpos.x);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float random(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(12.9898,78.233))) * 43758.5453123);\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        \n        vec2 b=smoothstep(size,size+vec2(.02),vUv);\n        b*=smoothstep(size,size+vec2(.02),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.02),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.02),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        float x = random(vec2(vUv));\n        vec3 color = vec3(0.);\n        vec2 ipos = floor(vUv); //integer\n        vec2 fpos = fract(vUv); //fraction\n        float b1 = BoxBorder(vUv, vec2(0.0) + x * abs(sin(u_time * 0.25)));\n        color = vec3(b1);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // vec2 Rot(vec2 vUv,float a){\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float random(in float x){\n        return fract(sin(x)*1e4);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    float random(vec2 vUv){\n        return fract(sin(dot(vUv.xy,vec2(12.9898,78.233)))*43758.5453123);\n    }\n    \n    //book of shaders\n    float pattern(vec2 vUv,vec2 v,float t){\n        vec2 p=floor(vUv+v);\n        return step(t,random(100.+p*.00001)+random(p.x)*.1);\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        \n        vUv=vUv*2.-1.;\n        vec2 cUv=vUv;\n        vUv = Rot(vUv, u_time * 0.25);\n        \n        vec3 color=vec3(0.);\n    \n        vec2 grid=vec2(25.,5.);\n        vUv*=grid + sin(u_time);\n    \n        \n        \n        vec2 ipos=floor(vUv);\n        vec2 fpos=fract(vUv);\n    \n        vec2 vel=vec2(u_time*.2*max(grid.y +sin(u_time),grid.x ));\n        vel*=vec2(0.,1.)*random(1.+ipos.x);\n    \n        vec2 vel2=vec2(u_time*0.2* max(grid.x +sin(u_time) ,grid.y + sin(u_time)));\n        vel2*=vec2(-1.,0.)*random(1.+ipos.y);\n    \n        vec2 offset2=vec2(1.1,1.0);\n        vec2 offset=vec2(1.0,1.1);\n        \n        color= vec3(pattern(vUv+offset,vel2,1.0));\n        color+= vec3(pattern(vUv+offset2,vel,1.0));\n    \n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nfloat plot(vec2 vUv,float pct){\n    return smoothstep(pct-.04,pct,vUv.y)-\n    smoothstep(pct,pct+.04,vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv.x *= 0.5;\n    vUv.y *= 0.5;\n    vUv.y -= 0.0;\n    vec2 ipos=floor(vUv);// integer\n    vec2 fpos=fract(vUv);// fraction\n    vec3 color = vec3(0.);\n    float y = fract(sin(vUv.x + sin(u_time)) * 100000.0);\n    float pct = plot(vUv, y);\n    color = (1. - pct) * color + pct * vec3(0.0, 1., 0.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    \nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(14.4385, 89.2384972))) * 56937.29837492);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 20.0;\n    vec2 ipos = floor(vec2(vUv.x, vUv.y + (u_time)));\n    vec2 fpos = fract(vUv);\n    float pattern = rand2(vec2(ipos.x + (0.0000025 * u_time), ipos.y));\n    color.b = (pattern);\n    color *= 1. - vec3(fpos, 0.0);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rand2(float x){\n        return fract(sin(x) * 56937.29837492);\n    }\n    \n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(14.4385, 89.2384972))) * 56937.29837492);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv *= 2.0 - 1.0;\n        vec2 cUv = vUv;\n        vUv = vec2(rand2(vUv.x) + (u_time * 0.0000002), rand2(vUv.y));\n        vUv = vUv * 20.;\n        vec3 color = vec3(0.);\n        float x = rand2(vec2(vUv.x, vUv.y));\n        float y = pow((x), 100.);\n        float cir = Cir(cUv, vec2((0.5 * x) + sin(u_time * 0.5), 0.5), 0.25);\n        float cir2 = Cir(cUv, vec2(0.5, (0.5 * x) + sin(u_time * 0.5)), 0.25);\n        color = vec3(cir + cir2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(12.9898, 78.233))) * 43758.649273);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv *= 10.0;\n        vec2 ipos = floor(vec2(vUv.x - u_time, vUv.y));\n        vec2 fpos = fract(vec2(vUv.x + u_time, vUv.y));\n        vec3 color = vec3(0.);\n        float y = rand2(ipos);\n        float x = rand2(fpos);\n    \n        color = vec3(y*x * y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _U=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//random\n\nfloat rand2(in float x){\n    return fract(sin(x)*1e4);\n}\n\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(23.487503, 89.37610982))) * 45873.34028347);\n}\n\n//book of shaders\nvec2 truchetPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.) - vUv;\n    } else if (i > 0.5) {\n        vUv = vec2(1. - vUv.x, vUv.y);\n    } else if (i > 0.25) {\n        vUv = 1. - vec2(1. - vUv.x, vUv.y);\n    }\n    return vUv;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv -= 0.5;\n    vUv.x += u_time * 0.1;\n    vec3 color=vec3(0.);\n    vec2 grid=vec2(12.,12.);\n    vUv *= grid;\n    vec2 ipos = floor(vUv); //integer\n    vec2 fpos = fract(vUv); //fraction\n    vec2 tile = truchetPattern(fpos, rand2(ipos * sin(u_time*.000000125)) );\n    float c = (step(length(tile ),.6)-\n         step(length(tile ),0.4) ) +\n        (step(length(tile-vec2(1.) ),0.6) -\n         step(length(tile-vec2(1.) ),0.4) );\n    color = 1. - vec3(c);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function UU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_U,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(12.4859, 75.2389234))) * 45687.28934720);\n    }\n    \n    float rand2(float x){\n        return fract(sin(x) * 10000.0);\n    }\n    \n    //book of shaders\n    float pattern(vec2 vUv, vec2 v, float t){\n        vec2 p = floor(vUv + v);\n        return step(t, rand2(100. + p * 0.00001) + rand2(p.x) * 0.5);\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n        vec3 color = vec3(0.);\n    \n        vec2 grid = vec2(10.0, 15.0);\n        vUv *= grid;\n    \n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n    \n        vec2 vel = vec2(u_time * (rand2(1.0)) * max(grid.x, grid.y));\n        vel *= vec2(0.0, 1.0) * rand2(1.0 + ipos.x);\n    \n        vec2 offset = vec2(0., 0.);\n        color.r = pattern(vUv + offset, vel, rand2(0.2) * 0.9);\n    \n        color *= step(0.5, fpos.x);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function SU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float cirOutline(vec2 vUv,vec2 pos,float size){\n        float x=1.-smoothstep(size,size+.01,distance(vUv,pos));\n        float y=1.-smoothstep((size*.25)+size,(size*.25)+size+.01,distance(vUv,pos));\n        return y-x;\n    }\n    \n    // float randx(vec2 vUv){\n    //     return fract(sin(dot(vUv.xy,vec2(12.9898,78.233)))*43724.3497231);\n    // }\n    \n    float rand1(float x){\n        return fract(sin(x)*1e4);\n    }\n    float rand2(float x){\n        return fract(sin(x)*1e4);\n    }\n    float rand3(float x){\n        return fract(sin(x)*1e4);\n    }\n    float rand4(float x){\n        return fract(sin(x)*1e4);\n    }\n    float rand5(float x){\n        return fract(sin(x)*1e4);\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv=vUv*2.-1.;\n        vec3 color=vec3(0.);\n        vec2 translate1=vec2(rand(vec2(rand1(.5)))+sin(u_time));\n        vec2 translate2=vec2(rand(vec2(rand2(.5)))-cos(u_time));\n        vec2 translate3=vec2(rand(vec2(rand3(.5)))+sin(u_time));\n        vec2 translate4=vec2(rand(vec2(rand4(.5)))-cos(u_time));\n        vec2 translate5=vec2(rand(vec2(rand5(.5)))+sin(u_time));\n        float shape1=cirOutline(vUv,(vec2(rand1(.5),rand1(.1)))*translate1,rand1(.5));\n        float shape2=cirOutline(vUv,(vec2(rand2(.4),rand2(.2)))*translate2,rand2(.5));\n        float shape3=cirOutline(vUv,(vec2(rand3(.3),rand3(.3)))*translate3,rand3(.5));\n        float shape4=cirOutline(vUv,(vec2(rand4(.2),rand4(.4)))*translate4,rand4(.5));\n        float shape5=cirOutline(vUv,(vec2(rand5(.1),rand5(.5)))*translate5,rand5(.5));\n        color=vec3(shape1+shape2+shape3+shape4+shape5);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function MU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // float rand(vec2 vUv){\n    //     return fract(cos(dot((vec2(vUv.x, vUv.y + (u_time * 0.001))),vec2(12.9898,78.233)))*43724.3497231 * abs(sin(u_time*.0000075))) ;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv.x *=0.15;\n        vUv.y*=0.15;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        float y = rand(vec2(ipos.x, fpos.y));\n        color.r = y;\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function CU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // float rand(vec2 vUv){\n    //     return fract(sin(dot(vUv.xy, vec2(748.3247298, 89.45870348))) * 2387402.3847293);\n    // }\n    \n    vec2 Pattern(vec2 vUv, float i){\n        i = fract((i - 0.5) * 2.0);\n        if(i > 0.8 + (0.1 * cos(u_time))){\n            vUv = vec2(1.0) - vUv;\n        }else if (i > 0.6 + (0.1 * cos(u_time))){\n            vUv = vec2(1.0 - vUv.y, vUv.x);\n        }else if (i > 0.4 + (0.1 * cos(u_time))){\n            vUv = 1.0 - vec2(1.0 - vUv.y, vUv.x);\n        }\n        return vUv;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv -= 0.5;\n        \n        vec3 color = vec3(0.);\n        vUv *= 20. * sin(u_time * 0.1) + 20.0;\n        vUv.x += 0.25;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = Pattern(fpos, rand(ipos));\n        float y = smoothstep(tile.x - 0.1, tile.x, tile.y)-\n                  smoothstep(tile.x, tile.x + 0.1, tile.y);\n        color = vec3(y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function RU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:TU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // float rand(vec2 vUv){\n    //     return fract(sin(dot(vUv.xy, vec2(34.89327402, 347023874))) * 23469273.38497290347);\n    // }\n    \n    vec2 Tile2(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > .5){\n            if(fract(vUv.y * .5)>.5){\n                vUv.x+= fract(t) * 2.;\n    \n            }else{\n                vUv.x-= fract(t) * 2. ;\n            }\n            //vUv = Rot(vUv, PI * 0.5);\n        } else {\n            if(fract(vUv.x*.5) > .5){\n                vUv.y += fract(t) * 2. ;\n            } else {\n                vUv.y -= fract(t) * 2. ;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile2(vUv, 5.5, 0.5);\n        //vUv *= 20.;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        float shape = cir(vUv, vec2(rand(fpos)), 0.25);\n        \n        \n        color = vec3(shape);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function PU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:DU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rand(float x) {\n        return fract(sin(x)*1e4);\n    }\n    //random\n    // float rand(vec2 vUv){\n    //     return fract(sin(dot(vUv.xy, vec2(12.483017652, 87.8729301234))) * 49763419.2834798234);\n    // }\n    //book of shaders\n    vec2 tPattern(vec2 vUv, float i){\n        i = fract((i - 0.5) * 2.0);\n        if(i > 0.75){\n            vUv = vec2(1.0) - vUv;\n        } else if (i > 0.5){\n            vUv = vec2(1.0 - vUv.x, vUv.y);\n        }else if (i > 0.25){\n            vUv = 1.0 - vec2(1.0 - vUv.x, - vUv.y);\n        }\n        return vUv;\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv *= 8.0;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = tPattern(fpos, rand(ipos * u_time * 0.000000001));\n        float s = step(tile.y, tile.x) + rand(fpos);\n        color = vec3(s);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function FU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //random\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.483017652, 87.8729301234))) * 49763419.2834798234);\n}\n\nfloat rand2(float x) {\n    return fract(sin(x)*1e4);\n}\n\n//book of shaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.0) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1.0 - vUv.x, vUv.y);\n    }else if (i > 0.25){\n        vUv = 1.0 - vec2(1.0 - vUv.x, - vUv.y);\n    }\n    return vUv;\n}\n\nfloat plot(vec2 vUv, float p){\n    return smoothstep(p - 0.075, p, vUv.y) -\n           smoothstep(p, p + 0.075, vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 10.0;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 tile = tPattern(fpos, rand2(ipos * u_time * 0.000000001));\n    float y = abs(sin(tile.x));\n    float s = plot(tile, y);\n    color = vec3(s);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function IU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:EU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //rand\nfloat rand2(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.34739482, 74.237492837))) * 2347081.3978489230);\n}\n\n//bookofshaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.0) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1.0 - vUv.x, vUv.y);\n    } else if (i > 0.25){\n        vUv = 1.0 - vec2(1.0 - vUv.x, vUv.y);\n    }\n    return vUv;\n}\n\nfloat plot(vec2 vUv, float p){\n    return smoothstep(p - 0.075, p, vUv.y) -\n           smoothstep(p, p + 0.075, vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 15.;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 tile = tPattern(fpos, rand2(ipos * u_time * 0.000000001));\n    float y = 1. - smoothstep(0.25, 0.26, distance(tile, vec2(0.5)));\n    float s = plot(tile, y / abs(sin(u_time)));\n    color = vec3(s);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function LU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:OU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //rand\nfloat rand2(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.34739482, 74.237492837))) * 2347081.3978489230);\n}\n\n//bookofshaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.0) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1.0 - vUv.x, vUv.y);\n    } else if (i > 0.25){\n        vUv = 1.0 - vec2(1.0 - vUv.x, vUv.y);\n    }\n    return vUv;\n}\n\n//plot function\nfloat plot(vec2 vUv, float p){\n    return smoothstep(p - 0.075, p, vUv.y) -\n           smoothstep(p, p + 0.075, vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 10.;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 tile = tPattern(ipos, rand2(ipos) + abs(sin(u_time * 0.25)));\n    float y = sin(tile.x);\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function NU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:AU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //rand\nfloat rand2(float x){\n    return fract(sin(x) * 1e4);\n}\n\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(46.3469872, 98.3468))) * 67382.4684018202);\n}\n\n//pattern\nfloat pattern(vec2 vUv, vec2 pos, float size){\n    vec2 p = floor(vUv + pos);\n    float y = distance(vUv, pos);\n    return step(size, rand2(100.+p * 0.000001) + rand2(p.x) * 0.5);\n}\n\nfloat pattern2(vec2 vUv,vec2 pos,float size){\n    vec2 p=floor(vUv+pos);\n    float y=distance(vUv,pos);\n    return step(size,rand2(100.+p*.000001)+rand2(p.x)*.95);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 grid = vec2(25., 25.);\n    vUv *= grid;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 vel = vec2(u_time * 2. * max(grid.x, grid.y));\n    vel *= vec2(-1., 0.0) * rand2(1.+ipos.y);\n    vec2 vel2=vec2(u_time*2.*max(grid.x,grid.y));\n    vel2*=vec2(0.,1.)*rand2(1.+ipos.x);\n    vec2 offset = vec2(0.1, 0.);\n    float y = pattern(vUv, vel, 0.75);\n    float x=pattern(vUv,vel2,.95);\n    color = vec3(x + y);\n    color*=step(.2,fpos.x);\n    color*=step(.2,fpos.y);\n    gl_FragColor = vec4(1.-color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function BU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:GU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    uniform float u_rand;\n    //rand\nfloat rand2(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(25. * u_rand, 98. * u_rand))) * 2347081. * u_rand);\n}\n\n//bookofshaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.0) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1.0 - vUv.x, vUv.y);\n    } else if (i > 0.25){\n        vUv = 1.0 - vec2(1.0 - vUv.x, vUv.y);\n    }\n    return vUv;\n}\n\n//plot function\nfloat plot(vec2 vUv, float p){\n    return smoothstep(p - 0.075, p, vUv.y) -\n           smoothstep(p, p + 0.075, vUv.y);\n}\n\nfloat plot2(vec2 vUv, float p){\n    return smoothstep(p - 0.075, p, vUv.x) -\n           smoothstep(p, p + 0.075, vUv.x);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 2.;\n    float y = sin(plot(vUv, u_time * u_rand)) * 500.;\n    y*= cir(vUv, vec2(1.), 1.);\n    float x = sin(plot2(vUv, u_time * u_rand)) * 500.;\n    x*= cir(vUv, vec2(1.), 1.);\n    color = (1.0 - y) * color + y * vec3(0.0, 1.0, 0.0);\n    color += (1.0 - x) * color + x * vec3(0.0, 1.0, 0.0);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function VU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    uniform float u_rand;\n    float Cir(vec2 vUv, float size){\n        return 1. - smoothstep( size, size + 0.01, distance(vUv, vec2(vUv.x * u_rand+ sin(u_time), vUv.y * u_rand+ cos(u_time))));\n    }\n    \n    float Cir2(vec2 vUv, float size){\n        return 1. - smoothstep( size, size + 0.01, distance(vUv, vec2(vUv.x * u_rand +cos(u_time), vUv.y * u_rand+ sin(u_time))));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 10. - 5.;\n        vec3 color = vec3(0.);\n        float c1 = Cir(vUv, 0.5);\n        float c2 = Cir2(vUv, 0.5);\n        color = vec3(c1 + c2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function HU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:WU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //rand\nfloat rand2(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n//book of shaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.0) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1.0 - vUv.x, vUv.y);\n    }else if (i > 0.25){\n        vUv = 1.0 - vec2(1.0 - vUv.x, - vUv.y);\n    }\n    return vUv;\n}\n\n//sinc curve iquilezles.org\nfloat sinc(float x,float k){\n    float a=PI*((k*x)-1.);\n    return sin(a)/a ;\n}\n\n//plot function bookofshaders\nfloat plot(vec2 st, float pct){\n  \n  return  smoothstep( pct-0.2, pct, st.x ) -\n          smoothstep( pct, pct+0.2, st.x );\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 5.0;\n    vec3 color = vec3(0.);\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 tile = tPattern(fpos, rand2(ipos)); \n    float x = (sinc((vUv.y), sin(u_time) * 0.5)) * 0.45;\n    float pct = plot(tile - 0.5, x);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function YU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:XU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $U=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //rand\nfloat rand2(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n//bookofshaders\nfloat pattern(vec2 vUv, vec2 v, float t){\n    vec2 p = floor(vUv + v);\n    float y = smoothstep(t, t+0.01, rand2(100.+p * 0.00001) + rand2(p.x)*0.5);\n    return distance(vUv *y, v * y);\n}\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.001), vUv);\n    b *= smoothstep(size, size + vec2(0.001), 1. - vUv);\n    float b1 = b.x * b.y;\n    vec2 bb = smoothstep(size-0.05, (size-0.05) + vec2(0.01), vUv);\n    bb *= smoothstep(size-0.05, (size-0.05) + vec2(0.01), 1. - vUv);\n    float b2 = bb.x * bb.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float x = Box(vUv, vec2(.125));\n    vec2 grid = vec2(25., 50.);\n    vec2 grid2 = vec2(5., 5.);\n    vUv *= grid;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 vel = vec2(u_time * 0.25 * max(grid.x, grid.y));\n    vel *= vec2(-1., 0.0) * rand2(1.0 + ipos.y);\n    vec2 vel2 = vec2(u_time * 1. * max(grid2.x, grid2.y));\n    vel2 *= vec2(0.0, -1.0) * rand2(1.0 + ipos.x);\n    float y = pattern(vUv, vel, 0.95);\n    float z = pattern(1. - vUv, vel2, 0.95);\n    color = vec3(y + z);\n    color += 1. - x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ZU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$U,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //rand\nfloat rand2(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand2(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n//book of shaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * (u_time * 0.25));\n    if(i > 0.75){\n        vUv = vec2(1.) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1. - vUv.x, vUv.y) ;\n    } else if (i > 0.25){\n        vUv = 1. - vec2(1. - vUv.x, vUv.y);\n    }\n    return vUv;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color = vec3(0.);\n    vUv *= 10.;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 tile = tPattern(fpos, rand2(ipos));\n    float y = step(tile.x, tile.y);\n    float z = smoothstep(tile.x - 0.1, tile.x, tile.y) - \n              smoothstep(tile.x, tile.x + 0.1, tile.y);\n    color = vec3(z);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function JU(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:KU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QU=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(38.67392, 98.376482))) * 46783.2347982);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    vec2 Tile(vec2 vUv,float zoom,float speed){\n        vUv*=zoom;\n        float t=u_time*speed;\n        if(fract(t)>.5){\n            if(fract(vUv.y*.5)>.5){\n                vUv.x+=fract(t)*2.;\n            }else{\n                vUv.x-=fract(t)*2.;\n            }\n        }else{\n            if(fract(vUv.x*.5)>.5){\n                vUv.y+=fract(t)*2.;\n            }else{\n                vUv.y-=fract(t)*2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 newUv = vUv;\n        vUv *= 10.0;\n        newUv = Tile(newUv, 10., 0.5);\n        float z=1. - Cir(newUv,vec2(.5),.25);\n        vec3 color = vec3(0.);\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        float y = 1. - rand(ipos * (u_time * sin(0.00000001)));\n        color = vec3(y * z);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:QU,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ew=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //bookofshaders\nfloat plot(vec2 vUv, float x){\n    return smoothstep(x - 2000000.5, x, vUv.y) -\n           smoothstep(x, x + 0.05, vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 4. - 1.;\n    vec3 color = vec3(0.);\n    float y = fract(sin(vUv.x) * u_time * u_time);\n    float p = plot(vUv, y);\n    color = vec3(p);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ew,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(83.8237492, 12.3874298))) *  2349236.8732947);\n    }\n    \n    //book of shaders\n    vec2 tPattern(vec2 vUv, float i){\n        i = fract((i-0.5) * 2.0);\n        if(i > 0.75){\n            vUv = vec2(1.0) - vUv;\n        } else if (i > 0.5){\n            vUv = vec2(1.0 - vUv.x, vUv.y);\n        } else if (i > 0.25){\n            vUv = 1.0 - vec2(1.0-vUv.x, vUv.y);\n        }\n        return vUv;\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv *= 20.;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = tPattern(fpos, rand2(ipos ));\n        float y = BoxBorder(tile, vec2(0.15 * abs(sin(u_time * 0.25))));\n        color = vec3(y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ow(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(83.8237492, 12.3874298))) *  2349236.8732947);\n    }\n    \n    //book of shaders\n    vec2 tPattern(vec2 vUv, float i){\n        i = fract((i-0.5) * 2.0);\n        if(i > 0.75){\n            vUv = vec2(1.0) - vUv;\n        } else if (i > 0.5){\n            vUv = vec2(1.0 - vUv.x, vUv.y);\n        } else if (i > 0.25){\n            vUv = 1.0 - vec2(1.0-vUv.x, vUv.y);\n        }\n        return vUv;\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.025),(size+.025)+.25,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.05,distance(vUv,pos));\n        return outer-inner;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv *= 10.;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = tPattern(fpos, rand2(ipos ));\n        float y = BoxBorder(tile, vec2(0.15 * (sin(u_time * 0.15))));\n        float x = CirOutline(tile, vec2(0.5 * abs(sin(u_time * 0.15)), 0.5 * abs(cos(u_time * 0.15))), 0.5);\n        color = vec3(x);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function iw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:aw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // float rand(vec2 vUv){\n    //     return fract(sin(dot(vUv.xy, vec2(83.8237492, 12.3874298))) *  2349236.8732947);\n    // }\n    \n    // vec2 Rot(vec2 vUv, float angle){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(angle), -sin(angle),\n    //                sin(angle), cos(angle)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    //book of shaders\n    vec2 tPattern(vec2 vUv, float i){\n        i = fract((i-0.5) * 2.0);\n        if(i > 0.75){\n            vUv = vec2(1.0) - vUv;\n        } else if (i > 0.5){\n            vUv = vec2(1.0 - vUv.x, vUv.y);\n        } else if (i > 0.25){\n            vUv = 1.0 - vec2(1.0-vUv.x, vUv.y);\n        }\n        return vUv;\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        vUv *= 5.;\n        \n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = tPattern(fpos, rand(ipos ));\n        tile = Rot(tile, u_time * 0.25);\n        float y = BoxBorder(tile, vec2(0.2 * abs(sin(u_time * 0.0525))));\n        color = vec3(y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rand(float x){\n        return fract(sin(x)* 1e4);\n    }\n    \n    float plot(vec2 vUv, float pct){\n        return smoothstep(pct - 0.02, pct, vUv.y) - \n               smoothstep(pct, pct + 0.02, vUv.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv *= 10. - 5.;\n        vUv.y -= 2.;\n        vUv.x += u_time;\n        vec3 color = vec3(0.);\n        float i = floor(vUv.x);\n        float f = fract(vUv.x);\n        float y = rand(i);\n        //y = mix(rand(i), rand(i + 1.0), f);\n        y = mix(rand(i), rand(i + 1.0), smoothstep(0., 1., f));\n        float x = sin(u_time);\n        float pct = plot(vUv, y);\n        color = vec3(pct);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rand(float x){\n        return fract(sin(x)* 1e4);\n    }\n    \n    float plot(vec2 vUv, float pct){\n        return smoothstep(pct - 0.02, pct, vUv.y) - \n               smoothstep(pct, pct + .75, vUv.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv *= 10. - 5.;\n        vUv.y -= 2.;\n        vUv.x += u_time;\n        vec3 color = vec3(0.);\n        float i = floor(vUv.x * 1.);\n        float f = fract(vUv.x * 1.);\n    \n        float i2 = floor(vUv.x * 1.5);\n        float f2 = fract(vUv.x * 1.5);\n    \n        float i3 = floor(vUv.x * 2.);\n        float f3 = fract(vUv.x * 2.);\n    \n        float i4 = floor(vUv.x * 2.5);\n        float f4 = fract(vUv.x * 2.5);\n    \n        float i5 = floor(vUv.x * 3.);\n        float f5 = fract(vUv.x * 3.);\n    \n    \n        float y = rand(i);\n        float y2 = rand(i2);\n        float y3 = rand(i3);\n        float y4 = rand(i2);\n        float y5 = rand(i3);\n        //y = mix(rand(i), rand(i + 1.0), f);\n        y = mix(rand(i), rand(i + 1.0), smoothstep(0., 1., f));\n        y2 = mix(rand(i2), rand(i2 + 1.0), smoothstep(0., 1., f2));\n        y3 = mix(rand(i3), rand(i3 + 1.0), smoothstep(0., 1., f3));\n        y4 = mix(rand(i4), rand(i4 + 1.0), smoothstep(0., 1., f4));\n        y5 = mix(rand(i5), rand(i5 + 1.0), smoothstep(0., 1., f5));\n    \n        float pct = plot(vUv, y);\n        float pct2 = plot(vUv, y2);\n        float pct3 = plot(vUv, y3);\n        float pct4 = plot(vUv, y4);\n        float pct5 = plot(vUv, y5);\n    \n        color.r = pct;\n        color.g = pct2;\n        color.b = pct3;\n        // color.r = pct4;\n        // color.g = pct5;\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rand(float x){\n        return fract(sin(x)*1e5);\n    }\n    \n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-.02,pct,vUv.y)-\n        smoothstep(pct,pct+.02,vUv.y);\n    }\n    \n    float noise(vec2 vUv){\n        float i=floor(vUv.x);\n        float f=fract(vUv.x);\n        float y=rand(i);\n        y=mix(rand(i),rand(i+1.),smoothstep(0.,1.,f));\n        return y;\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        float x = 1.-smoothstep(size,size+.01,distance(vUv,pos));\n        float y = 1.-smoothstep(size + 0.02, size + 0.02+0.01, distance(vUv, pos));\n        return y - x;\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv*=10.-5.;\n        //vUv.y-=2.; \n        //vUv.x+=u_time;\n        vec3 color=vec3(0.);\n        float y = noise(vUv);\n        float x1=cir(vUv,vec2(2.5),1.25+y*cos(u_time));\n        float x2=cir(vUv,vec2(2.5),1.5+y*sin(u_time));\n        float x3=cir(vUv,vec2(2.5),1.+y*cos(u_time));\n        float x4=cir(vUv,vec2(2.5),1.75+y*sin(u_time));\n        float x5=cir(vUv,vec2(2.5),.75+y*cos(u_time));\n        float pct=plot(vUv,y);\n    \n        color=vec3(x1 + x2 + x3 + x4 + x5);\n        //color=vec3(pct + x1);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // float rand(float x){\n    //     return fract(sin(x)* 1e4);\n    // }\n    \n    // //2D random\n    // float rand(vec2 vUv){\n    //     return fract(sin(dot(vUv.xy, vec2(23.74927,89.23476))) * 64827.27364872 + rand(u_time * 0.00001));\n    // }\n    \n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = rand(i);\n        float b = rand(i + vec2(1.0, 0.0));\n        float c = rand(i + vec2(0.0, 1.0));\n        float d = rand(i + vec2(1.0, 1.0));\n    \n        // Smooth Interpolation\n    \n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n    \n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 pos = vec2(vUv * 5.0);\n        float n = noise(pos);\n        vec3 color = vec3(0.);\n        color.r =1. - n - 0.5;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     //2D random\n// float rand(vec2 vUv){\n//     return fract(sin(dot(vUv.xy, vec2(23.74927,89.23476))) * 64827.27364872);\n// }\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat cir(vec2 vUv,vec2 pos,float size){\n    vUv = vec2(0.5) - vUv;\n    float f = size * 1.5;\n    float r = length(vUv) * 2.0;\n    float a = atan(vUv.y, vUv.x);\n    float m = abs(mod(a + u_time * 2., 3.14 * 2.) - 3.14)/3.6;\n    m += noise(vUv + u_time * 0.1) * .5;\n    f += sin(a * 40.) * noise(vUv + u_time * .2) * 0.1;\n    f += sin(a * 10.) * .1 * pow(m, 2.);\n    float x = 1.-smoothstep(size,size+.01,distance(vUv,pos));\n    float y = 1.-smoothstep(size + 0.02, size + 0.02+0.01, distance(vUv, pos));\n    return smoothstep(f, f + 0.01, r) + (x - y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = cir(vUv, vec2(0.0), 0.4);\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //2D random\n// float rand(vec2 vUv){\n//     return fract(sin(dot(vUv.xy, vec2(23.74927,89.23476))) * 64827.27364872);\n// }\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat lines(vec2 vUv, float b){\n    float s = 10.0;\n    vUv *= s;\n    return smoothstep(0., .5+b * .5, abs((sin(vUv.x * 3.1415) + b * 2.0)) * .5);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv -= 0.25;\n    vec3 color = vec3(0.);\n    vUv = vUv.yx * vec2(3., 3.);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = noise(vUv) * vUv + u_time * 0.25;\n    float p = vUv.x;\n    p = lines(vUv, .5);\n    color = vec3(p);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _w=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise2(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vec3 color = vec3(0.);\n    vUv += noise2(vUv * 2.5) * 5.0 + sin(u_time * 0.25);\n    float y = smoothstep(.19, .2, noise2(vUv ));\n    y += smoothstep(.1, .2, noise2(vUv * 10.));\n    y -= smoothstep(.3, .4, noise2(vUv * 10.));\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Uw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_w,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ww=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise2(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vec3 color = vec3(0.);\n    vUv += noise2(vUv * 2.5) * 1.0 + cos(u_time * 0.15);\n    float y = smoothstep(.19, .2, noise2(vUv ));\n    y += smoothstep(.1, .2, noise2(vUv * 10.));\n    y -= smoothstep(.3, .4, noise2(vUv * 10.));\n    y -= smoothstep(.4, .6, noise2(vUv * 20.));\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Sw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ww,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //2D random\n// float rand(vec2 vUv){\n//     return fract(sin(dot(vUv.xy, vec2(23.74927,89.23476))) * 64827.27364872);\n// }\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat cir(vec2 vUv,vec2 pos,float size){\n    vUv = vec2(0.5) - vUv;\n    float f = size * 1.5;\n    float r = length(vUv) * 2.0;\n    float a = atan(vUv.y, vUv.x);\n    float m = abs(mod(a + u_time * 2., 3.14 * 2.) - 3.14)/3.6;\n    m += noise(vUv + u_time * 0.1) * .5;\n    f += sin(a * 20.) * noise(vUv + u_time * .02) * 0.1;\n    f -= sin(a * 10.) * .1 * pow(m, 2.);\n    float x = 1.-smoothstep(size,size+.01,distance(vUv,pos));\n    float y = 1.-smoothstep(size + 0.05, size + 0.02+0.01, distance(vUv, pos));\n    return smoothstep(f, f + 0.007, r);\n}\n\nfloat boarder(vec2 vUv, float size, float w){\n    return cir(vUv, vec2(0.0), size ) - cir(vUv, vec2(0.0), size + w); \n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = boarder(vUv, 0.5, 0.04);\n    float y2 = boarder(vUv, 0.3, 0.04);\n    float y3 = boarder(vUv, 0.1, 0.04);\n    color = vec3(y + y2 + y3);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Mw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rand(float x){\n        return fract(sin(x)*1e4);\n    }\n    \n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-.2,pct,vUv.y)-\n        smoothstep(pct,pct+.02,vUv.y);\n    }\n    \n    //2D random\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy,vec2(23.74927,89.23476)))*64827.27364872);\n    }\n    \n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise(in vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        // Four corners in 2D of a tile\n        float a=rand(i);\n        float b=rand(i+vec2(1.,0.));\n        float c=rand(i+vec2(0.,1.));\n        float d=rand(i+vec2(1.,1.));\n        \n        // Smooth Interpolation\n        \n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u=f*f*(3.-2.*f);\n        // u = smoothstep(0.,1.,f);\n        \n        // Mix 4 coorners percentages\n        return mix(a,b,u.x)+\n        (c-a)*u.y*(1.-u.x)+\n        (d-b)*u.x*u.y;\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv*=10.-5.;\n        vUv.y-=2.5;\n        vUv.x+=u_time;\n        vec3 color=vec3(0.);\n        float i=floor(vUv.x);\n        float f=fract(vUv.x);\n        float y=rand(i);\n        //y = mix(rand(i), rand(i + 1.0), f);\n        y=mix(rand(i),rand(i+1.),smoothstep(0.,1.,f));\n        // float x=sin(u_time);\n        float pct=plot(noise(vUv+u_time)+vec2(vUv.x,vUv.y+ 0.8),y);\n        float pct2=plot(noise(vUv+u_time) + vUv,y);\n        float pct3=plot(noise(vUv+u_time)+vec2(vUv.x, vUv.y - 0.8),y);\n        float pct4=plot(noise(vUv+u_time)+vec2(vUv.x,vUv.y+ 1.6),y);\n        float pct5=plot(noise(vUv+u_time)+vec2(vUv.x,vUv.y-1.6),y);\n        color=vec3(pct + pct2 + pct3 + pct4 + pct5);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Cw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Tw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float rand(float x){\n        return fract(sin(x)*1e4);\n    }\n    \n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-.2,pct,vUv.y)-\n        smoothstep(pct,pct+.02,vUv.y);\n    }\n    \n    //2D random\n    float rand2(vec2 vUv){\n        return fract(sin(dot(vUv.xy,vec2(23.74927,89.23476)))*64827.27364872);\n    }\n    \n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise(in vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        // Four corners in 2D of a tile\n        float a=rand(i);\n        float b=rand(i+vec2(1.,0.));\n        float c=rand(i+vec2(0.,1.));\n        float d=rand(i+vec2(1.,1.));\n        \n        // Smooth Interpolation\n        \n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u=f*f*(3.-2.*f);\n        // u = smoothstep(0.,1.,f);\n        \n        // Mix 4 coorners percentages\n        return mix(a,b,u.x)+\n        (c-a)*u.y*(1.-u.x)+\n        (d-b)*u.x*u.y;\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv = noise(Rot(vUv, u_time * 0.2)) * vUv;\n        vUv*=20.-10.;\n        vUv.y-=.0;\n        vUv.x+=u_time;\n        vec3 color=vec3(0.);\n        float i=floor(vUv.x);\n        float f=fract(vUv.x);\n        float y=rand(i);\n        //y = mix(rand(i), rand(i + 1.0), f);\n        y=mix(rand(i),rand(i+1.),smoothstep(0.,1.,f));\n        // float x=sin(u_time);\n        float pct=plot(vUv,y);\n        float pct2=plot(noise(vUv+u_time) + vUv,y);\n        float pct3=plot(noise(vUv+u_time)+vec2(vUv.x, vUv.y - 0.2),y);\n        float pct4=plot(noise(vUv+u_time)+vec2(vUv.x,vUv.y+ 0.4),y);\n        float pct5=plot(noise(vUv+u_time)+vec2(vUv.x,vUv.y-0.4),y);\n        color=vec3(pct + pct2 + pct3 + pct4 + pct5);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Rw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Tw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Dw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //2D random\n// float rand(vec2 vUv){\n//     return fract(sin(dot(vUv.xy, vec2(23.74927,89.23476))) * 64827.27364872);\n// }\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat lines(vec2 vUv, float b){\n    float s = 10.0;\n    vUv *= s;\n    return smoothstep(0.45, .45+b * .451, abs((sin(vUv.x * 3.1415) + b * 1.)) * .5);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv -= .25;\n    vUv.x += sin(u_time) * 0.2;\n    vec3 color = vec3(0.);\n    vUv = vUv.yx * vec2(3., 3.);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = noise(vUv) * vUv + u_time * 0.025;\n    vUv.x = noise(vUv) * vUv.x;\n    vUv.y = noise(vUv) * vUv.y;\n    float p = vUv.x;\n    p = lines(vUv, .5);\n    color = vec3(p);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Pw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Dw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    vec2 pos = vec2(vUv * 2.);\n    pos = Rot(pos, u_time);\n    float y = noise(pos + sin(u_time));\n    float d = length( max(abs(vUv)-(.13 * sin(u_time * 0.25) * 2.),0.));\n    color = vec3(y * (fract(d * 10.0)));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Fw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ew=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 random2(vec2 st){\n        st = vec2( dot(st,vec2(127.1,311.7)),\n                  dot(st,vec2(269.5,183.3)) );\n        return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        vec2 u = f*f*(3.0-2.0*f);\n    \n        return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                         dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                    mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                         dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n    \n    mat2 rotate2d(float angle){\n        return mat2(cos(angle),-sin(angle),\n                    sin(angle),cos(angle));\n    }\n    \n    float lines(in vec2 pos, float b){\n        float scale = 10.0/2.;\n        pos *= scale;\n        return smoothstep(0.001,\n                        .05+b*.251,\n                        abs((sin(pos.x*3.1415)+b*2.0))*.0251);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        float scale  = 1.;\n        pos *= scale;\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        //vUv -= 0.5;\n        vec3 color = vec3(0.);\n        vec2 pos = vUv.yx*vec2(10.,3.);\n        pos -= vec2(5., 1.5);\n        float p = pos.x;\n        pos = rotate2d(noise2(pos + u_time)) * pos;\n        //p = Cir(pos, vec2(0.75), 0.45);\n        p += lines(pos, .5);\n        float r = smoothstep(0.4, 0.6, vUv.y * p);\n        float b = smoothstep(0.4, 0.6, 1. - vUv.y * p);\n        color.b = p * 0.025 * b;\n        color.b += 1. * r + p * 2. ;\n        //color.b = 1.0 * r;\n        //color.rg = vec2(p * b);\n        color.rg += (.8 - p * 1.23);\n        //color.rg += (.9 - p * 1.23);\n        //color.g = step(0.5, 1.);\n        //color.rg = vec2(1., 1.);\n        //color.b -= sin(u_time * 0.25);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Iw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ew,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ow=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 random2(vec2 st){\n        st = vec2( dot(st,vec2(127.1,311.7)),\n                  dot(st,vec2(269.5,183.3)) );\n        return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        vec2 u = f*f*(3.0-2.0*f);\n    \n        return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                         dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                    mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                         dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n    \n    mat2 rotate2d(float angle){\n        return mat2(cos(angle),-sin(angle),\n                    sin(angle),cos(angle));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv *= 10. - 5.;\n        //vUv.x += u_time * 0.2;\n        vec2 newUv = vUv;\n        newUv.x += 1. - noise2(newUv) * newUv.x + u_time;\n        newUv.y += 1. - noise2(newUv) * newUv.y + u_time;\n        \n        newUv = noise2(newUv) * newUv + sin(u_time);\n        color = vec3(newUv, 0.); \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Lw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ow,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Aw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 random2(vec2 st){\n        st = vec2( dot(st,vec2(127.1,311.7)),\n                  dot(st,vec2(269.5,183.3)) );\n        return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        vec2 u = f*f*(3.0-2.0*f);\n    \n        return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                         dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                    mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                         dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n    \n    mat2 rotate2d(float angle){\n        return mat2(cos(angle),-sin(angle),\n                    sin(angle),cos(angle));\n    }\n    \n    float Tri(vec2 vUv, float size){\n        vUv = vUv * 5. - 2.5;\n        float a  = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/3.;\n        float d = cos(floor(.05 * a/r) * r-a) * length(vUv);\n        return 1. - smoothstep(size, size+0.01, d);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 triUv = vUv;\n        triUv = noise2(triUv + (u_time * 0.5)) + triUv;\n        vec3 color = vec3(0.);\n        float tri = Tri(triUv, 0.5);\n        color = vec3(tri);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Nw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Aw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Gw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    vec2 rotate2d(vec2 vUv, float angle){\n        vUv -= vec2(0.5);\n        vUv = (cos(angle),-sin(angle),\n                sin(angle),cos(angle)) * vUv ;\n        vUv += vec2(0.5);\n        return vUv;\n    }\n    \n    float Tri(vec2 vUv,float size){\n        vUv=vUv*5.-2.5;\n        float a=atan(vUv.x,vUv.y)+PI;\n        float r=TWO_PI/3.;\n        float d=cos(floor(.05*a/r)*r-a)*length(vUv);\n        return 1.-smoothstep(size,size+.01,d);\n    }\n    \n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-8. - abs(cos(u_time * 0.75)),pct,(vUv.y * (noise2(vUv + u_time))))-\n        smoothstep(pct,pct+8. + abs(sin(u_time * 0.75)),(vUv.y*(noise2(vUv + u_time))));\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 15. - 7.5;\n        //vUv = rotate2d(vUv, sin(u_time));\n        //vUv.x -= 0.5;\n        vUv.x = noise2(vUv * sin(u_time * 0.5)) + vUv.x;\n        vUv.y = noise2(vUv * sin(u_time * 0.5)) + vUv.y;\n        vec3 color = vec3(0.);\n        float y = noise2(vUv) + vUv.x;\n        float pct=plot(vUv, y);\n        color = vec3(pct);\n        gl_FragColor = vec4(color, 0.5);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Bw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Gw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    vec2 rotate2d(vec2 vUv,float angle){\n        vUv-=vec2(.5);\n        vUv=(cos(angle),-sin(angle),\n        sin(angle),cos(angle))*vUv;\n        vUv+=vec2(.5);\n        return vUv;\n    }\n    \n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-0.01-abs(sin(u_time*.75 )+7.5),pct,(vUv.y*(noise2(vUv+u_time + 2.0))))-\n        smoothstep(pct,pct+0.01+abs(sin(u_time*.75 )+2.0),(vUv.y*(noise2(vUv+u_time + 2.0))));\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv=vUv*15.-7.5;\n        vUv.y += 4.5;\n        //vUv = rotate2d(vUv, sin(u_time));\n        //vUv.x -= 0.5;\n        vUv.x=noise2(vUv)+vUv.x;\n        vUv.y=noise2(vUv)+vUv.y;\n        vec2 newUv = vUv;\n        newUv.y += 7.0;\n        vec3 color=vec3(0.);\n        float y=noise2(vUv)+vUv.y;\n        //float y2=noise2(vec2(newUv))+vUv.y - 7.5;\n        float pct=plot(vUv,y);\n        //float pct2=plot(vUv,y2);\n        float gradient = pow(1.0 - vUv.y, 2.0) * 0.5;\n        float final = pct * gradient;\n        color = final * vec3(pct, pct*pct, pct*pct*pct*pct*pct);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Vw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ww=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    vec2 rotate2d(vec2 vUv,float angle){\n        vUv-=vec2(.5);\n        vUv=(cos(angle),-sin(angle),\n        sin(angle),cos(angle))*vUv;\n        vUv+=vec2(.5);\n        return vUv;\n    }\n    \n    float plot(vec2 vUv,float p){\n        return smoothstep(p + 4.5, p, vUv.y) -\n               smoothstep(p, p - 0.0005, vUv.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 4. - 2.;\n        vUv.y += 2.5;\n        //vUv = vUv * sin(u_time * 0.5)/2.0;\n        vec3 color = vec3(.5, .8, .9);\n        float y1 = noise2(vUv + u_time);\n        float y2 = noise2(vUv + u_time);\n        float y3 = noise2(vUv + u_time);\n        float y4 = noise2(vUv + u_time);\n        float y5 = noise2(vUv + u_time);\n        float pct1 = plot(vec2(vUv.x + 0.0, vUv.y), y1);\n        float pct2 = plot(vec2(vUv.x + 0.5, vUv.y), y2);\n        float pct3 = plot(vec2(vUv.x + 1.0, vUv.y), y3);\n        float pct4 = plot(vec2(vUv.x - 0.5, vUv.y), y4);\n        float pct5 = plot(vec2(vUv.x - 1.0, vUv.y), y5);\n        color *= vec3(pct1 * pct2 * pct3 * pct4 * pct5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Hw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ww,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Xw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p *= vUv.x;\n        return smoothstep(p + vUv.x * 1.5, p, vUv.y) -\n               smoothstep(p, p - vUv.x * 1.5, vUv.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 5.;\n        vUv.x -= 1.5;\n        vUv.y += 1.2;\n        vUv = Rot(vUv, PI * 0.5);\n        //vUv = vUv * sin(u_time * 0.5)/2.0;\n        vec3 color = vec3(0.);\n        float y1 = noise2(vUv - u_time * 0.2);\n        float y2 = noise2(vUv - u_time * 1.0);\n        float y3 = noise2(vUv - u_time * 1.5);\n        float y4 = noise2(vUv - u_time * 1.5);\n        float y5 = noise2(vUv - u_time * 0.5);\n        float pct1 = plot(vec2(vUv.x + 0.0, vUv.y), y1);\n        float pct2 = plot(vec2(vUv.x + 0.5, vUv.y), y2);\n        float pct3 = plot(vec2(vUv.x + 1.0, vUv.y), y3);\n        float pct4 = plot(vec2(vUv.x - 0.5, vUv.y), y4);\n        float pct5 = plot(vec2(vUv.x - 1.0, vUv.y), y5);\n        color = vec3(pct1 * pct2 * pct3 * pct4 * pct5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Yw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Xw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $w=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     //vUv *= 2.0;\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    \n    float plot(vec2 vUv,float p){\n        p *= vUv.x;\n        return smoothstep(p + vUv.x * 1.5, p, vUv.y) -\n               smoothstep(p, p - vUv.x * 1.5, vUv.y);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        //vUv = vUv * 3. - 0.5;\n        //vUv.x -= 1.5;\n        //vUv.y += 1.2;\n        //vUv *= 2.0;\n        vUv = Rot(vUv, PI * u_time * 0.25);\n        vUv = vUv * 2. - 1.;\n        //vUv = vUv * sin(u_time * 0.5)/2.0;\n        vec3 color = vec3(.5, .8, .9);\n        float y1 = noise2(vUv - u_time * 0.2);\n        float y2 = noise2(vUv - u_time * 1.0);\n        float y3 = noise2(vUv - u_time * 1.5);\n        float y4 = noise2(vUv - u_time * 1.5);\n        float y5 = noise2(vUv - u_time * 0.5);\n        float pct1 = plot(vec2(vUv.x + 0.0, vUv.y), y1);\n        float pct2 = plot(vec2(vUv.x + 0.5, vUv.y), y2);\n        float pct3 = plot(vec2(vUv.x + 1.0, vUv.y), y3);\n        float pct4 = plot(vec2(vUv.x - 0.5, vUv.y), y4);\n        float pct5 = plot(vec2(vUv.x - 1.0, vUv.y), y5);\n        color *= vec3(pct1 * pct2 * pct3 * pct4 * pct5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Zw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$w,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Kw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     //vUv *= 2.0;\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    \n    float plot(vec2 vUv,float p){\n        p *= vUv.x;\n        return smoothstep(p + vUv.x * 1.5, p, vUv.y) -\n               smoothstep(p, p - vUv.x * 1.5, vUv.y);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    vec2 Tile2(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        //vUv = noise2(vUv + u_time) + vUv;\n        float t = u_time * speed;\n        if(fract(t) > .5 ){\n            if(fract(vUv.y * .5)>.5){\n                vUv.x+= fract(t) * 2.;\n                vUv.x = noise2(vUv + u_time) + vUv.x;\n            }else{\n                vUv.x-= fract(t) * 2.;\n                vUv.x = noise2(vUv - u_time) - vUv.x;\n            }\n            //vUv = Rot(vUv, PI * 0.5);\n        } else {\n            if(fract(vUv.x*.5) > .5){\n                vUv.y += fract(t) * 2.;\n                vUv.y = noise2(vUv + u_time) + vUv.y;\n            } else {\n                vUv.y -= fract(t) * 2.;\n                vUv.y = noise2(vUv - u_time) - vUv.y;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float Tri(vec2 vUv, float size){\n        vUv -= 0.5;\n        float a = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/3.0;\n        float d = cos(floor(.5 + a/r) * r-a) * length(vUv);\n        return 1.0 - smoothstep(size, size+0.01, d);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile2(vUv, 10.0, 0.25);\n        float c1 = cir(vUv, vec2(0.5), 0.25);\n    \n        vec2 newUv = vUv;\n        newUv = Rot(vUv, sin(u_time + 2.0) * PI);\n        float t1 = Tri(newUv, 0.1);\n        \n        color = vec3(c1 - t1);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Jw(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Kw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qw=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     //vUv *= 2.0;\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    \n    float plot(vec2 vUv,float p){\n        p *= vUv.x;\n        return smoothstep(p +0.15, p, vUv.y) -\n               smoothstep(p, p - 0.15, vUv.y);\n    }\n    \n    float plot2(vec2 vUv,float p){\n        p *= vUv.y;\n        return smoothstep(p +0.15, p, vUv.x) -\n               smoothstep(p, p - 0.15, vUv.x);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 15. - 7.5;\n        vec3 color = vec3(0.);\n        vUv = noise2(vUv+u_time) * vUv;\n        float y = plot(vUv, 50.);\n        float y2 = plot2(vUv, cos(u_time+ TWO_PI));\n        color = vec3(y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Qw,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.15,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1. - (smoothstep(size,size+.01,distance(vUv,pos)) - \n                     smoothstep(size-0.025, size-0.025+0.1,distance(vUv,pos)));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2.6 - 1.3;\n        vec3 color = vec3(0.);\n        vec2 translate = noise2(vUv + u_time) * vUv;\n    \n        float c1=cir(vUv,vec2(.50 * translate.x , 0.50 * translate.y),.25);\n        float c2=cir(vUv,vec2(.25 * translate.x +sin(u_time), 0.50 * translate.y),.25);\n        float c3=cir(vUv,vec2(.75 * translate.x, 0.50 * translate.y +sin(u_time)),.25);\n        float c4=cir(vUv,vec2(.50 * translate.x -sin(u_time), 0.25 * translate.y),.25);\n        float c5=cir(vUv,vec2(.50 * translate.x, 0.75 * translate.y -sin(u_time)),.25);\n        color = 1. - vec3(c1*c2*c3*c4*c5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:eS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.15,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n        smoothstep(size-.025,size-.025+.1,distance(vUv,pos)));\n    }\n    \n    float sqr(vec2 vUv,vec2 size){\n        vec2 b=smoothstep(size,size+vec2(.03),vUv);\n        b*=smoothstep(size,size+vec2(.03),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.03),(size-vec2(.03))+vec2(.03),vUv);\n        b2*=smoothstep(size-vec2(.03),(size-vec2(.03))+vec2(.03),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv=vUv*3.-1.;\n        \n        vec2 newUv1= vUv;\n        newUv1.x += 1.0;\n        vec2 newUv2 = vUv;\n        newUv2.x -= 2.0;\n        vec3 color=vec3(0.);\n        vec2 translate1=noise2(newUv1+u_time)*newUv1;\n        vec2 translate2=noise2(newUv2+u_time)*newUv2;\n        //vUv = noise2(vUv+u_time ) + vUv;\n        float s1=sqr(vec2(newUv1.x,newUv1.y),vec2(.005+translate1.x,.05));\n        float s2=sqr(vec2(newUv1.x,newUv1.y+1.),vec2(.005-translate1.x,.005));\n        float s3=sqr(vec2(newUv1.x,newUv1.y-1.),vec2(.0005-translate1.x,.005));\n    \n        float s4=sqr(vec2(newUv2.x+1.,newUv2.y),vec2(.005+translate2.x,.05));\n        float s5=sqr(vec2(newUv2.x+1.,newUv2.y+1.),vec2(.005+translate2.x,.005));\n        float s6=sqr(vec2(newUv2.x+1.,newUv2.y-1.),vec2(.0005-translate2.x,.005));\n    \n        color = vec3(s1 + s2 + s3 + s4 + s5 + s6);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function oS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.15,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n        smoothstep(size-.025,size-.025+.1,distance(vUv,pos)));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 0.5;\n        vec3 color = vec3(0.);\n        vUv += noise2(vUv + u_time) * vUv;\n        float c1 = cir(vUv, vec2(0.5,0.0), 0.25);\n        float c2 = cir(vUv, vec2(0.0,0.0), 0.25);\n        float c3 = cir(vUv, vec2(1.0,0.0), 0.25);\n    \n        float c4 = cir(vUv, vec2(0.5,0.5), 0.25);\n        float c5 = cir(vUv, vec2(0.0,0.5), 0.25);\n        float c6 = cir(vUv, vec2(1.0,0.5), 0.25);\n    \n        float c7 = cir(vUv, vec2(0.5,1.0), 0.25);\n        float c8 = cir(vUv, vec2(0.0,1.0), 0.25);\n        float c9 = cir(vUv, vec2(1.0,1.0), 0.25);\n        color = vec3(c1 * c2 * c3 * c4 *c5 * c6 * c7 * c8 * c9);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function iS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:aS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.15,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n        smoothstep(size-.025,size-.025+.5,distance(vUv,pos)));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 3. - 1.;\n        vec2 newUv = vUv;\n        vec2 translate = vec2(noise2(newUv+u_time) + newUv.x, sin(noise2(newUv+u_time)) * newUv.y);\n        vec3 color = vec3(0.);\n    \n        vUv = Rot(vUv, u_time * 0.25);\n    \n        vec2 pos = vec2(0.5);\n        pos.x = translate.x * pos.x + 0.25;\n        pos.y = translate.y * pos.y + 0.75;\n        float c1 = cir(vUv, pos, 0.5);\n    \n        vec2 pos2 = vec2(0.5);\n        pos2.x = translate.x * pos2.x + 0.25;\n        pos2.y = translate.y * pos2.y + 0.5;\n        float c2 = cir(vUv, pos2, 0.5);\n    \n        vec2 pos3 = vec2(0.5);\n        pos3.x = translate.x * pos3.x + 0.25;\n        pos3.y = translate.y * pos3.y + 0.25;\n        float c3 = cir(vUv, pos3, 0.5);\n    \n        vec2 pos4 = vec2(0.5);\n        pos4.x = translate.x * pos4.x + 0.25;\n        pos4.y = translate.y * pos4.y + 1.0;\n        float c4 = cir(vUv, pos4, 0.5);\n    \n        vec2 pos5 = vec2(0.5);\n        pos5.x = translate.x * pos5.x + 0.25;\n        pos5.y = translate.y * pos5.y + 1.25;\n        float c5 = cir(vUv, pos5, 0.5);\n    \n        vec2 pos6 = vec2(0.5);\n        pos6.x = translate.x * pos6.x + 0.25;\n        pos6.y = translate.y * pos6.y + 0.0;\n        float c6 = cir(vUv, pos6, 0.5);\n    \n        color = vec3(c1 * c2 * c3 * c4 * c5 * c6);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.015,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n        smoothstep(size-.025,size-.025+.5,distance(vUv,pos)));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n        vUv = noise2(vUv + u_time) + vUv;\n        vec3 color = vec3(0.);\n        float p1 = vUv.y;\n        float p2 = vUv.y - 0.5;\n        float p3 = vUv.y - 1.0;\n        float p4 = vUv.x;\n        float p5 = vUv.x - 0.5;\n        float p6 = vUv.x - 1.0;\n        float pct1 = plot(vUv, p1);\n        float pct2 = plot(vUv, p2);\n        float pct3 = plot(vUv, p3);\n        float pct4 = plot(vUv, p4);\n        float pct5 = plot(vUv, p5);\n        float pct6 = plot(vUv, p6);\n        color = vec3(pct1 + pct2 + pct3 + pct4 + pct5 + pct6);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.015,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float plot2(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.015,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n        smoothstep(size-.025,size-.025+.5,distance(vUv,pos)));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 5. - 2.5;\n        vec3 color = vec3(0.);\n        vUv *= noise2(vUv+u_time) * vUv;\n        float y = plot(vUv, abs(sin(u_time+ TWO_PI)));\n        float y2 = plot2(vUv,  abs(sin(u_time+ TWO_PI)));\n        color = vec3(y2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, sin(u_time * 0.25));\n    vec3 color = vec3(0.);\n    vec2 pos = vec2(vUv * 5.);\n    vec2 vel = vec2(u_time * 0.1);\n    float y = snoise(pos + vel) * 0.25 + 0.25;\n    float a = snoise(pos * vec2(cos(u_time * 0.15), sin(u_time * 0.1)) * 0.1) * PI;\n    vel = vec2(cos(a), sin(a));\n    y += snoise(pos + vel) * 0.25 + 0.25;\n    color = vec3(smoothstep(0.7, 0.75, fract(y)));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = Rot(vUv, sin(u_time * 0.25));\n    vec3 color = vec3(0.);\n    vec2 pos = vec2(vUv * 2.);\n    vec2 vel = vec2(u_time * 0.1);\n    float y = snoise(pos) * 2.75 + 0.75;\n    float a = snoise(pos * vec2(cos(u_time * 0.25), sin(u_time * 0.2)) * 0.1) * PI;\n    vel = vec2(cos(a), sin(a));\n    y += snoise(pos + vel) * 0.25 + 0.25;\n    color = 1. - vec3(smoothstep(0.7, 0.75, fract(y)));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    p*=vUv.x;\n    return smoothstep(p+.015,p,vUv.y)-\n    smoothstep(p,p-.15,vUv.y);\n}\n\nfloat cir(vec2 vUv,vec2 pos,float size){\n    return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n    smoothstep(size+.292,size+.295,distance(vUv,pos)));\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, (u_time * 0.25));\n    vUv = vUv * 5.0 - 2.5;\n    vec3 color = vec3(0.);\n    vUv = snoise(vUv) * vUv;\n    vec2 pos = vec2(0.5);\n    pos = snoise(pos) * pos;\n    float c1 = cir(vUv, pos, 0.25 + snoise(vUv + (u_time * 0.1)));\n    color = vec3(c1);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    p*=vUv.x;\n    return smoothstep(p+.015,p,vUv.y)-\n    smoothstep(p,p-.15,vUv.y);\n}\n\nfloat cir(vec2 vUv,vec2 pos,float size){\n    float x = 1.-(smoothstep(size,size+.1,distance(vUv,pos)));\n    float y = 1.-(smoothstep(size * 1.5, size * 1.5 + 0.1, distance(vUv, pos)));\n    return y - x;\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, (u_time * 0.25));\n    //vUv.x += u_time * 0.25;\n    vUv = vUv * 2. - 0.5;\n    vec3 color = vec3(0.);\n    //vUv += snoise(vUv) * vUv;\n    vec2 pos = vec2(0.5);\n    vUv = snoise(vUv) * vec2 (0.5);\n    float size = 0.25;\n    size = snoise(vUv * 5.0 + sin(u_time * 0.25)) + size;\n    float x = 1.-(smoothstep(size,size+.5,distance(vUv,pos)));\n    float y = 1.-(smoothstep(size * 1.25, size * 1.75 + 0.5, distance(vUv, pos)));\n    float c1 = y - x;\n    color = vec3(c1);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _S=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x = snoise(vUv + u_time * 0.1);\n    p += x;\n    return smoothstep(p+(.045),p,vUv.y)-\n    smoothstep(p,p-(.045),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 1. - 2.;\n    vec3 color = vec3(0.);\n    float x = vUv.x;\n    float y1 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct1 = plot(vec2(vUv.x - 2.5, vUv.y), y1);\n    float y2 =  x*x*(3.0-2.0*x);\n    float pct2 = plot(vec2(vUv.x - 2.0, vUv.y), y2);\n    float y3 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct3 = plot(vec2(vUv.x - 1.5, vUv.y), y3);\n    float y4 =  x*x*(3.0-2.0*x);\n    float pct4 = plot(vec2(vUv.x -1.0, vUv.y), y4);\n    float y5 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct5 = plot(vec2(vUv.x , vUv.y), y5);\n    float y6 =  x*x*(3.0-2.0*x);\n    float pct6 = plot(vec2(vUv.x + 1.0, vUv.y), y6);\n    float y7 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct7 = plot(vec2(vUv.x + 1.5, vUv.y), y7);\n    float y8 =  x*x*(3.0-2.0*x);\n    float pct8 = plot(vec2(vUv.x + 2.0, vUv.y), y8);\n    float y9 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct9 = plot(vec2(vUv.x + 2.5, vUv.y), y9);\n    float y10 =  x*x*(3.0-2.0*x);\n    float pct10 = plot(vec2(vUv.x + 3.5, vUv.y), y10);\n    color = vec3(pct1 + pct2 + pct3 + pct4 + pct5 + pct6 + pct7 + pct8 + pct9 + pct10);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function US(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_S,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x = snoise(vUv + u_time * 0.1);\n    p += x;\n    return smoothstep(p+(.045),p,vUv.y)-\n    smoothstep(p,p-(.045),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 2.;\n    vUv.x += 1.0;\n    vec3 color = vec3(0.);\n    float noise = snoise(vUv + u_time);\n    float x = vUv.x;\n    float y1 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct1 = plot(vec2(vUv.x - 2.5, vUv.y), y1);\n    float y2 =  x*x*(3.0-2.0*x);\n    float pct2 = plot(vec2(vUv.x - 2.0, vUv.y), y2);\n    float y3 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct3 = plot(vec2(vUv.x - 1.5, vUv.y), y3);\n    float y4 =  x*x*(3.0-2.0*x);\n    float pct4 = plot(vec2(vUv.x -1.0, vUv.y), y4);\n    float y5 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct5 = plot(vec2(vUv.x , vUv.y), y5);\n    float y6 =  x*x*(3.0-2.0*x);\n    float pct6 = plot(vec2(vUv.x + 1.0, vUv.y), y6);\n    float y7 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct7 = plot(vec2(vUv.x + 1.5, vUv.y), y7);\n    float y8 =  x*x*(3.0-2.0*x);\n    float pct8 = plot(vec2(vUv.x + 2.0, vUv.y), y8);\n    float y9 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct9 = plot(vec2(vUv.x + 2.5, vUv.y), y9);\n    float y10 =  x*x*(3.0-2.0*x);\n    float pct10 = plot(vec2(vUv.x + 3.5, vUv.y), y10);\n    color = vec3(pct1 + pct2 + pct3 + pct4 + pct5 + pct6 + pct7 + pct8 + pct9 + pct10);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function SS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x = snoise(vUv + u_time * 0.1);\n    p += x;\n    return smoothstep(p+(.045),p,vUv.y)-\n    smoothstep(p,p-(.045),vUv.y);\n}\n\nfloat cir(vec2 vUv,vec2 pos,float size){\n    float x = 1.-(smoothstep(size,size+.01,distance(vUv,pos)));\n    float y = 1.-(smoothstep(size * 1.25, size * 1.25 + 0.01, distance(vUv, pos)));\n    return y - x;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.5 - 0.75;\n    vec3 color = vec3(0.);\n    float noise = snoise(vUv + u_time);\n    float c1 = cir(vUv, vec2(0.5 + sin(noise * 0.1), 0.5), 0.15);\n    float c2 = cir(vUv, vec2(0.5 + sin(noise * 0.1), 0.5), 0.35);\n    float c3 = cir(vUv, vec2(0.5 + sin(noise * 0.1), 0.5), 0.55);\n    float c4 = cir(vUv, vec2(0.5 + sin(noise * 0.1), 0.5), 0.75);\n    float c5 = cir(vUv, vec2(0.5 + sin(noise * 0.1), 0.5), 0.95);\n    color = vec3(c1 + c2 + c3 + c4 + c5);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function MS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat sqr(vec2 vUv,vec2 size){\n    vec2 b=smoothstep(size,size+vec2(.013),vUv);\n    b*=smoothstep(size,size+vec2(.013),1.-vUv);\n    float box1=b.x*b.y;\n    vec2 b2=smoothstep(size-vec2(.013),(size-vec2(.031))+vec2(.031),vUv);\n    b2*=smoothstep(size-vec2(.013),(size-vec2(.031))+vec2(.031),1.-vUv);\n    float box2=b2.x*b2.y;\n    return box2-box1;\n}\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvec2 movingTiles(vec2 _st, float _zoom, float _speed){\n    _st *= _zoom;\n    float time = u_time*_speed;\n    if( fract(time)>0.5 ){\n        if (fract( _st.y * 0.5) > 0.5){\n            _st.x += fract(time)*2.0;\n        } else {\n            _st.x -= fract(time)*2.0;\n        }\n    } else {\n        if (fract( _st.x * 0.5) > 0.5){\n            _st.y += fract(time)*2.0;\n        } else {\n            _st.y -= fract(time)*2.0;\n        }\n    }\n    return fract(_st);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv.y -= 2.5;\n    float noise = snoise(vUv + (u_time * 0.5));\n    vUv = movingTiles(vec2(sin(vUv.x) + noise * 0.01, cos(vUv.y) + noise * 0.01), 4., 0.15);\n    vec3 color = vec3(0.);\n    vec2 vUv2 = Rot(vUv, PI * 0.25);\n    vUv = Rot(vUv, u_time * 0.25 );\n    //vUv2 = Rot(vUv2, -u_time * 0.25  );\n    float y1 = sqr(vUv + (noise * 0.05), vec2(0.25));\n    float y2 = sqr(vUv2 + (noise * 0.05), vec2(0.2));\n    float y3 = sqr(vUv + (noise * 0.05), vec2(0.25 * 1.75));\n    float y4 = sqr(vUv2 + (noise * 0.05), vec2(0.2 * 1.75));\n    float y5 = sqr(vUv + (noise * 0.05), vec2(0.25 * 2.));\n    float y6 = sqr(vUv2 + (noise * 0.05), vec2(0.2 * 2.));\n    float y7 = sqr(vUv + (noise * 0.05), vec2(0.25 * 1.5));\n    float y8 = sqr(vUv2 + (noise * 0.05), vec2(0.2 * 1.5));\n    color = vec3(y1 + y2 + y3 + y4 + y5 + y6 + y7 + y8);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function CS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.1);\n    // p+=x * 0.15;\n    return smoothstep(p+(.045),p,vUv.y)-\n    smoothstep(p,p-(.045),vUv.y);\n}\n\nfloat cir(vec2 vUv, float size){\n    vUv=vec2(.5)-vUv;\n    float r=length(vUv)*2.;\n    float a=atan(vUv.y,vUv.x);\n    float m=abs(mod(a+u_time*1.,3.14*2.)-3.14)/3.6;\n    float f=size;\n    m+=snoise(vUv+u_time*.1)*.01;\n    // a *= 1.+abs(atan(u_time*0.2))*.1;\n    // a *= 1.+noise(st+u_time*0.1)*0.1;\n    f+=sin(a*12.)*snoise(vUv*u_time*.2)*.01;\n    f+=(sin(a*10.)*.1*pow(m,1.));\n    return 1.-smoothstep(f,f+.007,r);\n}\n\nfloat cirOutline(vec2 vUv, float size, float width){\n    return cir(vUv, size) - cir(vUv, size - width);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 0.5;\n    vec3 color = vec3(0.);\n    float y1=cirOutline(vUv,0.9,.025);\n    float y2=cirOutline(vUv,.8,.025);\n    float y3=cirOutline(vUv,0.7,.025);\n    float y4=cirOutline(vUv,.6,.025);\n    float y5=cirOutline(vUv,.5,.025);\n    color = vec3(y1 + y2 + y3 + y4 + y5);\n    gl_FragColor = vec4(color, 1.);\n}\n\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function RS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:TS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.1);\n    // p+=x * 0.15;\n    return smoothstep(p+(.045),p,vUv.y)-\n    smoothstep(p,p-(.045),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.2 - 1.1;\n    vUv /= u_time * 0.15;\n    vec3 color = vec3(0.);\n    float y = sin(vUv.x + u_time);\n    y *= snoise(sin(vUv*(u_time))) * 0.5 ;\n    float pct = plot(vec2(vUv.x,vUv.y), y);\n    float pct2= plot(vec2(vUv.x,vUv.y + 0.25),y);\n    float pct3=plot(vec2(vUv.x,vUv.y-.25),y);\n    float pct4=plot(vec2(vUv.x,vUv.y+.50),y);\n    float pct5=plot(vec2(vUv.x,vUv.y-.50),y);\n    color = vec3(pct + pct2 + pct3 + pct4 + pct5);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function PS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:DS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.1);\n    p=x * 0.15;\n    return smoothstep(p+(.05),p,vUv.y)-\n    smoothstep(p,p-(.5),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5. - 2.5;\n    vec3 color = vec3(0.);\n    float y = sin(vUv.x + u_time * 0.5);\n    float sn = snoise(vUv + u_time);\n    float pct = plot(vUv * sn, y);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function FS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ES=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.1);\n    p=x * 0.15;\n    return smoothstep(p+(.15),p,vUv.y)-\n    smoothstep(p,p-(2.5),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vUv.y -= 0.5;\n    vec3 color = vec3(0.);\n    vec2 translate = (vec2(snoise(vUv + (u_time * 0.5)) + vUv.x, snoise(vUv + (u_time * 0.5)) + vUv.y));\n    float x = vUv.x;\n    float y = x * x * ( 3. - 2. * x);\n    float pct = plot(vUv + translate, y);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function IS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ES,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.1);\n    p=x * 0.75;\n    return smoothstep(p+(.5),p,vUv.y)-\n    smoothstep(p,p-(2.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vUv = Rot(vUv, u_time * 0.15);\n    vec3 color = vec3(0.);\n    float n = snoise((vUv + u_time));\n    float y = sin(vUv.x + u_time) * n;\n    float pct = plot(vUv + sin(n + u_time * 0.25), y);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function LS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:OS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.1);\n    p=x * 0.5 ;\n    return smoothstep(p+(0.25),p,vUv.y)-\n    smoothstep(p,p-(1.0),vUv.y);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float noise = snoise(vUv);\n    float c1 = cir(vUv, vec2(0.5), 0.25);\n    color = vec3(c1);\n    float x = vUv.x;\n    float y = x*x*x*(x*(x*6.-15.)+10.) + noise;\n    float p1 = plot(vec2(vUv.x * (noise + sin(u_time)), vUv.y - 0.5 + (noise + cos(u_time))), y);\n    color *= p1;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function NS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:AS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.1);\n    p=x * 0.5 ;\n    return smoothstep(p+(0.25),p,vUv.y)-\n    smoothstep(p,p-(1.0),vUv.y);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float noise = snoise(vUv + (u_time * 0.5)) * 0.1;\n    float c1 = cir(vUv, vec2(0.5 + sin(noise), 0.5), 0.35 + noise);\n    float c2 = cir(vUv, vec2(0.5 + sin(noise), 0.5), 0.325 + noise);\n    float b1 = Box(vUv, vec2(0.25) + noise);\n    float b2 = Box(vUv, vec2(0.225) + noise);\n    color = vec3(c1 - c2);\n    color += (b2 - b1);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function BS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:GS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(0.01),p,vUv.y)-\n    smoothstep(p,p-(0.01),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.5;\n    vec3 color = vec3(0.);\n    float noise=snoise((vUv)+(u_time*.15))*.51;\n    vUv = vUv * sin(noise +u_time * 0.5);\n    float x=vUv.x;\n    float y=x*x*x*(x*(x*6.-15.)+10.)*noise;\n    float pct1=plot(vec2(vUv.x,vUv.y-.0),y);\n    float pct2=plot(vec2(vUv.x,vUv.y-.1),y);\n    float pct3=plot(vec2(vUv.x,vUv.y-.2),y);\n    float pct4=plot(vec2(vUv.x,vUv.y-.3),y);\n    float pct5=plot(vec2(vUv.x,vUv.y-.4),y);\n    float pct6=plot(vec2(vUv.x,vUv.y+.0),y);\n    float pct7=plot(vec2(vUv.x,vUv.y+.1),y);\n    float pct8=plot(vec2(vUv.x,vUv.y+.2),y);\n    float pct9=plot(vec2(vUv.x,vUv.y+.3),y);\n    float pct10=plot(vec2(vUv.x,vUv.y+.4),y);\n    color = vec3(pct1 + pct2 + pct3 + pct4 + pct5 + pct6 + pct7 + pct8 + pct9 + pct10);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function VS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+(0.5),p,vUv.y)-\n    smoothstep(p,p-(0.025),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5. - 2.5;\n    vUv.x += 1.5;\n    float noise = snoise(vUv) * (sin(u_time)) * 0.5;\n    vec3 color = vec3(0.);\n    float y = sin(vUv.x + (u_time) + noise);\n    float pct1=plot(vec2(vUv.x,vUv.y-0.25),y);\n    float pct2=plot(vec2(vUv.x,vUv.y),y);\n    float pct3=plot(vec2(vUv.x,vUv.y-0.5),y);\n    float pct4=plot(vec2(vUv.x,vUv.y-.75),y);\n    color = vec3(pct1 + pct2 + pct3 + pct4);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function HS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:WS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(.75),p,vUv.y)-\n    smoothstep(p,p-(.01),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    float noise = snoise(vUv);\n    float y1 = sin(vUv.x *noise+ u_time);\n    float pct1 = plot(vUv , y1);\n    vec2 newUv = vUv;\n    newUv = Rot(newUv, TWO_PI);\n    float y2=sin(newUv.x*noise+u_time);\n    float pct2=plot(newUv,y2);\n    vec2 newUv2=newUv;\n    newUv2=Rot(newUv2,TWO_PI);\n    float y3=sin(newUv2.x*noise+u_time);\n    float pct3=plot(newUv2,y3);\n    color = vec3(pct1 + pct2 + pct3);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function YS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:XS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $S=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.25);\n    p=x * 0.75 ;\n    return smoothstep(p+(2.75),p,vUv.y * p)-\n    smoothstep(p,p-(2.75),vUv.y * p);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    \n    vUv = vUv * 5. - 2.5;\n    \n    float noise = snoise(vUv + sin(u_time * 0.25) ) * (22.0);\n    vUv = vUv * (noise);\n    \n    vec3 color = vec3(0.);\n    float y = sin(vUv.x + u_time);\n    float pct = plot(Rot(vUv, u_time * 5.0), y);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ZS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$S,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(1.75),p,vUv.y * p)-\n    smoothstep(p,p-(1.75),vUv.y * p);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    \n    float n = snoise(vUv);\n    vec2 vUv = vec2(vUv.x + n, vUv.y - n);\n    \n    vUv = vUv * 5. - 2.5;\n    vUv = Rot(vUv, u_time * 0.25);\n    vec3 color = vec3(0.);\n    float y = sin(vUv.x * n * 2.5);\n    float pct = plot(vUv, y);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function JS(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:KS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QS=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(0.25),p,vUv.y * p)-\n    smoothstep(p,p-(0.025),vUv.y * p);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float c1 = cir(vUv, vec2(0.5), 0.25);\n    float y = snoise(vUv) + sin(c1);\n    float pct = plot(vec2(vUv.x, vUv.y + 0.5), y + (sin(u_time+ 15.0)) );\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:QS,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ek=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(0.525),p,vUv.y * p)-\n    smoothstep(p,p-(0.025),vUv.y * p);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 newUv = vUv;\n    newUv = Rot(vUv, u_time * 0.5);\n    float c1 = cir(vUv, vec2(0.5), 0.25);\n    float s1 = Box(newUv, vec2(0.25));\n    float y = snoise(vUv) + sin(s1);\n    float pct = plot(vec2(vUv.x, vUv.y + 0.5) + snoise(vUv + u_time * 0.25), y + (sin(u_time+ 15.0)) );\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ek,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(0.525),p,vUv.y * p)-\n    smoothstep(p,p-(0.025),vUv.y * p);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float n = snoise(vUv + u_time) * 0.05;\n    vec2 newUv = vUv;\n    newUv = Rot(vUv, u_time * 0.5);\n    float c1 = cir(vUv + n, vec2(0.5), 0.25);\n    float s1 = Box(newUv * n, vec2(0.25));\n    float y = snoise(vUv) + sin(s1);\n    float pct = plot(vUv, s1 - c1);\n    color = 1. - vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ok(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ak=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(0.525),p,vUv.y * p)-\n    smoothstep(p,p-(0.025),vUv.y * p);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.21, distance(vUv, pos));\n}\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.011), vUv);\n    b *= smoothstep(size, size + vec2(0.011), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float n = snoise(vUv * (u_time)) * 0.15;\n    vec2 newUv = vUv;\n    newUv = Rot(vUv, u_time * 0.5);\n    float c1 = cir(vUv * n, vec2(0.5), 0.25);\n    float s1 = Box(newUv + (n), vec2(0.15));\n    float y = snoise(vUv) + sin(s1);\n    float pct = plot(vUv, s1);\n    color = 1. - vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ik(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ak,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.25);\n    p=x * .95 ;\n    return smoothstep(p + 0.25,p,vUv.y)-\n    smoothstep(p,p-(0.25),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.25);\n    vUv = vUv * 8. - 4.;\n    vec3 color = vec3(0.);\n    float y = sin(vUv.x + u_time);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vUv2 = Rot(vUv2, PI * 0.5);\n    vUv3 = Rot(vUv3, PI * 0.75);\n    vUv4 = Rot(vUv4,-PI * 0.75);\n    float pct1 = plot(vUv1, y);\n    float pct2 = plot(vUv2, y);\n    float pct3 = plot(vUv3, y);\n    float pct4 = plot(vUv4, y);\n    color = vec3(pct1 + pct2 + pct3 + pct4);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ck(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * .05 ;\n    return smoothstep(p + 0.25,p,vUv.y)-\n    smoothstep(p,p-(0.25),vUv.y);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    float n = snoise((vUv) + (u_time * 0.25)) * .19;\n    float y0 = 1. - smoothstep(size - (0.15 * n) + n, size - (0.15 * n) + n + .01, distance(vUv + n, pos));\n    float y1 = 1. - smoothstep(size + n, (size + .01) + n, distance(vUv + n, pos));\n    float y2 = 1. - smoothstep(size + (0.15 * n) + n, size + (0.15 * n)  + n+ .01, distance(vUv + n, pos));\n    return y2 - y1 + y0;\n}\n\nvec2 tile(vec2 vUv, float zoom){\n    float n = snoise(vUv + u_time) * 0.2;\n    vUv *= zoom;\n    float time = u_time * 0.1 ;\n    if (fract(time) > 0.5){\n        if(fract(vUv.y * 0.5) > 0.5){\n            vUv.x += fract(time) * 2.0;\n        } else {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5){\n            vUv.y += fract(time) * 2.0;\n        } else {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vUv = tile(vUv, 1.);\n    vec3 color = vec3(0.);\n    float c1 = cir(vUv, vec2(0.5), 0.125);\n    color = vec3(c1);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * .05 ;\n    return smoothstep(p + 0.015,p,vUv.y)-\n    smoothstep(p,p-(0.015),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    float n = snoise(vUv + u_time) * 1.0;\n    float y = sin((vUv.x * n) + u_time) / 10.0;\n    float p1 = plot(vec2(vUv.x, vUv.y + 0.1), y);\n    float p2 = plot(vec2(vUv.x, vUv.y + 0.2), y);\n    float p3 = plot(vec2(vUv.x, vUv.y + 0.3), y);\n    float p4 = plot(vec2(vUv.x, vUv.y + 0.4), y);\n    float p5 = plot(vec2(vUv.x, vUv.y + 0.5), y);\n    float p6 = plot(vec2(vUv.x, vUv.y - 0.0), y);\n    float p7 = plot(vec2(vUv.x, vUv.y - 0.1), y);\n    float p8 = plot(vec2(vUv.x, vUv.y - 0.2), y);\n    float p9 = plot(vec2(vUv.x, vUv.y - 0.3), y);\n    float p10 =plot(vec2(vUv.x, vUv.y - 0.4), y);\n    float p11 =plot(vec2(vUv.x, vUv.y - 0.5), y);\n    float p12 =plot(vec2(vUv.x, vUv.y + 0.6), y);\n    float p13 =plot(vec2(vUv.x, vUv.y + 0.7), y);\n    float p14 =plot(vec2(vUv.x, vUv.y + 0.8), y);\n    float p15 =plot(vec2(vUv.x, vUv.y + 0.9), y);\n    float p16 =plot(vec2(vUv.x, vUv.y + 1.0), y);\n    float p17 =plot(vec2(vUv.x, vUv.y - 0.6), y);\n    float p18 =plot(vec2(vUv.x, vUv.y - 0.7), y);\n    float p19 =plot(vec2(vUv.x, vUv.y - 0.8), y);\n    float p20 =plot(vec2(vUv.x, vUv.y - 0.9), y);\n    float p21 =plot(vec2(vUv.x, vUv.y - 1.0), y);\n    float p22 =plot(vec2(vUv.x, vUv.y - 1.1), y);\n    float p23 =plot(vec2(vUv.x, vUv.y + 1.1), y);\n    color = vec3(p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9 + p10 + p11\n                 + p11 + p12 + p13 + p14 + p15 + p16 + p17 + p18 + p19 + p20 + p21 + p22 + p23);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 1.5 - 0.25;\n        vec3 color = vec3(0.);\n        //cellular noise loops\n        vec2 point[6];\n        point[0] = vec2(0.83 + sin(u_time * 0.25), 0.75);\n        point[1] = vec2(0.60 - cos(u_time * 0.25), 0.1);\n        point[2] = vec2(0.28 , 0.64 + sin(u_time * 0.25) );\n        point[3] = vec2(0.31 , 0.26 - cos(u_time * 0.25));\n        point[4] = vec2(0.50 + sin(u_time * 0.25), 0.50 + cos(u_time * 0.25) );\n        point[5] = vec2(0.5, 0.5);\n        float m_dist = 1.;\n    \n        for(int i = 0; i < 6; i++){\n            float dist = distance(vUv, point[i]);\n            m_dist = min(m_dist, dist);\n        }\n        color = vec3(smoothstep(.345, .511, abs(sin(50. * m_dist + cos(u_time * 2.)))));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    //cellular noise loops\n   //scale\n   vUv *= 3.;\n\n   //tile the space\n   vec2 vUvI = floor(vUv);\n   vec2 vUvF = fract(vUv);\n   float m_dist = 1.; //min distance\n\n    //double loop\n    for (int y = -1; y <= 1; y++){\n        for (int x = -1; x <= 1; x++){\n            //neighbor grid\n            vec2 neighbor = vec2(float(x), float(y));\n            //random position from current and neighbor place in grid\n            vec2 point = random2(vUvI + neighbor);\n            //animate points\n            point = 0.5 + 0.5 * sin(u_time + TWO_PI * point);\n            //vector b/n pixel and point\n            vec2 diff = neighbor + point - vUvF;\n            //distance to the point\n            float dist = length(diff);\n            //closer distance\n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    color += m_dist;\n    //center cell\n    color += 1. - step(0.02, m_dist);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.25);\n    vUv = vUv * 2. - 1.;\n\n    vec3 color = vec3(0.);\n    //cellular noise loops\n   //scale\n   vUv *= 3.;\n\n   //tile the space\n   vec2 vUvI = floor(vUv);\n   vec2 vUvF = fract(vUv);\n   float m_dist = 1.; //min distance\n   vec2 m_point;//min position\n    //double loop\n    for (int y = -1; y <= 1; y++){\n        for (int x = -1; x <= 1; x++){\n            //neighbor grid\n            vec2 neighbor = vec2(float(x), float(y));\n            //random position from current and neighbor place in grid\n            vec2 point = random2(vUvI + neighbor);\n            //animate points\n            point = 0.25 + 0.35 * sin(u_time * TWO_PI * point);\n            //vector b/n pixel and point\n            vec2 diff = neighbor + (point * sin(u_time - 20.)) - vUvF;\n            //distance to the point\n            float dist = length(diff);\n            //closer distance\n            m_dist = min(m_dist, dist);\n            m_point = point;\n        }\n    }\n\n    color = vec3(m_dist);\n    //color = vec3(abs(cos(100. * m_dist))*0.07);\n    color *= m_dist * 1.025 + abs(sin(u_time * 0.5));\n    //color += vec3(1.)  * (1. - max(0.0, dot(m_dist - cos(u_time), m_dist + sin(u_time))));\n    //center cell\n    //color += 1. - step(0.02, m_dist);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+1.15,p,vUv.y)-\n    smoothstep(p,p-(1.151),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv=Rot(vUv,u_time*.25);\n    vUv=vUv*2.-1.;\n    \n    vec3 color=vec3(0.);\n    //cellular noise loops\n    //scale\n    vUv*=3.;\n    \n    //tile the space\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=1.;//min distance\n    vec2 m_point;//min position\n    //double loop\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            //neighbor grid\n            vec2 neighbor=vec2(float(x),float(y));\n            //random position from current and neighbor place in grid\n            vec2 point=random2(vUvI+neighbor);\n            //animate points\n            // point.x=.15+.15*sin(u_time*TWO_PI*point.x);\n            // point.y=.25+.35*cos(u_time*TWO_PI*point.y);\n            point = 0.5 + 0.5 * sin(u_time + TWO_PI * point);\n            //vector b/n pixel and point\n            vec2 diff=neighbor+point-vUvF;\n            //distance to the point\n            float dist=length(diff);\n            //closer distance\n            m_dist=min(m_dist,m_dist * dist);\n            m_point=point;\n        }\n    }\n    \n    color=1. - vec3(m_dist) - .9;\n    color += smoothstep(0.04, 0.41, m_dist);\n    // //color = vec3(abs(cos(100. * m_dist))*0.07);\n    // //color*=m_dist*1.025+abs(sin(u_time*.5));\n    //color += vec3(1.)  * (1. - max(0.0, dot(m_dist - cos(u_time), m_dist + sin(u_time))));\n    // //center cell\n    //color += 1. - step(.2, m_dist);\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _k=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+1.15,p,vUv.y)-\n    smoothstep(p,p-(1.151),vUv.y);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv=Rot(vUv,u_time*.25);\n    vUv=vUv*2.-1.;\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //cellular noise loops\n    //scale\n    vUv*=3.;\n    \n    //tile the space\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=1.;//min distance\n    vec2 m_point;//min position\n    //double loop\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            //neighbor grid\n            vec2 neighbor=vec2(float(x),float(y));\n            //random position from current and neighbor place in grid\n            vec2 point=random2(vUvI+neighbor);\n            //animate points\n            // point.x=.15+.15*sin(u_time*TWO_PI*point.x);\n            // point.y=.25+.35*cos(u_time*TWO_PI*point.y);\n            point = 0.5 + 0.5 * sin(u_time + TWO_PI * point);\n            //vector b/n pixel and point\n            vec2 diff=neighbor+point-vUvF;\n            //distance to the point\n            float dist=length(diff);\n            //closer distance\n            m_dist=min(m_dist,m_dist * dist);\n            m_point=point;\n        }\n    }\n    color = vec3(m_dist);\n    //color += smoothstep(0.04, 0.41, m_dist);\n    // //color = vec3(abs(cos(100. * m_dist))*0.07);\n    // //color*=m_dist*1.025+abs(sin(u_time*.5));\n    //color += vec3(1.)  * (1. - max(0.0, dot(m_dist - cos(u_time), m_dist + sin(u_time))));\n    // //center cell\n    //color += 1. - step(.2, m_dist);\n    color -= smoothstep(.017, .171, abs(sin(12.0*m_dist))) * 0.25;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Uk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_k,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453) + (u_time * 0.25);\n}\n\n//return min distance\n// float cellular(vec2 vUv, float scale, vec2 vUvI, vec2 vUvF, float minDist){\n//     vUv *= scale;\n//     for(int y=-1; y<=1; y++){\n//         for(int x=-1; x<=1; x++){\n//             vec2 neighbor = vec2(float(x), float(y));\n//             vec2 point = random2(vUvI + neighbor);\n//             point = 0.5 + 0.5 * sin(u_time + TWO_PI * point);\n//             vec2 diff = neighbor + point - vUvF;\n//             float dist = length(diff);\n//             minDist = min(minDist,dist);\n//             //return minDist;\n//         }\n//     }\n    \n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color=vec3(0.);\n    vUv *= 8.;\n    vUv.x +=  u_time;\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    //vUv*=scale;\n    float minDist = 1.;\n    for(int y=-2;y<=2;y++){\n        for(int x=-2;x<=2;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor );\n            point=.5+.5*sin(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF;\n            float dist=length(diff);\n            minDist=min(minDist,dist + u_mouse.x + u_mouse.y);\n        }\n    }\n    color += minDist;\n    //float c1 = cellular(vUv, 4.0, vUvI, vUvF, 12.0);\n    //color += c1;\n    //color.r += step(.98, f_st.x) + step(.98, f_st.y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Sk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453) + (u_time * 0.25);\n}\n\n//simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color=vec3(0.);\n    vUv *= 5.;\n    vUv.x +=  u_time;\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float n = snoise(vUv + u_time) * 0.1;\n    //vUv*=scale;\n    float minDist = 1.;\n    for(int y=-2;y<=2;y++){\n        for(int x=-2;x<=2;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor ) + n;\n            point=.5+.5*sin(u_time+TWO_PI*point);\n            // point.x = point.x + n;\n            // point.y = point.y + n;\n            vec2 diff=neighbor+point-vUvF;\n            float dist=length(diff + n);\n            minDist=min(minDist,dist);\n        }\n    }\n    color += minDist;\n    //color += 1. - step(0.1, minDist);\n    //color.r += step(.98, vUvF.x) + step(.98, vUvF.y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Mk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+1.15,p,vUv.y)-\n    smoothstep(p,p-(1.151),vUv.y);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv=Rot(vUv,u_time*.25);\n    vUv=vUv*2.-1.;\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //cellular noise loops\n    //scale\n    vUv*=3.;\n    \n    //tile the space\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=10.;//min distance\n    vec2 m_point;//min position\n    //double loop\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            //neighbor grid\n            vec2 neighbor=vec2(float(x),float(y));\n            //random position from current and neighbor place in grid\n            vec2 point=random2(vUvI+neighbor);\n            //animate points\n            // point.x=.15+.15*sin(u_time*TWO_PI*point.x);\n            // point.y=.25+.35*cos(u_time*TWO_PI*point.y);\n            point = 0.5 + 0.5 * sin(u_time + TWO_PI * point);\n            //vector b/n pixel and point\n            vec2 diff=neighbor+point-vUvF;\n            //distance to the point\n            float dist=length(diff);\n            //closer distance\n            m_dist=min(m_dist,m_dist * dist);\n            m_point=point;\n        }\n    }\n    color = 1. - vec3(m_dist);\n    //color += smoothstep(0.04, 0.41, m_dist);\n    // //color = vec3(abs(cos(100. * m_dist))*0.07);\n    // //color*=m_dist*1.025+abs(sin(u_time*.5));\n    //color += vec3(1.)  * (1. - max(0.0, dot(m_dist - cos(u_time), m_dist + sin(u_time))));\n    // //center cell\n    //color += 1. - step(.2, m_dist);\n    color -= smoothstep(.017, .171, abs(sin(12.0*m_dist))) * 0.25;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Ck(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Tk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 2.;\n    vec2 vUvI = floor(vUv);\n    vec2 vUvF = fract(vUv);\n    float m_dist = 0.5 * sin(u_time) + 2.0;\n    for(int y = -1; y <= 1; y++){\n        for (int x = -1; x <= 1; x ++){\n            vec2 neighbor = vec2(float(x), float(y));\n            vec2 point = random2(vUvI + neighbor);\n            point = 0.5 + 0.5 * cos(u_time + TWO_PI * point);\n            vec2 diff = neighbor + point - vUvF;\n            float dist = length(diff) ;\n            m_dist = min(m_dist, dist);\n            \n        }\n    }\n    color.rg += m_dist;\n    color.rg += 1.- smoothstep(0.01, 0.011, m_dist);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Rk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Tk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Dk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    vUv.x+=u_time*.025;\n    vUv*=5.;\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=.05+.2*cos(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF;\n            float dist=length(diff);\n            m_dist=min(m_dist,dist);\n            \n        }\n    }\n    color +=m_dist;\n    color +=1.-smoothstep(.01,.011,m_dist);\n    color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Pk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Dk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.025,p,vUv.y)-\n    smoothstep(p,p-(0.025),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.025;\n    vUv*=5.;\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 0.25;\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=.5+.5*cos(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF;\n            float dist=length(diff);\n            m_dist=min(m_dist,dist);\n            float y =dist-m_dist;\n            float pct = plot(point, y);\n            color = vec3(pct);\n        }\n    }\n    \n    //color +=m_dist;\n    color +=1.-smoothstep(.01,.011,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Fk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ek=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.025,p,vUv.y)-\n    smoothstep(p,p-(0.25),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.025;\n    vUv*=5.;\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 0.25;\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=.5+.25*cos(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF;\n            float dist=length(diff);\n            m_dist=min(m_dist,dist);\n            float y =m_dist;\n            float pct = plot(vUvF, y);\n            color = vec3(pct);\n            \n            \n        }\n    }\n    \n    //color +=m_dist;\n    color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Ik(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ek,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ok=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.025,p,vUv.y)-\n    smoothstep(p,p-(0.025),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=8.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 4.;\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=.5+.5*cos(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist = dot(diff, diff);\n            dist -= 0.65;\n            m_dist=min(m_dist,dist);\n\n        }\n    }\n    \n    color +=m_dist * 3.;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Lk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ok,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ak=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.5,p,vUv.y)-\n    smoothstep(p,p-(0.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=3.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    for(int y=-5;y<=5;y++){\n        for(int x=-5; x<=5;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=.75+.75*sin(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.75));\n            dist1=plot(diff, vUvF.y);\n            float dist = dot(diff / dist1, diff/ dist1);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n\n        }\n    }\n    \n    color +=m_dist * 3.;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Nk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ak,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Gk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.5,p,vUv.y)-\n    smoothstep(p,p-(0.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-5;y<=5;y++){\n        for(int x=-5; x<=5;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=2.35+1.25*sin(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.5));\n            dist1=plot(diff, vUv.y - 2.5);\n            float dist = dot(diff / dist1 / 15., diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n\n        }\n    }\n    \n    color +=m_dist * 3.;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Bk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Gk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.5,p,vUv.y)-\n    smoothstep(p,p-(0.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=10.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-5;y<=5;y++){\n        for(int x=-5; x<=5;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=2.35+0.95*abs(sin(u_time+TWO_PI*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.5));\n            dist1=plot(diff, vUv.y - 2.5);\n            float dist = dot(diff / dist1 / 15., diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n\n        }\n    }\n    \n    color +=m_dist;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Vk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Wk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.5,p,vUv.y)-\n    smoothstep(p,p-(0.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=12.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) * 0.5;\n            point= .8*abs(sin(u_time+TWO_PI+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.15));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff / dist1 / 25., diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n\n        }\n    }\n    \n    \n    color = vec3(0., 0.25, 0.5);\n    color *= vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Hk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Wk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Xk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+.5,p,vUv.y)-\n    smoothstep(p,p-(.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv,vec2 size){\n    vec2 b=smoothstep(size,size+vec2(.01),vUv);\n    b*=smoothstep(size,size+vec2(.01),1.-vUv);\n    float b1=b.x*b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=12.;\n    vec3 m=vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8;x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor)*.5;\n            point=4.-abs(sin(u_time+TWO_PI+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF;\n            //float dist=length(diff);\n            float dist1=Box(diff,vec2(.15));\n            dist1=plot(diff,vUv.y-2.75);\n            float dist=dot(diff/m_dist,diff/m_dist);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            \n        }\n    }\n    \n    color=vec3(0.,.25,.5);\n    color=vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Yk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Xk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $k=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+.5,p,vUv.y)-\n    smoothstep(p,p-(.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv,vec2 size){\n    vec2 b=smoothstep(size,size+vec2(.01),vUv);\n    b*=smoothstep(size,size+vec2(.01),1.-vUv);\n    float b1=b.x*b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=3.;\n    vec3 m=vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8;x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor)*.5;\n            point=(sin(u_time+TWO_PI*2.*point));\n            vec2 diff=neighbor+point-vUvF;\n            //float dist=length(diff);\n            float dist1=Box(diff,vec2(.005));\n            dist1=plot(diff,vUv.y-2.75);\n            float dist=dot(diff/m_dist/m_dist,diff/m_dist/m_dist);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            \n        }\n    }\n    \n    color=vec3(0.,.25,.5);\n    color+=vec3(m_dist) * 0.9;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Zk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$k,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Kk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+.5,p,vUv.y)-\n    smoothstep(p,p-(.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv,vec2 size){\n    vec2 b=smoothstep(size,size+vec2(.01),vUv);\n    b*=smoothstep(size,size+vec2(.01),1.-vUv);\n    float b1=b.x*b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=3.;\n    vec3 m=vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=5.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8;x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor)*.25;\n            point=0.5 + 1.5 * (sin(u_time+TWO_PI + TWO_PI* 2.75*point));\n            vec2 diff=neighbor+point-vUvF;\n            //float dist=length(diff);\n            float dist1=Box(diff,vec2(.05));\n            dist1=plot(diff,vUv.y-2.75);\n            float dist=dot(diff/m_dist,diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            \n        }\n    }\n    \n    //color=vec3(0.,.25,.5);\n    color+=vec3(m_dist) * 2.0;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Jk(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Kk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qk=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.05,p,vUv.y)-\n    smoothstep(p,p-(0.05),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=12.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) * 0.5;\n            point= .8*abs(sin(u_time+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.15 * sin(u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff, diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            float y = plot(point, m_dist);\n            color = vec3(y);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color = vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Qk,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.05,p,vUv.y)-\n    smoothstep(p,p-(0.05),vUv.y);\n}\n\nfloat plot2(vec2 vUv,float p, float m){\n    return smoothstep(p + 0.05,p,vUv.y * m)-\n    smoothstep(p,p-(0.05),vUv.y * m);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) ;\n            point= 0.5 + .8*abs(sin(u_time+TWO_PI*2.75*point) + 12.0);\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.15 * (u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff, diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            float y = plot2(vUv, m_dist, m_dist);\n            color = vec3(y);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color = vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:eM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.05,p,vUv.y)-\n    smoothstep(p,p-(0.05),vUv.y);\n}\n\nfloat plot2(vec2 vUv,float p, float m){\n    return smoothstep(p + 0.05,p,vUv.y * m)-\n    smoothstep(p,p-(0.05),vUv.y * m);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b) {\n    float thickness = 1.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa - ba*h);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) ;\n            point= .8*abs(sin(u_time+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.15 * (u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff, diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            // float y = plot2(vUv, m_dist, m_dist);\n            // color = vec3(y);\n            float line = lineSegment(vUvF + m_dist, point, neighbor);\n            color = vec3(line);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color = vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function oM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.05,p,vUv.y)-\n    smoothstep(p,p-(0.05),vUv.y);\n}\n\nfloat plot2(vec2 vUv,float p, float m){\n    return smoothstep(p + 0.05,p,vUv.y * m)-\n    smoothstep(p,p-(0.05),vUv.y * m);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b, float m) {\n    float thickness = 2.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b * m);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 3.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) ;\n            point= .9*abs(sin(u_time+TWO_PI*1.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.25 * (u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff, diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            // float y = plot2(vUv, m_dist, m_dist);\n            // color = vec3(y);\n            float line = lineSegment(vUvF, point, neighbor, m_dist);\n            color = vec3(line);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color *= vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function iM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:aM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+.5,p,vUv.y)-\n    smoothstep(p,p-(.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv,vec2 size){\n    vec2 b=smoothstep(size,size+vec2(.01),vUv);\n    b*=smoothstep(size,size+vec2(.01),1.-vUv);\n    float b1=b.x*b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m=vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8;x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor)*.5;\n            point=1. + 1.8*abs(sin(u_time+TWO_PI+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF;\n            //float dist=length(diff);\n            float dist1=Box(diff,vec2(.15));\n            dist1=plot(diff,vUv.y-2.75);\n            float dist=dot(diff,diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            \n        }\n    }\n    \n    color=vec3(1.,.25,.5);\n    color*=1. - vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.05,p,vUv.y)-\n    smoothstep(p,p-(0.05),vUv.y);\n}\n\nfloat plot2(vec2 vUv,float p, float m){\n    return smoothstep(p + 0.05,p,vUv.y * m)-\n    smoothstep(p,p-(0.05),vUv.y * m);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b, float m) {\n    float thickness = 2.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b * m);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 8.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) ;\n            point= .7*abs(sin(u_time+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.25 * (u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff, diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            // float y = plot2(vUv, m_dist, m_dist);\n            // color = vec3(y);\n            float line = lineSegment(neighbor, point/m_dist, point * m_dist, 0.15);\n            color = 1. - vec3(line);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color *= vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.5,p,vUv.y)-\n    smoothstep(p,p-(0.5),vUv.y);\n}\n\nfloat plot2(vec2 vUv,float p, float m){\n    return smoothstep(p + 0.5,p,vUv.y * m)-\n    smoothstep(p,p-(0.5),vUv.y * m);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b, float m) {\n    float thickness = 5.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b * m);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv -= 0.25;\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=3.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) ;\n            point= 0.5 + .35*abs(cos(u_time+PI*20.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.25 * (u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff/m_dist, diff/m_dist);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            // float y = plot2(vUv, m_dist, m_dist);\n            // color = vec3(y);\n            float line = lineSegment(vUvF, point, neighbor, m_dist);\n            color = vec3(line);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color *= vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b) {\n    float thickness = 1.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec2 mg, mr;\n    float md = 8.0;\n\n    for (int i = -1; i <=1; i++){\n        for(int j = -1; j<= 1; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md){\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n    md = 8.0;\n    for (int i = -3; i <=3; i++){\n        for(int j = -3; j<= 3; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            if (dot(mr -r, mr -r) > 0.00001){\n                md = min(md, dot(0.5 * (mr + r), normalize(r -mr)));\n\n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = Rot(vUv, u_time * 0.25);\n    vUv *= 3.;\n    vec3 c = voronoi(vUv);\n    float dd = length( c.yz );\n    color = mix( vec3(1.0), color, smoothstep( 0.01, 0.02, c.x * c ) );\n    //color += vec3(1.) * (1. - smoothstep(0.0, 0.04, dd));\n    //color = c;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b) {\n    float thickness = 1.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec2 mg, mr;\n    float md = 8.0;\n\n    for (int i = -1; i <=1; i++){\n        for(int j = -1; j<= 1; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md){\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n    md = 8.0;\n    for (int i = -2; i <=2; i++){\n        for(int j = -2; j<= 2; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            if (dot(mr -r, mr -r) > 0.00001){\n                md = min(md, dot(0.5 * (mr + r), normalize(r -mr)));\n\n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv = vUv * 2. - 1.;\n    vUv *= 2.5 + sin(u_time * 0.5);\n    vec3 c = voronoi(vUv);\n    float dd = length( c.yz );\n    color = mix( vec3(1.0), color, smoothstep( 0.01, 0.04, c.x) );\n    //color += vec3(1.) * (1. - smoothstep(0.0, 0.04, dd));\n    color *= c * 20.;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b) {\n    float thickness = 1.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\n//simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvec3 voronoi(vec2 x){\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec2 mg, mr;\n    float md = 8.0;\n\n    for (int i = -1; i <=1; i++){\n        for(int j = -1; j<= 1; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md){\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n    md = 8.0;\n    for (int i = -2; i <=2; i++){\n        for(int j = -2; j<= 2; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            if (dot(mr -r, mr -r) > 0.00001){\n                md = min(md, dot(0.5 * (mr + r), normalize(r -mr)));\n\n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    float n = snoise(vUv + (u_time * 0.25)) * 0.4;\n    vUv = vUv * 2. - 1.;\n    vUv *= 2.5 + sin(u_time * 0.5);\n    vec3 c = voronoi(vUv + u_time);\n    float dd = length( c.yz );\n    color = mix( vec3(1.0), color, smoothstep( 0.01, 0.011, c.x * c.y * c.z) );\n    //color += vec3(1.) * (1. - smoothstep(0.0, 0.04, dd));\n    //color *= c * 20.;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=0.1;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-2;i<=2;i++){\n        for(int j=-2;j<=2;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.25;\n    vec3 c=voronoi(vUv);\n    float dd=length(c.yz);\n    color=1. - mix(vec3(1.),color,smoothstep(.01,.04,c.x));\n    color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _M=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n//book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=.1;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=.1;\n    for(int i=-2;i<=2;i++){\n        for(int j=-2;j<=2;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md,mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x+=u_time*.15;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    float n = snoise(vUv + u_time) * 0.05;\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x+=u_time*.25;\n    vec3 c=voronoi(vUv);\n    vec3 c2=voronoi(vec2(vUv.x+n+0.25,vUv.y+n+0.25));\n    vec3 c3=voronoi(vec2(vUv.x-n-0.25,vUv.y-n-0.25));\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.01,.04,c.x));\n    color+=mix(vec3(1.),color,smoothstep(.01,.04,c2.x));\n    color+=mix(vec3(1.),color,smoothstep(.01,.04,c3.x));\n    //color-=vec3(1.)*(1.-smoothstep(.1,.11,dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function UM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_M,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=3.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-2;i<=2;i++){\n        for(int j=-2;j<=2;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.25;\n    vec3 c=voronoi(vUv);\n    float dd=length(c.yz);\n    color=1. - mix(vec3(1.),color,smoothstep(.01,.04,c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function SM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=3.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-2;i<=2;i++){\n        for(int j=-2;j<=2;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=3.5;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi(vUv);\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.01 + c.x,.08,c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function MM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=3.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-2;i<=2;i++){\n        for(int j=-2;j<=2;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=3.5;\n    vUv.x += u_time * 0.125;\n    vec3 c1=voronoi(vec2(vUv.x, vUv.y + sin(u_time)));\n    vec3 c2=voronoi(vec2(vUv.x, vUv.y + 0.25 + sin(u_time)));\n    vec3 c3=voronoi(vec2(vUv.x, vUv.y - 0.25 + sin(u_time)));\n    float dd=length(c1.yz);\n    color=mix(vec3(1.),color,smoothstep(.05,.051,c1.x));\n    color=mix(vec3(1.),color,smoothstep(.045,.0451,c2.x));\n    color=mix(vec3(1.),color,smoothstep(.035,.0351,c3.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function CM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi((vUv));\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.2,.21,dd + c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function RM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:TM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi((vUv));\n    float dd=length(c.yz)/2.;\n    color=1. - mix(vec3(1.),color,smoothstep(.2,.21,dd + c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function PM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:DM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi((vUv));\n    // float c1 = cir(vec2 vUv, vec2(0.5), 0.25);\n    float dd=length(c.yz);\n    color=1. - mix(vec3(1.),color,smoothstep(.05,.1,c.x));\n    color /= vec3(1.) * (1. - smoothstep(0.01, 0.91, dd ));\n    color*=c.z * c.y / c.x * 50.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function FM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    float x = smoothstep(size + 0.05, size + 0.06, distance(vUv, pos));\n    float y = smoothstep(size, size + 0.01, distance(vUv, pos));\n    return x * y;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vec2 newUv = vUv;\n    //vUv.x += u_time * 0.25;\n    \n    float c1 = cir(newUv, vec2(0.5), 0.45);\n    vec3 color=vec3(0.);\n    color = vec3(c1); \n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5 * sin(u_time * 0.5) + 5.0;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi((vUv));\n    \n    float dd=length(c.yz);\n    \n    color=1. - mix(vec3(1.),color,smoothstep(.05,.04,c.x));\n    //color /= vec3(1.) * (1. - smoothstep(0.01, 0.91, dd ));\n    color*=c.x * 50.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function IM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:EM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.125;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi((vUv));\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.5,.51,dd + c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    color+=c.x*50.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function LM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:OM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.125;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*4.-2.;\n    vUv*=1.;\n    vUv.x += u_time * 0.25;\n    vec3 c=voronoi((vUv));\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.45,.751,dd + c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    color/=c.x * 70.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function NM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:AM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.025*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, vec2(mr.x, mr.y/md/(200.0 - sin(u_time))));\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.125;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*4.-2.;\n    vUv*=2.;\n    vUv.x += u_time * 0.25;\n    vec3 c=voronoi((vUv));\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.45,.751,dd + c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    color/=c.x;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function BM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:GM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    float plot(vec2 vUv,float p){\n        return smoothstep(p + 0.09,p,vUv.y)-\n        smoothstep(p,p-(0.02),vUv.y);\n    }\n    \n    float fbm(vec2 vUv, int octaves){\n        //inital values\n        float value = 0.0;\n        float amplitude = 0.5 ;\n        float frequency = 0. ;\n        //loop of octaves\n        for (int i = 0; i < octaves; i++){\n            //vUv += 2.;\n            value += amplitude * (noise(vUv + u_time));\n            //vUv = vUv * 2. - 1.;\n            vUv *= 2.;\n            // vUv.x += u_time * 0.5;\n            amplitude *= 0.5 ;\n        }\n        return value; \n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = fbm(vUv, 6);\n        // float pct = plot(vec2(vUv), y);\n        // color = vec3(pct);\n        color += y;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function VM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 2.0;\n    float gain = 0.5;\n    float offset = 0.9;\n\n    float sum = 0.0;\n    float freq = 1.0, amp = 0.5;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        float n = ridge(snoise(p*freq + (u_time * 0.25)), offset);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    color += y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function HM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:WM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = 0.6;\n    vec2 shift = vec2(100.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv);\n        vUv = rot * vUv * 2.0 + shift + (u_time * 0.05);\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 1.5;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv + 0.2 * u_time);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + r);\n\n    color = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.066667,0.666667,0.498039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.,0.5,0.164706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,.2));\n\n    float x = f * f * f + 0.6 * f * f + 0.5 * f;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function YM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:XM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $M=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .9;\n    vec2 shift = vec2(1000.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv);\n        vUv = rot * vUv * 2.0 + shift + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 1.5;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv + 0.2 * u_time);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.066667,0.666667,0.498039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.,0.5,0.164706),\n    //             clamp(length(q),0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.666667,1.,1),\n    //             clamp(length(r.x),0.0,.2));\n\n    float x = f;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ZM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$M,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .45;\n    vec2 shift = vec2(1.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv);\n        vUv = rot * vUv * 2.0 + shift + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 4.;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.,.8,0.94706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.166667,.1,0.2),\n                clamp(length(r.x),0.0,.2));\n\n    float x = f;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function JM(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:KM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QM=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = .0;\n    float a = .55;\n    vec2 shift = vec2(1.5);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv);\n        vUv = rot * vUv * 2.0 + shift + (u_time * 0.25);\n        a *= 1.05 * noise(vUv);\n    }\n    return v;\n}\n\n//  \n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.01);\n    vUv *= 2.;\n    vUv.x += u_time * 0.24;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.3, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(9.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.401961,0.619608,0.666667),\n                vec3(0.466667,0.666667,0.098039),\n                clamp((f),0.4,1.0));\n\n    color = mix(color,\n                vec3(0.15,.78,0.94706),\n                clamp(length(q),.2,1.0));\n\n    color = mix(color,\n                vec3(0.66667,.1,0.2),\n                clamp(length(r.x),0.0,.2));\n\n    float x = 1. - f;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:QM,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ez=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .1 ;\n    float gain = 0.5 ;\n    float offset = 1. + snoise(p + (u_time * 0.25));\n\n    float sum = 0.0 ;\n    float freq = 1.0; \n    float amp = 0.5 ;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 5.;\n        float n = ridge(snoise(p*freq + (u_time * 0.25)), offset);\n        sum += n*amp;\n        sum += n*amp*prev ;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    color += y;\n    color -= mix(vec3(0.401961,0.619608,0.666667),\n                vec3(0.466667,0.666667,0.098039),\n                clamp((y),0.4,1.0));\n    color -= mix(color,\n                vec3(0.66667,.1,0.2),\n                clamp(length(y),0.0,.2));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ez,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .1 ;\n    float gain = 0.5 ;\n    float offset = 1. + snoise(p + (u_time * 0.25));\n\n    float sum = 0.0 ;\n    float freq = 1.0; \n    float amp = 0.5 ;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 5.;\n        float n = ridge(snoise(p*freq + (u_time * 0.25)), offset);\n        sum += n*amp;\n        sum += n*amp*prev ;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv + snoise(vUv + (u_time * 0.1)));\n    color += y;\n    color -= mix(vec3(0.401961,0.619608,0.666667),\n                vec3(0.466667,0.666667,0.098039),\n                clamp((y),0.4,1.0));\n    color -= mix(color,\n                vec3(0.66667,.1,0.2 + sin(u_time)),\n                clamp(length(y),0.0,.2));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function oz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var az=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .1 ;\n    float gain = 1.5 ;\n    float offset = 1.25 + snoise(p + (u_time * 0.5));\n\n    float sum = 0.0 ;\n    float freq = 1.0; \n    float amp = 0.5 ;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 5.;\n        float n = 1. - ridge(snoise(p*freq + (u_time * 0.5)), offset);\n        sum += n*amp;\n        sum += 1. - n*amp*prev ;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = vUv * 5.;\n    float y = ridgedMF(vUv + snoise(vUv + (u_time * 0.1)));\n    color += y;\n    color -= mix(vec3(0.401961,0.619608,0.666667),\n                vec3(0.466667,0.666667,0.098039),\n                clamp((y),0.4,1.0));\n    color -= mix(color,\n                vec3(0.66667,.1,0.2 + sin(u_time)),\n                clamp(length(y),0.0,.2));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function iz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:az,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h ;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .1 ;\n    float gain = 1.5 ;\n    float offset = 1.1;\n\n    float sum = 0.0 ;\n    float freq = 1.0; \n    float amp = 0.5 ;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 3.;\n        float n = ridge(snoise(p*freq + (u_time * 0.25)), offset);\n        sum = n*amp;\n        sum += n*amp*prev ;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = vUv * 23.;\n    float y = ridgedMF(vUv);\n    color += y;\n    color -= mix(vec3(0.401961,0.619608,0.666667),\n                vec3(0.466667,0.666667,0.098039),\n                clamp((y),0.4,1.0));\n    color -= mix(color,\n                vec3(0.66667,.1,0.2),\n                clamp(length(y),0.0,.2));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 2.0 ;\n    float gain = 0.25 ;\n    float offset = .9;\n\n    float sum = .0;\n    float freq = 1.0; \n    float amp = 0.75;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        //p *= 3.;\n        p.x += u_time * 0.2;\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev * snoise(vUv + u_time * 0.5);  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv * 3.0);\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 2.0 ;\n    float gain = 0.25 ;\n    float offset = .9;\n\n    float sum = .0;\n    float freq = 1.0; \n    float amp = 0.75;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        //p *= 1.5;\n        p.x += u_time * 0.2;\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev - snoise(p + u_time * 0.25);  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv * 3.0);\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .45;\n    vec2 shift = vec2(1.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv);\n        vUv = rot * PI * 0.25 * vUv * 3. + shift + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 5.;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n    float f2 = fbm(vUv + fbm(vUv + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667 + sin(u_time)),\n                vec3(0.966667,0.666667,0.098039 + sin(u_time)),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.,.8,0.94706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.166667,.1,0.2),\n                clamp(length(r.x),0.0,.2));\n\n    float x = f * f2 + f + f2;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .95;\n    vec2 shift = vec2(1.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv + u_time);\n        //vUv = rot * PI * 0.25 *vUv * 3. + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 10.;\n    //vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    // q.x = fbm(vUv * vec2(8.));\n    // q.y = fbm(vUv * vec2(8.));\n\n    vec2 r = vec2(0.);\n    // r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    // r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n    float f2 = fbm(vUv + fbm(vUv + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667 + sin(u_time)),\n                vec3(0.966667,0.666667,0.098039 + sin(u_time)),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.,.8,0.94706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.166667,.1,0.2),\n                clamp(length(r.x),0.0,.2));\n\n    float x = f * f2 * f * f2;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 6\n    float fbm (in vec2 st) {\n        // Initial values\n        float value = 0.0;\n        float amplitude = .5;\n        float frequency = 0.1;\n        //\n        // Loop of octaves\n        for (int i = 0; i < OCTAVES; i++) {\n            value += amplitude * noise(st + (u_time * 0.5));\n            st *= 6.;\n            //st.x += u_time * 0.25;\n            amplitude *= .25;\n        }\n        return value;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float x = fbm(vUv * 1.0 + fbm(vUv * 3.0 + fbm(vUv * 5.0 + fbm(vUv * 7.0 + fbm(vUv * 11.0)))));\n    \n        vec2 q = vec2(0.);\n        q.x = fbm( vUv + 0.00*u_time);\n        q.y = fbm( vUv + vec2(1.0));\n    \n        vec2 r = vec2(0.);\n        r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.015*u_time );\n        r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.0126*u_time);\n        //x += x * sin(u_time * 0.15);\n        //color += x;\n        //color.x += sin(u_time * 0.05);\n        color = mix(color,\n                    vec3(0,0,0.164706),\n                    clamp(length(x),0.0,1.0));\n    \n        color = mix(color,\n                    vec3(0.966667,0,0),\n                    clamp(length(x),0.0,1.0));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f) ;\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 6\n    float fbm (in vec2 st) {\n        // Initial values\n        float value = 0.0;\n        float amplitude = .5;\n        float frequency = 0.1;\n        //\n        // Loop of octaves\n        for (int i = 0; i < OCTAVES; i++) {\n            value += amplitude * noise(st + (u_time * 0.5));\n            st *= 5.;\n            //st.x += u_time * 0.25;\n            amplitude *= .25;\n        }\n        return value;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2.75;\n        vec3 color = vec3(0.);\n        float x = fbm(vUv * 1.0 + fbm(vUv * 2.0 + fbm(vUv * 3. + fbm(vUv * 4. + fbm(vUv * 5.)))));\n        x += x - noise(vUv + u_time * 0.1);\n        vec2 q = vec2(0.);\n        q.x = fbm( vUv);\n        q.y = fbm( vUv);\n    \n        vec2 r = vec2(0.);\n        r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n        //x += x * sin(u_time * 0.15);\n        //color += x;\n        //color.x += sin(u_time * 0.05);\n        color = mix(color,\n                    vec3(0.2,0.4,0.64706),\n                    clamp(length(x),0.0,1.0));\n    \n        color = mix(color,\n                    vec3(0.166667,0.9,0.6),\n                    clamp(length(x),0.0,1.0));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _z=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.1;\n    float lacunarity = 2.0;\n    float prev = 1.0;\n    float offset = 0.9;\n    float gain = 0.5;\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        float n = ridge(snoise(st * frequency + (u_time * 0.25)), offset);\n        value += n * amplitude;\n        value += n * amplitude * prev;\n        prev = n;\n        frequency *= lacunarity;\n        //st.x += u_time * 0.25;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5.75;\n    vec3 color = vec3(0.);\n    float x = fbm(vUv * 1.0 + fbm(vUv * 5. + fbm(vUv * 10.)));\n    color += x;\n    vec2 q = vec2(0.);\n    q.x = fbm( vUv);\n    q.y = fbm( vUv);\n\n    vec2 r = vec2(0.);\n    r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n    r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n    //x += x * sin(u_time * 0.15);\n    //color += x;\n    //color.x += sin(u_time * 0.05);\n    // color = mix(color,\n    //             vec3(0.2,0.4,0.64706),\n    //             clamp(length(r),0.0,0.5));\n\n    // color = mix(color,\n    //             vec3(0.166667,0.5,0.7),\n    //             clamp(length(q),0.0,1.0));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Uz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_z,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.1;\n    float lacunarity = 2.0;\n    float prev = 1.0;\n    float offset = 0.9;\n    float gain = 0.5;\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        float n = ridge(snoise(st * frequency + (u_time * 0.25)), offset);\n        value += n * amplitude;\n        value += n * amplitude * prev;\n        prev = n;\n        frequency *= lacunarity;\n        //st.x += u_time * 0.25;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    // vUv = vUv * 1.75;\n    //vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n    float x = fbm(vUv * 1.0 + snoise(vUv + u_time * 0.01) - fbm(vUv * 5. - fbm(vUv * 10. + fbm(vUv ))));\n    color += 1. - x;\n    vec2 q = vec2(0.);\n    q.x = fbm( vUv);\n    q.y = fbm( vUv);\n\n    vec2 r = vec2(0.);\n    r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.0125*u_time );\n    r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.0126*u_time);\n    //x += x * sin(u_time * 0.15);\n    //color += x;\n    //color.x += sin(u_time * 0.05);\n    // color = mix(color,\n    //             vec3(0.2,0.4,0.64706),\n    //             clamp(length(r),0.0,0.5));\n\n    color = mix(color,\n                vec3(0.966667,0.,0.),\n                clamp(length(x),0.0,1.0));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Sz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.125;\n    float lacunarity = 2.;\n    float prev = 0.25;\n    float offset = 1.;\n    float gain = 0.5;\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        float n = ridge(snoise(st * frequency + (u_time * 0.125)), offset);\n        value += n * amplitude;\n        value += n * amplitude * prev;\n        prev = n;\n        frequency *= lacunarity;\n        //st.x += u_time * 0.25;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5.;\n    //vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n    float x = fbm(vUv * 1.0 + fbm(vUv * 1.1 + fbm(vUv * 1.2 + fbm(vUv * 1.3 ))));\n    color += x;\n    vec2 q = vec2(0.);\n    q.x = fbm( vUv);\n    q.y = fbm( vUv);\n\n    vec2 r = vec2(0.);\n    r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.125*u_time );\n    r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.0126*u_time);\n    //x += x * sin(u_time * 0.15);\n    //color += x;\n    //color.x += sin(u_time * 0.05);\n    // color = mix(color,\n    //             vec3(0.2,0.4,0.64706),\n    //             clamp(length(r),0.0,0.5));\n\n    color = mix(color,\n                vec3(0.066667,0.9,0.),\n                clamp(length(x),0.0,1.0));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Mz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f) ;\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 6\n    float fbm (in vec2 st) {\n        // Initial values\n        float value = 0.0;\n        float amplitude = .5;\n        float frequency = 0.1;\n        //\n        // Loop of octaves\n        for (int i = 0; i < OCTAVES; i++) {\n            value += amplitude * noise(st + (u_time * 0.5));\n            st *= 5.;\n            //st.x += u_time * 0.25;\n            amplitude *= .125;\n        }\n        return value;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2.75;\n        vUv.x += u_time * 0.25;\n        vec3 color = vec3(0.);\n        float x = fbm(vUv * 1.0 + fbm(vUv * 2.0 + fbm(vUv * 3. + fbm(vUv * 4. + fbm(vUv * 5.)))));\n        x += x - noise(vUv + u_time * 0.1);\n        vec2 q = vec2(0.);\n        q.x = fbm( vUv);\n        q.y = fbm( vUv);\n    \n        vec2 r = vec2(0.);\n        r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n        //x += x * sin(u_time * 0.15);\n        //color += x;\n        //color.x += sin(u_time * 0.05);\n        color = mix(color,\n                    vec3(0.0,0.,0.54706),\n                    clamp(length(x - r),0.0,1.0));\n    \n        color = mix(color,\n                    vec3(0.96667,0.2,.0),\n                    clamp(length(x - q),0.0,1.0));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Cz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Tz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .45;\n    vec2 shift = vec2(1.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a / noise(vUv - u_time * 0.2);\n        vUv = rot * PI * 0.25 * vUv * 3. + shift + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return 1. -  v / 4.;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 2.;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n    float f2 = fbm(vUv * 1.2 + fbm(vUv * 1.2 + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color *= mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f2*f2)*5.0,0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.,.8,0.94706),\n    //             clamp(length(q),0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.166667,.1,0.2),\n    //             clamp(length(r.x),0.0,.2));\n\n    float x = f + f2 + noise(vUv + u_time);\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Rz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Tz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Dz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.1;\n    float lacunarity = 2.0;\n    float prev = 1.0;\n    float offset = 0.9;\n    float gain = 0.5;\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        float n = ridge(snoise(st * frequency + (u_time * 0.25)), offset);\n        value += n * amplitude;\n        value += n * amplitude * prev;\n        prev = n;\n        frequency *= lacunarity;\n        //st.x += u_time * 0.25;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.75;\n    vec3 color = vec3(0.);\n    float x = fbm(vUv * 1.0 + fbm(vUv * 5. + fbm(vUv * 10.)));\n    color += x;\n    vec2 q = vec2(0.);\n    q.x = fbm( vUv);\n    q.y = fbm( vUv);\n\n    vec2 r = vec2(0.);\n    r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n    r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n    //x += x * sin(u_time * 0.15);\n    //color += x;\n    //color.x += sin(u_time * 0.05);\n    color = mix(color,\n                vec3(0.1,0.9,0.64706),\n                clamp(length(r- x),0.0,0.5));\n\n    color = mix(color,\n                vec3(0.166667,0.5,0.7),\n                clamp(length(q - x),0.0,1.0));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Pz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Dz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h + h ;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .01 ;\n    float gain = 0.25 ;\n    float offset = .1;\n\n    float sum = .25;\n    float freq = 4.15; \n    float amp = 3.25;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        //p *= 1.5;\n        p.x += u_time * 0.2;\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev - snoise(p + u_time * 0.15);  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain * 0.01;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv * 1.0);\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Fz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ez=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h * h * h * (abs(sin(u_time)) + 0.75);      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 112.0;\n    float gain = 0.0125;\n    float offset = 0.9;\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.5;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 2.0;\n        float n = ridge(snoise(p*freq), offset * snoise(p - u_time * 0.5));\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    color.g += y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Iz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ez,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Oz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h * h * h * (abs(sin(u_time)) + 0.75);      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .25 + snoise(p + u_time)* 0.015;\n    float gain = 1.25;\n    float offset = 0.6;\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.025;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 2.0;\n        float n = ridge(snoise(p*freq), offset * snoise(p - u_time * 0.5));\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    color.br += y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Lz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Oz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Az=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset + h; // invert so creases are at top\n    h = h * h * h * h * h * h + snoise(vUv + u_time) * 0.1;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .25 + snoise(1. - p + u_time)* 0.0115;\n    float gain = 1.25;\n    float offset = 0.96;\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.0025;\n    float prev = 12.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 2.05;\n        float n = ridge(snoise(p*freq), offset * snoise(p - u_time) * 1.25);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    //color.br += y;\n    color.b += y;\n    color.bg += y * abs(sin(u_time));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Nz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Az,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Gz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset + h; // invert so creases are at top\n    h = h * h * h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .25;\n    float gain = 1.25;\n    float offset = 0.01 + snoise(vUv + u_time * 0.25);\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.0025;\n    float prev = 12.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 4.0;\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    //vUv.x += u_time * 0.25;\n    float y = ridgedMF(vUv);\n    //color.br += y;\n    color.rb += y;\n    color.bg += y * abs(sin(u_time));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Bz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Gz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 1.25;\n    float gain = 0.5;\n    float offset = 0.9 + snoise(vUv + u_time * 0.25);\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.25;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 2.0;\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv.x += u_time * 0.05;\n    float y = ridgedMF(vUv);\n    //color.br += y;\n    color.rb += y;\n    color.bg += y * abs(sin(u_time));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Vz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Wz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 5\n    \n    float fbm(vec2 vUv){\n        float v = 0.;\n        float a = 0.65;\n        vec2 shift = vec2(100.);\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.5));\n        for (int i = 0; i < OCTAVES; ++i)\n        {\n             v += a * noise(vUv + (u_time * 0.25));\n             vUv = rot * vUv * 2.25 + shift;\n             a *= 0.5;\n        }\n        return v;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n    \n        vUv = vUv * 2.0;\n    \n        vec2 q = vec2(0.);\n        q.x = fbm( vUv + 0.05*u_time);\n        q.y = fbm( vUv + vec2(1.0));\n    \n        vec2 r = vec2(0.);\n        r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n    \n        float f = fbm(vUv + fbm(vUv + fbm(vUv + fbm(vUv + fbm(vUv + fbm(vUv))))));\n        color = vec3(f * f * f * f);\n    \n        // color = mix(vec3(0.101961,0.619608,0.666667),\n        //             vec3(0.666667,0.666667,0.498039),\n        //             clamp((f*f)*4.0,0.0,1.0));\n    \n        // color = mix(color,\n        //             vec3(0,0,0.164706),\n        //             clamp(length(q),0.0,1.0));\n    \n        // color = mix(color,\n        //             vec3(0.666667,1,1),\n        //             clamp(length(r.x),0.0,1.0));\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Hz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Wz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Xz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 5\n    \n    float fbm(vec2 vUv){\n        float v = 0.;\n        float a = 0.65;\n        vec2 shift = vec2(100.);\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.5));\n        for (int i = 0; i < OCTAVES; ++i)\n        {\n             v += a * noise(vUv + (u_time * 0.25));\n             vUv = rot * vUv * 2.25 + shift;\n             a *= 0.53;\n        }\n        return v;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n    \n        vUv = vUv * 2.0;\n    \n        float f = fbm(vUv + fbm(vUv / fbm(vUv)));\n        color = vec3(f * f * f * f);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Yz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Xz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $z=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 5\n    \n    float fbm(vec2 vUv){\n        float v = 0.;\n        float a = 0.65;\n        vec2 shift = vec2(100.);\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.5));\n        for (int i = 0; i < OCTAVES; ++i)\n        {\n             v += a * noise(vUv + (u_time * 0.25));\n             vUv = rot * vUv * 2.25 + shift;\n             a *= 0.83;\n        }\n        return v;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n    \n        vUv = vUv * 0.5;\n    \n        float f = fbm(vUv / u_time + fbm(vUv * fbm(vUv)));\n        color = 1. - vec3(f * f * f * f);\n    \n        // vec2 q = vec2(0.);\n        // q.x = fbm( vUv + 0.05*u_time);\n        // q.y = fbm( vUv + vec2(1.0));\n    \n        // vec2 r = vec2(0.);\n        // r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        // r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n    \n        // color = mix(vec3(0.101961,0.619608,0.666667),\n        //             vec3(0.666667,0.666667,0.498039),\n        //             clamp((f-f)*.0,0.,1.0));\n    \n        // color = mix(color,\n        //             vec3(0,0,0.164706),\n        //             clamp(length(q),0.0,1.0));\n    \n        // color = mix(color,\n        //             vec3(0.666667,1,1),\n        //             clamp(length(r.x),0.0,1.0));\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Zz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$z,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Kz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 5\n    \n    float fbm(vec2 vUv){\n        float v = 0.;\n        float a = 0.25;\n        vec2 shift = vec2(1.);\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.5));\n        for (int i = 0; i < OCTAVES; ++i)\n        {\n             v += a / noise(vUv + (u_time * 0.25));\n             vUv = rot * vUv * 1. + shift;\n             a *= 0.65;\n        }\n        return v;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n    \n        vUv = vUv * 5.25;\n        vUv.x += u_time * 0.25;\n        float f = fbm(vUv + u_time + fbm(vUv / fbm(vUv)));\n        color = vec3(f / f / f / f);\n    \n        // vec2 q = vec2(0.);\n        // q.x = fbm( vUv + 0.05*u_time);\n        // q.y = fbm( vUv + vec2(1.0));\n    \n        // vec2 r = vec2(0.);\n        // r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        // r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n    \n        // color = mix(vec3(0.101961,0.619608,0.666667),\n        //             vec3(0.666667,0.666667,0.498039),\n        //             clamp((f-f)*.0,0.,1.0));\n    \n        // color = mix(color,\n        //             vec3(0,0,0.164706),\n        //             clamp(length(q),0.0,1.0));\n    \n        // color = mix(color,\n        //             vec3(0.666667,1,1),\n        //             clamp(length(r.x),0.0,1.0));\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Jz(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Kz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qz=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .45;\n    vec2 shift = vec2(1.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a / noise(vUv - u_time * 0.2);\n        vUv = rot * PI * 0.25 * vUv * 3. + shift + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return 1. -  v / 4.;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 2.;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n    float f2 = fbm(vUv * 1.2 + fbm(vUv * 1.2 + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color *= mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f2*f2)*5.0,0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.,.8,0.94706),\n    //             clamp(length(q),0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.166667,.1,0.2),\n    //             clamp(length(r.x),0.0,.2));\n\n    float x = f + f2 + noise(vUv + u_time);\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Qz,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = 1.55;\n    vec2 shift = vec2(0.1);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a ;\n        vUv = rot * PI * 0.15 * vUv * 4. + (u_time * 0.25);\n        a *= .95 * noise(vUv + u_time);\n    }\n    return 1. -  v / 4.;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 2.;\n    //vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv * fbm(vUv))));\n    float f2 = fbm(vUv * 1.2 + fbm(vUv * 1.2 + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color *= mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f2*f2)*5.0,0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.,.8,0.94706),\n    //             clamp(length(q),0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.166667,.1,0.2),\n    //             clamp(length(r.x),0.0,.2));\n\n    float x = f + f2 + noise(vUv + u_time);\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:eC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h  * (abs(sin(u_time)) + 0.95);      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 152.0;\n    float gain = 0.0125;\n    float offset = 0.9;\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.5;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 2.0;\n        float n = ridge(snoise(p*freq), offset * snoise(p - u_time * 0.25));\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    color.g += y + y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function oC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 6\n    \n    float fbm(vec2 vUv){\n        float v = 0.;\n        float amp = 0.5;\n        float freq = 0.1;\n    \n        for( int i = 0; i < OCTAVES; i++){\n            v += amp * noise(vUv + u_time * 0.25);\n            vUv *= 2.;\n            amp *= .5;\n        }\n        return v;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv.x += u_time * 0.1;\n        float y = fbm(vUv * 5. * fbm(vUv * 5. * fbm(vUv * 5.)));\n        color.x = 1. - y;\n        \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function iC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:aC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.5;\n    float freq = 0.1;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.15)));\n        vUv *= 2.;\n        amp *= .5;\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 0.125;\n    vUv.x += u_time * 0.01;\n    float y = fbm(vUv * 10.) + fbm (vUv * 20.) + fbm(vUv * 10.);\n    color.b = 1. - y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.35;\n    float freq = 0.8;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        amp *= .35 + snoise(vUv + u_time * 0.1);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.;\n    vUv.x += u_time * 0.1;\n    float y = fbm(vUv + fbm(vUv));\n    color += y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.35;\n    float freq = 0.8;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        amp *= .35 + snoise(vUv + u_time * 0.1);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .5;\n    vUv.x += u_time * 0.05;\n    float y = fbm(vUv + fbm(vUv));\n    color.r += y + y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.35;\n    float freq = 0.8;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        amp *= .35 + snoise(vUv + u_time * 0.01);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .5;\n    vUv.x += u_time * 0.025;\n    float y = fbm(vUv + fbm(vUv) + snoise(vUv * (u_time * 0.015)));\n    color.br += y * y;\n    color.gr += y * y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.5;\n    float freq = 1.45;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        v *= freq;\n        amp *= .35 + snoise(vUv + u_time * 0.01);\n        \n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .5;\n    vUv.x += u_time * 0.025;\n    float y = fbm(vUv + fbm(vUv) + snoise(vUv * (u_time * 0.015)));\n    color.br += y * y;\n    color.gr += y * y * y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.5;\n    float freq = 1.45;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        v /= freq;\n        amp *= .35 + snoise(vUv + u_time * 0.01);\n        \n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.;\n    vUv.x += u_time * 0.025;\n    float y = fbm(vUv + fbm(vUv) + snoise(vUv + (u_time * 0.015)) + fbm(vUv + fbm(vUv)));\n    color.br *= y * y ;\n    color.gr *= y * y * y;\n    color += y + fbm(vUv + fbm(vUv));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.5;\n    float freq = 1.45;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        v /= freq;\n        amp *= .85 + snoise(vUv + u_time * 0.1);\n        \n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .125;\n    vUv.x += u_time * 0.00125 + 5.;\n    float y = fbm(vUv + fbm(vUv));\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += 1. - y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _C=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = .25;\n    float freq = .45;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 1.5;\n        v *= freq;\n        amp *= 1. + snoise(vUv + u_time * 0.1);\n        \n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .125;\n    vUv.x += u_time * 0.00125 + 5.;\n    float y = fbm(vUv - fbm(vUv));\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += 1. - y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function UC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_C,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 2.0;\n    float gain = 0.15;\n    float offset = 0.9;\n    float amp = 0.5;\n    float sum = 0.0;\n    float freq = 1.0; \n    float prev = 1.0;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq), offset * sin(snoise(vUv + u_time * 0.25)));\n        sum += v *amp;\n        sum += v * amp * prev;\n        prev = v;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    \n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv*3.0);\n    float x = fbm(vUv*6.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += y;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function SC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 2.0;\n    float gain = 0.25;\n    float offset = 0.9;\n    float amp = 0.5;\n    float sum = 0.0;\n    float freq = 1.0; \n    float prev = 1.0;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq + (u_time * 0.025)), offset * sin(snoise(vUv + (u_time * 0.025))));\n        sum += v *amp;\n        sum += v * amp * prev;\n        prev = v;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    \n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv*3.0 * fbm(vUv));\n    float x = fbm(vUv*6.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += y;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function MC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 2.0;\n    float gain = 0.125;\n    float offset = 0.19;\n    float amp = 0.125;\n    float sum = 0.;\n    float freq = .75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq + (u_time * 0.125)), offset);\n        sum += v *amp;\n        sum += v * amp * prev ;\n        prev = v;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    \n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv*.5);\n    float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += y / x;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function CC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 2.0;\n    float gain = 0.125;\n    float offset = 0.99;\n    float amp = 10.125;\n    float sum = 0.;\n    float freq = .75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq + (u_time * 0.125)), offset );\n        sum += v *amp;\n        sum += v * amp * prev ;\n        prev = v;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    \n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv*4.0);\n    float x = fbm(vUv*3.5);\n    //color = vec3(y);\n    color.br += y ;\n    color.gr /= x;\n    //color.gr += y * y * y;\n    //color += y / x;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function RC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:TC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 2.0;\n    float gain = 0.125;\n    float offset = 0.19;\n    float amp = 0.125;\n    float sum = 0.;\n    float freq = .75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq * (snoise(vUv + (u_time * 0.125))) ), offset);\n        sum += v *amp ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 0.75;\n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv*0.05);\n    float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color +=1. -  x / y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function PC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:DC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 1.1;\n    float gain = 0.5;\n    float offset = 1.19;\n    float amp = 0.125;\n    float sum = 0.;\n    float freq = 1.75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq ), offset * (snoise(vUv + (u_time * 0.125))) );\n        sum += v *amp ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 2.75;\n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv);\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function FC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 1.1;\n    float gain = 0.95125;\n    float offset = 1.95;\n    float amp = .50;\n    float sum = 0.;\n    float freq = 1.75; \n    float prev = .25;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq ), offset * (snoise(vUv + (u_time * 0.125))) );\n        sum += v *amp ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.75;\n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv);\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function IC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:EC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.35;\n    float freq = 0.8;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        amp *= .35 + snoise(vUv + u_time * 0.01);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.;\n    vUv.x += u_time * 0.025;\n    float y = fbm(vUv + fbm(vUv + snoise(vUv + (u_time * 0.05))) + snoise(vUv + (u_time * 0.015)));\n    color.br -= y * y * y;\n    color.gr += y * y * y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function LC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:OC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 1.9;\n    float gain = 0.5;\n    float offset = 1.19;\n    float amp = 0.125;\n    float sum = 0.;\n    float freq = 1.75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq ), offset * (snoise(vUv + (u_time * 0.125))) );\n        sum += v *amp ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.75;\n    vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv - fbm(vUv));\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color.gr += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function NC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:AC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 12.9;\n    float gain = 0.25;\n    float offset = .19;\n    float amp = .5;\n    float sum = 0.;\n    float freq = 1.75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq ), offset * (snoise(vUv + (u_time * 0.125))) );\n        sum += v *amp ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .95;\n    vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv + fbm(vUv));\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color.g += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function BC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:GC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 5.9;\n    float gain = 0.25 ;\n    float offset = .19 ;\n    float amp = .5 ;\n    float sum = 0. ;\n    float freq = 1.35 * (snoise(vUv + (u_time * 0.1))); \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq ), offset * (snoise(vUv + (u_time * 0.125))) );\n        sum += v *amp  ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.25;\n    vUv.x += 5.;\n    float y = fbm(vUv) * fbm(vUv) ;\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    color.br += y  ;\n    color.gr += y * y;\n    //color.g += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function VC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h + h * h + h ;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = .9;\n    float gain = 0.05 ;\n    float offset = .39 ;\n    float amp = .75 ;\n    float sum = 0. ;\n    float freq = 1.5 * (snoise(vUv + (u_time * 0.1))); \n    float prev = .25;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq), offset * (snoise(vUv + (u_time * 0.005))) );\n        sum += v *amp  ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 2.;\n    vUv.x += 5.;\n    float y = fbm(vUv) * fbm(vUv) + fbm(vUv) * 0.75 ;\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    color.r += y * y * y * y ;\n    color.b += y + y;\n    //color.g += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function HC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:WC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float plot(vec2 st){\n        return smoothstep(0.5, 0.0, abs(st.y - st.x));\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv*=2.;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv *= 4. - 3.;\n        vec2 vUv1 = vUv;\n        vec2 vUv2 = vUv;\n        vec2 vUv3 = vUv;\n        vUv3 = Rot(vUv, -(u_time * 4.5));\n        vUv2 = Rot(vUv, -(u_time * 3.0));\n        vUv1 = Rot(vUv, -(u_time * 2.5));\n        vec3 color = vec3(0.);\n        float y = vUv.x;\n        float x = 1. -  vUv.x;\n        float pct = plot(vUv1);\n        float pct2 = plot(vUv2);\n        float pct3 = plot(vUv3);\n        color = vec3(y * x);\n        color += vec3(pct) * vec3(1.0, .0, .0);\n        color += vec3(pct2) * vec3(.0, 1.0, .0);\n        color += vec3(pct3) * vec3(.0, .0, 1.0);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function YC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:XC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $C=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float plot(vec2 st, float pct){\n        return smoothstep(pct-0.1, pct, st.y) -\n               smoothstep(pct, pct+0.1, st.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 5. - 2.;\n        //vUv.y += 1.5;\n        \n        vec3 color = vec3(0.);\n        \n        //power function\n        //returns the value of x raised to the power of y\n        float y1 = pow(vUv.x, 5.0);\n        float pct1 = plot(vUv, y1);\n    \n        //exponentiation function\n        //returns the natural exponentiation of x\n        float y2 = exp(vUv.x);\n        float pct2 = plot(vUv, y2);\n    \n        //logarithm function\n        //returns the natural logarithm of x\n        float y3 = log(vUv.x);\n        float pct3 = plot(vUv, y3);\n    \n        //square root function\n        //returns the square root of x\n        float y4 = sqrt(vUv.x);\n        float pct4 = plot(vUv, y4);\n    \n        color += pct1*vec3(0.0,1.0,0.0);\n        color += pct2*vec3(1.0,0.0,0.0);\n        color += pct3*vec3(0.0,0.0,1.0);\n        color += pct4*vec3(1.0,1.0,.0);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ZC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$C,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    float plot(vec2 st, float pct){\n        return smoothstep(pct-0.35, pct, st.y) -\n               smoothstep(pct, pct+0.35, st.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        //rainbow\n        //red\n        float y1 = sqrt(vUv.x);\n        float pct1 = plot(vec2(vUv.x, vUv.y - 0.45 * sin(u_time)), y1);\n    \n        //orange\n        float y2 = sqrt(vUv.x);\n        float pct2 = plot(vec2(vUv.x, vUv.y - 0.30 * sin(u_time)), y2);\n    \n        //yellow\n        float y3 = sqrt(vUv.x);\n        float pct3 = plot(vec2(vUv.x, vUv.y - 0.25 * sin(u_time)), y3);\n    \n        //green\n        float y4 = sqrt(vUv.x);\n        float pct4 = plot(vec2(vUv.x, vUv.y - 0.10 * sin(u_time)), y4);\n    \n        //blue\n        float y5 = sqrt(vUv.x);\n        float pct5 = plot(vec2(vUv.x, vUv.y + 0.25 * sin(u_time)), y5);\n    \n        //indigo\n        float y6 = sqrt(vUv.x);\n        float pct6 = plot(vec2(vUv.x, vUv.y + 0.35 * sin(u_time)), y6);\n    \n        //violet\n        float y7 = sqrt(vUv.x);\n        float pct7 = plot(vec2(vUv.x, vUv.y + 0.55 * sin(u_time)), y7);\n    \n    \n        color += pct1*vec3(1.0,0.0,0.0);\n        color += pct2*vec3(1.0,0.6,0.0);\n        color += pct3*vec3(1.0,1.0,0.0);\n        color += pct4*vec3(0.0,0.5,0.0);\n        color += pct5*vec3(0.0,0.0,1.0);\n        color += pct6*vec3(0.29,0.0,0.5);\n        color += pct7*vec3(0.9,0.5,0.9);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function JC(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:KC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QC=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 4. - 2.;\n    vec3 color = vec3(0.);\n\n    float y6 = log(vUv.x - 4. + sin(u_time));\n    float pct6 = plot(vec2(vUv.x, vUv.y), y6);\n    color += pct6;\n\n    float y5 = log(vUv.x - 2. + sin(u_time));\n    float pct5 = plot(vec2(vUv.x, vUv.y), y5);\n    color += pct5;\n\n    float y1 = log(vUv.x + sin(u_time));\n    float pct1 = plot(vUv, y1);\n    color += pct1;\n\n    float y2 = log(vUv.x + 2. + sin(u_time));\n    float pct2 = plot(vec2(vUv.x, vUv.y), y2);\n    color += pct2;\n\n    float y3 = log(vUv.x + 4. + sin(u_time));\n    float pct3 = plot(vec2(vUv.x, vUv.y), y3);\n    color += pct3;\n\n    float y4 = log(vUv.x + 6. + sin(u_time));\n    float pct4 = plot(vec2(vUv.x, vUv.y), y4);\n    color += pct4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:QC,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    //step function\n    float y1 = 1. - step(0.142 * 1., vUv.x);\n    float y2 = 1. - step(0.142 * 2., vUv.x);\n    //float y2 = step(0.142 * 5.,1. - vUv.x);\n    float y3 = 1. - step(0.142 * 3., vUv.x);\n    float y4 = 1. - step(0.142 * 4., vUv.x);\n    float y5 = 1. - step(0.142 * 5., vUv.x);\n    float y6 = 1. - step(0.142 * 6., vUv.x);\n    float y7 = 1. - step(0.144 * 7., vUv.x);\n    \n    color.r += y1 + sin(u_time - 0.5);\n    color.g += y2 - sin(u_time + 1.0);\n    color.b += y3 + sin(u_time - 1.5);\n    color.r += y4 - sin(u_time + 2.0);\n    color.g += y5 + sin(u_time - 2.5);\n    color.b += y6 - sin(u_time + 3.0);\n    color.r += y7 + sin(u_time - 3.5);\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:eT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 6. - 3.;\n    vec3 color = vec3(0.);\n    //smoothstep line\n    float y1 = (sin(vUv.x + u_time * PI) + 2.0) * sin(u_time * 1.2);\n    float y2 = (sin(vUv.x + u_time * PI) + 1.0) * sin(u_time * 0.9);\n    float y3 = (sin(vUv.x + u_time * PI) - 1.0) * sin(u_time * 0.5);\n    float y4 = (sin(vUv.x + u_time * PI) - 2.0) * sin(u_time * 1.5);\n    float y5 = (sin(vUv.x + u_time * PI) + 0.0) * sin(u_time * 1.0);\n    //y += floor(y);\n    // float y = smoothstep(0.2, 0.5, vUv.x) - smoothstep(0.5, 0.8, vUv.x);\n    float pct1 = plot(vUv, y1);\n    float pct2 = plot(vUv, y2);\n    float pct3 = plot(vUv, y3);\n    float pct4 = plot(vUv, y4);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 + pct2 + pct3 + pct4 + pct5;\n    color -= smoothstep(0., 0.1, vUv.x);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function oT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 6. - 3.;\n    vec3 color = vec3(0.);\n    \n    float y1 = fract(sin(vUv.x + u_time * 0.25 * PI) + 2.0) * sin(u_time * 1.2);\n    float y2 = fract(sin(vUv.x + u_time * 0.25 * PI) + 1.0) * sin(u_time * 0.9);\n    float y3 = fract(sin(vUv.x + u_time * 0.25 * PI) - 1.0) * sin(u_time * 0.5);\n    float y4 = fract(sin(vUv.x + u_time * 0.25 * PI) - 2.0) * sin(u_time * 1.5);\n    float y5 = fract(sin(vUv.x + u_time * 0.25 * PI) + 0.0) * sin(u_time * 1.0);\n    //y += floor(y);\n    // float y = smoothstep(0.2, 0.5, vUv.x) - smoothstep(0.5, 0.8, vUv.x);\n    float pct1 = plot(vUv, y1);\n    float pct2 = plot(vUv, y2);\n    float pct3 = plot(vUv, y3);\n    float pct4 = plot(vUv, y4);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 + pct2 + pct3 + pct4 + pct5;\n   \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function iT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:aT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.01, pct, st.y) -\n           smoothstep(pct, pct+0.01, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n//m is threshold (value above m stays unchanged)\n//n is the value given when signal is zero\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    \n    float y = almostIdentity(vUv.x, 0.5, 0.2);\n    float pct = plot(vUv, y);\n\n    color = vec3(y);\n    color = (1.0 - pct) * color + pct * vec3(0., 1., 0.);\n   \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vUv.y += 1.0;\n    vec3 color = vec3(0.);\n    \n    float y = almostIdentity(vUv.x, 0.5, 0.2);\n    float y2 = almostIdentity2(vUv.x, 0. + cos(u_time));\n    float y3 = almostIdentity2(vUv.x, 0.3 + sin(u_time));\n    float y4 = almostIdentity2(vUv.x, 0.6 + cos(u_time));\n    float y5 = almostIdentity2(vUv.x, 0.9 + sin(u_time));\n    float y6 = almostIdentity2(vUv.x, 1.2 + cos(u_time));\n    float y7 = almostIdentity2(vUv.x, 1.5 + sin(u_time));\n    float pct2 = plot(vUv, y2);\n    float pct3 = plot(vUv, y3);\n    float pct4 = plot(vUv, y4);\n    float pct5 = plot(vUv, y5);\n    float pct6 = plot(vUv, y6);\n    float pct7 = plot(vUv, y7);\n\n    //color = vec3(y2);\n    color = pct2 * vec3(0., 1., 0.);\n    color += pct3 * vec3(0., 1., 0.);\n    color += pct4 * vec3(0., 1., 0.);\n    color += pct5 * vec3(0., 1., 0.);\n    color += pct6 * vec3(0., 1., 0.);\n    color += pct7 * vec3(0., 1., 0.);\n   \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.025, pct, st.y) -\n           smoothstep(pct, pct+0.025, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    float y = almostUnitIdentity(vUv.x + cos(u_time));\n    float y2 = almostUnitIdentity(1. - vUv.x + sin(u_time));\n    float pct = plot(vUv, y);\n    float pct2 = plot(vUv, y2);\n    color += pct * vec3(0., 1., 0.);\n    color += pct2 * vec3(0., 1., 0.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.025, pct, st.y) -\n           smoothstep(pct, pct+0.025, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    float y = integralSmoothstep(vUv.x, 1.0 + sin(u_time));\n    float pct = plot(vUv, y);\n    color += pct * vec3(0., 1., 0.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 4.;\n    vec3 color = vec3(0.);\n    float y1 = expImpulse(vUv.x, 0.);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = expImpulse(vUv.x, 0.5 + abs(sin(u_time * 0.25)));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = expImpulse(vUv.x, 1.0);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = expImpulse(vUv.x, 1.5);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = expImpulse(vUv.x, 2.0);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 2.0 * sqrt(k) * x/(.25 + k * x * x);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 4.;\n    vec3 color = vec3(0.);\n    float y1 = quaImpulse(vUv.x, 0.);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = quaImpulse(vUv.x, 0.5 + abs(sin(u_time * 0.5)));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = quaImpulse(vUv.x, 1.0);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = quaImpulse(vUv.x, 1.5);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = quaImpulse(vUv.x, 2.0);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.025, pct, st.y) -\n           smoothstep(pct, pct+0.025, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.;\n    vec3 color = vec3(0.);\n    float y1 = polyImpulse(vUv.x, 0.0, 4.);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = polyImpulse(vUv.x, 0.5, 4. + sin(u_time));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = polyImpulse(vUv.x, 1.0, 4. + cos(u_time));\n    float pct3 = plot(vUv, y3);\n\n    float y4 = polyImpulse(vUv.x, 1.5, 4.);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = polyImpulse(vUv.x, 2.0, 4.);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _T=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.025, pct, st.y) -\n           smoothstep(pct, pct+0.025, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv *3.;\n    vec3 color = vec3(0.);\n    float y1 = expSustainedImpulse(vUv.x, 2.0, 0.25);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = expSustainedImpulse(vUv.x, 1.25 + abs(sin(u_time * 0.25)), 0.25 + abs(cos(u_time * 0.25)));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = expSustainedImpulse(vUv.x, 1.5 + abs(sin(u_time * 0.25)), 0.5 );\n    float pct3 = plot(vUv, y3);\n\n    float y4 = expSustainedImpulse(vUv.x, 1.75, 0.25 + abs(sin(u_time * 0.25)));\n    float pct4 = plot(vUv, y4);\n\n    float y5 = expSustainedImpulse(vUv.x, 2.0, 0.5);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function UT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_T,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.025, pct, st.y) -\n           smoothstep(pct, pct+0.025, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv *3.;\n    vUv.x -= 1.15;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = cubicPulse(0.35, 2.00, vUv.x);\n    float pct1 = plot(vUv, y1);\n\n    \n\n    float y2 = cubicPulse(0.35, 1.25, vUv.x);\n    float pct2 = plot(vUv, y2);\n\n    float y3 = cubicPulse(0.35, 1.5, vUv.x);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = cubicPulse(0.35, 1.75, vUv.x);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = cubicPulse(0.35, 1.00, vUv.x);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ST(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\n//9. Exponential step\n//natural attenuation - exponential of a linearly decaying quantity\n//a gaussian - exponential of a quadratically decaying quantity\nfloat expStep(float x, float k, float n)\n{\n    return exp(-k * pow(x, n));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 1.5;\n    vUv.y -= 0.25;\n    //vUv.x -= 1.15;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = expStep(vUv.x, 1.0, 1.0);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = expStep(vUv.x, 1.5, 2.0);\n    float pct2 = plot(vUv, y2);\n\n    float y3 = expStep(vUv.x, 2.0, 3.0 + sin(u_time));\n    float pct3 = plot(vUv, y3);\n\n    float y4 = expStep(vUv.x, 2.0, 4.0);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = expStep(vUv.x, 3.0, 5.0);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function MT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\n//9. Exponential step\n//natural attenuation - exponential of a linearly decaying quantity\n//a gaussian - exponential of a quadratically decaying quantity\nfloat expStep(float x, float k, float n)\n{\n    return exp(-k * pow(x, n));\n}\n\n//10. Gain\n//remapping the unit interval by expanding the sides and compressing the center\n//k =1 - identity curve\n//k < 1 - classic gain\n//k > 1 - s curves\nfloat gain(float x, float k)\n{\n    if(x < 0.5)\n    {\n        float a = 0.5 * pow((2.0 * x), k);\n        return a;\n    }\n    else \n    {\n       float a = 0.5 * pow((2.0 * (1.0 - x)), k);\n       return 1.0 - a;\n    }\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 1.5;\n    //vUv.y -= 0.25;\n    //vUv.x -= 1.15;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = gain(vUv.x, 1.0);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = gain(vUv.x, 2.25 + sin(u_time * 0.5));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = gain(vUv.x, 0.5);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = gain(vUv.x, 5.5);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = gain(vUv.x, 0.25);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.); //yellow\n    color += pct2 * vec3(0., 1., 1.); //teal\n    color += pct3 * vec3(0.5, 1., .5); //green\n    color += pct4 * vec3(1., 0., 0.); //red\n    color += pct5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function CT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\n//9. Exponential step\n//natural attenuation - exponential of a linearly decaying quantity\n//a gaussian - exponential of a quadratically decaying quantity\nfloat expStep(float x, float k, float n)\n{\n    return exp(-k * pow(x, n));\n}\n\n//10. Gain\n//remapping the unit interval by expanding the sides and compressing the center\n//k =1 - identity curve\n//k < 1 - classic gain\n//k > 1 - s curves\nfloat gain(float x, float k)\n{\n    if(x < 0.5)\n    {\n        float a = 0.5 * pow((2.0 * x), k);\n        return a;\n    }\n    else \n    {\n       float a = 0.5 * pow((2.0 * (1.0 - x)), k);\n       return 1.0 - a;\n    }\n}\n\n//11. Parabola\n//remap the 0 to 1 interval into 0 to 1 where the corners are mapped to 0 and the center is mapped to 1\nfloat parabola(float x, float k)\n{\n    return pow(4.0*x*(1.0 - x), k);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 1.5;\n    //vUv.y -= 0.25;\n    //vUv.x -= 1.15;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = parabola(vUv.x, 1.0);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = parabola(vUv.x, 2.25 + sin(u_time));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = parabola(vUv.x, 0.75);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = parabola(vUv.x, 1.75);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = parabola(vUv.x, 1.25);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.); //yellow\n    color += pct2 * vec3(0., 1., 1.); //teal\n    color += pct3 * vec3(0.5, 1., .5); //green\n    color += pct4 * vec3(1., 0., 0.); //red\n    color += pct5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function RT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:TT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\n//9. Exponential step\n//natural attenuation - exponential of a linearly decaying quantity\n//a gaussian - exponential of a quadratically decaying quantity\nfloat expStep(float x, float k, float n)\n{\n    return exp(-k * pow(x, n));\n}\n\n//10. Gain\n//remapping the unit interval by expanding the sides and compressing the center\n//k =1 - identity curve\n//k < 1 - classic gain\n//k > 1 - s curves\nfloat gain(float x, float k)\n{\n    if(x < 0.5)\n    {\n        float a = 0.5 * pow((2.0 * x), k);\n        return a;\n    }\n    else \n    {\n       float a = 0.5 * pow((2.0 * (1.0 - x)), k);\n       return 1.0 - a;\n    }\n}\n\n//11. Parabola\n//remap the 0 to 1 interval into 0 to 1 where the corners are mapped to 0 and the center is mapped to 1\nfloat parabola(float x, float k)\n{\n    return pow(4.0*x*(1.0 - x), k);\n}\n\n//12. Power Curve\n//generalized parabola that can be control the shape on either side of the curve\n//useful for creating curved shaped\nfloat pcurve(float x, float a, float b)\n{\n    float k = pow(a + b, a + b)/(pow(a, a) * pow(b, b));\n    return k * pow(x, a)*pow(1. - x, b);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 1.5;\n    //vUv.y -= 0.25;\n    //vUv.x -= 1.15;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = pcurve(vUv.x, 0.65, 1.5);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = pcurve(vUv.x, 2.0, 2.25 + sin(u_time));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = pcurve(vUv.x, 2.5, 1.75);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = pcurve(vUv.x, 2.75, 1.75 + cos(u_time));\n    float pct4 = plot(vUv, y4);\n\n    float y5 = pcurve(vUv.x, 3.0, 1.25);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.); //yellow\n    color += pct2 * vec3(0., 1., 1.); //teal\n    color += pct3 * vec3(0.5, 1., .5); //green\n    color += pct4 * vec3(1., 0., 0.); //red\n    color += pct5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function PT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:DT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\n//9. Exponential step\n//natural attenuation - exponential of a linearly decaying quantity\n//a gaussian - exponential of a quadratically decaying quantity\nfloat expStep(float x, float k, float n)\n{\n    return exp(-k * pow(x, n));\n}\n\n//10. Gain\n//remapping the unit interval by expanding the sides and compressing the center\n//k =1 - identity curve\n//k < 1 - classic gain\n//k > 1 - s curves\nfloat gain(float x, float k)\n{\n    if(x < 0.5)\n    {\n        float a = 0.5 * pow((2.0 * x), k);\n        return a;\n    }\n    else \n    {\n       float a = 0.5 * pow((2.0 * (1.0 - x)), k);\n       return 1.0 - a;\n    }\n}\n\n//11. Parabola\n//remap the 0 to 1 interval into 0 to 1 where the corners are mapped to 0 and the center is mapped to 1\nfloat parabola(float x, float k)\n{\n    return pow(4.0*x*(1.0 - x), k);\n}\n\n//12. Power Curve\n//generalized parabola that can be control the shape on either side of the curve\n//useful for creating curved shaped\nfloat pcurve(float x, float a, float b)\n{\n    float k = pow(a + b, a + b)/(pow(a, a) * pow(b, b));\n    return k * pow(x, a)*pow(1. - x, b);\n}\n\n//13. Sinc curve\n//bouncing behavior\n//k - number for bounces\nfloat sinc(float x, float k)\n{\n    float a = PI *(k * x - 1.0);\n    return sin(a)/a;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.5 - 0.5;\n    //vUv.y -= 0.25;\n    vUv.x += 0.25;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = sinc(vUv.x, 1.5);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = sinc(vUv.x, 2.25);\n    float pct2 = plot(vUv, y2);\n\n    float y3 = sinc(vUv.x, 1.75);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = sinc(vUv.x, 1.4);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = sinc(vUv.x, 1.25);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.); //yellow\n    color += pct2 * vec3(0., 1., 1.); //teal\n    color += pct3 * vec3(0.5, 1., .5); //green\n    color += pct4 * vec3(1., 0., 0.); //red\n    color += pct5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function FT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ET=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.5 - 1.25;\n    //vUv.y -= 0.25;\n    //vUv.x += 0.25;\n\n    vec3 color = vec3(0.);\n\n    float y1 = sdCircle(vUv, .15 + abs(sin(u_time)));\n\n    float y2 = sdCircle(vUv, 0.5 + (cos(u_time)));\n\n    float y3 = sdCircle(vUv, 0.25 + (sin(u_time)));\n\n    float y4 = sdCircle(vUv, 0.35 + abs(cos(u_time)));\n\n    float y5 = sdCircle(vUv, 0.45 + (sin(u_time)));\n\n    //color = vec3(y1);\n\n    color += y1 * vec3(1., 1., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function IT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ET,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n//circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n//box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.5 - 1.25;\n    //vUv.y -= 0.25;\n    //vUv.x += 0.25;\n\n    vec3 color = vec3(0.);\n\n    float y1 = sdBox(vUv, vec2(2.5 * abs(cos(u_time))));\n\n    float y2 = sdBox(vUv, vec2(2.0 * abs(sin(u_time))));\n\n    float y3 = sdBox(vUv, vec2(1.5 * (cos(u_time))));\n\n    float y4 = sdBox(vUv, vec2(1.0 * (sin(u_time))));\n\n    float y5 = sdBox(vUv, vec2(0.5 * abs(cos(u_time))));\n\n    //color = vec3(y1);\n\n    color += y1 * vec3(1., 1., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function LT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:OT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n//circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2.5 - 1.25;\n    //vUv.y -= 0.25;\n    //vUv.x += 0.25;\n\n    vec3 color = vec3(0.);\n\n    float y1 = sdSegment(vUv, vec2(0.5), vec2(2.5 * (cos(u_time))));\n\n    float y2 = sdSegment(vUv, vec2(0.5), vec2(.05 * (sin(u_time))));\n\n    float y3 = sdSegment(vUv, vec2(0.5), vec2(1.5 * (cos(u_time))));\n\n    float y4 = sdSegment(vUv, vec2(0.5), vec2(1.0 * (sin(u_time))));\n\n    float y5 = sdSegment(vUv, vec2(0.25), vec2(0.5 * (cos(u_time))));\n\n    //color = vec3(y1);\n\n    color += y1 * vec3(1., 1., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function NT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:AT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 6. - 3.;\n    //vUv.y -= 0.25;\n    vUv.y += 0.25;\n\n    vec3 color = vec3(0.);\n\n    float y1 = sdEqTriangle(vUv * abs(sin(u_time) * 0.1));\n    float y2 = sdEqTriangle(vUv * abs(sin(u_time) * 0.2));\n    float y3 = sdEqTriangle(vUv * abs(sin(u_time) * 0.3));\n    float y4 = sdEqTriangle(vUv * abs(sin(u_time) * 0.4));\n    float y5 = sdEqTriangle(vUv * abs(sin(u_time) * 1.5));\n\n    //color = vec3(y1);\n\n    color += y1 * vec3(1., 1., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function BT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:GT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = vUv * 6. - 3.;\n    //vUv.y -= 0.25;\n    vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n\n    float y1 = 1. -  sdEqTriangle(vUv * 5.5 * abs(sin(u_time * 0.5) + 1.5)) * 2.;\n    float x = smoothstep(2.5, 2.51, y1);\n    // float y2 = sdEqTriangle(vUv * abs(sin(u_time) * 0.2));\n    // float y3 = sdEqTriangle(vUv * abs(sin(u_time) * 0.3));\n    // float y4 = sdEqTriangle(vUv * abs(sin(u_time) * 0.4));\n    // float y5 = sdEqTriangle(vUv * abs(sin(u_time) * 1.5));\n\n    //color = vec3(y1);\n\n    color += x * vec3(1., 1., 0.); //yellow\n    // color += y2 * vec3(0., 1., 1.); //teal\n    // color += y3 * vec3(0.5, 1., .5); //green\n    // color += y4 * vec3(1., 0., 0.); //red\n    // color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function VT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = vUv * 6. - 3.;\n    //vUv.y -= 0.25;\n    //vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n\n    float y1 =1. - sdHexagon(vUv, 18.25);\n    float y2 =1. - sdHexagon(vUv, 20.25);\n    float y3 =1. - sdHexagon(vUv, 21.25);\n    float y4 =1. - sdHexagon(vUv, 22.25);\n    float y5 =1. - sdHexagon(vUv, 23.25);\n\n    color = vec3(y1);\n\n    color += y1 * vec3(1., 0., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function HT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:WT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = vUv * 40. - 20.;\n    //vUv.y -= 0.25;\n    //vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n\n    float y1 = 1. - sdCircle(vUv * abs(sin(u_time + 4.0 * 0.25)) , 1.9);\n    float y2 = 1. - sdCircle(vUv * abs(sin(u_time + 4.0 * 0.5)), 3.5);\n    float y3 = sdCircle(vUv * cos(u_time + 4.0 * 0.5), 2.5);\n    float y4 = 1. - sdCircle(vUv * sin(u_time + 4.0 * 0.25), 3.5);\n    float y5 = sdCircle(vUv * sin(u_time + 4.0 * 0.25), 3.0);\n\n    color = vec3(y1);\n\n    color += y1 * vec3(1., 0., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function YT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:XT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $T=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n// //hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 60. - 30.;\n    //vUv.y -= 0.25;\n    //vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n\n    float y1 = 1. - sdHexagram(vUv * abs(sin(u_time + 4.0 * 0.25)) , 1.9);\n    float y2 = 1. - sdHexagram(vUv * abs(sin(u_time + 4.0 * 0.5)), 3.5);\n    float y3 = sdHexagram(vUv * cos(u_time + 4.0 * 0.5), 2.5);\n    float y4 = 1. - sdHexagram(vUv * sin(u_time + 4.0 * 0.25), 3.5);\n    float y5 = sdHexagram(vUv * sin(u_time + 4.0 * 0.25), 3.0);\n\n    color = vec3(y1);\n\n    color += y1 * vec3(1., 0., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ZT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$T,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 4. - 2.;\n    //vUv.y -= 0.25;\n    //vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n    float a = PI * (0.5 + 0.5 * sin(u_time * 0.5 + 2.0));\n    float b = 0.25 *(0.75 + 0.75);\n    float y1 = sdArc(vUv, vec2(a * 2.50, a * 2.50), 1.0, b * 1.0);\n    float y2 = sdArc(vUv, vec2(a * 2.25, a * 2.25), 1.0, b * 0.8);\n    float y3 = sdArc(vUv, vec2(a * 2.15, a * 2.15), 1.0, b * 0.6);\n    float y4 = sdArc(vUv, vec2(a * 2.45, a * 2.45), 1.0, b * 0.4);\n    float y5 = sdArc(vUv, vec2(a * 2.35, a * 2.35), 1.0, b * 0.2);\n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function JT(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:KT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QT=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 3. - 1.5;\n    //vUv.y -= 0.25;\n    //vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n    float a = PI * (0.5 + 0.5);\n    float b = 0.25 *(0.75 + 0.75);\n    float y1 = sdPie(vUv, vec2(a * 2.50, a * 2.50), b * 1.0 + abs(sin(u_time)));\n    float y2 = sdPie(vUv, vec2(a * 2.25, a * 2.25), b * 0.8 + abs(sin(u_time)));\n    float y3 = sdPie(vUv, vec2(a * 2.15, a * 2.15), b * 0.6 + abs(sin(u_time)));\n    float y4 = sdPie(vUv, vec2(a * 2.45, a * 2.45), b * 0.4 + abs(sin(u_time)));\n    float y5 = sdPie(vUv, vec2(a * 2.35, a * 2.35), b * 0.2 + abs(sin(u_time)));\n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:QT,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 3. - 1.5;\n    //vUv.y -= 0.25;\n    vUv.y += 1.0;\n    \n    vec3 color = vec3(0.);\n    float y1 = sdHeart(vUv * 0.12 * abs(sin(u_time) - 5.5));\n    float y2 = sdHeart(vUv * 0.14 * abs(sin(u_time) - 5.5));\n    float y3 = sdHeart(vUv * 0.16 * abs(sin(u_time) - 5.5));\n    float y4 = sdHeart(vUv * 0.1 * abs(sin(u_time) - 5.5));\n    float y5 = sdHeart(vUv * 0.11 * abs(sin(u_time) - 5.));\n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:eR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n// //hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    vec2 s = 0.6 + 0.3*cos(u_time + vec2(0.0, 1.57));\n    if (s.x < s.y){\n        s = s.yx;\n    }\n    vec3 color = vec3(0.);\n    float y1 = sdCross(vUv, s, 0.25);\n    float y2 = sdCross(vUv, s, 0.15);\n    float y3 = sdCross(vUv, s, 0.35);\n    float y4 = sdCross(vUv, s, 0.45);\n    float y5 = sdCross(vUv, s, 0.50);\n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function oR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    vec2 s = 0.6 + 0.3*cos(u_time + vec2(0.0, 1.57));\n    if (s.x < s.y){\n        s = s.yx;\n    }\n    vec3 color = vec3(0.);\n    float y1 = sdRoundedX(vUv, 0.5, 0.25 * sin(u_time * 0.5));\n    float y2 = sdRoundedX(vUv, 0.5, 0.15 * abs(cos(u_time * 0.5)));\n    float y3 = sdRoundedX(vUv, 0.5, 0.35 * abs(sin(u_time * 0.5)));\n    float y4 = sdRoundedX(vUv, 0.5, 0.45 / sin(u_time * 0.5));\n    float y5 = sdRoundedX(vUv, 0.5, 0.50 * cos(u_time * 0.5));\n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function iR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:aR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\n// float sdHexagon(vec2 p, float r)\n// {\n//     vec3 k = vec3(-0.866025404,0.5,0.577350269);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n//     return length(p) * sin(p.y);\n// }\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\nconst int N = 4;\n\nfloat sdPolygon(vec2 p, vec2[N] v)\n{\n    int num = v.length();\n    float d = dot(p-v[0], p-v[0]);\n    float s = 1.0;\n    for(int i=0, j =num-1; i <num; j=i, i++)\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e,e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ){\n             s=-s;\n            }\n        }\n\n    return s * sqrt(d);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    \n    vec2 v0 = 0.5 * cos(0.25 * u_time + vec2(0., 1.0) + 1.0);\n    vec2 v1 = 0.5 * cos(0.35 * u_time + vec2(0., 1.5) + 2.0);\n    vec2 v2 = 0.5 * cos(0.45 * u_time + vec2(0., 2.0) + 3.0);\n    vec2 v3 = 0.5 * cos(0.55 * u_time + vec2(0., 2.5) + 4.0);\n\n    vec2[] polygon = vec2[](v0, v1, v2, v3);\n\n    float d = sdPolygon(vUv, polygon);\n    vec3 color = vec3(0.);\n    color += 1.0 - exp(-6.0*abs(d));\n\n    color += smoothstep(0.0, 0.015, d) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, d) * vec3(0., 1., 1.); //teal\n    // color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    // color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    // color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vUv = Rot(vUv,   u_time * 0.4 * 2.);\n    vUv2 = Rot(vUv2, u_time * 0.6 * 2.);\n    vUv3 = Rot(vUv3, u_time * 0.8 * 2.);\n    vUv4 = Rot(vUv3, u_time * 0.2 * 2.);\n    vUv = vUv * 4. - 2.;\n    vUv2 = vUv2 * 4. - 2.;\n    vUv3 = vUv3 * 4. - 2.;\n    vUv4 = vUv4 * 4. - 2.;\n\n    \n    vec3 color = vec3(0.);\n    float a = PI * (0.5 + 0.5);\n    float b = 0.25 *(0.75 + 0.75);\n    float y1 = sdArc(vUv4 * 0.65, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y2 = sdArc(vUv, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y21 = sdArc(vUv2 / 0.65, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y211 = sdArc(vUv3 / 0.4, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    \n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1); //yellow\n    color *= smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color *= smoothstep(0.0, 0.015, y21) * vec3(0.5, 1., .5); //green\n    color *= smoothstep(0.0, 0.015, y211); //red\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vec2 vUv5 = vUv;\n\n    vUv = Rot(vUv,   u_time * 0.4 * 4.);\n    vUv2 = Rot(vUv2, u_time * 0.6 * 4.);\n    vUv3 = Rot(vUv3, u_time * 0.8 * 4.);\n    vUv4 = Rot(vUv4, u_time * 1.0 * 4.);\n    vUv5 = Rot(vUv5, u_time * 0.2 * 4.);\n\n    vUv = vUv * 4. - 2.;\n    vUv2 = vUv2 * 4. - 2.;\n    vUv3 = vUv3 * 4. - 2.;\n    vUv4 = vUv4 * 4. - 2.;\n    vUv5 = vUv5 * 4. - 2.;\n\n    \n    vec3 color = vec3(0.);\n    float a = PI * (0.25 + 0.25);\n    float b = 0.025 *(0.5 + 0.5);\n    float y1 = sdArc(vUv4 * 0.65, vec2(a * 2.5, a * 2.5), 1.0 , b * 0.4 );\n    float y2 = sdArc(vUv, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y21 = sdArc(vUv2 / 0.65, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y211 = sdArc(vUv3 / 0.4, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y2111 = sdArc(vUv5 /0.225, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    \n\n    color = vec3(y1);\n\n    y1 = smoothstep(0.0, 0.015, y1); //yellow\n    y2 = smoothstep(0.0, 0.015, y2); //teal\n    y21 = smoothstep(0.0, 0.015, y21); //green\n    y211 = smoothstep(0.0, 0.015, y211); //red\n    y2111 = smoothstep(0.0, 0.015, y2111); //red\n\n    color += y1;\n    color *= y2;\n    color *= y21;\n    color *= y211;\n    color *= y2111;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vec2 vUv5 = vUv;\n\n    vUv = Rot(vUv,   u_time * 0.15);\n\n    vUv = vUv * (100. *sin(u_time * 0.5) + 25.) - (50. * sin(u_time * 0.5) + 12.5);    \n    vec3 color = vec3(0.);\n    \n    float y1 = sdHexagram(vUv, 1.5);\n    float y2 = sdHexagram(vUv, 1.2);\n    float y21 = sdHexagram(vUv, 1.0);\n    float y211 = sdHexagram(vUv, 0.8);\n    float y2111 = sdHexagram(vUv, 0.5);\n\n    y1 = smoothstep(0.0, 0.015, y1); //yellow\n    y2 = smoothstep(0.0, 0.015, y2); //teal\n    y21 = smoothstep(0.0, 0.015, y21); //green\n    y211 = smoothstep(0.0, 0.015, y211); //red\n    y2111 = smoothstep(0.0, 0.015, y2111); //red\n\n    color += y1;\n    color += y2 ;\n    color *= y21 ;\n    color *= y211;\n    color *= y2111;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\nconst int N = 8;\n\nfloat sdPolygon(vec2 p, vec2[N] v)\n{\n    int num = v.length();\n    float d = dot(p-v[0], p-v[0]);\n    float s = 1.0;\n    for(int i=0, j =num-1; i <num; j=i, i++)\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e,e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ){\n             s=-s;\n            }\n        }\n\n    return s * sqrt(d);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    \n    vec2 v0 = 0.5 * cos(0.25 * u_time + vec2(0., 1.0) + 1.0);\n    vec2 v1 = 0.5 * cos(0.35 * u_time + vec2(0., 1.5) + 2.0);\n    vec2 v2 = 0.5 * cos(0.45 * u_time + vec2(0., 2.0) + 3.0);\n    vec2 v3 = 0.5 * cos(0.55 * u_time + vec2(0., 2.5) + 4.0);\n    vec2 v4 = 0.5 * cos(0.65 * u_time + vec2(0., 1.0) + 1.0);\n    vec2 v5 = 0.5 * cos(0.75 * u_time + vec2(0., 1.5) + 2.0);\n    vec2 v6 = 0.5 * cos(0.85 * u_time + vec2(0., 2.0) + 3.0);\n    vec2 v7 = 0.5 * cos(0.95 * u_time + vec2(0., 2.5) + 4.0);\n\n    vec2[] polygon = vec2[](v0, v1, v2, v3,v4, v5, v6, v7);\n\n    float d = sdPolygon(vUv, polygon);\n    vec3 color = vec3(0.);\n    color += 1.0 - exp(-6.0*abs(d));\n\n    color += smoothstep(0.0, 0.015, d) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, d) * vec3(0., 1., 1.); //teal\n    // color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    // color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    // color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\n// float sdHexagon(vec2 p, float r)\n// {\n//     vec3 k = vec3(-0.866025404,0.5,0.577350269);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n//     return length(p) * sin(p.y);\n// }\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\nconst int N = 3;\n\nfloat sdPolygon(vec2 p, vec2[N] v)\n{\n    int num = v.length();\n    float d = dot(p-v[0], p-v[0]);\n    float s = 1.0;\n    for(int i=0, j =num-1; i <num; j=i, i++)\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e,e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ){\n             s=-s;\n            }\n        }\n\n    return s * sqrt(d);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    \n    vec2 v0 = 0.5 * cos(0.25 * u_time + vec2(0., 1.0) + 1.0);\n    vec2 v1 = 0.5 * cos(0.55 * u_time + vec2(0., 1.5) + 2.0);\n    vec2 v2 = 0.5 * cos(0.95 * u_time + vec2(0., 2.0) + 3.0);\n    vec2 v3 = 0.5 * cos(0.55 * u_time + vec2(0., 2.5) + 4.0);\n    vec2 v4 = 0.5 * cos(0.65 * u_time + vec2(0., 1.0) + 1.0);\n    vec2 v5 = 0.5 * cos(0.75 * u_time + vec2(0., 1.5) + 2.0);\n    vec2 v6 = 0.5 * cos(0.85 * u_time + vec2(0., 2.0) + 3.0);\n    vec2 v7 = 0.5 * cos(0.95 * u_time + vec2(0., 2.5) + 4.0);\n    vec2 v8 = 0.5 * cos(1.25 * u_time + vec2(0., 3.5) + 4.0);\n\n    vec2[] polygon = vec2[](v0, v1, v2);\n    vec2[] polygon2 = vec2[](v3, v4, v5);\n    vec2[] polygon3 = vec2[](v6, v7, v8);\n\n    float d = sdPolygon(vUv, polygon);\n    float d2 = sdPolygon(vUv, polygon2);\n    float d3 = sdPolygon(vUv, polygon3);\n    vec3 color = vec3(0.);\n    color += exp(-16.0*abs(d));\n    color += exp(-16.0*abs(d2));\n    color += exp(-16.0*abs(d3));\n\n    color += smoothstep(0.0, 0.015, d) * vec3(0.2, 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, d2) * vec3(0., 0.2, 0.); //teal\n    color += smoothstep(0.0, 0.015, d3) * vec3(0.3, 0., 0.); //teal\n    // color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    // color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    // color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\nconst int N = 4;\n\nfloat sdPolygon(vec2 p, vec2[N] v)\n{\n    int num = v.length();\n    float d = dot(p-v[0], p-v[0]);\n    float s = 1.0;\n    for(int i=0, j =num-1; i <num; j=i, i++)\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e,e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ){\n             s=-s;\n            }\n        }\n\n    return s * sqrt(d);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    \n    vec2 v0 = 0.5 * cos(0.15 * u_time + vec2(10., 0.0) + 1.0);\n    vec2 v1 = 0.5 * cos(0.15 * u_time + vec2(0., 1.0) + 2.0);\n    vec2 v2 = 0.5 * cos(0.15 * u_time + vec2(1.0, 0.0) + 3.0);\n    vec2 v3 = 0.5 * cos(0.15 * u_time + vec2(1.0, 1.0) + 4.0);\n    vec2 v4 = 0.5 * cos(0.15 * u_time + vec2(1.5, 0.0) + 1.0);\n    vec2 v5 = 0.5 * cos(0.15 * u_time + vec2(1.5, 2.5) + 2.0);\n    vec2 v6 = 0.5 * cos(0.15 * u_time + vec2(3.0, 0.0) + 3.0);\n    vec2 v7 = 0.5 * cos(0.15 * u_time + vec2(3.0, 2.5) + 1.0);\n    vec2 v8 = 0.5 * cos(1.15 * u_time + vec2(0., 3.5) + 2.0);\n\n    vec2[] polygon = vec2[](v0, v1, v2, v3);\n    vec2[] polygon2 = vec2[](v4, v5, v6, v7);\n    vec2[] polygon3 = vec2[](v6, v7, v8);\n\n    float d = sdPolygon(vUv, polygon);\n    float d2 = sdPolygon(vUv, polygon2);\n    //float d3 = sdPolygon(vUv, polygon3);\n    vec3 color = vec3(0.);\n    color += exp(-32.0*abs(d));\n    color += exp(-32.0*abs(d2));\n    //color += exp(-32.0*abs(d3));\n\n    color += smoothstep(0.0, 0.015, d) * vec3(0.2, 0., 0.2); //yellow\n    color += smoothstep(0.0, 0.015, d2) * vec3(0., 0.2, 0.); //teal\n    //color += smoothstep(0.0, 0.015, d3) * vec3(0.1, 0., 0.); //teal\n    // color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    // color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    // color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _R=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n//circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\nconst int N = 4;\n\nfloat sdPolygon(vec2 p, vec2[N] v)\n{\n    int num = v.length();\n    float d = dot(p-v[0], p-v[0]);\n    float s = 1.0;\n    for(int i=0, j =num-1; i <num; j=i, i++)\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e,e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ){\n             s=-s;\n            }\n        }\n\n    return s * sqrt(d);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    \n    vec2 v0 = 0.5 * cos(0.15 * u_time + vec2(0.0, 0.0) + 1.5);\n    vec2 v1 = 0.5 * cos(0.15 * u_time + vec2(0.0, 4.0) + 2.3);\n    vec2 v2 = 0.5 * cos(0.15 * u_time + vec2(4.0, 2.0) + 3.5);\n    vec2 v3 = 0.5 * cos(0.15 * u_time + vec2(2.0, 0.0) + 4.1);\n    vec2 v4 = 0.5 * cos(0.15 * u_time + vec2(1.5, 0.0) + 1.0);\n    vec2 v5 = 0.5 * cos(0.15 * u_time + vec2(1.5, 2.5) + 2.0);\n    vec2 v6 = 0.5 * cos(0.15 * u_time + vec2(3.0, 0.0) + 3.0);\n    vec2 v7 = 0.5 * cos(0.15 * u_time + vec2(3.0, 2.5) + 1.0);\n    vec2 v8 = 0.5 * cos(1.15 * u_time + vec2(0., 3.5) + 2.0);\n\n    vec2[] polygon = vec2[](v0, v1, v2, v3);\n    vec2[] polygon2 = vec2[](v4, v5, v6, v7);\n    // vec2[] polygon3 = vec2[](v6, v7, v8);\n\n    float d = sdPolygon(vUv, polygon);\n    float d2 = sdPolygon(vUv, polygon2);\n    //float d3 = sdPolygon(vUv, polygon3);\n    vec3 color = vec3(0.);\n    color += exp(-16.0*abs(d));\n    color += exp(-32.0*abs(d2));\n    //color += exp(-32.0*abs(d3));\n\n    color += smoothstep(0.0, 0.015, d * d2) * vec3(0.2, 0., 0.2); //yellow\n    //color += smoothstep(0.0, 0.015, d2) * vec3(0., 0.2, 0.); //teal\n    //color += smoothstep(0.0, 0.015, d3) * vec3(0.1, 0., 0.); //teal\n    // color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    // color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    // color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function UR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_R,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = step(((1.0 - width)/ 2.0), vUv.x);\n//     float right = step(((1.0 - width)/2.0), 1. - vUv.x);\n//     float top = step(((1.0 - height)/2.0), 1. - vUv.y);\n//     float bottom = step(((1.0 - height)/2.0), vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = Rot(vUv, u_time * 0.75);\n    float rectangle1 = rect(vUv, 0.25, 0.25);\n    float rectangle2 = rect(vUv, 0.025, 0.5);\n    float rectangle3 = rect(vUv, 0.5, 0.025);\n    color = vec3(rectangle1 + rectangle2 + rectangle3);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function SR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = Rot(vUv, u_time * 0.75);\n    float rectangle1 = rect(vec2(vUv.x-0.25,vUv.y), 0.25, 0.25);\n    float rectangle2 = rect(vec2(vUv.x-0.25,vUv.y), 0.025, 0.5);\n    float rectangle3 = rect(vec2(vUv.x-0.25,vUv.y), 0.5, 0.025);\n    float rectangle4 = rect(vec2(vUv.x,vUv.y), 0.25, 0.25);\n    float rectangle5 = rect(vec2(vUv.x,vUv.y), 0.025, 0.5);\n    float rectangle6 = rect(vec2(vUv.x,vUv.y), 0.5, 0.025);\n    float rectangle7 = rect(vec2(vUv.x+0.25,vUv.y), 0.25, 0.25);\n    float rectangle8 = rect(vec2(vUv.x+0.25,vUv.y), 0.025, 0.5);\n    float rectangle9 = rect(vec2(vUv.x+0.25,vUv.y), 0.5, 0.025);\n    color = vec3(rectangle1 - rectangle2 + rectangle3);\n    color += vec3(rectangle4 - rectangle5 + rectangle6);\n    color += vec3(rectangle7 - rectangle8 + rectangle9);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function MR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1  - 366\n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float b1 = rect(vec2(vUv.x - 0.5, vUv.y - 0.225), 0.2, 0.2);\n    float b2 = rect(vec2(vUv.x - 0.5, vUv.y - 0.45), 0.2, 0.2);\n    float b3 = rect(vec2(vUv.x -0.125, vUv.y - 0.45), 0.65, 0.5);\n    float b4 = rect(vec2(vUv.x -0.125, vUv.y + 0.125 ), 0.45, 0.5);\n    float b5 = rect(vec2(vUv.x -0.125, vUv.y + 0.45 ), 0.15, 0.5);\n    float b6 = rect(vec2(vUv.x -0.5, vUv.y + 0.125 ), 0.45, 0.2);\n    float b7 = rect(vec2(vUv.x -0.5, vUv.y + 0.45 ), 0.15, 0.2);\n    float b8 = rect(vec2(vUv.x + 0.5, vUv.y + 0.45 ), 0.15, 0.2);\n    float b9 = rect(vec2(vUv.x + 0.5, vUv.y - 0.225 ), 0.75, 0.695);\n    float b10 = rect(vec2(vUv.x +0.5, vUv.y + 0.265), 0.175, 0.695);\n    float b11 = rect(vec2(vUv.x + 0.265, vUv.y + 0.445 ), 0.14, 0.22);\n\n    color.r = b1 * (sin(u_time * 0.1));\n    color.b += b2 * (sin(u_time * 0.2));\n    color.rgb += b3 * (sin(u_time * 0.3));\n    color.rg += b4 * (sin(u_time * 0.4));\n    color.b += b5 * (sin(u_time * 0.5));\n    color.rgb += b6 * (sin(u_time * 0.6));\n    color.r += b7 * (sin(u_time * 0.7));\n    color.rg += b8 * (sin(u_time * 0.8));\n    color.rg += b9 * (sin(u_time * 0.9));\n    color.rgb += b10 * (sin(u_time * 0.11));\n    color.r += b11 * (sin(u_time * 0.12));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function CR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec3 color = vec3(0.);\n\n    vUv1 = Rot(vUv1, u_time * 0.5 * 1.5);\n    vUv2 = Rot(vUv2, u_time * 0.25 * 1.5);\n    vUv3 = Rot(vUv3, u_time * 0.75 * 1.5);\n\n    float c1 = circle(vUv, 0.5);\n    color = vec3(c1);\n    float r1 = rect(vUv1, 0.55, 0.55);\n    color -= r1;\n\n    float c2 = circle(vUv, 0.25);\n    color += c2;\n    float r2 = rect(vUv2, 0.4, 0.4);\n    color -= r2;\n    \n    float c3 = circle(vUv, 0.125);\n    color += c3;\n    //float r3 = rect(vUv, 0.35, 0.035);\n    //color -= c3;\n\n    float c4 = circle(vUv, 0.75);\n    color += c4;\n    float r4 = rect(vUv3, 0.75, 0.75);\n    color -= r4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function RR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:TR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.25);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec3 color = vec3(0.);\n\n    vUv1 = Rot(vUv, PI * 0.25);\n    vUv2 = Rot(vUv, -PI * 0.25);\n    float c1 = circle(vUv, 0.25);\n    float c2 = circle(vUv, 0.35);\n\n    float c3 = circle(vUv, 0.15);\n    float c4 = circle(vUv, 0.1);\n    float r1 = rect(vUv, 0.05, 0.65);\n    float r2 = rect(vUv, 0.65, 0.05);\n    float r3 = rect(vUv1, 0.65, 0.05);\n    float r4 = rect(vUv2, 0.65, 0.05);\n\n    color += c2;\n    color -= c1;\n    color += c3;\n    color -= c4;\n\n    color -= r1;\n    color -= r2;\n    color -= r3;\n    color -= r4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function PR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:DR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vUv1 = Rot(vUv, u_time);\n    vec3 color = vec3(0.);\n\n    float r1 = rect(vUv1, 0.3, 0.75);\n    float c1 = circle(vUv, 0.35);\n    \n    float r2 = rect(vUv1, 0.75, 0.3);\n    float c2 = circle(vUv, 0.025);\n\n    float r3 = rect(vUv2, 0.3, 0.3);\n    \n    \n    color += r1;\n    color += r2;\n    color -= c1;\n    color += c2;\n    color -= r3;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function FR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ER=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vUv1 = Rot(vUv, u_time);\n    vec3 color = vec3(0.);\n\n    float r1 = rect(vUv1, 0.3, 0.75);\n    float c1 = circle(vUv, 0.35);\n    \n    float r2 = rect(vUv1, 0.75, 0.3);\n    float c2 = circle(vUv, 0.025);\n\n    float r3 = rect(vUv2, 0.3, 0.3);\n    \n    \n    color -= r1;\n    color -= r2;\n    color += c1;\n    color -= c2;\n    color += r3;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function IR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ER,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.6);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vUv1 = Rot(vUv1, PI);\n    vUv2 = Rot(vUv2, PI * 0.5);\n    vec3 color = vec3(0.);\n\n    float r1 = rect(vUv1, 0.5, 0.5);\n    float r2 = 1. - rect(vUv1, 0.25, 0.5);\n    float r3 = rect(vUv1, 0.1, 0.7);\n    \n\n    float r4 = rect(vUv2, 0.5, 0.5);\n    float r5 = 1. - rect(vUv2, 0.25, 0.5);\n    float r6 = rect(vUv2, 0.1, 0.7);\n    \n    color += r1;\n    color -= r2;\n    color -= r3;\n    color += r4;\n    color -= r5;\n    color -= r6;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function LR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:OR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 1.6);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vUv1 = Rot(vUv1, PI);\n    vUv2 = Rot(vUv2, PI * 0.5);\n    vec3 color = vec3(0.);\n\n    float r1 = rect(vUv1, 0.5, 0.5);\n    float r2 = 1. - rect(vUv1, 0.35, 0.75);\n    float r3 = rect(vUv1, 0.2, 0.7);\n    \n\n    float r4 = rect(vUv2, 0.25, 0.25);\n    float r5 = 1. - rect(vUv2, 0.55, 0.55);\n    float r6 = rect(vUv2, 0.1, 0.1);\n    \n    color += r1;\n    color -= r2;\n    color -= r3;\n    color += r4;\n    color -= r5;\n    color -= r6;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function NR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:AR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 1.6);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vUv1 = Rot(vUv1, PI);\n    vUv2 = Rot(vUv2, PI * 0.5);\n    vec3 color = vec3(0.);\n\n    float r1 = rect(vUv1, 0.5, 0.5);\n    float r2 = 1. - rect(vUv1, 0.35, 0.75);\n    float r3 = rect(vUv1, 0.2, 0.7);\n    \n\n    float r4 = rect(vUv2, 0.15, 0.45);\n    float r5 = 1. - rect(vUv2, 0.55, 0.55);\n    float r6 = rect(vUv2, 0.82, 0.1);\n    \n    color += r1;\n    color -= r2;\n    color -= r3;\n    color -= r4;\n    color -= r5;\n    color += r6;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function BR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:GR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    float c1 = circle(vUv, 0.5 * abs(sin(u_time)));\n    float c2 = circle(vUv, 0.51 * abs(sin(u_time)));\n    float c3 = smoothstep(0.1, 0.2, c2 - c1);\n    color += c3;\n\n    float r1 = rect(vUv, 0.6 * abs(cos(u_time)), 0.6 * abs(cos(u_time)));\n    float r2 = rect(vUv, 0.61 * abs(cos(u_time)), 0.61 * abs(cos(u_time)));\n    float r3 = smoothstep(0.1, 0.2, r2 - r1);\n    color += r3;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function VR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    float c1 = cirOutline(vUv, 0.50 * abs(sin(u_time * 0.95)) + .15);\n    float c2 = cirOutline(vUv, 0.45 * abs(sin(u_time * 0.85)) + .15);\n    float c3 = cirOutline(vUv, 0.40 * abs(sin(u_time * 0.75)) + .15);\n    float c4 = cirOutline(vUv, 0.35 * abs(sin(u_time * 0.65)) + .15);\n    float c5 = cirOutline(vUv, 0.30 * abs(sin(u_time * 0.56)) + .15);\n    float c6 = cirOutline(vUv, 0.25 * abs(sin(u_time * 0.45)) + .15);\n    float c7 = cirOutline(vUv, 0.20 * abs(sin(u_time * 0.35)) + .15);\n    float c8 = cirOutline(vUv, 0.15 * abs(sin(u_time * 0.25)) + .15);\n    float c9 = cirOutline(vUv, 0.10 * abs(sin(u_time * 0.15)) + .15);\n    float c10 = cirOutline(vUv, 0.05 *abs(sin(u_time * 0.05)) + .15);\n    color += c1 + c2 + c3 + c4 + c5 + c6 + c7 + c8 + c9 + c10;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function HR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:WR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    float r1 = rectOutline(vUv, 0.3 - (0.04 * 6.5) * sin(u_time), 0.3 - (0.04 * 6.5) * cos(u_time));\n    float r2 = rectOutline(vUv, 0.3 - (0.03 * 6.5) * sin(u_time), 0.3 - (0.03 * 6.5) * cos(u_time));\n    float r3 = rectOutline(vUv, 0.3 - (0.02 * 6.5) * sin(u_time), 0.3 - (0.02 * 6.5) * cos(u_time));\n    float r4 = rectOutline(vUv, 0.3 - (0.01 * 6.5) * sin(u_time), 0.3 - (0.01 * 6.5) * cos(u_time));\n    float r5 = rectOutline(vUv, 0.3 + (0.00 * 6.5) * sin(u_time), 0.3 + (0.00 * 6.5) * cos(u_time));\n    float r6 = rectOutline(vUv, 0.3 + (0.01 * 6.5) * sin(u_time), 0.3 + (0.01 * 6.5) * cos(u_time));\n    float r7 = rectOutline(vUv, 0.3 + (0.02 * 6.5) * sin(u_time), 0.3 + (0.02 * 6.5) * cos(u_time));\n    float r8 = rectOutline(vUv, 0.3 + (0.03 * 6.5) * sin(u_time), 0.3 + (0.03 * 6.5) * cos(u_time));\n    float r9 = rectOutline(vUv, 0.3 + (0.04 * 6.5) * sin(u_time), 0.3 + (0.04 * 6.5) * cos(u_time));\n\n    color += r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8 + r9;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function YR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:XR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $R=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    float r1 = rectOutline(vUv, 0.3 - (0.04 * 6.5) * cos(u_time + 1.5), 0.3 - (0.04 * 6.5) * cos(u_time * 0.5));\n    float r2 = rectOutline(vUv, 0.3 - (0.03 * 6.5) * cos(u_time + 1.5), 0.3 - (0.03 * 6.5) * cos(u_time * 0.5));\n    float r3 = rectOutline(vUv, 0.3 - (0.02 * 6.5) * cos(u_time + 1.5), 0.3 - (0.02 * 6.5) * cos(u_time * 0.5));\n    float r4 = rectOutline(vUv, 0.3 - (0.01 * 6.5) * cos(u_time + 1.5), 0.3 - (0.01 * 6.5) * cos(u_time * 0.5));\n    float r5 = rectOutline(vUv, 0.3 + (0.00 * 6.5) * cos(u_time + 1.5), 0.3 + (0.00 * 6.5) * cos(u_time * 0.5));\n    float r6 = rectOutline(vUv, 0.3 + (0.01 * 6.5) * cos(u_time + 1.5), 0.3 + (0.01 * 6.5) * cos(u_time * 0.5));\n    float r7 = rectOutline(vUv, 0.3 + (0.02 * 6.5) * cos(u_time + 1.5), 0.3 + (0.02 * 6.5) * cos(u_time * 0.5));\n    float r8 = rectOutline(vUv, 0.3 + (0.03 * 6.5) * cos(u_time + 1.5), 0.3 + (0.03 * 6.5) * cos(u_time * 0.5));\n    float r9 = rectOutline(vUv, 0.3 + (0.04 * 6.5) * cos(u_time + 1.5), 0.3 + (0.04 * 6.5) * cos(u_time * 0.5));\n\n    color += r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8 + r9;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ZR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$R,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = vUv * 2. - 0.5;\n\n    vec2 vUv1 = vUv;\n    vUv1.x += sin(u_time * 0.25);\n    float c1 = cirOutline(vUv1, 0.05);\n\n    vec2 vUv2 = vUv;\n    vUv2.x -= sin(u_time * 0.5);\n    float c2 = cirOutline(vUv2, 0.05);\n\n    vec2 vUv3 = vUv;\n    vUv3.x += sin(u_time * 0.2);\n    float c3 = cirOutline(vUv3, 0.05);\n\n    vec2 vUv4 = vUv;\n    vUv4.x += sin(u_time * 1.9);\n    float c4 = cirOutline(vUv4, 0.05);\n\n    vec2 vUv5 = vUv;\n    vUv5.x -= sin(u_time * 1.15);\n    float c5 = cirOutline(vUv5, 0.05);\n\n    vec2 vUv6 = vUv;\n    vUv6.x += sin(u_time * 0.85);\n    vUv6.y -= 0.25;\n    float c6 = cirOutline(vUv6, 0.05);\n\n    vec2 vUv7 = vUv;\n    vUv7.x -= sin(u_time * 0.55);\n    vUv7.y -= 0.25;\n    float c7 = cirOutline(vUv7, 0.05);\n\n    vec2 vUv8 = vUv;\n    vUv8.x += sin(u_time * 0.35);\n    vUv8.y -= 0.25;\n    float c8 = cirOutline(vUv8, 0.05);\n\n    vec2 vUv9 = vUv;\n    vUv9.x += sin(u_time * 1.24);\n    vUv9.y -= 0.25;\n    float c9 = cirOutline(vUv9, 0.05);\n\n    vec2 vUv10 = vUv;\n    vUv10.x -= sin(u_time * .25);\n    vUv10.y -= 0.25;\n    float c10 = cirOutline(vUv10, 0.05);\n\n    vec2 vUv11 = vUv;\n    vUv11.x -= sin(u_time * .25);\n    vUv11.y += 0.25;\n    float c11 = cirOutline(vUv11, 0.05);\n\n    vec2 vUv12 = vUv;\n    vUv12.x -= sin(u_time * .25);\n    vUv12.y += 0.25;\n    float c12 = cirOutline(vUv12, 0.05);\n\n    vec2 vUv13 = vUv;\n    vUv13.x -= sin(u_time * .45);\n    vUv13.y += 0.25;\n    float c13 = cirOutline(vUv13, 0.05);\n\n    vec2 vUv14 = vUv;\n    vUv14.x -= sin(u_time * .75);\n    vUv14.y += 0.25;\n    float c14 = cirOutline(vUv14, 0.05);\n\n    vec2 vUv15 = vUv;\n    vUv15.x -= sin(u_time * 1.35);\n    vUv15.y += 0.25;\n    float c15 = cirOutline(vUv15, 0.05);\n\n    color += c1 + c2 + c3 + c4 + c5;\n    color += c6 + c7 + c8 + c9 + c10;\n    color += c11 + c12 + c13 + c14 + c15;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function JR(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:KR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QR=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    //vUv = vUv * 2. - 0.5;\n\n    float r1 = rect(vUv, 0.5, 0.5);\n    float c1 = circle(vUv, 0.15);\n    float c2 = cirOutline(vUv, 0.045 + abs(sin(u_time) / 16.));\n    float r2 = rectOutline(vUv, 0.45 + abs(sin(u_time) / 32.), 0.45 + abs(sin(u_time) / 32.) );\n    color += r1;\n    color -= c1;\n    color += c2;\n    color -= r2;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:QR,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = vUv * 4. - 2.;\n\n    float d = 1. - length(max(abs(vUv) - .3, 0.));\n\n    d = fract((d * 2. + (u_time * 0.75)));\n    d = smoothstep(0.3, 0.4, d) * smoothstep(0.6, 0.5, d);\n    color += d;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:eD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    //vUv = Rot(vUv, (u_time * 0.25));\n    vUv = vUv * 4. - 2.;\n    \n    float d = 1. - length(max(abs(vUv) - .3, 0.));\n\n    d = fract((d + d * d * d * 2. - (u_time * 0.75)));\n    d /= smoothstep(0.3, 0.31, d) * smoothstep(0.4, 0.41, d);\n    color += 1. - d;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function oD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = Rot(vUv, (u_time * 0.25));\n    vUv = vUv * 4. - 2.;\n    \n    float d = 1. - length(max(abs(vUv) - .3, 0.));\n    d += length( min(abs(vUv)-.3,0.) );\n\n    d = fract((d * d + d + d + 2. - (u_time * 0.25)));\n    d =  step(.3,d );\n    d /= smoothstep(0.3, 0.31, d) * smoothstep(0.4, 0.41, d);\n    color += 1. - d;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function iD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:aD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 vUv1 = vUv;\n    vUv1 = Rot(vUv1, (u_time * 5.));\n    vUv *= 2. - 1.;\n    vec2 pos = vec2(0.5) - vUv1;\n\n    float r = length(pos) * 5.0;\n    float a = atan(pos.y, pos.x);\n\n    float f = cos(a * 3.);\n\n    float i = smoothstep(f, f + 0.1, r);\n    float r1 = 1. - rect(vec2(vUv.x, vUv.y + 0.27), 0.56, 0.025);\n    color = vec3(i);\n    color *= r1;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vUv1 = Rot(vUv1, (u_time * 0.5));\n    float i1 = flower(vUv1, 6., 4.0 * cos(u_time * 0.5));\n    float i2 = flower(vUv1, 6., 4.25 * cos(u_time * 0.5));\n    float i3 = flower(vUv1, 6., 2.0 * sin(u_time * 0.25));\n    float i4 = flower(vUv1, 6., 2.25 * sin(u_time * 0.25));\n    float i5 = flower(vUv1, 6., 8.0 * cos(u_time * 0.75));\n    float i6 = flower(vUv1, 6., 8.125 * cos(u_time * 0.75));\n    float i7 = flower(vUv1, 6., 6.0 * sin(u_time * 1.0));\n    float i8 = flower(vUv1, 6., 6.125 * sin(u_time * 1.0));\n    float x1 = i2 - i1;\n    float x2 = i4 - i3;\n    float x3 = i6 - i5;\n    float x4 = i8 - i7;\n    color += x1 + x1;\n    color += x2 + x2;\n    color += x3 + x3;\n    color += x4 + x4;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n\n    vUv1 = Rot(vUv1, u_time * 0.50);\n    vUv2 = Rot(vUv2, u_time * 0.75);\n    vUv3 = Rot(vUv3, u_time * 0.25);\n    vUv4 = Rot(vUv4, u_time * 1.00);\n    \n    float f1 = flower(vUv1, 4., 4.);\n    color.rg += f1 * sin(u_time);\n\n    float f2 = flower(vUv2, 4., 3.5);\n    color.g += f2 * 0.5 * abs(cos(u_time));\n\n    float f3 = flower(vUv3, 4., 3.);\n    color.r += f3 * 0.25 * abs(sin(u_time));\n\n    float f4 = flower(vUv4, 4., 2.5);\n    color.b += f4 * cos(u_time) * 0.25;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1.0 - smoothstep(size, size + 0.01, d);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vec2 vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time * 0.25);\n\n    vec2 vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time * 0.75);\n\n    vec2 vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time * 0.95);\n\n    vec2 vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time * 0.50);\n    \n    float p1 = polygon(vUv1, 6, 0.5);\n    float p2 = polygon(vUv2, 8, 0.5);\n    float p3 = polygon(vUv3, 7, 0.5);\n    float p4 = polygon(vUv4, 9, 0.5);\n\n    color += p1;\n    color.g -= p2;\n    color.b -= p3;\n    color.r -= p4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return smoothstep(size, size + 0.01, d);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vec2 vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time * 0.25);\n\n    vec2 vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time * 0.75);\n\n    vec2 vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time * 0.95);\n\n    vec2 vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time * 0.50);\n    \n    float p1 = polygon(vUv1, 6, 0.15);\n    float p2 = polygon(vUv2, 8, 0.25);\n    float p3 = polygon(vUv3, 7, 0.35);\n    float p4 = polygon(vUv4, 9, 0.45);\n\n    color -= p1 * cos(u_time);\n    color.g += p2 + cos(u_time);\n    color.b += p3 + sin(u_time);\n    color.r -= p4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.01 + 0.01, d);\n   return y - x;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5, vUv6;\n    vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time * 1.0);\n\n    vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time * 0.9);\n\n    vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time * 0.8);\n\n    vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time * 0.7);\n\n    vUv5 = vUv;\n    vUv5 = Rot(vUv5, u_time * 0.6);\n\n    vUv6 = vUv;\n    vUv6 = Rot(vUv6, u_time * 0.5);\n\n    float s1 = polygonOutline(vUv1, 6, 0.50);\n    float s2 = polygonOutline(vUv2, 6, 0.45);\n    float s3 = polygonOutline(vUv3, 6, 0.40);\n    float s4 = polygonOutline(vUv4, 6, 0.35);\n    float s5 = polygonOutline(vUv5, 6, 0.30);\n    float s6 = polygonOutline(vUv6, 6, 0.25);\n\n    color += s1 + s2 + s3 + s4 + s5 + s6;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    //vUv = vUv * 2. - 0.5;\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5, vUv6;\n    vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time * 1.0);\n\n    vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time * 0.9);\n\n    vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time * 0.8);\n\n    vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time * 0.7);\n\n    vUv5 = vUv;\n    vUv5 = Rot(vUv5, u_time * 0.6);\n\n    vUv6 = vUv;\n    vUv6 = Rot(vUv6, u_time * 0.5);\n\n    float s1 = polygonOutline(vUv1, 8, 0.5);\n    float s2 = polygonOutline(vUv2, 8, 0.4);\n    float s3 = polygonOutline(vUv3, 8, 0.3);\n    float s4 = polygonOutline(vUv4, 8, 0.2);\n    float s5 = polygonOutline(vUv5, 8, 0.1);\n    float s6 = polygonOutline(vUv6, 8, 0.025);\n\n    color += s1 + s2 + s3 + s4 + s5 + s6;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _D=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.0125, size + 0.125 + 0.01, d);\n   return y - x;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 0.5;\n    vec3 color = vec3(0.);\n\n    //vUv = vUv / 2. + 0.25;\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5, vUv6;\n    vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time + 1.0 * (2. * sin(u_time)));\n\n    vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time + 0.9 * (2. * sin(u_time)));\n\n    vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time + 0.8 * (2. * sin(u_time)));\n\n    vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time + 0.7 * (2. * sin(u_time)));\n\n    vUv5 = vUv;\n    vUv5 = Rot(vUv5, u_time + 0.6 * (2. * sin(u_time)));\n\n    vUv6 = vUv;\n    vUv6 = Rot(vUv6, u_time + 0.5 * (2. * sin(u_time)));\n\n    \n\n    float s1 = polygonOutline(vUv1, 3, 0.5);\n    float s2 = polygonOutline(vUv2, 3, 0.4);\n    float s3 = polygonOutline(vUv3, 3, 0.3);\n    float s4 = polygonOutline(vUv4, 3, 0.2);\n    float s5 = polygonOutline(vUv5, 3, 0.1);\n    float s6 = polygonOutline(vUv6, 3, 0.025);\n\n    color.r += s1 + s2 + s3 + s4 + s5 + s6 - 0.6 * (sin(u_time)/15.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function UD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_D,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.000005, size + 0.225 + 0.01, d);\n   return y - x;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 0.5;\n    vec3 color = vec3(0.);\n\n    //vUv = vUv / 2. + 0.25;\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5, vUv6;\n    vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time + 1.0 * (2. * sin(u_time)));\n\n    vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time + 0.9 * (2. * sin(u_time)));\n\n    vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time + 0.8 * (2. * sin(u_time)));\n\n    vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time + 0.7 * (2. * sin(u_time)));\n\n    vUv5 = vUv;\n    vUv5 = Rot(vUv5, u_time + 0.6 * (2. * sin(u_time)));\n\n    vUv6 = vUv;\n    vUv6 = Rot(vUv6, u_time + 0.5 * (2. * sin(u_time)));\n\n    \n\n    float s1 = polygonOutline(vUv1, 4, 0.5);\n    float s2 = polygonOutline(vUv2, 4, 0.4);\n    float s3 = polygonOutline(vUv3, 4, 0.3);\n    float s4 = polygonOutline(vUv4, 4, 0.2);\n    float s5 = polygonOutline(vUv5, 4, 0.1);\n    float s6 = polygonOutline(vUv6, 4, 0.025);\n\n    color.b += s1 + s2 + s3 + s4 + s5 + s6 - 0.6 * (sin(u_time)/15.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function SD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.000005, size + 0.225 + 0.01, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv / 2. + 0.25;\n    vec3 color = vec3(0.);\n\n    float x = blobOutline(vUv, 8., 0.5);\n    float y = blob(vUv, 8., 0.5);\n    color = vec3(x + y);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function MD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.000005, size + 0.225 + 0.01, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 vUv1, vUv2, vUv3, vUv4;\n    vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time * 0.75);\n\n    vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time * 1.00);\n\n    vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time * 0.50);\n\n    vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time * 1.25);\n\n    float y = spike(vUv1, 5, 0.5);\n    float x = spike(vUv2, 5, 0.25);\n    float z = spike(vUv3, 5, 0.75);\n    float a = spike(vUv4, 5, 0.05);\n    color += y + x + z + a;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function CD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// // float circle(vec2 vUv, float radius)\n// // {\n// //     vec2 dist = vUv - vec2(0.5);\n// //     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// // }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.521 + 0.01, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nvec2 scale(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 1.0) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 scale2(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 2.0) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 scale3(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 3.0) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 scale4(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 4.0) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 scale5(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 0.6) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    \n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vec2 vUv5 = vUv;\n    //vUv1 = Rot(vUv1, u_time * 0.5);\n    vUv2, vUv3, vUv4, vUv5 = vUv1;\n    vUv1 = scale(vUv1);\n    vUv2 = scale2(vUv2);\n    vUv3 = scale3(vUv3);\n    vUv4 = scale4(vUv4);\n    vUv5 = scale5(vUv5);\n    vec2 translate = vec2(cos(u_time), sin(u_time));\n    //vUv1 += translate * 0.25;\n\n    float s1 = polygonOutline(vUv1, 4, 0.15);\n\n    float s2 = polygonOutline(vUv2, 4, 0.25);\n\n    float s3 = polygonOutline(vUv3, 4, 0.35);\n\n    float s4 = polygonOutline(vUv4, 4, 0.45);\n\n    float s5 = polygonOutline(vUv5, 4, 0.55);\n\n    color += s1 + s2 + s3 + s4 + s5;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function RD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:TD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.521 + 0.01, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/3.);\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/3.);\n    float r2 = rect(vUv, size/3., size);\n    float r = r1 + r2;\n    float ra = rect(vUv, size + 0.01, size + 0.01/3.);\n    float rb = rect(vUv, size + 0.01, size + 0.02/3.);\n    float rn = ra + rb;\n    return rn - r;\n}\n\nvec2 scale(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 1.0) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5 = vUv;\n    vUv1 = vec2(vUv.x, vUv.y);\n    vUv2 = vec2(vUv.x, vUv.y);\n    vUv3 = vec2(vUv.x, vUv.y);\n    vUv4 = vec2(vUv.x, vUv.y);\n    vUv5 = vec2(vUv.x, vUv.y);\n\n    vUv1 = Rot(vUv1, u_time * 0.50);\n    vUv2 = Rot(vUv2, u_time * 0.45);\n    vUv3 = Rot(vUv2, u_time * 0.35);\n    vUv4 = Rot(vUv2, u_time * 0.25);\n    vUv5 = Rot(vUv2, u_time * 0.15);\n    vec2 translate = (vec2(cos(u_time), sin(u_time)));\n    vUv2 += translate *0.25;\n    vUv3 += translate *0.25;\n    vUv4 += translate *0.25;\n    vUv5 += translate *0.25;\n\n    float s1 = crossSDF(vUv1, 0.15);\n    float s2 = crossSDF(vUv2, 0.15);\n    float s3 = crossSDF(vUv3, 0.15);\n    float s4 = crossSDF(vUv4, 0.15);\n    float s5 = crossSDF(vUv5, 0.15);\n\n    color += s1 + s2 + s3 + s4 + s5;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function PD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:DD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.521 + 0.01, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5, vUv6, vUv7;\n\n    vUv1 = vUv;\n    vUv2 = vUv;\n    vUv3 = vUv;\n    vUv4 = vUv;\n    vUv5 = vUv;\n    vUv6 = vUv;\n    vUv7 = vUv;\n\n    vUv1 = scale(vUv1, sin(u_time * 0.5));\n    vUv2 = scale(vUv2, sin(u_time * 0.6));\n    vUv3 = scale(vUv3, sin(u_time * 0.7));\n    vUv4 = scale(vUv4, sin(u_time * 0.8));\n    vUv5 = scale(vUv5, sin(u_time * 0.9));\n    vUv6 = scale(vUv6, sin(u_time * 1.0));\n    vUv7 = scale(vUv7, sin(u_time * 1.1));\n\n    float c1 = crossSDFOutline(vUv1, 0.5 * 0.1);\n    float c2 = crossSDFOutline(vUv2, 0.5 * 0.2);\n    float c3 = crossSDFOutline(vUv3, 0.5 * 0.3);\n    float c4 = crossSDFOutline(vUv4, 0.5 * 0.4);\n    float c5 = crossSDFOutline(vUv5, 0.5 * 0.5);\n    float c6 = crossSDFOutline(vUv6, 0.5 * 0.6);\n    float c7 = crossSDFOutline(vUv7, 0.5 * 0.7);\n\n    color += c1 + c2 + c3 + c4 + c5 + c6 + c7;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function FD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ED=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// // float circle(vec2 vUv, float radius)\n// // {\n// //     vec2 dist = vUv - vec2(0.5);\n// //     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// // }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.02, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.15 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 5.);\n\n    float s1 = polygonOutline(vUv, 6, 1.);\n    float s2 = polygon(vUv, 6, 0.8);\n\n    color += s1 + s2;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ID(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ED,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// // float circle(vec2 vUv, float radius)\n// // {\n// //     vec2 dist = vUv - vec2(0.5);\n// //     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// // }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.02, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.15 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 5.);\n\n    float s1 = polygonOutline(vUv, 6, 1.);\n    float s2 = polygon(vUv, 6, 0.28);\n\n    color.r += 1. - s2;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function LD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:OD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.15 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 5.);\n\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n\n    vUv1 = Rot(vUv1, u_time * 0.25);\n    vUv2 = Rot(vUv2, -u_time * 0.95);\n\n    float s1 = polygonOutline(vUv1, 4, 0.75);\n    float s2 = polygon(vUv2, 4, 0.5);\n\n    color.r += s1 + s2 * vUv.x * vUv.y * 2.;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ND(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:AD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 1.);\n\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    \n    vUv2 = tile(vUv2, 3.);\n\n    vUv1 = Rot(vUv1, u_time * 0.25);\n    vUv2 = Rot(vUv2, -u_time * 0.5);\n\n    float s1 = blobOutline(vUv1, 0.15, 0.36);\n    float s2 = blobOutline(vUv2, 1.15, 1.);\n\n    color += s1 * vUv.x * vUv.y * 2.;\n    color += s2;\n\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function BD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:GD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.1, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    return vec3(str * shape );\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    float s1 = circle(vUv, 0.25);\n    vec3 mat = matrix(vUv, s1);\n\n    color = vec3(mat.x * 0.5 * abs(sin(u_time)), mat.y * 0.25 * abs(cos(u_time + 0.5)), mat.z * 0.1 );\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function VD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = Rot(vUv, u_time * 0.25);\n\n    float c1 = crossSDF(vUv, 0.6);\n    float s1 = circle(vUv, 0.25);\n    vec3 mat = matrix(vUv, c1);\n\n    color = vec3(mat);\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function HD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:WD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 3.);\n\n    vUv = Rot(vUv, u_time * 0.25);\n\n    float c1 = crossSDF(vUv, 0.61);\n    float s1 = circle(vUv, 0.25);\n    vec3 mat = matrix(vUv, c1);\n\n    color = vec3(mat.x * cos(u_time), mat.y, mat.z * sin(u_time));\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function YD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:XD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $D=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5, 0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = vUv * 2. - 1.;\n\n    float y = sdRoundedBox(vUv, vec2(0.5, 0.7), vec4(0.5, 0.0, 0.5, 0.0));\n    color += y;\n\n    float t1 =  polygon((vec2(vUv.x+0.86, vUv.y + 1.1)), 3, 0.3);\n\n    float t2 =  polygon((vec2(vUv.x+0.51, vUv.y + 1.1)), 3, 0.3);\n\n    float t3 =  polygon((vec2(vUv.x+0.16, vUv.y + 1.1)), 3, 0.3);\n\n    \n\n    color -= vec3(t1, 0.5, 0.5);\n    color -= vec3(t2, 0.5, 0.5);\n    color -= vec3(t3, 0.5, 0.5);\n\n    float c1 = circle(vec2(vUv.x+ 0.65, vUv.y + 0.2), 0.065);\n    float c2 = circle(vec2(vUv.x+ 0.65, vUv.y + 0.225), 0.065);\n\n    float c3 = circle(vec2(vUv.x+ 0.35, vUv.y + 0.2), 0.065);\n    float c4 = circle(vec2(vUv.x+ 0.35, vUv.y + 0.225), 0.065);\n\n    float c5 = circle(vec2(vUv.x+ 0.725 + ((sin(u_time)/12.) - 0.08), vUv.y + 0.2125), 0.0125);\n    float c6 = circle(vec2(vUv.x+ 0.425 + ((sin(u_time)/12.) - 0.08), vUv.y + 0.2125), 0.0125);\n\n    color += vec3(c1 + c2) * 2.;\n    color += vec3(c3 + c4) * 2.;\n\n    color *= 1. - vec3(c5 + c6);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ZD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$D,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5, 0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = vUv * 2. - 1.;\n\n    float y = sdRoundedBox(vUv, vec2(0.5, 0.7), vec4(0.5, 0.0, 0.5, 0.0));\n    \n\n    float t1 =  polygon((vec2(vUv.x+0.86 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t1 = smoothstep(0.01, 0.021, t1);\n    float t2 =  polygon((vec2(vUv.x+0.51 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t2 = smoothstep(0.01, 0.021, t2);\n    float t3 =  polygon((vec2(vUv.x+0.16 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t3 = smoothstep(0.01, 0.021, t3);\n    float t4 =  polygon((vec2(vUv.x-0.18 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t4 = smoothstep(0.01, 0.021, t4);\n    float t5 =  polygon((vec2(vUv.x+1.2 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t5 = smoothstep(0.01, 0.021, t5);\n    float t6 =  polygon((vec2(vUv.x+1.55 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t6 = smoothstep(0.01, 0.021, t6);\n    float t7 =  polygon((vec2(vUv.x-0.53 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t7 = smoothstep(0.01, 0.021, t7);\n    \n\n    \n\n    float c1 = circle(vec2(vUv.x+ 0.65, vUv.y + 0.2), 0.065);\n    float c2 = circle(vec2(vUv.x+ 0.65, vUv.y + 0.225), 0.065);\n    c1 = smoothstep(0.01, 0.03, c1);\n    c2 = smoothstep(0.01, 0.03, c2);\n    float c3 = circle(vec2(vUv.x+ 0.35, vUv.y + 0.2), 0.065);\n    float c4 = circle(vec2(vUv.x+ 0.35, vUv.y + 0.225), 0.065);\n    c3 = smoothstep(0.01, 0.03, c3);\n    c4 = smoothstep(0.01, 0.03, c4);\n    float c5 = circle(vec2(vUv.x+ 0.725 + ((sin(u_time)/12.) - 0.08), vUv.y + 0.2125), 0.0125);\n    float c6 = circle(vec2(vUv.x+ 0.425 + ((sin(u_time)/12.) - 0.08), vUv.y + 0.2125), 0.0125);\n    c5 = smoothstep(0.01, 0.03, c5);\n    c6 = smoothstep(0.01, 0.03, c6);\n    \n    \n    color = vec3(y, y * 0.75, 0.);\n    color += vec3(c1 + c2) * 2.;\n    color += vec3(c3 + c4) * 2.;\n    color *= 1. - vec3(c5 + c6);\n\n    color -= vec3(t1);\n    color -= vec3(t2);\n    color -= vec3(t3);\n    color -= vec3(t4);\n    color -= vec3(t5);\n    color -= vec3(t6);\n    color -= vec3(t7);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function JD(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:KD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QD=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5, 0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvec2 rotatedTilepattern(vec2 st)\n{\n    st *= 2.0;\n    float index = 0.0;\n    index += step(1., mod(st.x, 2.0));\n    index += step(1., mod(st.y, 2.0)) * 2.0;\n    st = fract(st);\n    if(index == 1.0){\n        st = Rot(st, PI * 0.5);\n    } else if (index == 2.0){\n        st = Rot(st, PI * -0.5);\n    } else if (index == 3.0){\n        st = Rot(st, PI);\n    }\n    return st;\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 3.);\n\n    vUv = rotatedTilepattern(vUv * 1.);\n\n    vUv = Rot(vUv, PI * u_time * 0.25);\n\n    float x = smoothstep(vUv.x, vUv.y, 0.01);\n    x = smoothstep(0.01, 0.04, x);\n\n    color = vec3(x);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:QD,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eP=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5, 0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvec2 rotatedTilepattern(vec2 st)\n{\n    st *= 4.0;\n    float index = 0.0;\n    index += step(1., mod(st.x, 2.0));\n    index += step(1., mod(st.y, 2.0)) * 2.0;\n    st = fract(st);\n    if(index == 1.0){\n        st = Rot(st, PI * 0.5);\n    } else if (index == 2.0){\n        st = Rot(st, PI * -0.5);\n    } else if (index == 3.0){\n        st = Rot(st, PI);\n    }\n    return st;\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 1.);\n\n    vUv = rotatedTilepattern(vUv);\n\n    vUv = Rot(vUv, PI * u_time * 0.25);\n\n    float x = polygonOutline(vUv, 4, 0.35);\n    x = smoothstep(0.01, 0.02, x);\n\n    color = vec3(x);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:eP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rP=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5, 0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvec2 rotatedTilepattern(vec2 st)\n{\n    st *= 4.0;\n    float index = 0.0;\n    index += step(1., mod(st.x, 2.0));\n    index += step(1., mod(st.y, 2.0)) * 2.0;\n    st = fract(st);\n    if(index == 1.0){\n        st = Rot(st, PI * 0.5);\n    } else if (index == 2.0){\n        st = Rot(st, PI * -0.5);\n    } else if (index == 3.0){\n        st = Rot(st, PI);\n    }\n    return st;\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float val1 = (sin(u_time * 0.5)/2.);\n    float val2 = (sin(u_time * 1.0)/3.);\n    float val3 = (sin(u_time * 1.5)/4.);\n    float val4 = (sin(u_time * 2.0)/5.);\n\n    float x = sdRoundedBox(vUv, vec2(0.5, 0.5), vec4(0.0 + val1, 0.0 + val2, 0.0 + val3, 0.0 + val4));\n\n    color = vec3(x);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function oP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aP=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //iquilezles.org/articls/distfunctions2d\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\n// float sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n// {\n//     //x - thickness\n//     float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n//     float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n//     return (c - a);\n// }\n\n// float sdBox(vec2 p, vec2 b)\n// {\n//     //p - point \n//     //b -\n//     p = p * 2.0 - 1.; \n//     vec2 d = abs(p) - b;\n//     float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n//     float y = length(max(d, 0.0)) + min(max(d.x + 0.01, d.y + 0.01), 0.0);\n//     return smoothstep(0.01, 0.11, y / x);\n// }\n\n// float sdCircle(vec2 p, float r)\n// {\n//     p = p * 2.0 - 1.;\n//     float x = length(p) - r;\n//     return 1. - smoothstep(0.01, 0.02, x);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float val1 = (sin(u_time * 0.5)/2.);\n    float val2 = (sin(u_time * 1.0)/3.);\n    float val3 = (sin(u_time * 1.5)/4.);\n    float val4 = (sin(u_time * 2.0)/5.);\n\n    float x = sdRoundedBox(vec2(vUv.x, vUv.y + 0.125), vec2(0.2, 0.125), vec4(0.0, 0.14, 0.0, 0.14));\n    float x1 = sdRoundedBox(vec2(vUv.x, vUv.y + 0.125), vec2(0.15 * (sin(u_time)/5. + 1.), 0.08), vec4(0.0, 0.08, 0.0, 0.08));\n    float y = sdRoundedBoxOutline(vUv, vec2(0.4, 0.45), vec4(0.1, 0.25, 0.1, 0.25), 0.02);\n    float z = sdCircle(vec2(vUv.x - 0.1, vUv.y - 0.1), 0.1);\n    float z1 = sdCircle(vec2(vUv.x - 0.1, vUv.y - 0.1), 0.05);\n    float a = sdCircle(vec2(vUv.x + 0.1, vUv.y - 0.1), 0.1);\n    float a1 = sdCircle(vec2(vUv.x + 0.1, vUv.y - 0.1), 0.05);\n\n    color = vec3(x + y + z + a);\n    color -= z1 + a1 + x1;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function iP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:aP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vP=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //iquilezles.org/articls/distfunctions2d\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\n// float sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n// {\n//     //x - thickness\n//     float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n//     float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n//     return (c - a);\n// }\n\n// float sdBox(vec2 p, vec2 b)\n// {\n//     //p - point \n//     //b -\n//     p = p * 2.0 - 1.; \n//     vec2 d = abs(p) - b;\n//     float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n//     float y = length(max(d, 0.0)) + min(max(d.x + 0.01, d.y + 0.01), 0.0);\n//     return smoothstep(0.01, 0.11, y / x);\n// }\n\n// float sdCircle(vec2 p, float r)\n// {\n//     p = p * 2.0 - 1.;\n//     float x = length(p) - r;\n//     return 1. - smoothstep(0.01, 0.02, x);\n// }\n\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p-a;\n//     vec2 ba = b-a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 1.;\n    vec2 vUv2 = vUv;\n    vUv2 = Rot(vUv2, PI * 0.5 );\n    vec3 color = vec3(0.);\n    float y =1. - smoothstep(0.01, 0.014, sdSegment(vec2(vUv.x, vUv.y), vec2(0.75 + (sin(u_time)/3.)), vec2(-0.75 + (cos(u_time)/3.))));\n    float x = sdSegment(vec2(vUv.x, vUv.y), vec2(0.75 + (sin(u_time)/3.)), vec2(-0.75 + (cos(u_time)/3.)));\n    float y1 =1. - smoothstep(0.01, 0.014, sdSegment(vec2(vUv2.x, vUv2.y), vec2(0.75 + (cos(u_time)/3.)), vec2(-0.75 + (cos(u_time)/3.))));\n    float x1 = sdSegment(vec2(vUv2.x, vUv2.y), vec2(0.75 + (sin(u_time)/4.)), vec2(-0.75 + (cos(u_time)/4.)));\n    color.g += y;\n    color.r += y1;\n    color.g += x;\n    color.r += x1;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lP=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //iquilezles.org/articls/distfunctions2d\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\n// float sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n// {\n//     //x - thickness\n//     float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n//     float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n//     return (c - a);\n// }\n\n// float sdBox(vec2 p, vec2 b)\n// {\n//     //p - point \n//     //b -\n//     p = p * 2.0 - 1.; \n//     vec2 d = abs(p) - b;\n//     float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n//     float y = length(max(d, 0.0)) + min(max(d.x + 0.01, d.y + 0.01), 0.0);\n//     return smoothstep(0.01, 0.11, y / x);\n// }\n\n// float sdCircle(vec2 p, float r)\n// {\n//     p = p * 2.0 - 1.;\n//     float x = length(p) - r;\n//     return 1. - smoothstep(0.01, 0.02, x);\n// }\n\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p-a;\n//     vec2 ba = b-a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\n// float ndot(vec2 a, vec2 b)\n// {\n//     return a.x * b.x - a.y * b.y;\n// }\n\n// float sdRhombus(vec2 p, vec2 b)\n// {\n//     p = abs(p);\n//     float h = clamp(ndot(b-2. *p, b) / dot(b, b), -1., 1.);\n//     float d = length(p - 0.5* b*vec2(1.0-h, 1.0+h));\n//     return d * sign(p.x * b.y + p.y * b.x - b.x*b.y);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    vec2 vUv2 = vUv;\n    vUv2 = Rot(vUv2, PI * 0.5 );\n    float x = sdRhombus(vUv, vec2(0.5 * (sin(u_time)/4. + 1.), 0.75 * (sin(u_time)/4. + 1.)));\n    float x1 = sdRhombus(vUv, vec2(0.5 * (sin(u_time)/4. + 1.), 0.75 * (sin(u_time)/4. + 1.)));\n    float y = sdRhombus(vec2(vUv.x, vUv.y - 0.05), vec2(0.5 * (sin(u_time)/4. + 1.), 0.25 * (sin(u_time)/4. + 1.)));\n    float y1 = sdRhombus(vec2(vUv.x, vUv.y), vec2(0.5 * (sin(u_time)/4. + 1.), 0.25 * (sin(u_time)/4. + 1.)));\n    color.g = 1. -  smoothstep(0.01, 0.014, x);\n    color.b -= 1. - smoothstep(0.01, 0.014, y);\n    color.br += x1;\n    color.rgb += 1. - smoothstep(0.01, 0.014, y1);\n    \n    color -= step(0., vUv.x) * 0.1;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uP=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //iquilezles.org/articls/distfunctions2d\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\n// float sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n// {\n//     //x - thickness\n//     float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n//     float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n//     return (c - a);\n// }\n\n// float sdBox(vec2 p, vec2 b)\n// {\n//     //p - point \n//     //b -\n//     p = p * 2.0 - 1.; \n//     vec2 d = abs(p) - b;\n//     float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n//     float y = length(max(d, 0.0)) + min(max(d.x + 0.01, d.y + 0.01), 0.0);\n//     return smoothstep(0.01, 0.11, y / x);\n// }\n\n// float sdCircle(vec2 p, float r)\n// {\n//     p = p * 2.0 - 1.;\n//     float x = length(p) - r;\n//     return 1. - smoothstep(0.01, 0.02, x);\n// }\n\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p-a;\n//     vec2 ba = b-a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\n// float ndot(vec2 a, vec2 b)\n// {\n//     return a.x * b.x - a.y * b.y;\n// }\n\n// float sdRhombus(vec2 p, vec2 b)\n// {\n//     p = abs(p);\n//     float h = clamp(ndot(b-2. *p, b) / dot(b, b), -1., 1.);\n//     float d = length(p - 0.5* b*vec2(1.0-h, 1.0+h));\n//     return d * sign(p.x * b.y + p.y * b.x - b.x*b.y);\n// }\n\n// float dot2(vec2 a)\n// {\n//     return dot(a.x, a.y);\n// }\n\n// float trapezoid(vec2 p, float r1, float r2, float he)\n// {\n//     vec2 k1 = vec2(r2, he);\n//     vec2 k2 = vec2(r2-r1, 2.0 * he);\n//     p.x = abs(p.x);\n//     vec2 ca = vec2(p.x-min(p.x, (p.y<0.)?r1:r2), abs(p.y)-he);\n//     vec2 cb = p - k1 + k2 * clamp(dot(k1-p,k2)/dot2(k2), 0., 1.);\n//     float s = (cb.x < 0. && ca.y<0.)? -1.: 1.;\n//     return s*sqrt(min(dot(ca, ca),dot(cb, cb)));\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 15. - 7.5;\n    vec3 color = vec3(0.);\n    vUv = Rot(vUv, (u_time));\n    float x =1. - trapezoid(vUv, 0.8, 0.2, 2. + sin(u_time));\n    x = smoothstep(0.01, 0.081, x);\n    color += x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pP=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n    //iquilezles.org/articls/distfunctions2d\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\n// float sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n// {\n//     //x - thickness\n//     float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n//     float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n//     return (c - a);\n// }\n\n// float sdBox(vec2 p, vec2 b)\n// {\n//     //p - point \n//     //b -\n//     p = p * 2.0 - 1.; \n//     vec2 d = abs(p) - b;\n//     float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n//     float y = length(max(d, 0.0)) + min(max(d.x + 0.01, d.y + 0.01), 0.0);\n//     return smoothstep(0.01, 0.11, y / x);\n// }\n\n// float sdCircle(vec2 p, float r)\n// {\n//     p = p * 2.0 - 1.;\n//     float x = length(p) - r;\n//     return 1. - smoothstep(0.01, 0.02, x);\n// }\n\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p-a;\n//     vec2 ba = b-a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\n// float ndot(vec2 a, vec2 b)\n// {\n//     return a.x * b.x - a.y * b.y;\n// }\n\n// float sdRhombus(vec2 p, vec2 b)\n// {\n//     p = abs(p);\n//     float h = clamp(ndot(b-2. *p, b) / dot(b, b), -1., 1.);\n//     float d = length(p - 0.5* b*vec2(1.0-h, 1.0+h));\n//     return d * sign(p.x * b.y + p.y * b.x - b.x*b.y);\n// }\n\n// float dot2(vec2 a)\n// {\n//     return dot(a.x, a.y);\n// }\n\n// float trapezoid(vec2 p, float r1, float r2, float he)\n// {\n//     vec2 k1 = vec2(r2, he);\n//     vec2 k2 = vec2(r2-r1, 2.0 * he);\n//     p.x = abs(p.x);\n//     vec2 ca = vec2(p.x-min(p.x, (p.y<0.)?r1:r2), abs(p.y)-he);\n//     vec2 cb = p - k1 + k2 * clamp(dot(k1-p,k2)/dot2(k2), 0., 1.);\n//     float s = (cb.x < 0. && ca.y<0.)? -1.: 1.;\n//     return s*sqrt(min(dot(ca, ca),dot(cb, cb)));\n// }\n\n// float sdEqTriangle(vec2 p, float size)\n// {\n//     p = p / size;\n//     float k = sqrt(3.);\n//     p.x = abs(p.x) - 1.;\n//     p.y = p.y + 1.0/k;\n//     if(p.x+k*p.y > 0.)\n//     {\n//         p = vec2(p.x-k*p.y, -k*p.x-p.y)/2.0; \n//     }\n//     p.x -= clamp(p.x, -2., 0.);\n//     return -length(p) * sign(p.y);\n// }\n\n// float sdEqTriangleOutline(vec2 p, float size)\n// {\n//     float x = 1. - sdEqTriangle(p, size);\n//     float y = 1. - sdEqTriangle(p, size + 0.025);\n//     x = smoothstep(0.01, 0.021, x);\n//     y = smoothstep(0.01, 0.021, y);\n//     return y - x;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5. - 2.5;\n    vec3 color = vec3(0.);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vUv1 = Rot(vUv1, (u_time));\n    vUv2 = Rot(vUv2, (u_time));\n    vUv3 = Rot(vUv3, (u_time));\n    // vUv = Rot(vUv, (u_time));\n    float x = sdEqTriangleOutline(vUv1, 0.4);\n    float y = sdEqTriangleOutline(vUv2, 0.25);\n    float z = sdEqTriangleOutline(vUv3, 0.125);\n    //x = smoothstep(0.01, 0.021, x);\n    color += x + y + z ;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mP=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n        void main()\n        {\n            vec2 vUv = vec2(vUv.x, vUv.y);\n            vUv = vUv * 2.;\n            //vUv.y -= 0.25;\n            vec2 vUv2 = vUv;\n            vUv2 -= 1.;\n            vUv2 = Rot(vUv2, PI);\n            vec3 color = vec3(0.);\n            float y = sdTriIsosceles(vUv, vec2(0.25 +(sin(u_time)/4.), 0.5 +(cos(u_time)/4.)));\n            float x = sdTriIsosceles(vUv2, vec2(0.25 +(cos(u_time)/4.), 0.5 +(sin(u_time)/4.)));\n            y = 1. - smoothstep(0.01, 0.021, y);\n            x = 1. - smoothstep(0.01, 0.021, x);\n            color += y;\n            color += x;\n            gl_FragColor = vec4(color, 1.);\n        }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xP=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = vUv * 2.;\n    \n    //vUv.y -= 0.25;\n    vec2 vUv2 = vUv;\n    vUv2 -= 1.;\n    vec2 vUv3 = vUv;\n    vUv3 -= 1.;\n    vUv3.y += 1.;\n    vec2 vUv4 = vUv;\n    vUv4 -= 1.;\n    vUv4.x += 1.;\n    vUv2 = Rot(vUv2, PI);\n    vUv3 = Rot(vUv3, PI * 0.5);\n    \n    vUv4 = Rot(vUv4, PI * -0.5);\n    vec3 color = vec3(0.);\n    float y = sdTriIsosceles(vUv, vec2(0.25 +(sin(u_time)/4.), 0.5 +(cos(u_time)/4.)));\n    float x = sdTriIsosceles(vUv2, vec2(0.25 +(cos(u_time)/4.), 0.5 +(sin(u_time)/4.)));\n    float y2 = sdTriIsosceles(vUv3, vec2(0.25 +(cos(u_time)/4.), 0.5 +(sin(u_time)/4.)));\n    float x2 = sdTriIsosceles(vUv4, vec2(0.25 +(sin(u_time)/4.), 0.5 +(cos(u_time)/4.)));\n    y = 1. - smoothstep(0.01, 0.021, y);\n    x = 1. - smoothstep(0.01, 0.021, x);\n    y2 = 1. - smoothstep(0.01, 0.021, y2);\n    x2 = 1. - smoothstep(0.01, 0.021, x2);\n    color.g += y + y2;\n    color.r += x + x2;\n    gl_FragColor = vec4(color, 1.);\n}\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yP=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 onevUv = vUv;\n    vec2 vUvy2 = vUv;\n    vUv = vUv * 2. - 0.5;\n    vec2 twovUv = vUv;\n    twovUv = twovUv * 2. - 1.;\n    twovUv.x -= 0.5;\n    \n    onevUv = Rot(onevUv, PI * -0.25);\n    float one = sdRoundedBox(vec2(vUv.x + 0.275, vUv.y), vec2(0.17, 0.85), vec4(0.1, 0.1, 0.1, 0.1));\n    float oneP = sdRoundedBox(vec2(onevUv.x + 0.24, onevUv.y + 0.05), vec2(0.07, 0.2), vec4(0.1, 0.075, 0.1, 0.075));\n    \n    // color += one;\n    float a = PI * (0.5 + 0.25);\n    float b = 0.2 *(0.5 + 0.5);\n    twovUv = Rot(twovUv, PI * 1.85);\n    float y1 = sdArc(vec2(twovUv.x - 0.1, twovUv.y - 0.15), vec2(a * 0.8, a * 0.8), .35, b * 0.84 );\n    y1 = smoothstep(0.0, 0.015, y1); //yellow\n    vUvy2 = Rot(vUvy2, PI * -0.22);\n    float y2 = sdRoundedBox(vec2(vUvy2.x - 0.122, vUvy2.y - 0.05), vec2(0.075, 0.35), vec4(0.2, 0.1, 0.1, 0.1));\n    float y3 = sdRoundedBox(vec2(vUv.x - 0.25, vUv.y + 0.335), vec2(0.5, 0.155), vec4(0.1, 0.1, 0.1, 0.1));\n    color += y1;\n    color -= one;\n    color -= y2;\n    color -= y3; \n    color -= oneP;\n    gl_FragColor = vec4(color, 1.);\n}\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _P=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        // vUv = vUv * 2. - 0.5;\n        float one = sdOne(vec2(vUv.x + 0.35, vUv.y));\n        // color += one;\n        float two = sdTwo(vec2(vUv.x + 0.05, vUv.y));\n        // color += two;\n        float three = sdThree(vec2(vUv.x, vUv.y));\n        color += three;\n        // color += one;\n        // color += two;\n\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function UP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_P,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wP=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = vUv * 2. - 0.5;\n        float one = sdOne(vec2(vUv.x + 0.5 * sin(u_time), vUv.y - 0.5 * cos(u_time)));\n        color += one;\n        float two = sdTwo(vec2(vUv.x + 0.5 * sin(u_time), vUv.y + 0.5 * cos(u_time)));\n        color += two;\n        float three = sdThree(vec2(vUv.x - 0.5 * cos(u_time), vUv.y - 0.5 * sin(u_time)));\n        color += three;\n        float four = sdFour(vec2(vUv.x - 0.5 * cos(u_time), vUv.y + 0.5 * sin(u_time)));\n        color += four;\n\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function SP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kP=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = vUv * 2. - 0.5;\n        float one = sdOne(vec2(vUv.x + 0.5 * sin(u_time), vUv.y - 0.5 * cos(u_time)));\n        color += one;\n        float two = sdTwo(vec2(vUv.x + 0.5 * sin(u_time), vUv.y + 0.5 * cos(u_time)));\n        color += two;\n        float three = sdThree(vec2(vUv.x - 0.5 * cos(u_time), vUv.y - 0.5 * sin(u_time)));\n        color += three;\n        float four = sdFour(vec2(vUv.x - 0.5 * cos(u_time), vUv.y + 0.5 * sin(u_time)));\n        color += four;\n        float five = sdFive(vec2(vUv.x + (sin(u_time)*0.5), vUv.y));\n        color += five;\n\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function MP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zP=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    float randFloat(float x){\n        return fract(sin(x) * 4748393.7585);\n    }\n    \n    float randVec2(vec2 vUv){\n        return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n    }\n    \n    vec3 matrix(vec2 vUv){\n        float rows = 15.0;\n        vec2 a = floor(vUv * rows);\n        a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n        vec2 b = fract(vUv * rows);\n        vec2 newUv = 0.5 - b;\n        float str = randVec2(a);\n        float one = sdOne(b);\n        float zero = sdZero(b);\n        float shape;\n        if(str > .5 )\n        {\n            shape = smoothstep(0.01, 0.011, one);\n        } else {\n            shape = smoothstep(0.01, 0.011, zero);\n        }\n        \n        return vec3(shape * str );\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        // vUv = vUv * 2. - 0.5;\n        float one = sdOne(vec2(vUv.x , vUv.y ));\n        // color += one;\n        float zero = sdZero(vUv);\n        // color += zero;\n        // float two = sdTwo(vec2(vUv.x + 0.5 * sin(u_time), vUv.y + 0.5 * cos(u_time)));\n        // color += two;\n        // float three = sdThree(vec2(vUv.x - 0.5 * cos(u_time), vUv.y - 0.5 * sin(u_time)));\n        // color += three;\n        // float four = sdFour(vec2(vUv.x - 0.5 * cos(u_time), vUv.y + 0.5 * sin(u_time)));\n        // color += four;\n        // float five = sdFive(vec2(vUv.x + (sin(u_time)*0.5), vUv.y));\n        // color += five;\n        vec3 m = matrix(vUv);\n        color.g += m.x * 1.5;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function CP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TP=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float randFloat(float x){\n        return fract(sin(x) * 4748393.7585);\n    }\n    \n    float randVec2(vec2 vUv){\n        return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n    }\n    \n    vec3 matrix(vec2 vUv){\n        float rows = 8.0;\n        vec2 a = floor(vUv * rows);\n        a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n        vec2 b = fract(vUv * rows);\n        vec2 newUv = 0.5 - b;\n        float str = randVec2(a);\n        float shape;\n        float zero = sdZero(b);\n        float one = sdOne(b);\n        float two = sdTwo(b);\n        float three = sdThree(b);\n        float four = sdFour(b);\n        float five = sdFive(b);\n        float six = sdSix(b);\n         if(str > 0.0 && str < 0.1 ){\n            shape = smoothstep(0.01, 0.011, zero);\n        }if(str > 0.1 && str < 0.2 ) {\n            shape = smoothstep(0.01, 0.011, one);\n        }if(str > 0.2 && str < 0.3 ) {\n            shape = smoothstep(0.01, 0.011, two);\n        }if(str > 0.3 && str < 0.4 ) {\n            shape = smoothstep(0.01, 0.011, three);\n        }if(str > 0.4 && str < 0.5 ) {\n            shape = smoothstep(0.01, 0.011, four);\n        }if(str > 0.5 && str < 0.6 ) {\n            shape = smoothstep(0.01, 0.011, five);\n        }if(str > 0.6 && str < 0.7 ) {\n            shape = smoothstep(0.01, 0.011, six);\n        }if(str > 0.7 && str < 0.8 ) {\n            shape = smoothstep(0.01, 0.011, two);\n        }if(str > 0.8 && str < 0.9 ) {\n            shape = smoothstep(0.01, 0.011, three);\n        }if(str > 0.9 && str < 1.0 ) {\n            shape = smoothstep(0.01, 0.011, four);\n        }\n        \n        return vec3(shape * str );\n    }\n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec3 m = matrix(vUv);\n        m.x *= sin(u_time * 0.25);\n        m.y *= cos(u_time * 0.25);\n        color = m * 2.5;\n       \n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function RP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:TP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DP=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float randFloat(float x){\n        return fract(sin(x) * 4748393.7585);\n    }\n    \n    float randVec2(vec2 vUv){\n        return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n    }\n    \n    vec3 matrix(vec2 vUv){\n        float rows = 15.0;\n        vec2 a = floor(vUv * rows);\n        a += vec2(1., floor(u_time * 6. * randFloat(a.x)));\n        vec2 b = fract(vUv * rows);\n        vec2 newUv = 0.5 - b;\n        float str = randVec2(a);\n        float shape;\n        float zero = sdZero(b);\n        float one = sdOne(b);\n        float two = sdTwo(b);\n        float three = sdThree(b);\n        float four = sdFour(b);\n        float five = sdFive(b);\n        float six = sdSix(b);\n        float seven = sdSeven(b);\n        float eight = sdEight(b);\n        float nine = sdNine(b);\n         if(str >= 0.0 && str < 0.1 ){\n            shape = zero;\n        }if(str >= 0.1 && str < 0.2 ) {\n            shape = one;\n        }if(str >= 0.2 && str < 0.3 ) {\n            shape = two;\n        }if(str >= 0.3 && str < 0.4 ) {\n            shape = three;\n        }if(str >= 0.4 && str < 0.5 ) {\n            shape = four;\n        }if(str >= 0.5 && str < 0.6 ) {\n            shape = five;\n        }if(str >= 0.6 && str < 0.7 ) {\n            shape = six;\n        }if(str >= 0.7 && str < 0.8 ) {\n            shape = seven;\n        }if(str >= 0.8 && str < 0.9 ) {\n            shape = eight;\n        }if(str >= 0.9 && str < 1.0 ) {\n            shape = nine;\n        }\n        return vec3(shape);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec3 m = matrix(vUv);\n        // m.x *= sin(u_time * 0.25) + 2.;\n        // m.y *= cos(u_time * 0.25) ;\n        color = m;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function PP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:DP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jP=new Va({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:Hh+Xh+Wh+"\n\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdTwo(vec2(p.x, p.y));\n        float right = sdFive(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    float hexagramOutline(vec2 p, float size)\n    {\n        float x = sdHexagram(p, size);\n        x = 1. - smoothstep(0.01, 0.02, x);\n        float y = sdHexagram(p, size * 0.95);\n        y = 1. - smoothstep(0.01, 0.02, y);\n        return x - y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time);\n        newUv = newUv * 2. - 1.;\n        vec2 uv2 = newUv;\n        uv2 *= ((sin(u_time) / 1.25) - 2.);\n        float hexagram = sdHexagram(newUv, 0.25);\n        hexagram = 1. - smoothstep(0.01, 0.02, hexagram);\n        color += hexagram;\n        float hexOutline = hexagramOutline(newUv, 0.28);\n        color += hexOutline;\n        float hexOutline2 = hexagramOutline(uv2, 0.2);\n        color -= hexOutline2;\n        float shaderLabel = label(vUv);\n        color += shaderLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function FP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EP=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdTwo(vec2(p.x, p.y));\n        float right = sdSix(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 vUv2 = vUv;\n        float s1 = sdSegment(vUv, vec2(0.5 + (sin(u_time)/2.5),0.5 + (cos(u_time) / 2.5)), vec2(0.5, 0.5));\n        float s2 = sdSegment(vUv2, vec2(0.5 + (sin(u_time * 0.5)/5.), 0.5 + (cos(u_time * 0.5) / 5.)), vec2(0.5, 0.5));\n        s1 = 1. - smoothstep(0.01, 0.012, s1);\n        s2 = 1. - smoothstep(0.01, 0.012, s2);\n        color.r += s1;\n        color.g += s2;\n        float shaderLabel = label(vUv);\n        color += shaderLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function IP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:EP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OP=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdTwo(vec2(p.x, p.y));\n        float right = sdSeven(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 evUv = vUv;\n        evUv = evUv * 2. - 1.;\n        float e1 = sdEgg(evUv, 0.5, 0.25);\n        e1 = 1. - smoothstep(0.01, 0.02, e1);\n        color += e1;\n\n        float s1 = sdSegment(vUv, vec2(0.45, 0.5), vec2(0.45, 0.1));\n        float s2 = sdSegment(vUv, vec2(0.55, 0.5), vec2(0.55, 0.1));\n        s1 = 1. - smoothstep(0.01, 0.015, s1);\n        s2 = 1. - smoothstep(0.01, 0.015, s2);\n        color += s1 + s2;\n\n        float numberLabel = label(vUv);\n        color += numberLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function LP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:OP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AP=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdTwo(vec2(p.x, p.y));\n        float right = sdEight(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 5. - 2.5;\n        p.y -= 1.25;\n        p.x += 0.5;\n        float c;\n        float steps = 15.;\n        for(float i = 1.; i < steps; i++)\n        {\n            c += sdCircle(vec2(p.x  + i/ 4. * (sin(u_time * i * 0.25)), p.y + i / 4. ), a);\n        }\n        \n        return c;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float x = newfunc(vUv, 0.25);\n        color += x;\n        float num = label(vUv);\n        color += num;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function NP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:AP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GP=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdTwo(vec2(p.x, p.y));\n        float right = sdNine(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 8. - 4.;\n        //p.y -= 1.25;\n        p.x += 0.5;\n        p.y += 0.5;\n        float c;\n        float steps = 25.;\n        for(float i = 1.; i < steps; i++)\n        {\n            c += sdCircle(vec2(p.x  + i/ 4. * (sin(u_time * i * 0.25)), p.y + i / 12. * (cos(u_time * i * 0.25)) ), a);\n        }\n        return c;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        float y = newfunc(vUv, 0.25);\n        color += y;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function BP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:GP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qP=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdZero(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n    float sdCircleHighlight(vec2 p, float r)\n    {\n        p = p * 2.0 - 1.;\n        float x = length(p) - r;\n        return 1. - smoothstep(0.01, 1.5, x);\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 8. - 4.;\n        //p.y -= 1.25;\n        p.x += 0.5;\n        p.y += 0.5;\n        float c;\n        float d;\n        float e;\n        float f;\n        float steps = 25.;\n        for(float i = 1.; i < steps; i++)\n        {\n            c += sdCircle(vec2(p.x  + i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y + i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n            d += sdCircle(vec2(p.x  - i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y - i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n            e += sdCircleHighlight(vec2(p.x  + i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y + i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n            f += sdCircleHighlight(vec2(p.x  - i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y - i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n        }\n        e *= 0.25;\n        f *= 0.25;\n        return c + d + e + f ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        gl_FragColor = vec4(color, 1.);\n    } \n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function VP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WP=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdOne(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n    \n    float newfunc(vec2 p, float a)\n    {\n        p = p * 8. - 4.;\n        // //p.y -= 1.25;\n        p.x += 0.5;\n        p.y += 0.5;\n        p*= 0.5;\n        // float c;\n        // float d;\n        // float steps = 25.;\n        // for(float i = 1.; i < steps; i++)\n        // {\n        //     c += sdCircle(vec2(p.x  + i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y + i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n        //     d += sdCircle(vec2(p.x  - i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y - i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n            \n        // }\n        // return c + d;\n        float b;\n        float steps = 30.;\n        for(float i = 1.; i<steps; i++)\n        {\n            b += sdSegment(vec2(p.x, p.y), vec2(0.25 + i/20. * (cos(u_time * i * 0.015)) , 0.25 + i/20. * (sin(u_time * i * 0.05)) ), vec2(0.75 + i/20. * (cos(u_time * i * 0.025)), 0.75 + i/20. * (sin(u_time * i * 0.05)) ));\n            \n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function HP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:WP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XP=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdTwo(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 12. - 6.;\n        // //p.y -= 1.25;\n        // p.x += 0.5;\n        // p.y += 0.5;\n        p*= 0.5;\n        float b;\n        float steps = 25.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            b += sdEqTriangleOutline(vec2(p.x + i / 10. * sin(u_time + i / 5. ), p.y + i / 10. * cos(u_time + i / 10.)), a);\n            b += sdEqTriangleOutline(vec2(p.x - i / 10. * sin(u_time + i / 5. ), p.y + i / 10. * cos(u_time + i / 10.)), a);\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function YP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:XP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $P=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdThree(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 12. - 6.;\n        // //p.y -= 1.25;\n        p.x += 1.;\n        p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 25.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            b += sdCircleOutline(vec2(p.x + i / 10. * sin(u_time + i / 5. ), p.y + i / 10. * cos(u_time + i / 10.)), a);\n            b += sdCircleOutline(vec2(p.x - i / 10. * sin(u_time + i / 5. ), p.y + i / 10. * cos(u_time + i / 10.)), a);\n            b += sdCircleOutline(vec2(p.x + i / 10. * cos(u_time + i / 5. ), p.y + i / 10. * sin(u_time + i / 10.)), a);\n            b += sdCircleOutline(vec2(p.x - i / 10. * cos(u_time + i / 5. ), p.y + i / 10. * sin(u_time + i / 10.)), a);\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    } \n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ZP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$P,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KP=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdFour(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 100. - 50.;\n        // //p.y -= 1.25;\n        p.x += 1.;\n        p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 25.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, sin(u_time * i/1.));\n            b += 1. - sdBox(vec2(p.x + i + sin(u_time * i), p.y + sin(u_time * i)), vec2(1.5, 0.5));\n            b += 1. - sdBox(vec2(p.x - i + cos(u_time * i), p.y + sin(u_time * i)), vec2(1.5, 0.5));\n            b += 1. - sdBox(vec2(p.x + sin(u_time * i), p.y + i + cos(u_time * i)), vec2(0.5, 1.5));\n            b += 1. - sdBox(vec2(p.x + sin(u_time * i) , p.y - i + sin(u_time * i)), vec2(0.5, 1.5));\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    } \n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function JP(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:KP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QP=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdFive(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 100. - 50.;\n        // //p.y -= 1.25;\n        p.x += 1.;\n        p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 25.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, cos(u_time * i/25.));\n            b += 1. - sdBox(vec2(p.x + i + sin(u_time * i / 50.), p.y + sin(u_time * i / 50.)), vec2(2.5 * i/50., 2.5 * i/50.));\n            b += 1. - sdBox(vec2(p.x - i + cos(u_time * i / 50.), p.y + sin(u_time * i / 50.)), vec2(2.5 * i/50., 2.5 * i/50.));\n            b += 1. - sdBox(vec2(p.x + sin(u_time * i / 50.), p.y + i + cos(u_time * i / 50.)), vec2(2.5 * i/50., 2.5 * i/50.));\n            b += 1. - sdBox(vec2(p.x + sin(u_time * i / 50.) , p.y - i + sin(u_time * i / 50.)), vec2(2.5 * i/50., 2.5 * i/50.));\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    } \n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:QP,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ej=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdSix(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 100. - 50.;\n        // //p.y -= 1.25;\n        p.x += 1.;\n        p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 30.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, (sin(u_time * i/10.)));\n            b += sdCircle(vec2(p.x + i /1.75 + sin(u_time * i / 150.), p.y + sin(u_time * i / 150.)),  2.5 * i/50.);\n            b += sdCircle(vec2(p.x - i/1.75 + cos(u_time * i / 150.), p.y + sin(u_time * i / 150.)),  2.5 * i/50.);\n            b += sdCircle(vec2(p.x + sin(u_time * i / 150.), p.y + i/1.75 + cos(u_time * i / 150.)),  2.5 * i/50.);\n            b += sdCircle(vec2(p.x + sin(u_time * i / 150.) , p.y - i/1.75 + sin(u_time * i / 150.)),  2.5 * i/50.);\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    } \n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:ej,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdSeven(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 10. - 5.;\n        // //p.y -= 1.25;\n        p.x += 1.;\n        p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 30.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, (sin(u_time * i/15.)));\n            b += sdSegment(p, vec2(0.25 * i + ((sin(u_time) * 2.) - 12.5), 0.25 ), vec2(2.75 * i, 2.75));\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        color += numLabel;\n        float n = newfunc(vUv, 0.5);\n        color += n;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function oj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdEight(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 2.;\n\n        // //p.y -= 1.25;\n        // p.x += 1.;\n        // p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 15.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, (sin(u_time * i/15.)));\n            b += rectOutline(vec2(p.x, p.y), 0.5 * i / 15., 0.5 * i / 15.);\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        color += numLabel;\n        float n = newfunc(vUv, 0.5);\n        color += n;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ij(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:aj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdNine(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 8. - 3.;\n        p*= 0.5;\n        float b;\n        float steps = 15.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, (sin(u_time * i/15.)));\n            b += cirOutline(vec2(p.x + sin(u_time * i/15. + i), p.y + cos(u_time * i/15. + i)), 0.5 * (i + sin(u_time)) * 0.25);\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        color += numLabel;\n        float n = newfunc(vUv, 0.5);\n        color += n;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdZero(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 8. - 3.;\n        p*= 0.5;\n        float b;\n        float steps = 25.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            // if(i < 12.)\n            // {\n            //     p = Rot(p, (cos(u_time * i/50.)));\n            // } else \n            // {\n            //     p = Rot(p, (sin(u_time * i/50.)));\n            // }\n\n            p = Rot(p, (sin(u_time * i/50.)));\n            b += cirOutline(vec2(p.x + 0.75, p.y + sin(u_time * i/25. + 5.)), 0.5);\n            b += cirOutline(vec2(p.x - 0.75, p.y + sin(u_time * i/25. + 5.)), 0.5);\n\n           \n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        color += numLabel;\n        float n = newfunc(vUv, 0.5);\n        color += n;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdOne(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    float random(vec2 vUv){\n        return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        // vUv = vUv * 4. - 2.;\n        float x = random(vUv);\n        float y = sin(vUv.x);\n        vec2 cp = vec2(cos(u_time), sin(u_time  )) * 0.45 + 0.5;\n        y = quadraticBezier(y, cp);\n        // y += mod(vUv.x, 0.5);\n        float line = plot(vec2(vUv.x, vUv.y) , y, 0.01);\n        float line2 = plot(vec2(vUv.x, vUv.y) , y / x, 0.1);\n        float line3 = plot(vec2(vUv.x, vUv.y), y * x, 0.001);\n        color += line + line2 + line3;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdTwo(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // vec3 sdgBox(vec2 p, vec2 b)\n    // {\n    //     vec2 w = abs(p) - b;\n    //     vec2 s = vec2(p.y < 0. ? -1. : 1., p.x < 0. ? -1. : 1.);\n    //     float g = max(w.x, w.y);\n    //     vec2 q = max(w, 0.0);\n    //     float l = length(q);\n    //     vec3 x = vec3((g > 0.0) ? l : g, s * ((g > 0.0) ? q /l : ((w.x > w.y) ? vec2(1., 0.) : vec2(0., 1.))));\n    //     return smoothstep(0.01, 0.02, x);\n    // }\n\n    vec3 sdgCircle(vec2 p, float r)\n    {\n        float d = length(p);\n        return vec3(d -r, p /d);\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        \n        vUv = Rot(vUv, u_time);\n        vUv = vUv * 6. - 3.;\n        \n        float ra = 0.5;\n        vec3 cir = 1. - sdgCircle(vUv, ra);\n        float d = cir.x;\n        vec2 g = cir.yz;\n        \n        color += (d > 0.) ? vec3(1.) : vec3(0.0);\n        color *= 1.0 + vec3(0.5 * g, 0.0);\n        color *= 1.0 - 0.5 * exp(-16.0 * abs(d));\n        color *= 0.5 + 0.1 * cos(150.0 * d);\n        color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdThree(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    vec3 sdgBox(vec2 p, vec2 b)\n    {\n        vec2 w = abs(p) - b;\n        vec2 s = vec2(p.y < 0. ? -1. : 1., p.x < 0. ? -1. : 1.);\n        float g = max(w.x, w.y);\n        vec2 q = max(w, 0.0);\n        float l = length(q);\n        vec3 x = vec3((g > 0.0) ? l : g, s * ((g > 0.0) ? q /l : ((w.x > w.y) ? vec2(1., 0.) : vec2(0., 1.))));\n        return x;\n    }\n\n    vec3 sdgCircle(vec2 p, float r)\n    {\n        float d = length(p);\n        return vec3(d -r, p /d);\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        \n        vUv = Rot(vUv, u_time);\n        vUv = vUv * 6. - 3.;\n        \n        float ra = 0.5;\n        vec3 cir = 1. - sdgCircle(vUv, ra);\n        vec3 box = 1. - sdgBox(vUv, vec2(0.5, 0.5));\n        float d = cir.x;\n        vec2 g = cir.yz;\n\n        d = box.x;\n        g = box.yz;\n        \n        color += (d > 0.) ? vec3(1.) : vec3(0.0);\n        color *= 1.0 + vec3(0.5 * g, 0.0);\n        color *= 1.0 - 0.5 * exp(-16.0 * abs(d));\n        color *= 0.5 + 0.1 * cos(150.0 * d);\n        color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    vec3 sdgBox(vec2 p, vec2 b)\n    {\n        vec2 w = abs(p) - b;\n        vec2 s = vec2(p.y < 0. ? -1. : 1., p.x < 0. ? -1. : 1.);\n        float g = max(w.x, w.y);\n        vec2 q = max(w, 0.0);\n        float l = length(q);\n        vec3 x = vec3((g > 0.0) ? l : g, s * ((g > 0.0) ? q /l : ((w.x > w.y) ? vec2(1., 0.) : vec2(0., 1.))));\n        return x;\n    }\n\n    vec3 sdgCircle(vec2 p, float r)\n    {\n        float d = length(p);\n        return vec3(d -r, p /d);\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        \n        vUv = Rot(vUv, u_time);\n        vUv = vUv * 4. - 2.;\n        \n        float ra = 0.5;\n        vec3 cir = 1. - sdgCircle(vUv, ra);\n        vec3 box = 1. - sdgBox(vUv, vec2(0.5, 0.5));\n        float d = cir.x;\n        vec2 g = cir.yz;\n\n        d = box.x;\n        g = box.yz;\n        \n        color += (d > 0.) ? vec3(1.) : vec3(0.0);\n        // color *= 1.0 + vec3(0.5 * g, 0.0);\n        color *= 1.0 - 0.5 * exp(-16.0 * abs(d));\n        color *= 0.1 + 0.5 * cos(20.0 * d * (sin(u_time * 0.5) * 2.) + 5. );\n        color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdFive(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    vec3 sdgCircle(vec2 p, float r)\n    {\n        float d = length(p);\n        return vec3(d -r, p /d);\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n\n        vUv = vUv * 2. - 1.;\n        float k = 1. + 20. * (0.5 - 0.5 * cos(u_time + 1.5));\n        float spiral = sdSpiral(vUv, 1.0, k);\n        color += 1. - smoothstep(0.01, 0.02, spiral);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _j=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdSix(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = Rot(p , u_time);\n        p = p * 2. - 1.;\n        // //p.y -= 1.25;\n        // p.x += 1.;\n        // p.y += 1.;\n        // p*= 0.5;\n        float b;\n        float steps = 15.;\n        \n        for(float i = 1.; i<steps; i++)\n        {\n            // p = Rot(p, u_time * 0.25);\n            // p = p * 2. - 1.;\n            float k = 1. + i * (0.25 - 0.25 * cos(u_time * i * 0.025));\n            b += sdSpiral(p , a  * i, k + i * 0.2);\n        }\n        return b;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n\n        // vUv = vUv * 2. - 1.;\n        float k = 1. + 20. * (0.5 - 0.5 * cos(u_time + 1.5));\n        float spiral = sdSpiral(vUv, 1.0, k);\n        // color += spiral;\n        float func = newfunc(vUv, 1.0);\n        // color.g += func * 0.25;\n        color.r += func * 0.25 - abs(cos(u_time * 0.5));\n        color.b += func * 0.25 - (sin(u_time * 0.5)  /2.) - 0.5;\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Uj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_j,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdSeven(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = Rot(p , u_time);\n        p = p * 2. - 1.;\n        // //p.y -= 1.25;\n        // p.x += 1.;\n        // p.y += 1.;\n        // p*= 0.5;\n        float b;\n        float steps = 15.;\n        \n        for(float i = 1.; i<steps; i++)\n        {\n            // p = Rot(p, u_time * 0.25);\n            // p = p * 2. - 1.;\n            p = p * i / (3. + sin(u_time * 0.5));\n            float k = 1. + i * (0.25 - 0.25 * cos(u_time * i * 0.025));\n            b += sdSpiral(p , a  * i, k + i * 0.2);\n        }\n        return b;\n    }\n\n    \n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n\n        // vUv = vUv * 2. - 1.;\n        float k = 1. + 20. * (0.5 - 0.5 * cos(u_time + 1.5));\n        float spiral = sdSpiral(vUv, 1.0, k);\n        // color += spiral;\n        float func = newfunc(vUv, 1.0);\n        // color.g += func * 0.25;\n        color.r += func * 0.25 - abs(cos(u_time * 0.5));\n        color.b += func * 0.25 - (sin(u_time * 0.5)  /2.) - 0.5;\n        color += numLabel + numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Sj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\nfloat label(vec2 p)\n{\n    p *= 10.;\n    p.x -= 0.25;\n    float left = sdFour(vec2(p.x + 0.3, p.y));\n    float center = sdFour(vec2(p.x -0.05, p.y));\n    float right = sdEight(vec2(p.x - 0.38, p.y));\n    return left + center + right;\n}\n\nfloat newfunc(vec2 p, float a)\n{\np = Rot(p , u_time);\np = p * 2. - 1.;\n// //p.y -= 1.25;\n// p.x += 1.;\n// p.y += 1.;\n// p*= 0.5;\nfloat b;\nfloat steps = 15.;\n\nfor(float i = 1.; i<steps; i++)\n{\n    // p = Rot(p, u_time * 0.25);\n    // p = p * 2. - 1.;\n    p = p * i / (3.);\n    float k = 1. + i * (0.25 - 0.25 * cos(u_time * i * 0.025));\n    b += sdSpiral(p * i, a  * i, k + i * 0.2);\n    b += sdSegment(p * i , vec2(0.0), vec2(0.25));\n}\nreturn b;\n}\n\nvoid main()\n{\nvec2 vUv = vec2(vUv.x, vUv.y);\nvec3 color = vec3(0.);\nfloat numLabel = label(vUv);\nvec2 newUv = vUv;\n// vUv = vUv * 2. - 1.;\nfloat k = 1. + 20. * (0.5 - 0.5 * cos(u_time + 1.5));\nfloat spiral = sdSpiral(vUv, 1.0, k);\n// color += spiral;\nvUv = Rot(vUv, u_time);\nnewUv = Rot(newUv, PI * 0.25);\nfloat func = newfunc(vUv, 1.0);\nfloat func2 = newfunc(newUv, 1.0);\n// color.g += func * 0.25;\ncolor.r += func * 0.25 - abs(cos(u_time * 0.5));\ncolor.r += func2 * 0.25 - abs(cos(u_time * 0.5));\ncolor.b += func * 0.25 - (sin(u_time * 0.5)  /2.) - 0.5;\ncolor.b += func2 * 0.25 - (sin(u_time * 0.5)  /2.) - 0.5;\ncolor += numLabel + numLabel + numLabel;\ngl_FragColor = vec4(color, 1.);\n}\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Mj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdNine(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n\n        float y = (sin(noiseUv.x + u_time) )  / 2. ;\n        float line = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y, 0.01);\n        float line2 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n, 0.01);\n        float line3 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n * n, 0.01);\n        color += line;\n        color += line2;\n        color += line3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Cj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Tj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = newUv / 1.25 + 0.1;\n        float box = sdRoundedBoxOutline(newUv, vec2(0.5), vec4(\n            0.25 * n + (sin(u_time * (sin(n + u_time/5.))/50.) / 10.) + 0.2, \n            0.25 * n + (sin(u_time * (sin(n + u_time/5.))/50.) / 10.) + 0.2, \n            0.25 * n + (sin(u_time * (cos(n + u_time/5.))/50.) / 10.) + 0.2, \n            0.25 * n + (sin(u_time * (cos(n + u_time/5.))/50.) / 10.) + 0.2), \n            0.025);\n        float y = (sin(noiseUv.x + u_time) )  / 2. ;\n        float line = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y, 0.01);\n        float line2 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n, 0.01);\n        float line3 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n * n, 0.01);\n        // color += line;\n        // color += line2;\n        // color += line3;\n        color += box;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Rj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Tj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Dj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = newUv / 1.25 + 0.1;\n        float box = sdRoundedBox(newUv, vec2(0.5), vec4(\n            0.25 * n + (sin(u_time + abs(sin(n * u_time * 0.5) + 125.0)/2.) / 2.) + 0.2, \n            0.25 * n + (sin(u_time + abs(sin(n * u_time * 0.5) + 125.0)/2.) / 2.) + 0.2, \n            0.25 * n + (sin(u_time + abs(sin(n * u_time * 0.5) + 125.0)/2.) / 2.) + 0.2, \n            0.25 * n + (sin(u_time + abs(sin(n * u_time * 0.5) + 125.0)/2.) / 2.) + 0.2));\n        float y = (sin(noiseUv.x + u_time) )  / 2. ;\n        float line = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y, 0.01);\n        float line2 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n, 0.01);\n        float line3 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n * n, 0.01);\n        // color += line;\n        // color += line2;\n        // color += line3;\n        color += box;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Pj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Dj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 120.)/5.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n       \n        float k = 1. + 20. * (0.5 - 0.5 + (n * 0.025 + (sin(u_time) + 1.)/5.));\n        float spiral = sdSpiral(vec2(vUv.x * 2. - 1., vUv.y * 2. - 1. ), 1.0 + (sin(u_time) + 2.), k);\n        color += spiral;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Fj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ej=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 120.)/5.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time * 0.25);\n        newUv = newUv * 2. - 1.;\n        vec2 newUv2 = vUv;\n        newUv2 = Rot(newUv2, u_time * 0.5);\n        newUv2 = newUv2 * 2. - 1.;\n        float tri = sdEqTriangleOutline(newUv, 0.35 + (n * 0.05 * sin(u_time)));\n        float tri2 = sdEqTriangleOutline(newUv2, 0.15 + (n * 0.05 * sin(u_time)));\n        float k = 1. + 20. * (0.5 - 0.5 + (n * 0.025 + (sin(u_time) + 1.)/5.));\n        float spiral = sdSpiral(vec2(vUv.x * 2. - 1., vUv.y * 2. - 1. ), 1.0 + (sin(u_time) + 2.), k);\n        // color += spiral;\n        color += tri;\n        color += tri2;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Ij(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Ej,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Oj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 120.)/5.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time * 0.25);\n        // newUv = newUv * 2. - 1.;\n        vec2 newUv2 = vUv;\n        newUv2 = Rot(newUv2, u_time * 0.5);\n        // newUv2 = newUv2 * 2. - 1.;\n        float c1 = cirOutline(newUv, 0.35 + (n * 0.05 * sin(u_time)));\n        float c2 = cirOutline(newUv2, 0.15 + (n * 0.05 * sin(u_time)));\n        float c3 = cirOutline(newUv, 0.5 + (n * 0.05 * sin(u_time)));\n        float c4 = cirOutline(newUv2, 0.25 + (n * 0.035 * sin(u_time)));\n        float k = 1. + 20. * (0.5 - 0.5 + (n * 0.025 + (sin(u_time) + 1.)/5.));\n        float spiral = sdSpiral(vec2(vUv.x * 2. - 1., vUv.y * 2. - 1. ), 1.0 + (sin(u_time) + 2.), k);\n        // color += spiral;\n        color += c1;\n        color += c2 + c3 + c4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Lj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Oj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Aj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 120.)/25.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = newUv * 4. - 2.;\n        float y = sin(vUv.x + u_time + n);\n        float x = sin(vUv.y + u_time + n);\n        float line = plot(newUv, y, 0.5);\n        float line2 = plot(newUv, x, 0.25);\n        color += line;\n        color += line2;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Nj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Aj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Gj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 220. * 1.2)/10.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n       \n        float shape = rectOutline(vUv, 0.5 + n/5., 0.25);\n        color += shape;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Bj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Gj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 82. * 1.2)/15.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n       \n        float shape = rectOutline(vUv, 0.5 + n/5. * sin(u_time), 0.5 + n/5. * cos(u_time));\n        color += shape;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Vj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Wj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 82. * 1.2)/15.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time * 0.25);\n        float shape = rectOutline(newUv, 0.5 + n/5. * sin(u_time), 0.5 + n/5. * cos(u_time));\n        float shape2 = cirOutline(vUv, 0.5 + n/5. * sin(u_time));\n        color += shape;\n        color += shape2;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Hj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Wj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Xj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 1580. * 1.2)/35.);\n        vec2 vUv2, vUv3, vUv4, vUv5;\n        vUv2 = vUv;\n        vUv2 = vUv2 * 2. - 0.5;\n        vUv2.x += 0.56;\n        vUv3 = vUv;\n        vUv3 = vUv3 * 2. - 0.5;\n        vUv3.x += 0.2;\n        vUv4 = vUv;\n        vUv4 = vUv4 * 2. - 0.5;\n        vUv4.x -= 0.05;\n        vUv5 = vUv;\n        vUv5 = vUv5 * 2. - 0.5;\n        vUv5.x -= 0.4;\n\n        float two = sdTwo(vUv2 * abs(sin(n + u_time)+ 25.)/25.);\n        float zero = sdZero(vUv3 * abs(cos(n + u_time) + 25.)/25.);\n        float two1 = sdTwo(vUv4 * abs(sin(n + u_time)+ 25.)/25.);\n        float three = sdThree(vUv5 * abs(cos(n + u_time)+ 25.)/25.);\n        color += two;\n        color += zero;\n        color += two1;\n        color += three;\n\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Yj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Xj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $j=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 82. * 1.2)/15.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time * 0.25);\n        float shape = rect(newUv, 0.5 + n/5. * sin(u_time), 0.5 + n/5. * cos(u_time));\n        float shape2 = circle(vUv * 2. - 0.5, 0.5 + n/5. * sin(u_time));\n        float shape3 = circle(vUv * 2.5 - 0.75, 0.5 + n/5. * sin(u_time));        color += shape;\n        color += shape2;\n        color -= shape3;\n        float shape4 = rect(newUv, 0.45 + n/5. * sin(u_time), 0.45 + n/5. * cos(u_time));\n        color -= shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Zj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$j,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Kj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * ((u_time) / 5.) + 65.);\n        vec2 newUv = vUv;\n        float y = vUv.x * n;\n\n        float line = plot(vUv, y, 0.01);\n        // newUv = newUv * 2.;\n        float cir = cirOutline(newUv, 0.25); \n        // color += line;\n        color += cir;\n        color += line;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function Jj(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Kj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qj=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    \n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv + u_time);\n        // vUv.x += u_time;\n        float y = sin(vUv.x * n * u_time);\n\n        float line = plot(vUv, y, 0.5 + n);\n        color += line;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:Qj,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 120.)/5.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time * 0.25);\n        // newUv = newUv * 2. - 1.;\n        vec2 newUv2 = vUv;\n        newUv2 = Rot(newUv2, u_time * 0.5);\n        // newUv2 = newUv2 * 2. - 1.;\n        float c1 = circle(newUv, 0.35 + (n * 0.07 * sin(u_time)));\n        float c2 = circle(newUv2, 0.15 + (n * 0.05 * cos(u_time)));\n        float c3 = circle(newUv, 0.5 + (n * 0.04 * sin(u_time)));\n        float c4 = circle(newUv2, 0.25 + (n * 0.035 * cos(u_time)));\n        float k = 1. + 20. * (0.5 - 0.5 + (n * 0.025 + (sin(u_time) + 1.)/5.));\n        float spiral = sdSpiral(vec2(vUv.x * 2. - 1., vUv.y * 2. - 1. ), 1.0 + (sin(u_time) + 2.), k);\n        // color += spiral;\n        \n        color += c2;\n        color -= c1;\n        color += c3;\n        // color -= c3;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:eF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        // float shape1 = sdPolygonOutline(vUv, 7.0 + sin(u_time), 0.1);\n        // float shape2 = sdPolygonOutline(vUv, 6.0 + sin(u_time), 0.2);\n        // float shape3 = sdPolygonOutline(vUv, 5.0 + sin(u_time), 0.3);\n        // float shape4 = sdPolygonOutline(vUv, 4.0 + sin(u_time), 0.4);\n        //float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        //color += shape1 + shape2 + shape3 + shape4;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function oF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        for (int i=4; i<=15; i++)\n        {\n            shape1 += sdPolygonOutline(vUv, i, float(i) * 0.1 + (sin(u_time)/2.) - 0.95);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function iF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:aF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 2. - 0.5;\n        newvUv = Rot(newvUv, u_time * 0.25);\n        for (int i=4; i<=15; i++)\n        {\n            shape1 += sdPolygonOutline(vec2(newvUv.x, newvUv.y + sin(float(i)/2.)), i, float(i) * 0.1 + (sin(u_time)/4.) - 0.95);\n            shape2 += sdPolygonOutline(vec2(newvUv.x + cos(float(i)/2.), newvUv.y ), i, float(i) * 0.1 + (cos(u_time)/4.) - 0.95);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        color += shape2;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 2. - 0.5;\n        newvUv = Rot(newvUv, u_time * 0.25);\n        for (int i=3; i<=7; i++)\n        {\n            shape1 += sdPolygonOutline(vec2(newvUv.x, newvUv.y + sin(float(i)/1.)), i, float(i) * 0.1 + (sin(u_time * float(i) * 0.5)/1.) - 0.95);\n            shape2 += sdPolygonOutline(vec2(newvUv.x + cos(float(i)/1.), newvUv.y ), i, float(i) * 0.1 + (cos(u_time * float(i) * 0.5)/1.) - 0.95);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        color += shape2;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 2. - 1.;\n        // newvUv = Rot(newvUv, u_time * 0.25);\n        float k = 1. + 20. * (0.5 - 0.5 + (0.025 + (sin(u_time * 0.25) + .5)/015.));\n        for (int i=3; i<=7; i++)\n        {\n            shape1 += sdSpiral(newvUv, 0.5* float(i), k);\n            shape2 += sdSpiral(newvUv, 0.5* float(i), 5./k );\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        color *= shape2;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 4. - 1.5;\n        // newvUv = Rot(newvUv, u_time * 0.25);\n        float k = 1. + 20. * (0.5 - 0.5 + (0.025 + (sin(u_time * 0.25) + .5)/015.));\n        for (int i=3; i<=7; i++)\n        {\n            // shape1 += sdSpiral(newvUv, 0.5* float(i), k);\n            // shape2 += sdSpiral(newvUv, 0.5* float(i), 20./k );\n            // shape3 += sdSpiral(newvUv, 0.5* float(i), 100./k );\n            shape1 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + sin(u_time * 0.75), 0.5* float(i)), vec4(float(i)), 0.1);\n            shape2 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + sin(u_time * 0.25), 0.5* float(i)), vec4(float(i)), 0.1);\n            shape3 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + sin(u_time * 0.5), 0.5* float(i)), vec4(float(i)), 0.2);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        color *= shape2;\n        color *= shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 4. - 1.5;\n        newvUv = Rot(newvUv, u_time * 0.5);\n        float k = 1. + 20. * (0.5 - 0.5 + (0.025 + (sin(u_time * 0.25) + .5)/015.));\n        for (int i=0; i<=10; i++)\n        {\n            // shape1 += sdSpiral(newvUv, 0.5* float(i), k);\n            // shape2 += sdSpiral(newvUv, 0.5* float(i), 20./k );\n            // shape3 += sdSpiral(newvUv, 0.5* float(i), 100./k );\n            shape1 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + sin(u_time * 0.35), 0.25* float(i)), vec4(float(i)), 0.1);\n            shape2 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + cos(u_time * 0.25), 0.5* float(i)), vec4(float(i)), 0.1);\n            shape3 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + cos(u_time * 0.35), 0.5* float(i)), vec4(float(i)), 0.1);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        color *= shape2;\n        color *= shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = Rot(newvUv, u_time * 0.5);\n        newvUv = newvUv * 4. - 2.;\n        \n        float k = 1. + 20. * (0.5 - 0.5 + (0.025 + (sin(u_time * 0.25) + .5)/015.));\n        for (int i=0; i<=10; i++)\n        {\n            // shape1 += sdSpiral(newvUv, 0.5* float(i), k);\n            // shape2 += sdSpiral(newvUv, 0.5* float(i), 20./k );\n            // shape3 += sdSpiral(newvUv, 0.5* float(i), 100./k );\n            shape1 += sdEqTriangleOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.25), newvUv.y + cos(float(i) * u_time * 0.25)), 0.3 * (float(i) * 0.1));\n            // shape2 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + cos(u_time * 0.25), 0.5* float(i)), vec4(float(i)), 0.1);\n            // shape3 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + cos(u_time * 0.35), 0.5* float(i)), vec4(float(i)), 0.1);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        // color *= shape2;\n        // color *= shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 3. - 1.;\n        newvUv = Rot(newvUv, u_time * 0.25);\n        \n        for (int i=4; i<=10; i++)\n        {\n            // shape1 += sdEqTriangleOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.25), newvUv.y + cos(float(i) * u_time * 0.25)), 0.3 * (float(i) * 0.1));\n            shape2 += sdPolygonOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.0725), newvUv.y + sin(float(i) * u_time * 0.0725)), 4, 0.1 * (float(i) - 0.125));\n            shape3 += sdPolygonOutline(vec2(newvUv.x - sin(float(i) * u_time * 0.0725), newvUv.y - sin(float(i) * u_time * 0.0725)), 4, 0.1 * (float(i) - 0.125));\n            \n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        // color += shape1;\n        color += shape2;\n        color *= shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _F=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 3. - 1.;\n        // newvUv = Rot(newvUv, u_time * 0.25);\n        \n        for (int i=4; i<=8; i++)\n        {\n            // shape1 += sdEqTriangleOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.25), newvUv.y + cos(float(i) * u_time * 0.25)), 0.3 * (float(i) * 0.1));\n            shape2 += sdPolygonOutline(vec2(newvUv.x - sin(float(i) * u_time * 0.25), newvUv.y + sin(float(i) * u_time * 0.125)), 4, 0.05 * (float(i) - 0.125));\n            shape3 += sdPolygonOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.25), newvUv.y + sin(float(i) * u_time * 0.125)), 4, 0.05 * (float(i) - 0.125));\n            \n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        // color += shape1;\n        color += shape2;\n        color += shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function UF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_F,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 2. - 0.5;\n        \n        \n        for (int i=4; i<=15; i++)\n        {\n            newvUv = Rot(newvUv, u_time * 0.125);\n            // shape1 += sdEqTriangleOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.25), newvUv.y + cos(float(i) * u_time * 0.25)), 0.3 * (float(i) * 0.1));\n            shape2 += sdPolygonOutline(vec2(newvUv), 3, 0.0525 * (float(i) - 0.125));\n            shape3 += sdPolygonOutline(vec2(newvUv.x + cos(float(i) * u_time * 0.125), newvUv.y + sin(float(i) * u_time * 0.125)), 3, 0.025 * (float(i) - 0.125));\n            \n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        // color += shape1;\n        color += shape2;\n        // color += shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function SF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = Rot(newvUv, u_time * 4.);\n        newvUv = newvUv / 2. - 0.25;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=4; i<=15; i++)\n        {\n            shape1 += sdSpiral(vec2(newvUv), 0.45, k);\n        }\n        \n        color += shape1;\n        shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        color += shape2;\n        color += shape3;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function MF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        newvUv = Rot(newvUv, u_time * .25);\n        // newvUv = newvUv / 2. - 0.25;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=0; i<=10; i++)\n        {\n            shape1 += rectOutline(vec2(newvUv.x + (float(i) * (sin(u_time) / 2.)/ 20.), newvUv.y), 0.25, 0.25);\n            shape2 += rectOutline(vec2(newvUv.x , newvUv.y + (float(i) * (sin(u_time) / 2.)/ 20.)), 0.25, 0.25);\n            // shape3 += rectOutline(vec2(newvUv.x + (float(i) * (cos(u_time) / 2.)/ 20.), newvUv.y), 0.25, 0.25);\n            // shape4 += rectOutline(vec2(newvUv.x , newvUv.y + (float(i) * (cos(u_time) / 2.)/ 20.)), 0.25, 0.25);\n        }\n        \n        color += shape1;\n        // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        color += shape2;\n        // color += shape3;\n        // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function CF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        newvUv = Rot(newvUv, u_time * .25);\n        // newvUv = newvUv / 2. +0.125;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=5; i<=15; i++)\n        {\n            shape1 += rectOutline(vec2(newvUv) , 0.0725 * float(i) * cos(u_time * float(i) * 0.01), 0.0725 * float(i) * sin(u_time * float(i) * 0.05));\n        //     shape2 += rectOutline(vec2(newvUv.x , newvUv.y), 0.025 * float(i), 0.25);\n        //     shape3 += rectOutline(vec2(newvUv.x , newvUv.y), 0.025 * float(i), 0.25);\n        //     shape4 += rectOutline(vec2(newvUv.x , newvUv.y), 0.025 * float(i), 0.25);\n        }\n        \n        color += shape1;\n        // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        color += shape2;\n        color += shape3;\n        color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function RF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:TF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        // newvUv = Rot(newvUv, u_time * .25);\n        newvUv = newvUv * 4. - 1.5;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=0; i<=13; i++)\n        {\n            shape1 += circle(vec2(newvUv.x + sin(u_time * float(i) * 0.1 + 0.5), newvUv.y +  float(i) * 0.1), 0.15 * (sin(float(i) * u_time * 0.1))+0.15);\n            shape2 += circle(vec2(newvUv.x + sin(u_time * float(i) * 0.1 + 0.5) , newvUv.y -  float(i) * 0.1), 0.15 * (sin(float(i) * u_time * 0.1))+0.15);\n            shape3 += cirOutline(vec2(newvUv.x + sin(u_time * float(i) * 0.1 + 0.5), newvUv.y +  float(i) * 0.1), 0.15 * (sin(float(i) * u_time * 0.1))+0.15);\n            shape4 += cirOutline(vec2(newvUv.x + sin(u_time * float(i) * 0.1 + 0.5) , newvUv.y -  float(i) * 0.1), 0.15 * (sin(float(i) * u_time * 0.1))+0.15);\n        }\n        \n        color += shape1 * shape3;\n        // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        color += shape2 * shape4;\n        // color *= shape3;\n        // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function PF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:DF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        // newvUv = Rot(newvUv, u_time * .25);\n        newvUv = newvUv * 3. - 1.5;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=1; i<=15; i++)\n        {\n            shape1 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.5 * (sin(u_time * float(i) * 0.1)), 0.75 * (cos(u_time * float(i) * 0.21))));\n            shape2 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.5 * (sin(u_time * float(i) * 0.1)), 0.75 * (cos(u_time * float(i) * 0.21))));\n            shape3 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.75 * (cos(u_time * float(i) * 0.21)), 0.75 * (sin(u_time * float(i) * 0.21))));\n            shape4 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.75 * (cos(u_time * float(i) * 0.21)), 0.75 * (sin(u_time * float(i) * 0.21))));\n        }\n        \n        // color += shape1;\n        color += shape1 * shape3;\n        color += shape2 * shape4;\n        // // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        \n        // // color *= shape3;\n        // // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function FF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        // newvUv = Rot(newvUv, u_time * .25);\n        newvUv = newvUv * 3. - 1.5;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=1; i<=15; i++)\n        {\n            shape1 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.25 * (sin(u_time * float(i) * 0.1)), 0.25 * (cos(u_time * float(i) * 0.1))));\n            shape2 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.15 + (sin(u_time * float(i) * 0.1)), 0.15 + (cos(u_time * float(i) * 0.1))));\n            shape3 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.15 + (sin(u_time * float(i) * 0.1)), -0.15 + (cos(u_time * float(i) * 0.1))));\n            shape4 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(-0.15 + (sin(u_time * float(i) * 0.1)), 0.15 + (cos(u_time * float(i) * 0.1))));\n        }\n        \n        // color += shape1;\n        color += shape1; \n        color += shape3;\n        color += shape2;\n        color += shape4;\n        // // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        \n        // // color *= shape3;\n        // // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function IF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:EF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        \n        newvUv = newvUv * 2. - 0.5;\n        newvUv.y -= 0.7;\n        newvUv = Rot(newvUv, PI * 0.25);\n        float k = 1. + 20. * (0.25 - 0.125);\n        vec2 uv2 = newvUv;\n        \n        uv2.x += 1.;\n        uv2.y -0.2;\n        uv2 = Rot(uv2, PI * 0.5);\n        \n        for (int i=1; i<=15; i++)\n        {\n            shape1 += sdSegment(vec2(newvUv.x + sin(float(i) * u_time * 0.1), newvUv.y + cos(float(i) * u_time * 0.1)), vec2(0. + sin(u_time * float(i) * (0.1))), vec2(0.0 + cos(u_time * float(i) * 0.1)));\n            \n        }\n        \n        // color += shape1;\n        color += shape1; \n        color += shape3;\n        color += shape2;\n        color += shape4;\n        // // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        \n        // // color *= shape3;\n        // // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function LF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:OF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        vec2 uv2 = newvUv;\n        newvUv = Rot(newvUv, PI * 0.5);\n        uv2 = Rot(uv2, PI *0.5);\n        newvUv = newvUv * 2. - 0.5;\n        newvUv.y -= 0.7;\n        newvUv = Rot(newvUv, PI * 0.25);\n        uv2 = uv2 * 2. - 0.5;\n        uv2.y -= 0.7;\n        \n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        \n        for (int i=1; i<=15; i++)\n        {\n            uv2 = Rot(uv2, PI * 0.25 + u_time * 0.1);\n            shape1 += sdSegment(vec2(newvUv.x + cos(float(i) * u_time * 0.01), newvUv.y + sin(float(i) * u_time * 0.1)), vec2(0. + cos(u_time * float(i) * (0.1))), vec2(0.0 + sin(u_time * float(i) * 0.1)));\n            shape2 += sdSegment(vec2(uv2.x + cos(float(i) * u_time * 0.01), uv2.y + sin(float(i) * u_time * 0.1)), vec2(0. + cos(u_time * float(i) * (0.1))), vec2(0.0 + sin(u_time * float(i) * 0.0)));\n            \n        }\n        \n        // color += shape1;\n        color += shape1; \n        color += shape3;\n        color += shape2;\n        color += shape4;\n        // // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        \n        // // color *= shape3;\n        // // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function NF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:AF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2 = Rot(uv2, u_time * 0.1);\n        for (int i=1; i<=15; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, u_time * 0.05 * float(i));\n            shape1 += sdSegment(vec2(uv2.x + float(i) /10. - 0.25, uv2.y + float(i) /10. - 0.25), vec2(0.0), vec2(0.25));\n            \n        }\n        \n        color += shape1; \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function BF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:GF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.25;\n        // uv2 = Rot(uv2, u_time * 0.1);\n        for (int i=1; i<=15; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, u_time * 0.05 * float(i));\n            shape1 += sdSegment(vec2(uv2.x + (float(i) * sin(u_time) /10. ) , uv2.y + (float(i) * cos(u_time) /10. )), vec2(0.0), vec2(0.5));\n            shape2 += sdSegment(vec2(uv2.x - (float(i) * sin(u_time) /10. ) , uv2.y - (float(i) * cos(u_time) /10. )), vec2(0.0), vec2(0.5));\n            shape3 += sdSegment(vec2(uv2.x + (float(i) * sin(u_time) /10. ) , uv2.y - (float(i) * cos(u_time) /10. )), vec2(0.0), vec2(0.5));\n            shape4 += sdSegment(vec2(uv2.x - (float(i) * sin(u_time) /10. ) , uv2.y + (float(i) * cos(u_time) /10. )), vec2(0.0), vec2(0.5));\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function VF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.1);\n        for (int i=0; i<=20; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, u_time * 0.05 * float(i));\n            shape1 += circle(vec2(uv2.x + float(i) / 10. + sin(u_time*(float(i)/15.)), uv2.y - float(i) / 150. + cos(u_time*(float(i)/10.))), 0.25);\n            shape2 += cirOutline(vec2(uv2.x + float(i) / 10. + sin(u_time*(float(i)/15.)), uv2.y - float(i) / 150. + cos(u_time*(float(i)/10.))), 0.25);\n            \n        }\n        \n        color += shape1; \n        color *= shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function HF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:WF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.1);\n        for (int i=1; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, u_time * 0.05 * float(i));\n            shape1 += circle(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) * cos(u_time)), 0.005);\n            shape2 += circle(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * sin(u_time)), 0.005);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function YF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:XF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $F=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.1);\n        for (int i=1; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, u_time * 0.0000005 * float(i));\n            shape1 += circle(vec2(uv2.x + sin(u_time*(float(i)/25.)) - sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) + cos(u_time)), 0.005);\n            shape2 += circle(vec2(uv2.x + cos(u_time*(float(i)/25.)) - cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) + sin(u_time)), 0.005);\n            shape3 += circle(vec2(uv2.x + sin(u_time*(float(i)/12.5)) + sin(u_time), uv2.y - cos(u_time*(float(i)/12.5)) - cos(u_time)), 0.005);\n            shape4 += circle(vec2(uv2.x - cos(u_time*(float(i)/12.5)) + cos(u_time), uv2.y + sin(u_time*(float(i)/12.5)) - sin(u_time)), 0.005);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ZF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$F,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=1; i<=45; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, u_time * 0.0000005 * float(i));\n            shape1 += circle(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) + sin(u_time)), 0.005);\n            shape2 += circle(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) + sin(u_time)), 0.005);\n            shape3 += circle(vec2(uv2.x + sin(u_time*(float(i)/12.5)) * cos(u_time), uv2.y - cos(u_time*(float(i)/12.5)) - cos(u_time)), 0.005);\n            shape4 += circle(vec2(uv2.x + cos(u_time*(float(i)/12.5)) * sin(u_time), uv2.y + sin(u_time*(float(i)/12.5)) - sin(u_time)), 0.005);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function JF(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:KF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QF=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=1; i<=50; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, u_time * 0.0000005 * float(i));\n            shape1 += rectOutline(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) * sin(u_time)), 0.25, 0.25);\n            shape2 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * sin(u_time)), 0.25, 0.25);\n            shape3 += rectOutline(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) * cos(u_time)), 0.25, 0.25);\n            shape4 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * sin(u_time)), 0.05, 0.05);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:QF,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=1; i<=40; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, ((u_time * 0.5) * float(i/25))/200825.);\n            // shape1 += rectOutline(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) * sin(u_time)), 0.25, 0.25);\n            shape2 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/5.)) * abs(cos(u_time * 0.5)), uv2.y + sin(u_time*(float(i)/5.)) * abs(sin(u_time * 0.5))), 0.0525, 0.0525);\n            shape3 += rectOutline(vec2(uv2.x + (sin(u_time*(float(i)/5.))) * (sin(u_time * 0.5)), uv2.y + cos(u_time*(float(i)/5.)) * abs(cos(u_time * 0.5))), 0.0525, 0.0525);\n            // shape4 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * cos(u_time)), 0.05, 0.05);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:eE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=1; i<=40; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, ((u_time * 0.5) * float(i/25))/200825.);\n            // shape1 += rectOutline(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) * sin(u_time)), 0.25, 0.25);\n            shape2 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/5.)) + abs(cos(u_time * 0.5)), uv2.y + sin(u_time*(float(i)/5.)) * abs(sin(u_time * 0.5))), 0.0525, 0.0525);\n            shape3 += rectOutline(vec2(uv2.x + (sin(u_time*(float(i)/5.))) - (sin(u_time * 0.5)), uv2.y + cos(u_time*(float(i)/5.)) * abs(cos(u_time * 0.5))), 0.0525, 0.0525);\n            // shape4 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * cos(u_time)), 0.05, 0.05);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function oE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=1; i<=40; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, ((u_time * 0.5) * float(i/25))/200825.);\n            shape1 += rectOutline(vec2(uv2.x + sin(u_time*(float(i)/25.)) + sin(u_time), uv2.y + cos(u_time*(float(i)/15.)) - cos(u_time * float(i/10))), 0.25, 0.25);\n            // shape2 += rectOutline(vec2(uv2.x / cos(u_time*(float(i)/5.)) + abs(cos(u_time * 0.5)), uv2.y + sin(u_time*(float(i)/5.)) * abs(sin(u_time * 0.5))), 0.0525, 0.0525);\n            // shape3 += rectOutline(vec2(uv2.x * (sin(u_time*(float(i)/5.))) - (sin(u_time * 0.5)), uv2.y + cos(u_time*(float(i)/5.)) * abs(cos(u_time * 0.5))), 0.0525, 0.0525);\n            // shape4 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * cos(u_time)), 0.05, 0.05);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function iE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:aE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=0; i<=10; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            \n            shape1 += circle(vec2(uv2.x + sin(float(i) + u_time) * 2. , uv2.y), 0.0525);\n            shape2 += circle(vec2(uv2.x  , uv2.y + sin(float(i) + u_time) * 2.), 0.0525);\n            shape3 += circle(vec2(uv2.x + sin(float(i) + u_time) * 2. , uv2.y + sin(float(i) + u_time) * 2.), 0.0525);\n            shape4 += circle(vec2(uv2.x - sin(float(i) + u_time) * 2. , uv2.y + sin(float(i) + u_time) * 2.), 0.0525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.15);\n        for (int i=5; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.15));\n            shape1 += circle(vec2(uv2.x + cos(float(i) + u_time) * 2. , uv2.y), 0.0525);\n            shape2 += circle(vec2(uv2.x  , uv2.y - sin(float(i) + u_time) * 2.), 0.0525);\n            shape3 += circle(vec2(uv2.x + sin(float(i) + u_time) * 2. , uv2.y + sin(float(i) + u_time) * 2.), 0.0525);\n            shape4 += circle(vec2(uv2.x - sin(float(i) + u_time) * 2. , uv2.y + sin(float(i) + u_time) * 2.), 0.0525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.15);\n        for (int i=5; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, sin(u_time * 0.15 * (float(i))));\n            shape1 += circle(vec2(uv2.x + cos(float(i) + u_time) - float(i)/10. , uv2.y + sin(float(i) + u_time) + float(i)/10.), 0.0525);\n            shape2 += circle(vec2(uv2.x + cos(float(i) + u_time) + float(i)/10.  , uv2.y - sin(float(i) + u_time) - float(i)/10.), 0.0525);\n            shape3 += circle(vec2(uv2.x + sin(float(i) + u_time) + float(i)/10. , uv2.y + cos(float(i) + u_time) - float(i)/10.), 0.0525);\n            shape4 += circle(vec2(uv2.x - sin(float(i) + u_time) + float(i)/10. , uv2.y + cos(float(i) + u_time) - float(i)/10.), 0.0525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.15);\n        for (int i=5; i<=150; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.0125 * (float(i))));\n            shape1 += circle(vec2(uv2.x + cos(float(i) + u_time) - float(i)/50. , uv2.y ), 0.0525);\n            shape2 += circle(vec2(uv2.x + cos(float(i) + u_time) + float(i)/50. , uv2.y ), 0.0525);\n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.15);\n        for (int i=0; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, sin(u_time * 0.0125));\n            shape1 += cirOutline(vec2(uv2.x + sin(float(i) * u_time/12.) - float(i)/12. , uv2.y + sin(float(i) * u_time/12.) + float(i)/10.), 0.0525);\n            shape2 += cirOutline(vec2(uv2.x - sin(float(i) * u_time/12.) + float(i)/12. , uv2.y + sin(float(i) * u_time/12.) + float(i)/10. ), 0.0525);\n            shape3 += circle(vec2(uv2.x + sin(float(i) * u_time/12.) - float(i)/12. , uv2.y + sin(float(i) * u_time/12.) + float(i)/10.), 0.0525);\n            shape4 += circle(vec2(uv2.x - sin(float(i) * u_time/12.) + float(i)/12. , uv2.y + sin(float(i) * u_time/12.) + float(i)/10. ), 0.0525);\n        }\n        \n        color += shape1; \n        color += shape2;\n        color -= shape3; \n        color -= shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        for (int i=0; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.25));\n            shape1 += cirOutline(vec2(uv2.x + (float(i)/4.) + cos(u_time * 0.5 + (float(i))), uv2.y+ sin(float(i)/4.) + sin(u_time * 0.5 + (float(i)))), 0.0525);\n            shape2 += cirOutline(vec2(uv2.x + (float(i)/4.) + cos(u_time + (float(i)) ), uv2.y+ sin(float(i)/4.) + sin(u_time * 0.5 + (float(i)))), 0.0525);\n            shape3 += cirOutline(vec2(uv2.x + (float(i)/4.) + sin(u_time * 0.5 + (float(i))), uv2.y+ sin(float(i)/4.) + cos(u_time)), 0.0525);\n            shape4 += cirOutline(vec2(uv2.x + (float(i)/4.) + sin(u_time + (float(i))), uv2.y+ sin(float(i)/4.) + cos(u_time)), 0.0525);\n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=0; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.25));\n            float y = sin(u_time + uv2.x + (float(i) * sin(u_time + 25.) * 0.1));\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i)), uv2.y), y, 0.05 );\n        }\n        \n        color += shape1; \n        color += shape2;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _E=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=0; i<=20; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.125) + 2.5);\n            float y = abs(sin(u_time + uv2.x + (float(i) * cos(u_time + 025.) * 0.00161)) + 1.5);\n            float x = abs(cos(u_time + uv2.x + (float(i) * sin(u_time + 025.) * 0.00161)) + 1.5);\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i)), uv2.y), x / y, 0.0375 );\n        }\n        \n        color += shape1; \n        color += shape2;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function UE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_E,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=0; i<=20; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.125) + 2.5);\n            float y = abs(sin(u_time + uv2.x + (float(i) * cos(u_time + 025.) * 0.00161)) + .05);\n            float x = abs(cos(u_time + uv2.x + (float(i) * sin(u_time + 025.) * 0.00161)) + .05);\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i) * u_time), uv2.y), x, 0.04575 );\n        }\n        \n        color += shape1; \n        color += shape2;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function SE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=8; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.25) + 10.5);\n            float y = (sin(u_time + uv2.x + (float(i) * cos(u_time * 25.) * 0.00161)) + .05);\n            float x = (cos(u_time + uv2.x + (float(i) * sin(u_time * 25.) * 0.00161)) + .05);\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i)/100. + u_time), uv2.y), x, 0.04575 );\n        }\n\n        float z = circle(uv2, 10.5);\n        \n        color += shape1; \n        color += shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ME(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=8; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, cos(u_time * 0.025) + 10.5 / 1.);\n            float y = (sin(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05);\n            float x = (sin(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05);\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i)/100. + u_time), uv2.y), x * y, 0.04575 );\n        }\n\n        float z = circle(uv2, 10.5);\n        \n        color += shape1; \n        color += shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function CE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=5; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, cos(u_time * 0.025) + 10.5 / 1.);\n            float y = (sin(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            float x = (sin(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            float z = (cos(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            float a = (cos(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i)/100. + u_time), uv2.y), y * x, 0.075 );\n            shape2 += plot(vec2(uv2.x + cos(u_time + float(i)/100. * u_time), uv2.y), z * a, 0.075 );\n        }\n\n        float z = circle(uv2, 10.5);\n        \n        color += shape1; \n        color *= shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function RE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:TE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        vec2 uv3 = vUv;\n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *15. - 15.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=10; i++)\n        {\n            for(int j=1; j<=10; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i) * 1.5, newUv.y + float(j) * 1.5), sin(u_time + 0.075 * float(j + i))*4.);\n                float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(1.));\n                \n                shape1 += line;\n            }\n            // uv2 = uv2 * 1.1 - 0.1;\n            \n            // float y = (sin(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            // float x = (sin(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            // float z = (cos(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            // float a = (cos(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            // shape1 += plot(vec2(uv2.x + sin(u_time + float(i)/100. + u_time), uv2.y), y * x, 0.075 );\n            // shape2 += plot(vec2(uv2.x + cos(u_time + float(i)/100. * u_time), uv2.y), z * a, 0.075 );\n        }\n\n        float z = circle(uv3, 0.75);\n        \n        color += shape1; \n        // color *= shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function PE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:DE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        vec2 uv3 = vUv;\n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *25. - 25.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=20; i++)\n        {\n            for(int j=1; j<=20; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i) * 1.5, newUv.y + float(j) * 1.5), sin(u_time + 0.075 * float(j * i)/4.)*4.);\n                float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                \n                shape1 += line;\n            }\n            // uv2 = uv2 * 1.1 - 0.1;\n            \n            // float y = (sin(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            // float x = (sin(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            // float z = (cos(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            // float a = (cos(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            // shape1 += plot(vec2(uv2.x + sin(u_time + float(i)/100. + u_time), uv2.y), y * x, 0.075 );\n            // shape2 += plot(vec2(uv2.x + cos(u_time + float(i)/100. * u_time), uv2.y), z * a, 0.075 );\n        }\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color *= shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function FE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        vec2 uv3 = vUv;\n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *25. - 24.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=15; i++)\n        {\n            for(int j=1; j<=15; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i) * 1.5, newUv.y + float(j) * 1.5), cos(u_time + 0.08 * float(j * i)/5.) + 0.53*1.9);\n                float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                float r = rect(vec2(newUv), 0.45, 3.);\n                shape1 += r;\n            }\n        }\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color *= shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function IE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:EE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        vec2 uv3 = vUv;\n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *15. - 15.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=15; i++)\n        {\n            for(int j=1; j<=15; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i) * 1.5, newUv.y + float(j) * 1.5), cos(u_time + 0.08 * float(j * i)/5.) + 0.53*1.9);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                shape1 += c;\n            }\n        }\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color *= shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function LE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:OE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *2. - 0.5;\n        // uv2.x -= 1.;\n        vec2 uv3 = uv2;\n        uv2 = Rot(uv2, u_time * 0.75);\n        uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<=5; i++)\n        {\n            for(int j=1; j<=15; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i) * 0.085, newUv.y + float(i) * .085), (u_time + 0.08 * float(j * i)/5.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                shape1 += rectOutline(vec2(newUv), 0.5, 0.5);\n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function NE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:AE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *1.5 - 0.5;\n        uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<=13; i++)\n        {\n            for(int j=1; j<=10; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i /2) * 0.085, newUv.y + float(j) * .085), sin(u_time + 0.05 * float(j * i)/2.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                // float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                shape1 += rectOutline(vec2(newUv), 0.15, 0.15);\n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function BE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:GE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<=5; i++)\n        {\n            for(int j=1; j<=5; j++)\n            {\n                \n                vec2 newUv = uv2;\n                // newUv = Rot(vec2(newUv.x + float(i /2) * 0.085, newUv.y + float(j) * .085), sin(u_time + 0.05 * float(j * i)/2.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                // float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                // shape1 += rectOutline(vec2(newUv), 0.15, 0.15);\n                // for (int i=0; i<=10; i++)\n                \n            // uv2 = uv2 * 1.1 - 0.1;\n                uv2 = Rot(uv2, (u_time * float(i * j) * 0.025)/11. + 100.);\n                shape1 += circle(vec2(uv2.x + sin(float(i) + u_time)  , uv2.y), 0.00525);\n                shape2 += circle(vec2(uv2.x  , uv2.y + sin(float(i) + u_time)), 0.00525);\n                shape3 += circle(vec2(uv2.x + sin(float(i) + u_time), uv2.y + sin(float(i) + u_time)), 0.00525);\n                shape4 += circle(vec2(uv2.x - sin(float(i) + u_time), uv2.y + sin(float(i) + u_time)), 0.00525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        \n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        color += shape2;\n        // color *= z;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function VE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<7; i++)\n        {\n            for(int j=1; j<=7; j++)\n            {\n                \n                vec2 newUv = uv2;\n                // newUv = Rot(vec2(newUv.x + float(i /2) * 0.085, newUv.y + float(j) * .085), sin(u_time + 0.05 * float(j * i)/2.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                // float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                // shape1 += rectOutline(vec2(newUv), 0.15, 0.15);\n                // for (int i=0; i<=10; i++)\n                \n            // uv2 = uv2 * 1.1 - 0.1;\n                uv2 = Rot(uv2, sin(u_time * 0.000115));\n                shape1 += circle(vec2(uv2.x + sin(float(i * j) + (u_time * 0.5))  , uv2.y), 0.00525);\n                shape2 += circle(vec2(uv2.x  , uv2.y + cos(float(i - j) + (u_time * 0.5))), 0.00525);\n                shape3 += circle(vec2(uv2.x + sin(float(j -i  ) + (u_time * 0.5)), uv2.y + cos(float(j * i) + (u_time * 0.5))), 0.00525);\n                shape4 += circle(vec2(uv2.x - sin(float(j * i) +(u_time * 0.5)), uv2.y + cos(float(j * i) + (u_time * 0.5))), 0.00525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        \n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        color += shape2;\n        // color *= z;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function HE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:WE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<15; i++)\n        {\n            for(int j=1; j<=10; j++)\n            {\n                \n                vec2 newUv = uv2;\n                // newUv = Rot(vec2(newUv.x + float(i /2) * 0.085, newUv.y + float(j) * .085), sin(u_time + 0.05 * float(j * i)/2.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                // float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                // shape1 += rectOutline(vec2(newUv), 0.15, 0.15);\n                // for (int i=0; i<=10; i++)\n                \n            // uv2 = uv2 * 1.1 - 0.1;\n                uv2 = Rot(uv2, sin(u_time * 0.00115 * float(i)));\n                shape1 += circle(vec2(uv2.x + sin(float(i - j)/30. + (u_time * 0.25)) * 2. , uv2.y), 0.00525);\n                shape2 += circle(vec2(uv2.x  , uv2.y + cos(float(i - j) + (u_time * 0.5))), 0.00525);\n                shape3 += circle(vec2(uv2.x + sin(float(j -i  ) + (u_time * 0.5)), uv2.y + cos(float(j * i) + (u_time * 0.5))), 0.00525);\n                shape4 += circle(vec2(uv2.x - sin(float(j * i) +(u_time * 0.5)), uv2.y + cos(float(j * i) + (u_time * 0.5))), 0.00525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        \n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function YE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:XE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $E=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<15; i++)\n        {\n            for(int j=1; j<=5; j++)\n            {\n                \n                vec2 newUv = uv2;\n                // newUv = Rot(vec2(newUv.x + float(i /2) * 0.085, newUv.y + float(j) * .085), sin(u_time + 0.05 * float(j * i)/2.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                // float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                // shape1 += rectOutline(vec2(newUv), 0.15, 0.15);\n                // for (int i=0; i<=10; i++)\n                \n            // uv2 = uv2 * 1.1 - 0.1;\n                uv2 = Rot(uv2, (sin(u_time * 0.0525)));\n                // shape1 += circle(vec2(uv2.x + sin(float(i * j)/30. + (u_time * 0.25)) * 1. , uv2.y), 0.00525);\n                shape1 += sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.) * sin(float(i + j)));\n                // shape2 += circle(vec2(uv2.x  , uv2.y + cos(float(i - j) + (u_time * 0.5))), 0.00525);\n                // shape3 += circle(vec2(uv2.x + sin(float(j ) + (u_time * 0.5)), uv2.y + cos(float(j) + (u_time * 0.5))), 0.00525);\n                // shape4 += circle(vec2(uv2.x - sin(float(j) +(u_time * 0.5)), uv2.y + cos(float(j ) + (u_time * 0.5))), 0.00525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        \n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ZE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$E,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<15; i++)\n        {\n            for(int j=1; j<=5; j++)\n            {\n                \n                vec2 newUv = uv2;\n                \n                uv2 = Rot(uv2, ((u_time * 0.01525) + 10.));\n                uv2 = noise(uv2) * 0.08 + uv2;\n                shape1 += sdSegment(vec2(uv2.x , uv2.y ), vec2(0.0), vec2(2.));\n                \n\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function JE(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:KE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QE=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *2. - .5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=2; i<5; i++)\n        {\n            for(int j=2; j<=5; j++)\n            {\n                \n                vec2 newUv = uv2;\n                \n                uv2 = Rot(uv2, (sin(u_time * 1.525)/5. - 10.2));\n                // uv2 = (noise(uv2) * 0.15) + uv2;\n                shape1 += sdSegment(vec2(uv2.x , uv2.y), vec2(0.0 + noise(uv2) * (cos(u_time)/1. + 2.) * 0.2, 0.0 + noise(uv2) * (sin(u_time)/1. + 2.)), vec2(0.0 + noise(uv2) * (cos(u_time)/1. + 2.), 0.0 + noise(uv2) * (sin(u_time)/1. + 2.)));\n                \n\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        // float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:QE,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *2. - .5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<14; i++)\n        {\n            for(int j=1; j<=4; j++)\n            {\n                \n                vec2 newUv = uv2;\n                \n                uv2 = Rot(uv2, (sin(u_time * .175)/4. + 11.0));\n                uv2 = (noise(uv2) * 0.15) + uv2;\n                shape1 += sdSegment(vec2(uv2.x , uv2.y), vec2(0.0), vec2(0.01 * float(i + j), 0.01 * float(i +j)));\n                shape2 += sdSegment(vec2(uv2.x , uv2.y), vec2(0.0), vec2(0.015 * float(j + i), 0.015 * float(j + i)));\n                \n\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        // float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:eI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *2. - .5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<5; i++)\n        {\n            for(int j=1; j<=4; j++)\n            {\n                \n                vec2 newUv = uv2;\n                \n                uv2 = Rot(uv2, (sin(u_time * .175)/6. + 11.0));\n                uv2 = (noise(uv2) * 0.15) + uv2;\n                shape1 += sdSegment(vec2(uv2.x , uv2.y), vec2(0.0), vec2(0.05 * float(i) + cos(u_time), 0.05 / float(i) + cos(u_time)));\n                shape2 += sdSegment(vec2(uv2.x , uv2.y), vec2(0.0), vec2(0.05 * float(i) + sin(u_time), 0.05 / float(i) + sin(u_time)));\n                \n\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 2.);\n        \n        color += shape1; \n        color += shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function oI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    float semi (vec2 p, float n)\n    {\n        float c = circle(vec2(p), n);\n        float c2 = circle(vec2(p), n + n * 0.05);\n        float r = rect(vec2(p.x, p.y- n * 0.45), n - n * 0.1, n + n * 0.5);\n        float r2= rect(vec2(p.x, p.y -0.2), n, n * 0.3);\n        float shape = r * c * 2.;\n        float shape2 = r2 * c2* 2.;\n        return shape;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        uv2 = uv2 *2. - .5;\n\n        for(int i = 1; i < 20; i++)\n        {\n            uv2 = Rot(uv2, ((u_time * .175)/1. + 1.0));\n            vec2 newUv = uv2;\n            shape1 += semi(newUv, float(i)/10. + 0.5);\n            shape2 -= semi(newUv, float(i)/10. + 0.45);\n        }\n        \n        \n        color += shape1; \n        color += shape2;\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function iI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:aI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    float semi (vec2 p, float n)\n    {\n        float c = circle(vec2(p), n);\n        float c2 = circle(vec2(p), n + n * 0.05);\n        float r = rect(vec2(p.x, p.y- n * 0.45), n - n * 0.1, n + n * 0.5);\n        float r2= rect(vec2(p.x, p.y -0.2), n, n * 0.3);\n        float shape = r * c * 2.;\n        float shape2 = r2 * c2* 2.;\n        return shape;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        uv2 = uv2 *2. - .5;\n\n        for(int i = 0; i < 20; i++)\n        {\n            uv2 = Rot(uv2, ((u_time * .275)));\n            vec2 newUv = uv2;\n            float n = noise(newUv) + u_time;\n            \n            shape1 += semi(newUv, float(i)/5. + 0.5);\n            shape2 -= semi(newUv, float(i)/5. + 0.45);\n            shape3 += semi(newUv, float(i)/10. + 0.52);\n            shape4 -= semi(newUv, float(i)/10. + 0.45);\n        }\n        \n        color += shape1; \n        color += shape2;\n        color *= shape3 * 1.5; \n        color += shape4;\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    float semi (vec2 p, float n)\n    {\n        float c = circle(vec2(p), n);\n        float c2 = circle(vec2(p), n + n * 0.05);\n        float r = rect(vec2(p.x, p.y- n * 0.45), n - n * 0.1, n + n * 0.5);\n        float r2= rect(vec2(p.x, p.y -0.2), n, n * 0.3);\n        float shape = r * c * 2.;\n        float shape2 = r2 * c2* 2.;\n        return shape;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        uv2 = uv2 *3. - 1.;\n\n        for(int i = 1; i < 80; i++)\n        {\n            uv2 = Rot(uv2, ((u_time * .275 )));\n            // uv2 *= 2. - 1.;\n            vec2 newUv = uv2;\n            // float n = noise(newUv) * u_time;\n            // newUv += n * 0.0005;\n            shape1 += semi(newUv, float(i)/5. + 0.5);\n            shape2 -= semi(newUv, float(i)/5. + 0.45);\n            shape3 += semi(newUv, float(i)/10. + 0.52);\n            shape4 -= semi(newUv, float(i)/10. + 0.45);\n        }\n        \n        color += shape1; \n        color += shape2;\n        color *= shape3 * 2.5; \n        color += shape4;\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n\n        uv2 *= 4.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 1.;\n        float seg;\n        float shape;\n\n        for(int y = -2; y <=2; y++){\n            for(int x = -2; x <=2; x++){\n                vec2 n = vec2(float(x), float(y));\n                vec2 p = random2(iUv + n);\n                p = 0.5 + 0.5 * sin(u_time + TWO_PI * p);\n                vec2 dif = n + p - fUv;\n                float dist = length(dif);\n                m_dist = min(m_dist, dist);\n                shape = min(m_dist, dist);\n                // m_dist = smoothstep(0.05, 0.051, m_dist);\n                \n                // seg = sdSegment(fUv, dif, dif * dis);\n            }\n        }\n        color += seg;\n        color += shape;\n        // color += smoothstep(0.9, 0.11, shape);\n        // color += 1. - m_dist;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n    \n        vec2 mg,mr;\n        float md=1.;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.75)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=0.5;\n        for(int i=-5;i<=5;i++){\n            for(int j=-5;j<=5;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.75)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.001){\n                    md=min(md,dot(.25*(mr+r),normalize(r-mr)));\n                    \n                }\n            }\n        }\n        return vec3(md, mr);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n\n        uv2 *= 5.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 50.;\n        float seg;\n        float shape;\n\n        vec3 s = voronoi(uv2);\n        float dd = length(s.yz);\n\n        color+=mix(vec3(1.), color, smoothstep(0.002, 0.05, dd * s.x));\n        // color += 1. - smoothstep(0.01, 0.012, s.x);\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n    \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n            }\n        }\n        return vec3(md, mr);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n\n        uv2 *= 10.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 50.;\n        float seg;\n        float shape;\n\n        vec3 s = voronoi(uv2);\n        float dd = length(s.yz) + 0.;\n\n        color+=mix(vec3(1.), color, smoothstep(0.09, 0.061, dd * s.x));\n        // color += 1. - smoothstep(0.01, 0.02, s.x);\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float seg;\n        vec2 uv2 = vUv;\n\n        uv2 *= 5.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 50.;\n        float shape;\n\n        vec3 s = voronoi(uv2);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/4., uv2.y  + cos(u_time)/4.));\n        float dd = length(s.yz) + 0.;\n        seg = sdSegment(fUv, vec2(s2.yz), vec2(s.yz));\n        color+=mix(vec3(1.), color, smoothstep(0.01, 0.021, s.x));\n        color+= mix(vec3(1.), color,smoothstep(0.01, 0.021, s2.x));\n        // color += 1. - smoothstep(0.01, 0.02, s.x);\n        \n        // color += seg;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float seg;\n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, u_time * 0.1);\n        uv2 *= 10.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 50.;\n        float shape;\n\n        vec3 s = voronoi(uv2);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        float dd = length(s.yz) + 0.;\n        seg = sdSegment(fUv, vec2(s2.yz), vec2(s.yz));\n        color.r+= 1. - smoothstep(0.01 * 2., 0.021 * 2., s.x);\n        color.g+= 1. - smoothstep(0.0075 * 2., (0.021-0.0025) * 4., s2.x);\n        color.b+= 1. - smoothstep(0.005 * 2., (0.021 -0.005) * 4., s3.x);\n        // color += 1. - smoothstep(0.01, 0.02, s.x);\n        \n        // color += seg;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _I=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float seg;\n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, u_time * 0.1);\n        uv2 *= 5.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 50.;\n        float shape;\n\n        vec3 s = voronoi(uv2);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        float dd = length(s.yz) + 0.;\n        seg = sdSegment(fUv, vec2(s2.yz), vec2(s.yz));\n        color.r+= 1. - smoothstep(0.01 * 2., 0.021 * 2.,  dd);\n        color.g+= 1. - smoothstep(0.0075 * 2., (0.021-0.0025) * 4., dd);\n        color.b+= 1. - smoothstep(0.005 * 2., (0.021 -0.005) * 4., s3.x / dd);\n        // color += 1. - smoothstep(0.01, 0.02, s.x);\n        \n        // color += seg;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function UI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_I,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n\n        uv2 *= 4.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 1.;\n        float seg;\n        float shape;\n\n        for(int y = -2; y <=2; y++){\n            for(int x = -2; x <=2; x++){\n                vec2 n = vec2(float(x), float(y));\n                vec2 p = random2(iUv + n);\n                p = 0.25 + 0.25 * sin(u_time + TWO_PI * p );\n                vec2 dif = n + p - fUv;\n                float dist = length(dif);\n                m_dist = min(m_dist, dist);\n                shape = min(m_dist, dist);\n                // m_dist = smoothstep(0.05, 0.051, m_dist);\n                \n                seg = sdSegment(p, vec2(m_dist /dist), vec2(m_dist));\n                color += seg;\n            }\n        }\n        \n        // color += shape;\n        // color += smoothstep(0.9, 0.11, shape);\n        // color += 1. - m_dist;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function SI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    #define S(a, b, t) smoothstep(a, b, t)\n\n    float DistLine(vec2 p, vec2 a, vec2 b)\n    {\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n        return length(pa - ba * t);\n    }\n\n    float N21(vec2 p)\n    {\n        p = fract(p * vec2(445.23, 789.92));\n        p += dot(p, p + 54.23 );\n        return fract(p.x * p.y);\n    }\n\n    vec2 N22(vec2 p)\n    {\n        float n = N21(p);\n        return vec2(n, N21(p + n));\n    }\n\n    vec2 GetPos(vec2 id, vec2 offset)\n    {\n        vec2 n = N22(id+offset) * u_time;\n        // float x = sin(u_time* n.x);\n        // float y = cos(u_time*n.y);\n        return offset + sin(n) * .4;\n    }\n\n    float Line(vec2 p, vec2 a, vec2 b)\n    {\n        float d = DistLine(p, a, b);\n        float m = S(.03, 0.01, d);\n        m *= S(1.0, .5, length(a -b));\n        return m;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n        \n        // float d = DistLine(uv2, vec2(0.), vec2(1.));\n        float m = 0.;\n        \n        uv2 *= 8.;\n        vec2 gv = fract(uv2) - 0.5;\n        vec2 id = floor(uv2);\n\n        // vec2 p = N22(id) - 0.5;\n\n        vec2 p[9];\n\n        // vec2 p = GetPos(id);\n        // float d = length(gv - p);\n        // m = S(0.1, 0.05, d);\n\n        int i = 0;\n        for(float y=-1.; y <=1.; y++)\n        {\n            for(float x=-1.; x<=1.; x++)\n            {\n                p[i++]= GetPos(id, vec2(x, y));\n            }\n        }\n\n        float t = u_time * 10.;\n\n        for(int i=0; i < 9; i++)\n        {\n            m += Line(gv, p[4], p[i]);\n            \n            vec2 j = (p[i] - gv) * 40.;\n            float sparkle = 1. / dot(j, j);\n\n            m += sparkle * (sin(t+p[i].x * 10.) * .5 + .5);\n        }\n        m += Line(gv, p[1], p[3]);\n        m += Line(gv, p[1], p[5]);\n        m += Line(gv, p[7], p[3]);\n        m += Line(gv, p[7], p[5]);\n\n        vec3 col = vec3(m);\n        // col.rg = gv;\n\n        // color.rg = col.rg;\n\n        // color += m;\n        // if(gv.x > .48 || gv.y > .48) col = vec3(1., 0, 0);\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function MI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    #define S(a, b, t) smoothstep(a, b, t)\n\n    float DistLine(vec2 p, vec2 a, vec2 b)\n    {\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n        return length(pa - ba * t);\n    }\n\n    float N21(vec2 p)\n    {\n        p = fract(p * vec2(445.23, 789.92));\n        p += dot(p, p + 54.23 );\n        return fract(p.x * p.y);\n    }\n\n    vec2 N22(vec2 p)\n    {\n        float n = N21(p);\n        return vec2(n, N21(p + n));\n    }\n\n    vec2 GetPos(vec2 id, vec2 offset)\n    {\n        vec2 n = N22(id+offset) * u_time;\n        // float x = sin(u_time* n.x);\n        // float y = cos(u_time*n.y);\n        return offset + sin(n) * .4;\n    }\n\n    float Line(vec2 p, vec2 a, vec2 b)\n    {\n        float d = DistLine(p, a, b);\n        float m = S(.03, 0.01, d);\n        float d2 = length(a - b);\n        m *= S(1.2, .8, d2) * .5 + S(.05, .03, abs(d2-.75));\n        return m;\n    }\n\n    float Layer(vec2 uv2)\n    {\n        float m;\n        vec2 gv = fract(uv2) - 0.5;\n        vec2 id = floor(uv2);\n\n        // vec2 p = N22(id) - 0.5;\n\n        vec2 p[9];\n\n        // vec2 p = GetPos(id);\n        // float d = length(gv - p);\n        // m = S(0.1, 0.05, d);\n\n        int i = 0;\n        for(float y=-1.; y <=1.; y++)\n        {\n            for(float x=-1.; x<=1.; x++)\n            {\n                p[i++]= GetPos(id, vec2(x, y));\n            }\n        }\n\n        float t = u_time * 10.;\n\n        for(int i=0; i < 9; i++)\n        {\n            m += Line(gv, p[4], p[i]);\n            \n            vec2 j = (p[i] - gv) * 40.;\n            float sparkle = 1. / dot(j, j);\n\n            m += sparkle * (sin(t+fract(p[i].x) * 10.) * .5 + .5);\n        }\n        m += Line(gv, p[1], p[3]);\n        m += Line(gv, p[1], p[5]);\n        m += Line(gv, p[7], p[3]);\n        m += Line(gv, p[7], p[5]);\n\n        return m;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, u_time * 0.1);\n        uv2 -= 0.5;\n        \n        // float d = DistLine(uv2, vec2(0.), vec2(1.));\n        float m = 0.;\n        float t = u_time * 0.05;\n        \n        for(float i =0.; i <1.; i+= 1./4.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(20., .1, z);\n            float fade = S(0., 0.5, z) * S(1., 0.8, z);\n            m += Layer(uv2 * size + i * 20.) * fade;\n        }\n        \n\n        vec3 base = sin(t * vec3(.345, .456, .678)) * .4 + .6;\n        vec3 col = m * base;\n        col += uv2.y * base * 0.2;\n        col -= uv2.x  * base * 0.2;\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function CI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float GetDist(vec3 p)\n    {\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p.y;\n\n        float d = min(sphereDist, planeDist);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(0, 5, 6);\n        lightPos.xz += vec2(sin(u_time), cos(u_time)) * 2.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 1, 0);//camera\n        vec3 rd = normalize(vec3(uv2.x, uv2.y, 1));//ray direction\n\n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n\n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function RI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:TI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p.y;\n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, .5, 6), vec2(1., 0.3));\n        float bd = sdBox(p - vec3(-3, .75, 6), vec3(.5));\n        float cyld = sdCylinder(p, vec3(0, .3, 3), vec3(3, 1, 6), 0.2);\n\n        // float d = min(sphereDist, planeDist);\n        float d = min(cd, planeDist);\n        d = min(d, td);\n        d = min(d, bd);\n        d = min(d, cyld);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(0, 5, 6);\n        lightPos.xz += vec2(sin(u_time), cos(u_time)) * 2.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(sin(u_time), 3, -2.-cos(u_time));//camera\n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2, 1));//ray direction\n\n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n\n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function PI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:DI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p.y;\n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p - vec3(0, 2.75, 6.+ sin(u_time) * 2.), vec3(.5));\n        float bd2 = sdBox(p - vec3(0, 2.75+ cos(u_time * 2.) * 2., 6.), vec3(.5));\n        float bd3 = sdBox(p - vec3(0. + cos(u_time * 2.) * 2., 0.75, 6.), vec3(.5));\n        float cyld = sdCylinder(p, vec3(0, .3, 3), vec3(3, 1, 6), 0.2);\n\n        float d = min(bd, planeDist);\n        // float d = min(bd, planeDist);\n        d = min(bd, d);\n        d = min(bd2, d);\n        d = min(bd, d);\n        d = min(bd3, d);\n        // d = min(d, cyld);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 5, -2.-cos(u_time));//camera\n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2, 1));//ray direction\n\n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n\n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function FI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p2 - vec3(0, 2.75, 6.+ sin(u_time) * 2.), vec3(.5));\n        float bd2 = sdBox(p2 - vec3(0, 2.75+ cos(u_time * 2.) * 2., 6.), vec3(.5));\n        float bd3 = sdBox(p2 - vec3(0. + cos(u_time * 2.) * 2., 0.75, 6.), vec3(.5));\n        float cyld = sdCylinder(p, vec3(0, .3, 3), vec3(3, 1, 6), 0.2);\n\n        float d = min(bd, planeDist);\n        // float d = min(bd, planeDist);\n        d = min(bd, d);\n        d = min(bd2, d);\n        d = min(bd, d);\n        d = min(bd3, d);\n        // d = min(d, cyld);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(-1, 5, -6.);//camera\n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2, 1));//ray direction\n\n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n\n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function II(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:EI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p2 - vec3(0, 2.75 + sin(u_time), 6.), vec3(.5));\n        float bd2 = sdBox(p2 - vec3(-2. + sin(u_time), 2.75, 6.), vec3(.5));\n        float bd3 = sdBox(p2 - vec3(2. + sin(u_time), 2.75, 6.), vec3(.5));\n        float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        float d = min(bd, planeDist);\n        // float d = min(bd, planeDist);\n        d = min(bd, d);\n        d = min(bd2, d);\n        d = min(bd3, d);\n        d = min(cyld, d);\n        // d = min(d, cyld);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(-1, 5., -6.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function LI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:OI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, u_time);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p2 - vec3(0, 4.75 - sin(u_time), 6.), vec3(.5));\n        float bd2 = sdBox(p2 - vec3(-2. + sin(u_time), 2.75, 6.), vec3(.5));\n        float bd3 = sdBox(p2 - vec3(2. - sin(u_time), 2.75, 6.), vec3(.5));\n        float bd4 = sdBox(p2 - vec3(0. , 1.75 + sin(u_time), 6.), vec3(.5));\n        float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        float d = min(bd, planeDist);\n        // float d = min(bd, planeDist);\n        d = min(bd, d);\n        d = min(bd2, d);\n        d = min(bd3, d);\n        d = min(bd4, d);\n        // d = min(cyld, d);\n        // d = min(d, cyld);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(-1, 5., -6.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function NI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:AI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, u_time);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p2 - vec3(0, 4.75 - sin(u_time), 6.), vec3(.5));\n        float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float shape;\n        for(int i =0; i<= 5; i++)\n        {\n            // shape = sdBox(p2 - vec3(0., 0.+ (float(i)), 5.), vec3(.5));\n            // float d = min(shape, planeDist);\n            float d = min(sdBox(p2 - vec3(0. , 0. + 2., 6.), vec3(.5)), planeDist);\n            // d = min(bd, d);\n            d = min(bd2, d);\n            d = min(bd3, d);\n            d = min(bd4, d);\n        // d = min(cyld, d);\n        // d = min(d, cyld);\n            return d;\n            // return d;\n        }\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(-1, 5., -6.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function BI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:GI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, u_time);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox2(vec3 p, vec3 s)\n    {\n        p = rotateX(p, u_time);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox3(vec3 p, vec3 s)\n    {\n        p = rotateZ(p, u_time);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p - vec3(0, 3. , 6.), vec3(.5));\n        float bd2 = sdBox2(p - vec3(0, 4.5 , 6.), vec3(.5));\n        float bd3 = sdBox3(p - vec3(0, 1.5 , 6.), vec3(.5));\n        float bd4 = sdBox3(p - vec3(-1.5, 3. , 6.), vec3(.5));\n        float bd5 = sdBox(p - vec3(-1.5, 4.5 , 6.), vec3(.5));\n        float bd6 = sdBox2(p - vec3(-1.5, 1.5 , 6.), vec3(.5));\n        float bd7 = sdBox2(p - vec3(1.5, 3. , 6.), vec3(.5));\n        float bd8 = sdBox3(p - vec3(1.5, 4.5 , 6.), vec3(.5));\n        float bd9 = sdBox(p - vec3(1.5, 1.5 , 6.), vec3(.5));\n        // float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        // float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        // float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        // float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float d = min(bd, planeDist);\n        d = min(bd2, d);\n        d = min(bd3, d);\n        d = min(bd4, d);\n        d = min(bd5, d);\n        d = min(bd6, d);\n        d = min(bd7, d);\n        d = min(bd8, d);\n        d = min(bd9, d);\n\n        return d;\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 4., 0.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function VI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox2(vec3 p, vec3 s)\n    {\n        p = rotateX(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox3(vec3 p, vec3 s)\n    {\n        p = rotateZ(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p - vec3(0. + sin(u_time), 3. + cos(u_time), 6.), vec3(.5));\n        float bd2 = sdBox2(p - vec3(0. + cos(u_time), 4.5 + cos(u_time) , 6.), vec3(.5));\n        float bd3 = sdBox3(p - vec3(0. + sin(u_time), 1.5 + cos(u_time), 6.), vec3(.5));\n        float bd4 = sdBox3(p - vec3(-1.5 + sin(u_time), 3. + cos(u_time) , 6.), vec3(.5));\n        float bd5 = sdBox(p - vec3(-1.5, 4.5 , 6.), vec3(.5));\n        float bd6 = sdBox2(p - vec3(-1.5, 1.5 , 6.), vec3(.5));\n        float bd7 = sdBox2(p - vec3(1.5 + sin(u_time), 3. + sin(u_time) , 6.), vec3(.5));\n        float bd8 = sdBox3(p - vec3(1.5, 4.5 , 6.), vec3(.5));\n        float bd9 = sdBox(p - vec3(1.5, 1.5 , 6.), vec3(.5));\n        // float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        // float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        // float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        // float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float d = min(bd, planeDist);\n        d = min(bd2, d);\n        d = min(bd3, d);\n        d = min(bd4, d);\n        // d = min(bd5, d);\n        // d = min(bd6, d);\n        d = min(bd7, d);\n        // d = min(bd8, d);\n        // d = min(bd9, d);\n\n        return d;\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 4., 0.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function HI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:WI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus2(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox2(vec3 p, vec3 s)\n    {\n        p = rotateX(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox3(vec3 p, vec3 s)\n    {\n        p = rotateZ(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 3., 6), vec2(1., 0.3));\n        float bd = sdBox(p - vec3(0., 3., 6.), vec3(.5));\n        float td2 = sdTorus2(p-vec3(0, 3., 6), vec2(.4, 0.2));\n        // float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        // float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        // float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        // float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float d = min(td, planeDist);\n\n        d = min(td2, d);\n\n        return d;\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 4., 0.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function YI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:XI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $I=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus2(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus3(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateZ(p, (u_time));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus4(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time *2.));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox2(vec3 p, vec3 s)\n    {\n        p = rotateX(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox3(vec3 p, vec3 s)\n    {\n        p = rotateZ(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 3., 6), vec2(1., 0.2));\n        float bd = sdBox(p - vec3(0., 3., 6.), vec3(.5));\n        float td2 = sdTorus2(p-vec3(0, 3., 6), vec2(.4, 0.1));\n        float td3 = sdTorus3(p-vec3(0, 3., 6), vec2(1.5, 0.1));\n        float td4 = sdTorus4(p-vec3(0, 3., 6), vec2(2.0, 0.2));\n        // float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        // float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        // float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        // float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float d = min(td, planeDist);\n\n        d = min(td2, d);\n        d = min(td3, d);\n        d = min(td4, d);\n\n        return d;\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 4., 0.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ZI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$I,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus2(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus3(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateZ(p, (u_time));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus4(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time *2.));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox2(vec3 p, vec3 s)\n    {\n        p = rotateX(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox3(vec3 p, vec3 s)\n    {\n        p = rotateZ(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n        float n = cnoise(p + u_time) * 0.15;\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 3., 6) + n, vec2(1., 0.2));\n        float bd = sdBox(p - vec3(0., 3., 6.) + n, vec3(.5));\n        float td2 = sdTorus2(p-vec3(0, 3., 6), vec2(.4, 0.1));\n        float td3 = sdTorus3(p-vec3(0, 3., 6), vec2(1.5, 0.1));\n        float td4 = sdTorus4(p-vec3(0, 3., 6) + n, vec2(2.0, 0.2));\n        // float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        // float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        // float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        // float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float d = min(bd, planeDist);\n\n        // d = min(td2, d);\n        // d = min(td3, d);\n        d = min(td4, d);\n\n        return d;\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 4., 0.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function JI(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:KI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QI=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        float d = max(a.w, b.w);\n        return d == a.w? a : b;\n    }\n    \n    vec4 unionSDF(vec4 a, vec4 b) {\n        float d = min(a.w, b.w);\n        return d == a.w? a : b;\n    }\n    \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        float d = max(a.w, -b.w);\n        return d == a.w ? a : vec4(b.rgb,-b.w);\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1.); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(u_time * .2);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.,1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,1.05));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0);\n     \n    csg0 = differenceSDF(b0,s0); // Intersect box with sphere creating a CSG object.\n\n    \n     \n    // csg1 = unionSDF(c0,c1); // Unite cylinders\n    // csg1 = unionSDF(csg1,c2);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg0, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(5.*sin(u_time),5.,5.*cos(u_time));// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.5,-3.5); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:QI,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        float d = max(a.w, b.w);\n        return d == a.w? a : b;\n    }\n    \n    vec4 unionSDF(vec4 a, vec4 b) {\n        float d = min(a.w, b.w);\n        return d == a.w? a : b;\n    }\n    \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        float d = max(a.w, -b.w);\n        return d == a.w ? a : vec4(b.rgb,-b.w);\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1.); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(u_time * .2);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.85,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .2);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .2);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.,1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,1.05));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0);\n     \n    csg0 = differenceSDF(b0, b1); // Intersect box with sphere creating a CSG object.\n\n    \n     \n    csg1 = differenceSDF(csg0,b2);\n\n    // csg1 = unionSDF(csg1,c2);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg1, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.5,-3.5); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:eO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1.); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(u_time * .2);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.85,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .2);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .2);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2.,1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0.,0.5,1.);\n    s1p=p-s1p;\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, b1, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, s0, 0.15 + sin(u_time * 1.5)/8.);\n     \n    csg2 = smoothDifferenceSDF(csg1, s1, 0.15 + cos(u_time * 1.5)/8.);\n\n    csg3 = smoothDifferenceSDF(csg2, b2, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg3, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function oO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(1,0,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1.); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(u_time * .4);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(1.5,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2.,1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0.,0.5,1.);\n    s1p=p-s1p;\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n     \n    csg0 = smoothUnionSDF(b0, b1, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothUnionSDF(csg0, s0, 0.25);\n     \n    // csg2 = smoothDifferenceSDF(csg1, s1, 0.15 + cos(u_time * 1.5)/8.);\n\n    csg3 = smoothUnionSDF(csg1, b2, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg3, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function iO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:aO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(1,0,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(u_time * .4);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(1.5,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2. - sin(u_time),1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0.,2. + sin(u_time),1.);\n    s1p=p-s1p;\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, b1, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothUnionSDF(csg0, s1, 0.25);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.25);\n\n    csg3 = smoothUnionSDF(csg2, s1, 0.25);\n\n    csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    csg5 = smoothDifferenceSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg5, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(1,0,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.0175,1.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(1.5,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2. - sin(u_time),1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0. + sin(u_time),2. ,1.);\n    s1p=p-s1p;\n    s1p.xz *=Rotate(0.1);\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, p0, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothUnionSDF(csg0, s1, 0.25);\n     \n    // csg2 = smoothUnionSDF(csg1, s1, 0.25);\n\n    // csg3 = smoothUnionSDF(csg2, s1, 0.25);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothDifferenceSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg1, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.0175,1.75,1.5); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1 + sin(u_time));\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(1.5,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(2.,2. - sin(u_time),2.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0. + sin(u_time) * 2.,2. ,.5);\n    s1p=p-s1p;\n    s1p.xz *=Rotate(0.1);\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, p0, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothUnionSDF(csg0, s1, 0.25);\n     \n    // csg2 = smoothUnionSDF(csg1, s1, 0.25);\n\n    // csg3 = smoothUnionSDF(csg2, s1, 0.25);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothDifferenceSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg1, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.25 + sin(u_time)/5.)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.75); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(BoxColor1.rgb,roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(2.,2. - sin(u_time),2.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, p0, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b2, 0.25);\n     \n    csg2 = smoothDifferenceSDF(csg1, b1, 0.25);\n\n    // csg3 = smoothUnionSDF(csg2, s1, 0.25);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothDifferenceSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg0, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.25 + sin(u_time)/5.)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.75); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(1.25,.5,.75);\n    vec3 b3p = vec3(0., 1.5, 1.);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2. - sin(u_time),0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,.5));\n\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothUnionSDF(b1, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b2, 0.125);\n     \n    csg2 = unionSDF(csg1, b3);\n\n    csg3 = smoothUnionSDF(csg2, s0, 0.125);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothDifferenceSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg3, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.25 + sin(u_time)/5.)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.75); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,0.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.0,0.75);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p,1.5 + sin(u_time)/2. - 0.5));\n\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, s1, 0.125); // Intersect box with sphere creating a CSG object.\n\n    // csg1 = smoothDifferenceSDF(csg0, s1, 0.125);\n     \n    // csg2 = unionSDF(csg1, b3);\n\n    // csg3 = smoothUnionSDF(csg2, s0, 0.125);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothUnionSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg0, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.25 + sin(u_time)/5.)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.75); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,0.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.0,0.75);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p,1.5 + sin(u_time)/2. - 0.5));\n\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, s1, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothUnionSDF(csg0, b1, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, b2, 0.125);\n\n    // csg3 = smoothUnionSDF(csg2, s0, 0.125);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothUnionSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg2, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _O=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdFour(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.0005,0.25); //box size\n    vec3 b0p = vec3(0.,1.5,-0.4 ); // box position\n    b0p = p-b0p;\n    // b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.045 + sin(u_time)/8. + 0.2)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.175); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    // b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    // b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.1,-0.45);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p, 0.35));\n\n     // Sphere.\n     vec3 s2p=vec3(-0.65,2.5,-0.45);\n     s2p=p-s2p;\n    //  s2p.xz *=Rotate(u_time * .4);\n     vec4 s2 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s2p, 0.35));\n\n     // Sphere.\n     vec3 s3p=vec3(0.65,2.5,-0.45);\n     s3p=p-s3p;\n     vec4 s3 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s3p, 0.35));\n\n      // Sphere.\n      vec3 s4p=vec3(-0.65,2.5,-0.1);\n      s4p=p-s4p;\n     //  s2p.xz *=Rotate(u_time * .4);\n      vec4 s4 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s4p, 0.25));\n \n      // Sphere.\n      vec3 s5p=vec3(0.65,2.5,-0.15);\n      s5p=p-s5p;\n      vec4 s5 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s5p, 0.25));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0), csg6 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b0, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.125);\n\n    csg3 = smoothDifferenceSDF(csg2, s2, 0.5);\n\n    csg4 = smoothDifferenceSDF(csg3, s3, 0.5);\n\n    csg5 = smoothUnionSDF(csg4, s4, 0.15);\n\n    csg6 = smoothUnionSDF(csg5, s5, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg6, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function UO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_O,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdFive(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.0005,0.25); //box size\n    vec3 b0p = vec3(0.,1.5,-0.4 ); // box position\n    b0p = p-b0p;\n    // b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.045 + sin(u_time)/8. + 0.2)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.175); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    // b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    // b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n\n    //smile\n    vec3 b4s = vec3(.5);\n    vec3 b4p = vec3(0.,2.,-0.65 ); // box position\n    b4p = p-b4p;\n    b4p.zy *=Rotate(PI);\n    vec4 b4 = vec4(BoxColor1.rgb, cappedTorusSDF(b4p, vec2(.65 + abs(sin(u_time))/5., 0.5), 0.8, 0.075 ));\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.1,-0.45);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p, 0.35));\n\n     // Sphere.\n     vec3 s2p=vec3(-0.65,2.5,-0.45);\n     s2p=p-s2p;\n    //  s2p.xz *=Rotate(u_time * .4);\n     vec4 s2 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s2p, 0.35));\n\n     // Sphere.\n     vec3 s3p=vec3(0.65,2.5,-0.45);\n     s3p=p-s3p;\n     vec4 s3 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s3p, 0.35));\n\n      // Sphere.\n      vec3 s4p=vec3(-0.65,2.5,-0.1);\n      s4p=p-s4p;\n     //  s2p.xz *=Rotate(u_time * .4);\n      vec4 s4 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s4p, 0.25));\n \n      // Sphere.\n      vec3 s5p=vec3(0.65,2.5,-0.15);\n      s5p=p-s5p;\n      vec4 s5 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s5p, 0.25));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0), csg6 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b4, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.125);\n\n    csg3 = smoothDifferenceSDF(csg2, s2, 0.5);\n\n    csg4 = smoothDifferenceSDF(csg3, s3, 0.5);\n\n    csg5 = smoothUnionSDF(csg4, s4, 0.15);\n\n    csg6 = smoothUnionSDF(csg5, s5, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg6, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function SO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdSix(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.0005,0.25); //box size\n    vec3 b0p = vec3(0.,1.5,-0.4 ); // box position\n    b0p = p-b0p;\n    // b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.045 + sin(u_time)/8. + 0.2)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.175); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    // b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    // b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n\n    //smile\n    vec3 b4s = vec3(.5);\n    vec3 b4p = vec3(0.,0.6,-0.7 - sin(u_time)/15. ); // box position\n    b4p = p-b4p;\n    b4p.zy *=Rotate(PI * 2.);\n    vec4 b4 = vec4(BoxColor1.rgb, cappedTorusSDF(b4p, vec2(.65 + abs(sin(u_time))/5., 0.5), 0.8, 0.075 ));\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.1,-0.45);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p, 0.35));\n\n     // Sphere.\n     vec3 s2p=vec3(-0.65,2.24,-0.45);\n     s2p=p-s2p;\n    //  s2p.xz *=Rotate(u_time * .4);\n     vec4 s2 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s2p, 0.35));\n\n     // Sphere.\n     vec3 s3p=vec3(0.65,2.24,-0.6);\n     s3p=p-s3p;\n     vec4 s3 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s3p, 0.35));\n\n      // Sphere.\n      vec3 s4p=vec3(-0.65,2.24,-0.1);\n      s4p=p-s4p;\n     //  s2p.xz *=Rotate(u_time * .4);\n      vec4 s4 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s4p, 0.125));\n \n      // Sphere.\n      vec3 s5p=vec3(0.65,2.24,-0.1);\n      s5p=p-s5p;\n      vec4 s5 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s5p, 0.125));\n\n      vec4 s6 = vec4(vec3(0, 0, 0), sphereSDF(s5p, 0.125));\n      vec4 s7 = vec4(vec3(0, 0, 0), sphereSDF(s4p, 0.125));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0), csg6 = vec4(0), csg7 = vec4(0), csg8 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b4, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.125);\n\n    csg3 = smoothDifferenceSDF(csg2, s2, 0.5);\n\n    csg4 = smoothDifferenceSDF(csg3, s3, 0.5);\n\n    csg5 = smoothUnionSDF(csg4, s4, 0.15);\n\n    csg6 = smoothUnionSDF(csg5, s5, 0.15);\n\n    csg7 = smoothUnionSDF(csg6, s6, 0.15);\n\n    csg8 = smoothUnionSDF(csg7, s7, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg8, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function MO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 t = vUv;\n        vUv -= 0.5;\n        // t *= 0.5;\n\n        for(int i = 0; i < 20; i++) {\n            float t = 2.0 * PI * float(i) / 30.0 * u_time * 0.5;\n            float x = cos(0.0*t);\n\t\t    float y = sin(2.0*t);\n            vec2 o = 0.40 * vec2(x + sin(u_time) - 1., y);\n            float r = fract(x);\n            float g = 1.0 - r;\n            color += 0.003 / (length(vUv - o)) * vec3(r, g, 0.9);\n        }\n        for(int i = 0; i < 20; i++) {\n            float t = 2.0 * PI * float(i) / 30.0 * u_time * 0.5;\n            float x = cos(2.0*t);\n\t\t    float y = sin(0.0*t);\n            vec2 o = 0.40 * vec2(x , y - sin(u_time) );\n            float r = fract(x);\n            float g = 1.0 - r;\n            color += 0.003 / (length(vUv - o)) * vec3(r, g, 0.9);\n        }\n        for(int i = 0; i < 20; i++) {\n            float t = 2.0 * PI * float(i) / 30.0 * u_time * 0.5;\n            float x = cos(2.0*t);\n\t\t    float y = sin(2.0*t);\n            vec2 o = 0.40 * vec2(x , y );\n            float r = fract(x);\n            float g = 1.0 - r;\n            color += 0.003 / (length(vUv - o)) * vec3(r, g, 0.9);\n        }\n\n        float numLabel = label(t);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function CO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdEight(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    // Octahedron - exact\n    float octahedronSDF(vec3 p,float s) {\n    p=abs(p);\n    float m=p.x+p.y+p.z-s;\n    vec3 q;\n    if(3.*p.x<m)q=p.xyz;\n    else if(3.*p.y<m)q=p.yzx;\n    else if(3.*p.z<m)q=p.zxy;\n    else return m*.57735027;\n \n    float k=clamp(.5*(q.z-q.y+s),0.,s);\n    return length(vec3(q.x,q.y-s+k,q.z-k));\n}\n\n    vec4 GetDist(vec3 p)\n    {\n        //octahedron\n\n        vec3 op = vec3(0, 2.5, 0);\n        op = p - op;\n        op.xy *= Rotate(-u_time);\n        op.xz *= Rotate(-u_time);\n\n        float r = fract(BoxColor.b);\n        float g = 1.0 - r;\n        vec4 o = vec4(BoxColor.rgb + vec3(r * cos(u_time), g * sin(u_time), 0.9 * sin(u_time)), octahedronSDF(op, 1.));\n\n        vec4 scene = vec4(0);\n\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n        scene = unionSDF(p0, o);\n        \n        \n    \n        return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function RO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:TO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdNine(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    // float sdNumHorizontal(vec2 p)\n    // {\n    //     vec2 newUv = p;\n    //     newUv.x += 0.125;\n    //     newUv.y -= 0.25;\n    //     vec2 uv1 = newUv;\n    //     vec2 uv2 = newUv;\n    //     uv1 = Rot(uv1, PI * 0.5);\n    //     uv1 /= .5;\n    //     uv1 -= 1.;\n\n    //     uv2 = Rot(uv2, -PI* .5);\n    //     uv2 /= .5;\n    //     uv2 -= 1.;\n    //     float shape1 = sdEqTriangle(uv1, 0.15);\n    //     shape1 = 1. - smoothstep(0.1, 0.11, shape1);\n\n    //     float shape2 = sdBox(vec2(uv1.x + 0.5, uv1.y+0.75), vec2(0.33, 0.2815));\n    //     shape2 = 1. - smoothstep(0.1, 0.11, shape2);\n\n    //     float shape3 = sdEqTriangle(vec2(uv2.x, uv2.y-0.5), 0.15);\n    //     shape3 = 1. - smoothstep(0.1, 0.11, shape3);\n\n    //     return shape1 + shape2 + shape3;\n    // }\n\n    // float sdNumVertical(vec2 p){\n    //     vec2 newUv = p;\n    //     newUv.x += 0.125;\n    //     newUv.y -= 0.25;\n    //     vec2 uv1 = newUv;\n    //     vec2 uv3 = newUv;\n    //     vec2 uv4 = newUv;\n    //     uv1 = Rot(uv1, PI * 0.5);\n    //     uv1 /= .5;\n    //     uv1 -= 1.;\n\n    //     uv3 = Rot(uv3, PI * 1.5);\n    //     uv3 /= .5;\n    //     uv3 -= 1.;\n    //     uv3.x -= 0.2;\n    //     uv3.y += 0.1;\n\n    //     uv4 = Rot(uv4, PI * 1.5);\n    //     uv4 /= .5;\n    //     uv4 -= 1.;\n    //     uv4.y += 0.1;\n    //     uv4.x -= 0.52;\n\n    //     float shape1 = sdEqTriangle(vec2(uv1.x + 0.36125, uv1.y-0.01), 0.125);\n    //     shape1 = 1. - smoothstep(0.1, 0.11, shape1);\n\n    //     float shape4 = sdEqTriangle(vec2(uv3.x, uv3.y), 0.14);\n    //     shape4 = 1. - smoothstep(0.1, 0.11, shape4);\n\n    //     float shape5 = sdBox(vec2(uv1.x + 0.859, uv1.y+0.442), vec2(0.35, 0.325));\n    //     shape5 = 1. - smoothstep(0.1, 0.11, shape5);\n\n    //     float shape6 = sdEqTriangle(vec2(uv4), 0.14);\n    //     shape6 = 1. - smoothstep(0.1, 0.11, shape6);\n\n    //     float tri = ((shape4 + shape6 + shape1 ) );\n    //     float sq = sdBox(vec2(uv1.x + 0.859, uv1.y +0.442), vec2(0.3));\n    //     sq = 1. - smoothstep(0.1, 0.11, sq);\n    //     float shape7 = sdBox(vec2(uv1.x + 0.859, uv1.y+0.442), vec2(0.3));\n    //     shape7 = 1. - smoothstep(0.1, 0.11, shape7);\n\n    //     return tri ;\n    // }\n\n   \n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float z = sdZero(vUv);\n        // color += z;\n\n        float zero = numZero(vUv);\n        // color += zero;\n        \n        float one = numOne(vUv);\n        color += one;\n\n        float two = numTwo(vUv);\n        // color += two;\n\n        float three = numThree(vUv);\n        // color += three;\n\n        float four = numFour(vUv);\n        // color += four;\n\n        float five = numFive(vUv);\n        // color += five;\n\n        float six = numSix(vUv);\n        // color += six;\n\n        float seven = numSeven(vUv);\n        // color += seven;\n\n        float eight = numEight(vUv);\n        // color += eight;\n        \n        float nine = numNine(vUv);\n        // color += nine;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function PO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:DO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n  \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float zero = numZero(vUv);\n        float one = numOne(vUv);\n        float two = numTwo(vUv);\n        float three = numThree(vUv);\n        float four = numFour(vUv);\n        float five = numFive(vUv);\n        float six = numSix(vUv);\n        float seven = numSeven(vUv);\n        float eight = numEight(vUv);\n        float nine = numNine(vUv);\n        // color += zero;\n\n        \n        // color += one;\n\n        float t = u_time;\n        t = t * 0.5;\n\n        if(fract(t) < 0.1)\n        {\n            color += zero;\n        }\n        if(fract(t) <= 0.2)\n        {\n            if(fract(t) > 0.1)\n            {\n                color += one;\n            }\n            \n        }\n        if(fract(t) <= 0.3)\n        {\n            if(fract(t) > 0.2)\n            {\n                color += two;\n            }\n        }\n        if(fract(t) <= 0.4)\n        {\n            if(fract(t) > 0.3)\n            {\n                color += three;\n            }\n        }\n        if(fract(t) <= 0.5)\n        {\n            if(fract(t) > 0.4)\n            {\n                color += four;\n            }\n        }\n        if(fract(t) <= 0.6)\n        {\n            if(fract(t) > 0.5)\n            {\n                color += five;\n            }\n        }\n        if(fract(t) <= 0.7)\n        {\n            if(fract(t) > 0.6)\n            {\n                color += six;\n            }\n        }\n        if(fract(t) <= 0.8)\n        {\n            if(fract(t) > 0.7)\n            {\n                color += seven;\n            }\n        }\n        if(fract(t) <= 0.9)\n        {\n            if(fract(t) > 0.8)\n            {\n                color += eight;\n            }\n        }\n        if(fract(t) <= 1.)\n        {\n            if(fract(t) > 0.9)\n            {\n                color += nine;\n            }\n        }\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function FO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    float tile(vec2 uv, float zoom)\n    {\n        uv *= zoom;\n\n        float index = 0.;\n        index += step(1., mod(uv.x, 3.));\n        index += step(1., mod(uv.y, 3.)) * 2.;\n        \n        uv = fract(uv);\n        float c;\n        float zero = numZero(uv);\n        float one = numOne(uv);\n        float two = numTwo(uv);\n        float three = numThree(uv);\n        float four = numFour(uv);\n        float five = numFive(uv);\n        float six = numSix(uv);\n        float seven = numSeven(uv);\n        float eight = numEight(uv);\n        float nine = numNine(uv);\n\n        float t = u_time;\n        t = t / 2.;\n\n        if(index == 0.)\n        {\n            c = zero;\n        } else if (index == 1.){\n            if(fract(t) < 0.1)\n            {\n                c += zero;\n            }\n            if(fract(t) <= 0.2)\n            {\n                if(fract(t) > 0.1)\n                {\n                    c += one;\n                }\n                \n            }\n            if(fract(t) <= 0.3)\n            {\n                if(fract(t) > 0.2)\n                {\n                    c += two;\n                }\n            }\n            if(fract(t) <= 0.4)\n            {\n                if(fract(t) > 0.3)\n                {\n                    c += three;\n                }\n            }\n            if(fract(t) <= 0.5)\n            {\n                if(fract(t) > 0.4)\n                {\n                    c += four;\n                }\n            }\n            if(fract(t) <= 0.6)\n            {\n                if(fract(t) > 0.5)\n                {\n                    c += five;\n                }\n            }\n            if(fract(t) <= 0.7)\n            {\n                if(fract(t) > 0.6)\n                {\n                    c += six;\n                }\n            }\n            if(fract(t) <= 0.8)\n            {\n                if(fract(t) > 0.7)\n                {\n                    c += seven;\n                }\n            }\n            if(fract(t) <= 0.9)\n            {\n                if(fract(t) > 0.8)\n                {\n                    c += eight;\n                }\n            }\n            if(fract(t) <= 1.)\n            {\n                if(fract(t) > 0.9)\n                {\n                    c += nine;\n                }\n            }\n        } else if (index == 2.){\n            c = two;\n        } else if (index == 3.){\n            c = three;\n        } else if (index == 4.){\n            c = four;\n        }else if (index == 5.){\n            c = five;\n        } else if (index == 6.){\n            c = six;\n        }\n\n        return c;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        float x = tile(uv2, 3.);\n        color += x;\n\n        float count = numZero(vec2(uv2.x + 0.2, uv2.y)) + numZero(vec2(uv2.x-0.2, uv2.y));\n\n        // color += count;\n        \n        // float zero = numZero(uv2);\n        // float one = numOne(uv2);\n        // float two = numTwo(uv2);\n        // float three = numThree(uv2);\n        // float four = numFour(uv2);\n        // float five = numFive(uv2);\n        // float six = numSix(uv2);\n        // float seven = numSeven(uv2);\n        // float eight = numEight(uv2);\n        // float nine = numNine(uv2);\n        // color += zero;\n\n        \n        // color += one;\n\n        // float t = u_time;\n        // t = t / 2.;\n\n        // if(fract(t) < 0.1)\n        // {\n        //     color += zero;\n        // }\n        // if(fract(t) <= 0.2)\n        // {\n        //     if(fract(t) > 0.1)\n        //     {\n        //         color += one;\n        //     }\n            \n        // }\n        // if(fract(t) <= 0.3)\n        // {\n        //     if(fract(t) > 0.2)\n        //     {\n        //         color += two;\n        //     }\n        // }\n        // if(fract(t) <= 0.4)\n        // {\n        //     if(fract(t) > 0.3)\n        //     {\n        //         color += three;\n        //     }\n        // }\n        // if(fract(t) <= 0.5)\n        // {\n        //     if(fract(t) > 0.4)\n        //     {\n        //         color += four;\n        //     }\n        // }\n        // if(fract(t) <= 0.6)\n        // {\n        //     if(fract(t) > 0.5)\n        //     {\n        //         color += five;\n        //     }\n        // }\n        // if(fract(t) <= 0.7)\n        // {\n        //     if(fract(t) > 0.6)\n        //     {\n        //         color += six;\n        //     }\n        // }\n        // if(fract(t) <= 0.8)\n        // {\n        //     if(fract(t) > 0.7)\n        //     {\n        //         color += seven;\n        //     }\n        // }\n        // if(fract(t) <= 0.9)\n        // {\n        //     if(fract(t) > 0.8)\n        //     {\n        //         color += eight;\n        //     }\n        // }\n        // if(fract(t) <= 1.)\n        // {\n        //     if(fract(t) > 0.9)\n        //     {\n        //         color += nine;\n        //     }\n        // }\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function IO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:EO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.0005,0.25); //box size\n    vec3 b0p = vec3(0.,1.5,-0.4 ); // box position\n    b0p = p-b0p;\n    // b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.045 + sin(u_time)/8. + 0.2)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.175); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    // b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    // b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n\n    //smile\n    vec3 b4s = vec3(.5);\n    vec3 b4p = vec3(0.,2.,-0.65 ); // box position\n    b4p = p-b4p;\n    b4p.zy *=Rotate(PI);\n    vec4 b4 = vec4(BoxColor1.rgb, cappedTorusSDF(b4p, vec2(.65 + abs(sin(u_time))/5., 0.5), 0.8, 0.075 ));\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.1,-0.45);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p, 0.35));\n\n     // Sphere.\n     vec3 s2p=vec3(-0.5,2.5,-0.5);\n     s2p=p-s2p;\n    //  s2p.xz *=Rotate(u_time * .4);\n     vec4 s2 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s2p, 0.35));\n\n     // Sphere.\n     vec3 s3p=vec3(0.5,2.5,-0.5);\n     s3p=p-s3p;\n     vec4 s3 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s3p, 0.35));\n\n      // Sphere.\n      vec3 s4p=vec3(-0.65,2.5,-0.15);\n      s4p=p-s4p;\n     //  s2p.xz *=Rotate(u_time * .4);\n      vec4 s4 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s4p, 0.25));\n \n      // Sphere.\n      vec3 s5p=vec3(0.65,2.5,-0.15);\n      s5p=p-s5p;\n      vec4 s5 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s5p, 0.25));\n\n      // Sphere.\n      vec3 s6p=vec3(-0.15,2.,-0.75);\n      s6p=p-s6p;\n      vec4 s6 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s6p, 0.012525));\n\n      vec3 s7p=vec3(0.15,2.,-0.75);\n      s7p=p-s7p;\n      vec4 s7 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s7p, 0.012525));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0), csg6 = vec4(0), csg7 = vec4(0), csg8 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b4, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.125);\n\n    csg3 = smoothDifferenceSDF(csg2, s2, 0.5);\n\n    csg4 = smoothDifferenceSDF(csg3, s3, 0.5);\n\n    csg5 = smoothUnionSDF(csg4, s4, 0.15);\n\n    csg6 = smoothUnionSDF(csg5, s5, 0.15);\n\n    csg7 = smoothDifferenceSDF(csg6, s6, 0.15);\n\n    csg8 = smoothDifferenceSDF(csg7, s7, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg8, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function LO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:OO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.0005,0.25); //box size\n    vec3 b0p = vec3(0.,1.5,-0.4 ); // box position\n    b0p = p-b0p;\n    // b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.045 + sin(u_time)/8. + 0.2)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.175); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    // b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    // b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n\n    //smile\n    vec3 b4s = vec3(.5);\n    vec3 b4p = vec3(0.,2.,-0.65 ); // box position\n    b4p = p-b4p;\n    b4p.zy *=Rotate(PI);\n    vec4 b4 = vec4(BoxColor1.rgb, cappedTorusSDF(b4p, vec2(.65 + abs(sin(u_time))/5., 0.5), 0.8, 0.075 ));\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.1,-0.45);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p, 0.35));\n\n     // Sphere.\n     vec3 s2p=vec3(-0.5,2.5,-0.5);\n     s2p=p-s2p;\n    //  s2p.xz *=Rotate(u_time * .4);\n     vec4 s2 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s2p, 0.35));\n\n     // Sphere.\n     vec3 s3p=vec3(0.5,2.5,-0.5);\n     s3p=p-s3p;\n     vec4 s3 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s3p, 0.35));\n\n      // Sphere.\n      vec3 s4p=vec3(-0.65,2.5,-0.15);\n      s4p=p-s4p;\n     //  s2p.xz *=Rotate(u_time * .4);\n      vec4 s4 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s4p, 0.25));\n \n      // Sphere.\n      vec3 s5p=vec3(0.65,2.5,-0.15);\n      s5p=p-s5p;\n      vec4 s5 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s5p, 0.25));\n\n      // Sphere.\n      vec3 s6p=vec3(-0.15,2.,-0.75);\n      s6p=p-s6p;\n      vec4 s6 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s6p, 0.012525));\n\n      vec3 s7p=vec3(0.15,2.,-0.75);\n      s7p=p-s7p;\n      vec4 s7 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s7p, 0.012525));\n\n      // Sphere.\n      vec3 s8p=vec3(0.65,2.5,-0.35);\n      s8p=p-s8p;\n      vec4 s8 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s8p, 0.125));\n\n      vec3 s9p=vec3(-0.65,2.5,-0.35);\n      s9p=p-s9p;\n      vec4 s9 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s9p, 0.125));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0), csg6 = vec4(0), csg7 = vec4(0), csg8 = vec4(0), csg9 = vec4(0), csg10 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b4, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.125);\n\n    csg3 = smoothDifferenceSDF(csg2, s2, 0.5);\n\n    csg4 = smoothDifferenceSDF(csg3, s3, 0.5);\n\n    csg5 = smoothUnionSDF(csg4, s4, 0.15);\n\n    csg6 = smoothUnionSDF(csg5, s5, 0.15);\n\n    csg7 = smoothDifferenceSDF(csg6, s6, 0.15);\n\n    csg8 = smoothDifferenceSDF(csg7, s7, 0.15);\n     \n    csg9 = smoothDifferenceSDF(csg8, s8, 0.15);\n    csg10 = smoothDifferenceSDF(csg9, s9, 0.15);\n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg10, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function NO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:AO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    float displacement =  sin(2.0 * p.x + (u_time)/1.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/1.) * 0.37525;\n    s0p=p-s0p + displacement;\n    \n    // s0p=p-s0p - displacement;\n    // s0p += displacement;\n    // s0p.z += sin(u_time);\n    float distortedSphere = distortSphere(p);\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 1.));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect \n\n    scene = smoothUnionSDF(s0, p0, 0.15);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function BO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:GO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    float displacement =  sin(2.0 * p.x + (u_time)/1.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/1.) * 0.37525;\n    s0p=p-s0p + displacement;\n    \n    // s0p=p-s0p - displacement;\n    // s0p += displacement;\n    // s0p.z += sin(u_time);\n    float distortedSphere = distortSphere(p);\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 1.));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n    float p1 = dot(p, normalize(vec3(1.5, 1.0,0.)));\n    vec4 plane = vec4(ColorRed.rgb, p1);\n\n    float b1 = boxSDF(p - vec3(-1.5,1.5,0), vec3(1));\n    vec4 box = vec4(ColorRed.rgb, b1 );\n    //shell\n    box = abs(box)-.1 + (sin(u_time * 0.5)/6.)-0.15;\n    // box.a += displacement;\n \n    vec4 scene = vec4(0), csg0 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect \n\n    scene = smoothIntersectSDF(box, plane, 0.15);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(4.9,4.5,-4.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.zx *= Rotate(PI*-.3 );\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function VO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    float displacement =  sin(2.0 * p.x + (u_time)/1.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/1.) * 0.37525;\n    s0p=p-s0p + displacement;\n    \n    // s0p=p-s0p - displacement;\n    // s0p += displacement;\n    // s0p.z += sin(u_time);\n    float distortedSphere = distortSphere(p);\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 1.));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n    float p1 = dot(p, normalize(vec3(1.5 + sin(u_time), 1.0 + sin(u_time),0.)));\n    vec4 plane = vec4(ColorRed.rgb, p1);\n    vec3 b1p = vec3(-1.5,1.5,0);\n    // b1p.yz *= Rotate((u_time));\n    float b1 = boxSDF(p - b1p, vec3(1));\n    vec4 box = vec4(ColorRed.rgb, b1 );\n    //shell\n    box = abs(box)-.1;\n    // box.xy *= Rotate(sin(u_time)); \n    // box.a += displacement;\n \n    vec4 scene = vec4(0), csg0 = vec4(0);\n     \n    csg0 = smoothIntersectSDF(box, plane, 0.125); // Intersect \n\n    scene = unionSDF(csg0, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(4.9,4.5,-4.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.zx *= Rotate(PI*-.3);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function HO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:WO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(-1.5,1.5,0);\n    float displacement =  sin(2.0 * p.x + (u_time)/2.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/2.) * 0.37525;\n    // s0p=p-s0p + displacement;\n    \n    // s0p=p-s0p - displacement;\n    // s0p += displacement;\n    // s0p.z += sin(u_time);\n    float distortedSphere = distortSphere(p);\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 0.15));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n    float p1 = dot(p, normalize(vec3(1.5 + sin(u_time), 1.0 + sin(u_time),0.)));\n    vec4 plane = vec4(ColorRed.rgb, p1);\n    vec3 b1p = vec3(-1.5,1.5,0);\n    // b1p.yz *= Rotate((u_time));\n    float b1 = boxSDF(p - b1p + displacement, vec3(1.25));\n    vec4 box = vec4(ColorRed.rgb, b1 );\n    //shell\n    box = abs(box)-.1;\n    // box.xy *= Rotate(sin(u_time)); \n    // box.a += displacement;\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0);\n     \n    csg0 = smoothUnionSDF(box, p0, 0.125);\n    csg1 = smoothUnionSDF(csg0, s0, 0.125); \n\n    scene = smoothUnionSDF(box, p0, 0.25);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n        lightPos.zx *= Rotate(PI * 1.75);\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(4.9 ,4.5,-4.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.zx *= Rotate(PI*-.3);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function YO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:XO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $O=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(.0,1.5,0);\n    float displacement =  sin(3.0 * p.x + (u_time)/2.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/2.) * 0.137525;\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 0.05));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n    float p1 = dot(p, normalize(vec3(1.5 + sin(u_time), 1.0 + sin(u_time),0.)));\n    vec4 plane = vec4(ColorRed.rgb, p1);\n    vec3 b1p = vec3(-.5,1.5,0);\n    b1p.xz *= Rotate((u_time));\n    \n    float s1 = sphereSDF(p - s0p + displacement, 1.75);\n    float s2 = sphereSDF(p - s0p + displacement, 0.5);\n    float b1 = boxSDF(p - b1p , vec3(1.25));\n    vec4 box = vec4(ColorRed.rgb, b1 );\n    \n    vec4 sphere = vec4(ColorRed.rgb, s1);\n    vec4 sphere2 = vec4(ColorRed.rgb, s2);\n    //shell\n    box = abs(box)-.1;\n    // box.xy *= Rotate(sin(u_time)); \n    // box.a += displacement;\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0);\n     \n    csg0 = smoothUnionSDF(box, p0, 0.125);\n    csg1 = smoothDifferenceSDF(csg0, sphere, 0.125); \n    csg2 = smoothUnionSDF(csg1, sphere2, 0.125);\n    scene = smoothUnionSDF(csg2, p0, 0.25);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n        lightPos.zx *= Rotate(PI * 1.75);\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(4.9 ,4.5,-4.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.zx *= Rotate(PI*-.3);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ZO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$O,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(.0,1.5,0);\n    float displacement =  sin(3.0 * p.x + (u_time)/2.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/2.) * 0.137525;\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 0.05));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n    float p1 = dot(p, normalize(vec3(1.5 + sin(u_time), 1.0 + sin(u_time),0.)));\n    vec4 plane = vec4(ColorRed.rgb, p1);\n    vec3 b1p = vec3(-0.5,1.5,0) ;\n    // b1p.xz *= Rotate((u_time));\n    float b1 = boxSDF(p - b1p * displacement , vec3(1.25 + sin(u_time * 0.25), .525 , 1.25 + cos(u_time * 0.25)));\n    vec4 box = vec4(ColorRed.rgb, b1 );\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0);\n     \n    csg0 = smoothUnionSDF(box, p0, 0.125);\n    scene = smoothUnionSDF(csg0, p0, 0.25);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n        lightPos.zx *= Rotate(PI * 1.75);\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(4.9 ,4.5,-4.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.zx *= Rotate(PI*-.3);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function JO(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:KO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QO=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(1.0, 1.0, 1.0);\n        vec3 d = vec3(0.263,0.416 * u_time,0.557);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, u_time *0.25);\n        uv2 -= 0.5;\n        vec2 uv3 = uv2;\n\n        \n        float d;\n        vec3 c;\n\n        for (float i = 0.; i < 4.; i++)\n        {\n            uv2 = fract(uv2 * 1.) - 0.5;\n            d = length(uv3) * exp(-length(uv2));\n            c = palette(length(uv2) + i * .4 + u_time * .4);\n            d = sin(d * 20. + u_time) / 8.;\n            d = abs(d);\n            d = pow(0.01/d, 1.2);\n            color += c * d;\n        }\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:QO,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        // uv2 = Rot(uv2, u_time * 0.25);\n        uv2 -= 0.5;\n        vec2 uv3 = uv2;\n\n        \n        float d;\n        vec3 c;\n\n        for (float i = 0.; i < 4.; i++)\n        {\n            uv2 = fract(uv2 * (1.5 + sin(u_time * 0.25)/15.)) - 0.5;\n            d = length(uv3) * (-length(uv2));\n            c = palette(length(uv2) + i * .4 + u_time * .4);\n            d = sin(d * 15. + sin(u_time)) / 5.;\n            d = abs(d);\n            d = pow(0.01/d, 1.);\n            color += c * d;\n        }\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:eL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, u_time * 0.25);\n        uv2 -= 0.5;\n        vec2 uv3 = uv2;\n\n        \n        float d;\n        float d2;\n        vec3 c;\n\n        for (float i = 0.; i < 4.; i++)\n        {\n            uv2 = fract(uv2 * (1.5 + sin(u_time * 0.25)/15.)) - 0.5;\n            d = length(uv3) * (length(uv2));\n            c = palette(length(uv2) + i * .4 + u_time * .4);\n            d2 = d;\n            d = sin(d * 5. + (u_time * 0.5)) / 5.;\n            d2 = tan(d * 5. + (u_time * 0.5)) / 5.;\n            d = abs(d);\n            d2 = abs(d2);\n            d = pow(0.005/d, 1.);\n            d2 = pow(0.002/d2, 1.);\n            color += c * d + d2;\n        }\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function oL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    float variation(vec2 v1, vec2 v2, float strength, float speed) {\n        return sin(\n            dot(normalize(v1), normalize(v2)) * strength + u_time * speed\n        ) / 100.0;\n    }\n    \n    vec3 paintCircle (vec2 uv, vec2 center, float rad, float width) {\n        \n        vec2 diff = center-uv;\n        float len = length(diff);\n    \n        len += variation(diff, vec2(0.0, 1.0), 5.0, 2.0);\n        len -= variation(diff, vec2(1.0, 0.0), 5.0, 2.0);\n        \n        float circle = smoothstep(rad-width, rad, len) - smoothstep(rad, rad+width, len);\n\n        float segment = sdSegment(uv, vec2(0.), vec2(0.5));\n\n        return vec3(circle);\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        // uv2 = Rot(uv2, u_time * 0.25);\n        float m = 0.;\n        vec3 d;\n        uv2 -= 0.5;\n        float t = u_time * 0.05;\n        for(float i =0.; i <1.; i+= 1./2.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(.5, .05, z);\n            float fade = S(0.0, 0.5, z) * S(.0, 1., z) ;\n            \n            \n            vec3 cir = paintCircle(uv2 , vec2(0.0) ,  fade  + 0.15 * 1.25 , 0.01 );\n            vec3 cir2 = paintCircle(uv2, vec2(0.0) ,  fade + 0.15 * 1.25, 0.04 );\n\n            vec3 cir3 = paintCircle(uv2, vec2(0.0) ,  fade + 0.1 * 1.25, 0.01);\n            vec3 cir4 = paintCircle(uv2, vec2(0.0) ,  fade + 0.1 * 1.25, 0.04);\n\n            vec3 cir5 = paintCircle(uv2, vec2(0.0) ,  fade + 0.05 * 1.25, 0.01);\n            vec3 cir6 = paintCircle(uv2, vec2(0.0) ,  fade + 0.05 * 1.25, 0.04 );\n\n            vec3 cir7 = paintCircle(uv2, vec2(0.0) ,  fade - 0.0 * 1.25, 0.01);\n            vec3 cir8 = paintCircle(uv2, vec2(0.0) ,  fade - 0.0 * 1.25, 0.04);\n\n            vec3 cir9 = paintCircle(uv2, vec2(0.0) ,  fade - 0.05 * 1.25, 0.01);\n            vec3 cir10 = paintCircle(uv2, vec2(0.0) ,  fade - 0.05 * 1.25, 0.04);\n\n            vec3 cir11 = paintCircle(uv2, vec2(0.0) , fade - 0.1 * 1.25, 0.01);\n            vec3 cir12 = paintCircle(uv2, vec2(0.0) , fade - 0.1 * 1.25, 0.04);\n\n            vec3 cir13 = paintCircle(uv2, vec2(0.0) , fade - 0.15  * 1.25, 0.01 );\n            vec3 cir14 = paintCircle(uv2, vec2(0.0) ,  fade - 0.15 * 1.25, 0.04);\n\n            cir += cir2;\n            color += cir2 * vec3(0.9, 0., 0.);\n            // m += Layer(uv2 * size + i * 20.) * fade;\n\n            cir3 += cir4;\n            color += cir4 * vec3(0.9, 0.5, 0.0);\n\n            cir5 += cir6;\n            color += cir6 * vec3(1., 1., 0.0);\n\n            cir7 += cir8;\n            color += cir8 * vec3(0., 1., 0.0);\n\n            cir9 += cir10;\n            color += cir10 * vec3(0., 0., 1.0);\n\n            cir11 += cir12;\n            color += cir12 * vec3(0.29, 0., 0.51);\n\n            cir13 += cir14;\n            color += cir14 * vec3(0.93, 0.51, 0.93);\n        }\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function iL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:aL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n        uv2.y -= 0.065;\n\n        float one = 1. - sdBox(vec2(uv2.x, uv2.y + (1./7.)), vec2(2.5, 1./7.));\n        float two = 1. - sdBox(vec2(uv2.x, uv2.y + (2./7.)), vec2(2.5, 1./7.));\n        float three = 1. - sdBox(vec2(uv2.x, uv2.y + 3./7.), vec2(2.5, 1./7.));\n        float four = 1. - sdBox(vec2(uv2.x, uv2.y + 4./7.), vec2(2.5, 1./7.));\n        float five = 1. - sdBox(vec2(uv2.x, uv2.y + 5./7.), vec2(2.5, 1./7.));\n        float six = 1. - sdBox(vec2(uv2.x, uv2.y + 6./7.), vec2(2.5, 1./7.));\n        float seven = 1. - sdBox(vec2(uv2.x, uv2.y + 7./7.), vec2(2.5, 1./7.));\n\n        color += one * vec3(0.9, 0., 0.);\n        color += two * vec3(0.9, 0.5, 0.0);\n        color += three * vec3(1., 1., 0.0);\n        color += four * vec3(0., 1., 0.0);\n        color += five * vec3(0., 0., 1.0);\n        color += six * vec3(0.29, 0., 0.51);\n        color += seven * vec3(0.93, 0.51, 0.93);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:vL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, - uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (TWO_PI * 2.0) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), 4.0);\n    \n    return radialUv;\n    }\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        vec2 uv3 = uv2;\n        vec2 uv4 = vUv;\n        uv4 -= 0.5;\n        uv4 = getRadialUv(uv4);\n        uv2 -= .5;\n        uv3 = Rot(uv3, PI * 2.);\n        uv3 -= 0.5;\n        \n\n        float an = -u_time * 0.15;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2);\n        float a = atan(uv2.y, uv2.x);\n        uv2 = vec2(0.3/r1 + 0.5 * u_time , a);\n        float r2 = length(uv3);\n        float a2 = atan(uv3.y, uv3.x);\n        uv3 = vec2(0.3/r2 + 0.5 * u_time, a2);\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv4 + 0.00*u_time);\n        q.y = fbm( uv4 + vec2(1.0));\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv4 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv4 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r);\n        float f2 = fbm(uv3+r);\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.101961,0.619608,0.666667),\n                    vec3(0.666667,0.666667,0.498039),\n                    clamp((f*f)*4.0,0.0,1.0));\n\n        c = mix(color,\n                    vec3(0,0,0.164706),\n                    clamp(length(q),0.0,1.0));\n\n        c = mix(color,\n                    vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n\n        c *= f*f*f+.6*f *f + .5 *f * c ;\n        // c *= f2*f2*f2+.6*f2 *f2 + .5 *f2 * c ;\n\n        color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:lL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    // radialUv.x = angle / (PI) + 0.5;\n    // radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) + 0.0005 * u_time, angle );\n    \n    return radialUv;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n        \n        \n\n        float an = -u_time * 0.15;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2) ;\n        r1 = abs(r1);\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a);\n        uv2 = vec2(0.3/r1 + .95 * u_time , a);\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.00*u_time);\n        q.y = fbm( uv2 + vec2(1.0));\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.101961,0.619608,0.666667),\n                    vec3(0.666667,0.666667,0.498039),\n                    clamp((f*f)*4.0,0.0,1.0));\n\n        c = mix(color,\n                    vec3(0,0,0.164706),\n                    clamp(length(q),0.0,1.0));\n\n        c = mix(color,\n                    vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n\n        c *= f*f*f+.6*f *f + .25 *f * c* f * c ;\n\n        color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:uL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (PI) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) * u_time, angle );\n    \n    return radialUv;\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.15;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * 0.5) ;\n        r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.3/r1 + .95 - u_time * 1.25 , a);\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + vec2(50.01));\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.619608,0.666667),\n                    vec3(0.666667,0.666667,0.498039),\n                    clamp((f*f)*5.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.9,0,0.164706),\n                    clamp(length(q),0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.966667,1,1),\n                clamp(length(r.x),0.0,1.0));\n\n        c *= f*f*f+.6*f *f + .25 *f * c* f * f ;\n\n        float cir = sdCircle(vUv, 0.0525);\n        \n\n        color += c * 2. * 2. + c;\n        color *=  c - cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:pL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (PI) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) * u_time, angle );\n    \n    return radialUv;\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.15;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * 0.5) ;\n        r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.3/r1 + .95 + u_time * 2.25 , a);\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + vec2(50.01));\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.9666667,0.9666667,0.998039),\n                    clamp((f*f)*1.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.099,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,1),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color,\n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        c *= f ;\n\n        float cir = sdCircle(vUv, 0.125 * sin(1. /u_time));\n        \n\n        color += c * 2. * 2. + c;\n        color *=  c - cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:mL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (PI) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) * u_time, angle );\n    \n    return radialUv;\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1 + sin(u_time), a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color,\n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        c *= f * f * 2.;\n\n        float cir = sdCircle(vUv, 0.125 ) * 0.65;\n        \n\n        color += c * 2. ;\n        color *=  c - cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:xL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1 + sin(u_time), a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color,\n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        // c *= f * f * 2.;\n\n        float cir = sdCircle(vUv, 0.125 );\n        \n        vec3 s = voronoi(uv2);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        \n        color.rgb+= smoothstep(0.02 * 2., 0.031 * 2., s.x);\n        //color.g+= 1. - smoothstep(0.0075 * 2., (0.021-0.0025) * 2., s2.x);\n        //color.b+= 1. - smoothstep(0.005 * 2., (0.021 -0.005) * 2., s3.x);\n        // color += c * 2. ;\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:yL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _L=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1 + sin(u_time), a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color, \n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        // c *= f * f * 2.;\n\n        float cir = sdCircle(vUv, 0.125 );\n        \n        vec3 s = voronoi(uv2 * 0.25);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        \n        color.rgb+= smoothstep(0.02 * 2., 0.031 * 2., s.x * f * f);\n        //color.g+= 1. - smoothstep(0.0075 * 2., (0.021-0.0025) * 2., s2.x);\n        //color.b+= 1. - smoothstep(0.005 * 2., (0.021 -0.005) * 2., s3.x);\n        // color += c * 2. ;\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function UL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:_L,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1, a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color, \n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        // c *= f * f * 2.;\n\n        float cir = sdCircle(vUv, 0.0125 );\n        \n        vec3 s = voronoi(uv2 * 0.25);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        \n        color.rgb += smoothstep(0.02 * 2., 0.031 * 2., s.x * f * f + s2.x);\n        color.g+= 1. - smoothstep(0.0075 * 2., (0.021-0.0025) * 2., s2.x);\n        color.b+= 1. - smoothstep(0.005 * 2., (0.021 -0.005) * 2., s3.x);\n        // color += c * 2. ;\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function SL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:wL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n\n    vec2 tile(vec2 uv, float zoom, float speed){\n        uv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > 0.5)\n        {\n            if(fract(uv.y * 0.5) > 0.5){\n                uv.x += fract(t) * 2.;\n            } else {\n                uv.x -= fract(t) * 2.;\n            }\n        } else {\n            if(fract(uv.x * 0.5) > 0.5)\n            {\n                uv.y += fract(t) * 2.;\n            } else {\n                uv.y -= fract(t) * 2.;\n            }\n        }\n        return fract(uv);\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1, a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color, \n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        // c *= f * f * 2.;\n\n        vec2 pattern = tile(uv2, 1., 0.5);\n        float x = numZero(pattern);\n        color.g += x;\n\n        float cir = sdCircle(vUv, 0.0125 );\n        \n        vec3 s = voronoi(uv2 );\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        \n        // color.rgb += 1. - smoothstep(0.02 * 2., 0.031 * 2., s.x * f * f + s.x);\n        // color.g+= smoothstep(0.0075 * 2., (0.021-0.0025) * 2., s2.x);\n        // color.b+= smoothstep(0.005 * 2., (0.021 -0.005) * 2., s3.x);\n        // color += c * 2. ;\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ML(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:kL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n\n    vec2 tile(vec2 uv, float zoom, float speed){\n        uv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > 0.5)\n        {\n            if(fract(uv.y * 0.5) > 0.5){\n                uv.x += fract(t) * 2.;\n            } else {\n                uv.x -= fract(t) * 2.;\n            }\n        } else {\n            if(fract(uv.x * 0.5) > 0.5)\n            {\n                uv.y += fract(t) * 2.;\n            } else {\n                uv.y -= fract(t) * 2.;\n            }\n        }\n        return fract(uv);\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1, a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color, \n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        // c *= f * f * 2.;\n\n        vec2 pattern = tile(uv2, 1., 0.5);\n        float x = numTwo(pattern);\n        color.r += x;\n\n        \n        float cir = sdCircle(vUv, 0.0125 );\n        vec3 s = voronoi(uv2 );\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        \n        // color.rgb += 1. - smoothstep(0.02 * 2., 0.031 * 2., s.x * f * f + s.x);\n        // color.g+= smoothstep(0.0075 * 2., (0.021-0.0025) * 2., s2.x);\n        // color.b+= smoothstep(0.005 * 2., (0.021 -0.005) * 2., s3.x);\n        // color += c * 2. ;\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function CL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:zL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        newUv -= 0.5;\n\n        float x = sdSpiral(newUv, 0.525, 2.525 + sin(u_time));\n        color += x;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function RL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:TL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        newUv *= 0.25 + 0.75;\n        newUv = Rot(newUv, u_time * 4.5 + sin(u_time));\n        newUv -= 0.5;\n\n        float x;\n        for(float i=0.; i<2.; i++){\n            newUv*= 0.165;\n\n            x = sdSpiral(newUv, 0.82, 3.525 + sin(u_time + i/2. ));\n            color += x;\n\n            vec3 c = palette(x * i);\n            color -= c.xyz;\n        }\n\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function PL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:DL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        newUv *= 0.25 + 0.75;\n        newUv = Rot(newUv, u_time * 4.5 + sin(u_time));\n        newUv -= 0.5;\n\n        float x;\n        for(float i=0.; i<6.; i++){\n            newUv*= 0.165;\n\n            x = sdSpiral(vec2(newUv.x * 55.5 * i, newUv.y * 55.5 * i), i, 3.525 + sin(u_time + i/2. ));\n            color += x;\n\n            vec3 c = palette(x * i);\n            color -= c.xyz;\n        }\n\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function FL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:jL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        // newUv *= 0.25 + 0.75;\n        // newUv = Rot(newUv, u_time * 4.5 + sin(u_time));\n        // newUv -= 0.5;\n\n        float line = 0.;\n        // float x = plot(newUv, line, 0.02 );\n        float x = circle(newUv, 1.025);\n        float x1 = circle(vec2(newUv.x + sin(u_time)/4., newUv.y + cos(u_time)/4.), 0.275);\n        float x2 = circle(vec2(newUv.x + sin(u_time)/8., newUv.y + cos(u_time)/8.), 0.075);\n        float x3 = circle(vec2(newUv.x + sin(u_time)/16. , newUv.y + cos(u_time)/16.) , 0.022);\n        float x4 = circle(vec2(newUv.x + sin(u_time)/32. , newUv.y + cos(u_time)/32.) , 0.006);\n        float x5 = circle(vec2(newUv.x + sin(u_time)/64. , newUv.y + cos(u_time)/64.) , 0.002);\n\n        color.rgb += x;\n        color.rgb -= x1;\n        color.rgb += x2;\n        color.rgb -= x3;\n        color.rgb += x4;\n        color.rgb -= x5;\n        // color.rb -= x2;\n\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function IL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:EL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    float flower(vec2 vUv, float n, float zoom)\n    {\n        vec2 pos = vec2(0.5) - vUv;\n        float r = length(pos) * zoom;\n        float a = atan(pos.y, pos.x);\n        float f = cos(a * n );\n        return smoothstep(f, f + 0.25, r );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        // newUv *= 0.25 + 0.75;\n        vec2 newUv2 = newUv;\n        vec2 newUv3 = newUv;\n        newUv = Rot(newUv, u_time * 1.5 + sin(u_time));\n        newUv2 = Rot(newUv2, u_time * 1.5 + cos(u_time));\n        newUv3 = Rot(newUv2, u_time * 1. + cos(u_time));\n        // newUv -= 0.5;\n        // newUv2.x -= 0.2;\n\n        float line = 0.;\n        // float x = plot(newUv, line, 0.02 );\n        float x = flower(newUv, 5., 2.);\n        float x2 = flower(newUv2, 5., 2.);\n        float x3 = flower(newUv3, 5., 2.);\n        color += 1. - palette(x * 0.5);\n        color += 1. - palette(x2 * 0.25);\n        color += 1. - palette(x3 * 0.15);\n\n        // color.rb -= x2;\n\n        \n\n        float numLabel = label(vUv);\n        color *= 1. - numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function LL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:OL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 3.28318*(c*t+d) * abs(sin(u_time/8. )- 0.25));\n    }\n\n    float flower(vec2 vUv, float n, float zoom)\n    {\n        vec2 pos = vec2(0.5) - vUv;\n        float r = length(pos) * zoom;\n        float a = atan(pos.y, pos.x);\n        float f = cos(a * n );\n        return smoothstep(f, f + 0.25, r );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        // newUv *= 0.25 + 0.75;\n        vec2 newUv2 = newUv;\n        vec2 newUv3 = newUv;\n        vec2 newUv4 = newUv;\n        vec2 newUv5 = newUv;\n        vec2 newUv6 = newUv;\n        vec2 newUv7 = newUv;\n        vec2 newUv8 = newUv;\n\n        newUv = Rot(newUv, u_time * 2.25 + cos(u_time));\n        newUv2 = Rot(newUv2, u_time * 2.0 + cos(u_time));\n        newUv3 = Rot(newUv3, u_time * 1.75 + cos(u_time));\n        newUv4 = Rot(newUv4, u_time * 1.5 + cos(u_time));\n        newUv5 = Rot(newUv5, u_time * 1.25 + cos(u_time));\n        newUv6 = Rot(newUv6, u_time * 1. + cos(u_time));\n        newUv7 = Rot(newUv7, u_time * 0.75 + cos(u_time));\n        newUv8 = Rot(newUv8, u_time * 0.5 + cos(u_time));\n        // newUv -= 0.5;\n        // newUv2.x -= 0.2;\n\n        float x = sdPolygonOutline(newUv, 6, 0.8); \n        float x2 = sdPolygonOutline(newUv2, 6, 0.7);\n        float x3 = sdPolygonOutline(newUv3, 6, 0.6); \n        float x4 = sdPolygonOutline(newUv4, 6, 0.5); \n        float x5 = sdPolygonOutline(newUv5, 6, 0.4); \n        float x6 = sdPolygonOutline(newUv6, 6, 0.3);\n        float x7 = sdPolygonOutline(newUv7, 6, 0.2); \n        float x8 = sdPolygonOutline(newUv8, 6, 0.1);  \n        \n        color += 1. - palette(x * 0.59);\n        color += 1. - palette(x2 * 0.58);\n        color += 1. - palette(x3 * 0.57);\n        color += 1. - palette(x4 * 0.56);\n        color += 1. - palette(x5 * 0.55);\n        color += 1. - palette(x6 * 0.54);\n        color += 1. - palette(x7 * 0.53);\n        color += 1. - palette(x8 * 0.52);\n\n        color *= 2.;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function NL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:AL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 3.28318*(c*t+d) * abs(sin(u_time/8. )- 0.25));\n    }\n\n    float flower(vec2 vUv, float n, float zoom)\n    {\n        vec2 pos = vec2(0.5) - vUv;\n        float r = length(pos) * zoom;\n        float a = atan(pos.y, pos.x);\n        float f = cos(a * n );\n        return smoothstep(f, f + 0.25, r );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        // newUv *= 0.25 + 0.75;\n        vec2 newUv2 = newUv;\n        vec2 newUv3 = newUv;\n        vec2 newUv4 = newUv;\n        vec2 newUv5 = newUv;\n        vec2 newUv6 = newUv;\n        vec2 newUv7 = newUv;\n        vec2 newUv8 = newUv;\n\n        newUv = Rot(newUv,   u_time/4. * 2.25 + cos(u_time));\n        newUv2 = Rot(newUv2, u_time/4. * 2.00 + cos(u_time));\n        newUv3 = Rot(newUv3, u_time/4. * 1.75 + cos(u_time));\n        newUv4 = Rot(newUv4, u_time/4. * 1.50 + cos(u_time));\n        newUv5 = Rot(newUv5, u_time/4. * 1.25 + cos(u_time));\n        newUv6 = Rot(newUv6, u_time/4. * 1.00 + cos(u_time));\n        newUv7 = Rot(newUv7, u_time/4. * 0.75 + cos(u_time));\n        newUv8 = Rot(newUv8, u_time/4. * 0.50 + cos(u_time));\n        // newUv -= 0.5;\n        // newUv2.x -= 0.2;\n\n        float x = sdPolygonOutline(newUv,   4, 0.8); \n        float x2 = sdPolygonOutline(newUv2, 4, 0.7);\n        float x3 = sdPolygonOutline(newUv3, 4, 0.6); \n        float x4 = sdPolygonOutline(newUv4, 4, 0.5); \n        float x5 = sdPolygonOutline(newUv5, 4, 0.4); \n        float x6 = sdPolygonOutline(newUv6, 4, 0.3);\n        float x7 = sdPolygonOutline(newUv7, 4, 0.2); \n        float x8 = sdPolygonOutline(newUv8, 4, 0.1);  \n        \n        color += 1. - palette(x  * 0.59 * 2.2 * abs(sin(u_time) + 0.1));\n        color += 1. - palette(x2 * 0.58 * 2.2 * abs(cos(u_time) + 0.2));\n        color += 1. - palette(x3 * 0.57 * 2.2 * abs(sin(u_time) + 0.3));\n        color += 1. - palette(x4 * 0.56 * 2.2 * abs(cos(u_time) + 0.4));\n        color += 1. - palette(x5 * 0.55 * 2.2 * abs(sin(u_time) + 0.5));\n        color += 1. - palette(x6 * 0.54 * 2.2 * abs(cos(u_time) + 0.6));\n        color += 1. - palette(x7 * 0.53 * 2.2 * abs(sin(u_time) + 0.7));\n        color += 1. - palette(x8 * 0.52 * 2.2 * abs(cos(u_time) + 0.8));\n\n        // color *= 2.;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function BL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:GL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var qL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    float randFloat(float x){\n        return fract(sin(x) * 4748393.7585);\n    }\n    \n    float randVec2(vec2 vUv){\n        return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n    }\n    \n    vec3 matrix(vec2 vUv){\n        float rows = 15.0;\n        vec2 a = floor(vUv * rows);\n        a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n        vec2 b = fract(vUv * rows);\n        vec2 newUv = 0.5 - b;\n        float str = randVec2(a);\n        float one = sdOne(b);\n        float zero = sdZero(b);\n        float two = sdTwo(b);\n        float three = sdThree(b);\n        float four = sdFour(b);\n        float five = sdFive(b);\n        float six = sdSix(b);\n        float seven = sdSeven(b);\n        float eight = sdEight(b);\n        float nine = sdNine(b);\n        float shape;\n        if(str > .9 )\n        {\n            shape = smoothstep(0.01, 0.011, zero);\n        } else if(str > .8){\n            shape = smoothstep(0.01, 0.011, one);\n        } else if(str > .7){\n            shape = smoothstep(0.01, 0.011, two);\n        } else if(str > .6){\n            shape = smoothstep(0.01, 0.011, three);\n        } else if(str > .5){\n            shape = smoothstep(0.01, 0.011, four);\n        } else if(str > .4){\n            shape = smoothstep(0.01, 0.011, five);\n        } else if(str > .3){\n            shape = smoothstep(0.01, 0.011, six);\n        } else if(str > .2){\n            shape = smoothstep(0.01, 0.011, seven);\n        } else if(str > .1){\n            shape = smoothstep(0.01, 0.011, eight);\n        } else {\n            shape = smoothstep(0.01, 0.011, nine);\n        }\n        \n        return vec3(shape * str );\n    }\n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        newUv -= 0.5;\n    \n        float an = -u_time * 0.5;\n        // newUv = mat2(cos(an),-sin(an),sin(an),cos(an)) * newUv;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(newUv) ;\n        // r1 = abs(r1 );\n        float a = -atan(newUv.x, newUv.y) * 0.425;\n        // a = abs(a * 0.85);\n        newUv = vec2(0.5/r1 + .95 + u_time * 0.25 + r1, a );\n\n        vec3 mat = matrix(vec2(newUv.y, newUv.x));\n\n        color.g += mat.g;\n\n        float cir = sdCircle(vUv, 0.125 );\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function VL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:qL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var WL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float cloudscale = 1.1;\n    float speed = 0.03;\n    float clouddark = 0.5;\n    float cloudlight = 0.3;\n    float cloudcover = 0.2;\n    float cloudalpha = 8.0;\n    float skytint = 0.5;\n    vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\n    vec3 skycolour2 = vec3(1.4, 0.7, 1.0);\n\n    const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\n    vec2 hash( vec2 p ) {\n        p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n        return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    }\n    \n    float noise( in vec2 p ) {\n        const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n        const float K2 = 0.211324865; // (3-sqrt(3))/6;\n        vec2 i = floor(p + (p.x+p.y)*K1);\t\n        vec2 a = p - i + (i.x+i.y)*K2;\n        vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n        vec2 b = a - o + K2;\n        vec2 c = a - 1.0 + 2.0*K2;\n        vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n        vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n        return dot(n, vec3(70.0));\t\n    }\n    \n    float fbm(vec2 n) {\n        float total = 0.0, amplitude = 0.1;\n        for (int i = 0; i < 7; i++) {\n            total += noise(n) * amplitude;\n            n = m * n;\n            amplitude *= 0.4;\n        }\n        return total;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        // newUv = newUv*vec2(u_resolution.x/u_resolution.y,1.0);\n        newUv -= 0.5;\n        // newUv *= 20.5;\n        float t = u_time * speed;\n        float q = fbm(newUv * cloudscale * 0.5);\n\n        float r = 0.;\n        newUv *= cloudscale;\n        newUv -= q - t;\n        float weight = 0.8;\n        for(int i = 0; i < 8; i++){\n            r += abs(weight*noise(newUv));\n            newUv = m*newUv + t;\n            weight *= 0.7;\n        }\n        float f = 0.0;\n        // newUv = newUv*vec2(u_resolution.x/u_resolution.y,1.0);\n        newUv *= cloudscale;\n        newUv -= q - t;\n        weight = 0.7;\n        for (int i=0; i<8; i++){\n            f += weight*noise( newUv );\n            newUv = m*newUv + t;\n            weight *= 0.6;\n    }\n        f *= r + f;\n        float c = 0.0;\n        t = u_time * speed * 2.0;\n        // newUv = newUv*vec2(u_resolution.x/u_resolution.y,1.0);\n        newUv *= cloudscale*2.0;\n        newUv -= q - t;\n        weight = 0.4;\n        for (int i=0; i<7; i++){\n            c += weight*noise( newUv );\n            newUv = m*newUv + t;\n            weight *= 0.6;\n        }\n        float c1 = 0.0;\n        t = u_time * speed * 3.0;\n        // newUv = newUv*vec2(u_resolution.x/u_resolution.y,1.0);\n        newUv *= cloudscale*3.0;\n        newUv -= q - t;\n        weight = 0.4;\n        for (int i=0; i<7; i++){\n            c1 += abs(weight*noise( newUv ));\n            newUv = m*newUv + t;\n            weight *= 0.6;\n        }\n\n        c += c1;\n        \n        vec3 skycolour = mix(skycolour2, skycolour1, vUv.x);\n        vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n    \n        f = cloudcover + cloudalpha*f*r;\n\n        vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n    \n        color += result;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function HL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:WL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var XL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.52;\n        uv2 *= 2.9;\n        uv2.x += u_time*0.1;\n        \n        vec2 q = vec2(0.);\n        q.y = fbm( uv2 + 0.2*u_time);\n        q.x = fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r ));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f),0.0,1.0));\n        color += c;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function YL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:XL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var $L=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.52;\n        uv2 *= 3.9;\n        uv2.x += u_time*0.1;\n        uv2.y += u_time * 0.1;\n        \n        vec2 q = vec2(0.);\n        q.y = fbm( uv2 + 0.2*u_time);\n        q.x = fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f*f + f * 0.85),0.0,1.0));\n        color += c;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function ZL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:$L,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    // Helper functions:\n    float slopeFromT (float t, float A, float B, float C){\n        float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n        return dtdx;\n    }\n    float xFromT (float t, float A, float B, float C, float D){\n        float x = A*(t*t*t) + B*(t*t) + C*t + D;\n        return x;\n    }\n    float yFromT (float t, float E, float F, float G, float H){\n        float y = E*(t*t*t) + F*(t*t) + G*t + H;\n        return y;\n    }\n    float B0 (float t){\n        return (1.0-t)*(1.0-t)*(1.0-t);\n    }\n    float B1 (float t){\n        return  3.0*t*(1.0-t)*(1.0-t);\n    }\n    float B2 (float t){\n        return 3.0*t*t* (1.0-t);\n    }\n    float B3 (float t){\n        return t*t*t;\n    }\n    float  findx (float t, float x0, float x1, float x2, float x3){\n        return x0*B0(t) + x1*B1(t) + x2*B2(t) + x3*B3(t);\n    }\n    float  findy (float t, float y0, float y1, float y2, float y3){\n        return y0*B0(t) + y1*B1(t) + y2*B2(t) + y3*B3(t);\n    }\n    \n    float cubicBezier(float x, vec2 a, vec2 b){\n        float y0a = 0.0; // initial y\n        float x0a = 0.0; // initial x \n        float y1a = a.y;    // 1st influence y   \n        float x1a = a.x;    // 1st influence x \n        float y2a = b.y;    // 2nd influence y\n        float x2a = b.x;    // 2nd influence x\n        float y3a = 1.0; // final y \n        float x3a = 1.0; // final x \n    \n        float A =   x3a - 3.0*x2a + 3.0*x1a - x0a;\n        float B = 3.0*x2a - 6.0*x1a + 3.0*x0a;\n        float C = 3.0*x1a - 3.0*x0a;   \n        float D =   x0a;\n    \n        float E =   y3a - 3.0*y2a + 3.0*y1a - y0a;    \n        float F = 3.0*y2a - 6.0*y1a + 3.0*y0a;             \n        float G = 3.0*y1a - 3.0*y0a;             \n        float H =   y0a;\n    \n        // Solve for t given x (using Newton-Raphelson), then solve for y given t.\n        // Assume for the first guess that t = x.\n        float currentt = x;\n        for (int i=0; i < 5; i++){\n        float currentx = xFromT (currentt, A,B,C,D); \n        float currentslope = slopeFromT (currentt, A,B,C);\n        currentt -= (currentx - x)*(currentslope);\n            currentt = clamp(currentt,0.0,1.0); \n        } \n    \n        float y = yFromT (currentt,  E,F,G,H);\n        return y;\n    }\n    \n    float cubicBezierNearlyThroughTwoPoints(float x, vec2 a, vec2 b){\n    \n        float y = 0.0;\n        float epsilon = 0.00001;\n        float min_param_a = 0.0 + epsilon;\n        float max_param_a = 1.0 - epsilon;\n        float min_param_b = 0.0 + epsilon;\n        float max_param_b = 1.0 - epsilon;\n        a.x = max(min_param_a, min(max_param_a, a.x));\n        a.y = max(min_param_b, min(max_param_b, a.y));\n    \n        float x0 = 0.0;  \n        float y0 = 0.0;\n        float x4 = a.x;  \n        float y4 = a.y;\n        float x5 = b.x;  \n        float y5 = b.y;\n        float x3 = 1.0;  \n        float y3 = 1.0;\n        float x1,y1,x2,y2; // to be solved.\n    \n        // arbitrary but reasonable \n        // t-values for interior control points\n        float t1 = 0.3;\n        float t2 = 0.7;\n    \n        float B0t1 = B0(t1);\n        float B1t1 = B1(t1);\n        float B2t1 = B2(t1);\n        float B3t1 = B3(t1);\n        float B0t2 = B0(t2);\n        float B1t2 = B1(t2);\n        float B2t2 = B2(t2);\n        float B3t2 = B3(t2);\n    \n        float ccx = x4 - x0*B0t1 - x3*B3t1;\n        float ccy = y4 - y0*B0t1 - y3*B3t1;\n        float ffx = x5 - x0*B0t2 - x3*B3t2;\n        float ffy = y5 - y0*B0t2 - y3*B3t2;\n    \n        x2 = (ccx - (ffx*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        y2 = (ccy - (ffy*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        x1 = (ccx - x2*B2t1) / B1t1;\n        y1 = (ccy - y2*B2t1) / B1t1;\n    \n        x1 = max(0.0+epsilon, min(1.0-epsilon, x1));\n        x2 = max(0.0+epsilon, min(1.0-epsilon, x2));\n    \n        y = cubicBezier (x, vec2(x1,y1), vec2(x2,y2));\n        y = max(0.0, min(1.0, y));\n        return y;\n    }\n\n    \n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        \n\n        // float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(1.83/r1 + .95 + u_time * 0.025 + r1, a );\n        uv2 -= 0.52;\n        uv2 *= 2.9;\n        uv2.x -= u_time*0.1;\n        uv2.y += u_time * 0.2;\n\n        vec2 uv3 = vUv;\n        uv3 *= 1.2;\n        uv3.y += 2.5;\n        uv3.x += 0.5;\n\n        vec2 uv4 = uv3;\n        float rand = random(uv4);\n        uv4 = uv4 * rand;\n        \n        vec2 q = vec2(0.);\n        q.y = -fbm( uv2 + 0.2*u_time);\n        q.x = -fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        vec2 r2 = vec2(0.);\n        r2.x = fbm( uv2 + 1.0*q - vec2(1.7,0.2)+ 0.1*u_time );\n        r2.y = fbm( uv2 + 1.0*q - vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f*f + f * 0.85),0.0,1.0));\n        color += c;\n\n        vec2 cp0 = vec2(-0.5, 1.95);\n        vec2 cp1 = vec2(0.75, 0.5);\n        vec2 cp3 = vec2(0.5, 0.5);\n        float l = cubicBezierNearlyThroughTwoPoints(uv3.x*0.25, cp0, cp1);\n        float l2 = cubicBezierNearlyThroughTwoPoints(uv4.y*0.25, cp0, cp3);\n        float px = 1. / vUv.y;\n\n        float t1 = uv3.x*7.-2.*u_time+uv3.y*3.;\n        uv3.y += sin(t1) * 0.05;\n        float x = .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        float y = fbm(uv4 + r2 * fbm(uv4 + r2));\n        // color *= .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        \n        color *= vec3( smoothstep(l, l+0.025, vUv.y+0.6));\n        color.g += (1. - smoothstep(l, l+0.025, vUv.y+0.6))* 0.72 * x* y;\n        \n        // color -= vec3(1. - smoothstep(l2, l2, vUv.y+0.5));\n\n        \n        \n        // color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function JL(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:KL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QL=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    // Helper functions:\n    float slopeFromT (float t, float A, float B, float C){\n        float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n        return dtdx;\n    }\n    float xFromT (float t, float A, float B, float C, float D){\n        float x = A*(t*t*t) + B*(t*t) + C*t + D;\n        return x;\n    }\n    float yFromT (float t, float E, float F, float G, float H){\n        float y = E*(t*t*t) + F*(t*t) + G*t + H;\n        return y;\n    }\n    float B0 (float t){\n        return (1.0-t)*(1.0-t)*(1.0-t);\n    }\n    float B1 (float t){\n        return  3.0*t*(1.0-t)*(1.0-t);\n    }\n    float B2 (float t){\n        return 3.0*t*t* (1.0-t);\n    }\n    float B3 (float t){\n        return t*t*t;\n    }\n    float  findx (float t, float x0, float x1, float x2, float x3){\n        return x0*B0(t) + x1*B1(t) + x2*B2(t) + x3*B3(t);\n    }\n    float  findy (float t, float y0, float y1, float y2, float y3){\n        return y0*B0(t) + y1*B1(t) + y2*B2(t) + y3*B3(t);\n    }\n    \n    float cubicBezier(float x, vec2 a, vec2 b){\n        float y0a = 0.0; // initial y\n        float x0a = 0.0; // initial x \n        float y1a = a.y;    // 1st influence y   \n        float x1a = a.x;    // 1st influence x \n        float y2a = b.y;    // 2nd influence y\n        float x2a = b.x;    // 2nd influence x\n        float y3a = 1.0; // final y \n        float x3a = 1.0; // final x \n    \n        float A =   x3a - 3.0*x2a + 3.0*x1a - x0a;\n        float B = 3.0*x2a - 6.0*x1a + 3.0*x0a;\n        float C = 3.0*x1a - 3.0*x0a;   \n        float D =   x0a;\n    \n        float E =   y3a - 3.0*y2a + 3.0*y1a - y0a;    \n        float F = 3.0*y2a - 6.0*y1a + 3.0*y0a;             \n        float G = 3.0*y1a - 3.0*y0a;             \n        float H =   y0a;\n    \n        // Solve for t given x (using Newton-Raphelson), then solve for y given t.\n        // Assume for the first guess that t = x.\n        float currentt = x;\n        for (int i=0; i < 5; i++){\n        float currentx = xFromT (currentt, A,B,C,D); \n        float currentslope = slopeFromT (currentt, A,B,C);\n        currentt -= (currentx - x)*(currentslope);\n            currentt = clamp(currentt,0.0,1.0); \n        } \n    \n        float y = yFromT (currentt,  E,F,G,H);\n        return y;\n    }\n    \n    float cubicBezierNearlyThroughTwoPoints(float x, vec2 a, vec2 b){\n    \n        float y = 0.0;\n        float epsilon = 0.00001;\n        float min_param_a = 0.0 + epsilon;\n        float max_param_a = 1.0 - epsilon;\n        float min_param_b = 0.0 + epsilon;\n        float max_param_b = 1.0 - epsilon;\n        a.x = max(min_param_a, min(max_param_a, a.x));\n        a.y = max(min_param_b, min(max_param_b, a.y));\n    \n        float x0 = 0.0;  \n        float y0 = 0.0;\n        float x4 = a.x;  \n        float y4 = a.y;\n        float x5 = b.x;  \n        float y5 = b.y;\n        float x3 = 1.0;  \n        float y3 = 1.0;\n        float x1,y1,x2,y2; // to be solved.\n    \n        // arbitrary but reasonable \n        // t-values for interior control points\n        float t1 = 0.3;\n        float t2 = 0.7;\n    \n        float B0t1 = B0(t1);\n        float B1t1 = B1(t1);\n        float B2t1 = B2(t1);\n        float B3t1 = B3(t1);\n        float B0t2 = B0(t2);\n        float B1t2 = B1(t2);\n        float B2t2 = B2(t2);\n        float B3t2 = B3(t2);\n    \n        float ccx = x4 - x0*B0t1 - x3*B3t1;\n        float ccy = y4 - y0*B0t1 - y3*B3t1;\n        float ffx = x5 - x0*B0t2 - x3*B3t2;\n        float ffy = y5 - y0*B0t2 - y3*B3t2;\n    \n        x2 = (ccx - (ffx*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        y2 = (ccy - (ffy*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        x1 = (ccx - x2*B2t1) / B1t1;\n        y1 = (ccy - y2*B2t1) / B1t1;\n    \n        x1 = max(0.0+epsilon, min(1.0-epsilon, x1));\n        x2 = max(0.0+epsilon, min(1.0-epsilon, x2));\n    \n        y = cubicBezier (x, vec2(x1,y1), vec2(x2,y2));\n        y = max(0.0, min(1.0, y));\n        return y;\n    }\n\n    \n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        \n\n        // float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(1.83/r1 + .95 + u_time * 0.025 + r1, a );\n        uv2 -= 0.52;\n        uv2 *= 2.9;\n        // uv2.x -= u_time*0.1;\n        // uv2.y += u_time * 0.2;\n\n        vec2 uv3 = vUv;\n        uv3 *= 1.2;\n        uv3.y += 2.5;\n        uv3.x += 0.5;\n\n        vec2 uv4 = uv3;\n        float rand = random(uv4);\n        uv4 = uv4 * rand;\n        \n        vec2 q = vec2(0.);\n        q.y = -fbm( uv2 + 0.2*u_time);\n        q.x = -fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        vec2 r2 = vec2(0.);\n        r2.x = fbm( uv2 + 1.0*q - vec2(1.7,0.2)+ 0.1*u_time );\n        r2.y = fbm( uv2 + 1.0*q - vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f*f + f * 0.85),0.0,1.0));\n        color += c;\n\n        vec2 cp0 = vec2(-0.5, 1.95);\n        vec2 cp1 = vec2(0.75, 0.5);\n        vec2 cp3 = vec2(0.5, 0.5);\n        float l = cubicBezierNearlyThroughTwoPoints(uv3.x*0.25, cp0, cp1);\n        float l2 = cubicBezierNearlyThroughTwoPoints(uv4.y*0.25, cp0, cp3);\n        float px = 1. / vUv.y;\n\n        float t1 = uv3.x*7.-2.*u_time+uv3.y*3.;\n        uv3.y += sin(t1) * 0.05;\n        float x = .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        float y = fbm(uv4 + r2 * fbm(uv4 + r2));\n        color *= .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        \n        color *= vec3( smoothstep(l, l+0.025, vUv.y+0.6));\n        color.g += (1. - smoothstep(l, l+0.025, vUv.y+0.6))* 0.72 * x* y;\n        \n        // color -= vec3(1. - smoothstep(l2, l2, vUv.y+0.5));\n\n        \n        \n        // color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function nA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:QL,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var eA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    uniform sampler2D u_texture;\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    // Helper functions:\n    float slopeFromT (float t, float A, float B, float C){\n        float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n        return dtdx;\n    }\n    float xFromT (float t, float A, float B, float C, float D){\n        float x = A*(t*t*t) + B*(t*t) + C*t + D;\n        return x;\n    }\n    float yFromT (float t, float E, float F, float G, float H){\n        float y = E*(t*t*t) + F*(t*t) + G*t + H;\n        return y;\n    }\n    float B0 (float t){\n        return (1.0-t)*(1.0-t)*(1.0-t);\n    }\n    float B1 (float t){\n        return  3.0*t*(1.0-t)*(1.0-t);\n    }\n    float B2 (float t){\n        return 3.0*t*t* (1.0-t);\n    }\n    float B3 (float t){\n        return t*t*t;\n    }\n    float  findx (float t, float x0, float x1, float x2, float x3){\n        return x0*B0(t) + x1*B1(t) + x2*B2(t) + x3*B3(t);\n    }\n    float  findy (float t, float y0, float y1, float y2, float y3){\n        return y0*B0(t) + y1*B1(t) + y2*B2(t) + y3*B3(t);\n    }\n    \n    float cubicBezier(float x, vec2 a, vec2 b){\n        float y0a = 0.0; // initial y\n        float x0a = 0.0; // initial x \n        float y1a = a.y;    // 1st influence y   \n        float x1a = a.x;    // 1st influence x \n        float y2a = b.y;    // 2nd influence y\n        float x2a = b.x;    // 2nd influence x\n        float y3a = 1.0; // final y \n        float x3a = 1.0; // final x \n    \n        float A =   x3a - 3.0*x2a + 3.0*x1a - x0a;\n        float B = 3.0*x2a - 6.0*x1a + 3.0*x0a;\n        float C = 3.0*x1a - 3.0*x0a;   \n        float D =   x0a;\n    \n        float E =   y3a - 3.0*y2a + 3.0*y1a - y0a;    \n        float F = 3.0*y2a - 6.0*y1a + 3.0*y0a;             \n        float G = 3.0*y1a - 3.0*y0a;             \n        float H =   y0a;\n    \n        // Solve for t given x (using Newton-Raphelson), then solve for y given t.\n        // Assume for the first guess that t = x.\n        float currentt = x;\n        for (int i=0; i < 5; i++){\n        float currentx = xFromT (currentt, A,B,C,D); \n        float currentslope = slopeFromT (currentt, A,B,C);\n        currentt -= (currentx - x)*(currentslope);\n            currentt = clamp(currentt,0.0,1.0); \n        } \n    \n        float y = yFromT (currentt,  E,F,G,H);\n        return y;\n    }\n    \n    float cubicBezierNearlyThroughTwoPoints(float x, vec2 a, vec2 b){\n    \n        float y = 0.0;\n        float epsilon = 0.00001;\n        float min_param_a = 0.0 + epsilon;\n        float max_param_a = 1.0 - epsilon;\n        float min_param_b = 0.0 + epsilon;\n        float max_param_b = 1.0 - epsilon;\n        a.x = max(min_param_a, min(max_param_a, a.x));\n        a.y = max(min_param_b, min(max_param_b, a.y));\n    \n        float x0 = 0.0;  \n        float y0 = 0.0;\n        float x4 = a.x;  \n        float y4 = a.y;\n        float x5 = b.x;  \n        float y5 = b.y;\n        float x3 = 1.0;  \n        float y3 = 1.0;\n        float x1,y1,x2,y2; // to be solved.\n    \n        // arbitrary but reasonable \n        // t-values for interior control points\n        float t1 = 0.3;\n        float t2 = 0.7;\n    \n        float B0t1 = B0(t1);\n        float B1t1 = B1(t1);\n        float B2t1 = B2(t1);\n        float B3t1 = B3(t1);\n        float B0t2 = B0(t2);\n        float B1t2 = B1(t2);\n        float B2t2 = B2(t2);\n        float B3t2 = B3(t2);\n    \n        float ccx = x4 - x0*B0t1 - x3*B3t1;\n        float ccy = y4 - y0*B0t1 - y3*B3t1;\n        float ffx = x5 - x0*B0t2 - x3*B3t2;\n        float ffy = y5 - y0*B0t2 - y3*B3t2;\n    \n        x2 = (ccx - (ffx*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        y2 = (ccy - (ffy*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        x1 = (ccx - x2*B2t1) / B1t1;\n        y1 = (ccy - y2*B2t1) / B1t1;\n    \n        x1 = max(0.0+epsilon, min(1.0-epsilon, x1));\n        x2 = max(0.0+epsilon, min(1.0-epsilon, x2));\n    \n        y = cubicBezier (x, vec2(x1,y1), vec2(x2,y2));\n        y = max(0.0, min(1.0, y));\n        return y;\n    }\n\n    \n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        \n        \n        // vec2 pic = texture2D(u_texture);\n\n        // float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 2.5);\n        uv2 = vec2(1.83/r1 + .45 + -u_time * 0.125 + r1, a );\n        uv2 -= 0.52;\n        uv2 *= 1.9;\n        // uv2.x -= u_time*0.1;\n        // uv2.y += u_time * 0.2;\n\n        vec2 uv3 = vUv;\n        uv3 *= 1.2;\n        uv3.y += 2.5;\n        uv3.x += 0.5;\n\n        vec2 uv4 = uv3;\n        float rand = random(uv4);\n        uv4 = uv4 * rand;\n        \n        vec2 q = vec2(0.);\n        q.y = -fbm( uv2 + 0.2*u_time);\n        q.x = -fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        vec2 r2 = vec2(0.);\n        r2.x = fbm( uv2 + 1.0*q - vec2(1.7,0.2)+ 0.1*u_time );\n        r2.y = fbm( uv2 + 1.0*q - vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f*f + f * 0.85),0.0,1.0));\n        color += c;\n\n        vec2 cp0 = vec2(-0.65, 1.95);\n        vec2 cp1 = vec2(0.85, 0.4);\n        vec2 cp3 = vec2(0.5, 0.5);\n        float l = cubicBezierNearlyThroughTwoPoints(uv3.x*0.25, cp0, cp1);\n        float l2 = cubicBezierNearlyThroughTwoPoints(uv4.y*0.25, cp0, cp3);\n        float px = 1. / vUv.y;\n\n        float t1 = uv3.x*7.-2.*u_time+uv3.y*3.;\n        uv3.y += sin(t1) * 0.05;\n        float x = .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        float y = fbm(uv4 + r2 * fbm(uv4 + r2));\n        // color *= .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        \n        color *= vec3( smoothstep(l, l+0.025, vUv.y+0.6));\n        // color.g += (1. - smoothstep(l, l+0.025, vUv.y+0.6))* 0.72 * x* y;\n        \n        // color -= vec3(1. - smoothstep(l2, l2, vUv.y+0.5));\n\n        \n        // color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        vec4 col = texture2D(u_texture, vec2(vUv.x, vUv.y + 0.305));\n        \n        col.xyz += color;\n        gl_FragColor = vec4(color, 1.);\n        // gl_FragColor = texture2D(u_texture, vUv);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function tA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:eA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n   \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    // Helper functions:\n    float slopeFromT (float t, float A, float B, float C){\n        float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n        return dtdx;\n    }\n    float xFromT (float t, float A, float B, float C, float D){\n        float x = A*(t*t*t) + B*(t*t) + C*t + D;\n        return x;\n    }\n    float yFromT (float t, float E, float F, float G, float H){\n        float y = E*(t*t*t) + F*(t*t) + G*t + H;\n        return y;\n    }\n    float B0 (float t){\n        return (1.0-t)*(1.0-t)*(1.0-t);\n    }\n    float B1 (float t){\n        return  3.0*t*(1.0-t)*(1.0-t);\n    }\n    float B2 (float t){\n        return 3.0*t*t* (1.0-t);\n    }\n    float B3 (float t){\n        return t*t*t;\n    }\n    float  findx (float t, float x0, float x1, float x2, float x3){\n        return x0*B0(t) + x1*B1(t) + x2*B2(t) + x3*B3(t);\n    }\n    float  findy (float t, float y0, float y1, float y2, float y3){\n        return y0*B0(t) + y1*B1(t) + y2*B2(t) + y3*B3(t);\n    }\n    \n    float cubicBezier(float x, vec2 a, vec2 b){\n        float y0a = 0.0; // initial y\n        float x0a = 0.0; // initial x \n        float y1a = a.y;    // 1st influence y   \n        float x1a = a.x;    // 1st influence x \n        float y2a = b.y;    // 2nd influence y\n        float x2a = b.x;    // 2nd influence x\n        float y3a = 1.0; // final y \n        float x3a = 1.0; // final x \n    \n        float A =   x3a - 3.0*x2a + 3.0*x1a - x0a;\n        float B = 3.0*x2a - 6.0*x1a + 3.0*x0a;\n        float C = 3.0*x1a - 3.0*x0a;   \n        float D =   x0a;\n    \n        float E =   y3a - 3.0*y2a + 3.0*y1a - y0a;    \n        float F = 3.0*y2a - 6.0*y1a + 3.0*y0a;             \n        float G = 3.0*y1a - 3.0*y0a;             \n        float H =   y0a;\n    \n        // Solve for t given x (using Newton-Raphelson), then solve for y given t.\n        // Assume for the first guess that t = x.\n        float currentt = x;\n        for (int i=0; i < 5; i++){\n        float currentx = xFromT (currentt, A,B,C,D); \n        float currentslope = slopeFromT (currentt, A,B,C);\n        currentt -= (currentx - x)*(currentslope);\n            currentt = clamp(currentt,0.0,1.0); \n        } \n    \n        float y = yFromT (currentt,  E,F,G,H);\n        return y;\n    }\n    \n    float cubicBezierNearlyThroughTwoPoints(float x, vec2 a, vec2 b){\n    \n        float y = 0.0;\n        float epsilon = 0.00001;\n        float min_param_a = 0.0 + epsilon;\n        float max_param_a = 1.0 - epsilon;\n        float min_param_b = 0.0 + epsilon;\n        float max_param_b = 1.0 - epsilon;\n        a.x = max(min_param_a, min(max_param_a, a.x));\n        a.y = max(min_param_b, min(max_param_b, a.y));\n    \n        float x0 = 0.0;  \n        float y0 = 0.0;\n        float x4 = a.x;  \n        float y4 = a.y;\n        float x5 = b.x;  \n        float y5 = b.y;\n        float x3 = 1.0;  \n        float y3 = 1.0;\n        float x1,y1,x2,y2; // to be solved.\n    \n        // arbitrary but reasonable \n        // t-values for interior control points\n        float t1 = 0.3;\n        float t2 = 0.7;\n    \n        float B0t1 = B0(t1);\n        float B1t1 = B1(t1);\n        float B2t1 = B2(t1);\n        float B3t1 = B3(t1);\n        float B0t2 = B0(t2);\n        float B1t2 = B1(t2);\n        float B2t2 = B2(t2);\n        float B3t2 = B3(t2);\n    \n        float ccx = x4 - x0*B0t1 - x3*B3t1;\n        float ccy = y4 - y0*B0t1 - y3*B3t1;\n        float ffx = x5 - x0*B0t2 - x3*B3t2;\n        float ffy = y5 - y0*B0t2 - y3*B3t2;\n    \n        x2 = (ccx - (ffx*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        y2 = (ccy - (ffy*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        x1 = (ccx - x2*B2t1) / B1t1;\n        y1 = (ccy - y2*B2t1) / B1t1;\n    \n        x1 = max(0.0+epsilon, min(1.0-epsilon, x1));\n        x2 = max(0.0+epsilon, min(1.0-epsilon, x2));\n    \n        y = cubicBezier (x, vec2(x1,y1), vec2(x2,y2));\n        y = max(0.0, min(1.0, y));\n        return y;\n    }\n\n    \n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        \n        uv2 -= 0.475;\n        // vec2 pic = texture2D(u_texture);\n\n        // float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * 2.75 +0.6) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(.000083/r1 + .45 + -u_time * 0.925 + r1, a );\n        // uv2.x -= 0.52;\n        // uv2 *= 1.9;\n        // uv2.x -= u_time*0.1;\n        // uv2.y += u_time * 0.2;\n\n        vec2 uv3 = vUv;\n        // uv3 *= 1.2;\n        // uv3.y += 2.5;\n        uv3.x += 0.5;\n\n        vec2 uv4 = uv3;\n        float rand = random(uv4);\n        uv4 = uv4 * rand;\n        \n        vec2 q = vec2(0.);\n        q.y = -fbm( uv2 + 0.2*u_time);\n        q.x = -fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        vec2 r2 = vec2(0.);\n        r2.x = fbm( uv2 + 1.0*q - vec2(1.7,0.2)+ 0.1*u_time );\n        r2.y = fbm( uv2 + 1.0*q - vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f*f + f * f * 0.8),0.0,1.0));\n\n        \n        color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        gl_FragColor = vec4(color, 1.);\n        // gl_FragColor = texture2D(u_texture, vUv);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function oA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:rA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n   \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.5, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    // Helper functions:\n    float slopeFromT (float t, float A, float B, float C){\n        float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n        return dtdx;\n    }\n    float xFromT (float t, float A, float B, float C, float D){\n        float x = A*(t*t*t) + B*(t*t) + C*t + D;\n        return x;\n    }\n    float yFromT (float t, float E, float F, float G, float H){\n        float y = E*(t*t*t) + F*(t*t) + G*t + H;\n        return y;\n    }\n    float B0 (float t){\n        return (1.0-t)*(1.0-t)*(1.0-t);\n    }\n    float B1 (float t){\n        return  3.0*t*(1.0-t)*(1.0-t);\n    }\n    float B2 (float t){\n        return 3.0*t*t* (1.0-t);\n    }\n    float B3 (float t){\n        return t*t*t;\n    }\n    float  findx (float t, float x0, float x1, float x2, float x3){\n        return x0*B0(t) + x1*B1(t) + x2*B2(t) + x3*B3(t);\n    }\n    float  findy (float t, float y0, float y1, float y2, float y3){\n        return y0*B0(t) + y1*B1(t) + y2*B2(t) + y3*B3(t);\n    }\n    \n    float cubicBezier(float x, vec2 a, vec2 b){\n        float y0a = 0.0; // initial y\n        float x0a = 0.0; // initial x \n        float y1a = a.y;    // 1st influence y   \n        float x1a = a.x;    // 1st influence x \n        float y2a = b.y;    // 2nd influence y\n        float x2a = b.x;    // 2nd influence x\n        float y3a = 1.0; // final y \n        float x3a = 1.0; // final x \n    \n        float A =   x3a - 3.0*x2a + 3.0*x1a - x0a;\n        float B = 3.0*x2a - 6.0*x1a + 3.0*x0a;\n        float C = 3.0*x1a - 3.0*x0a;   \n        float D =   x0a;\n    \n        float E =   y3a - 3.0*y2a + 3.0*y1a - y0a;    \n        float F = 3.0*y2a - 6.0*y1a + 3.0*y0a;             \n        float G = 3.0*y1a - 3.0*y0a;             \n        float H =   y0a;\n    \n        // Solve for t given x (using Newton-Raphelson), then solve for y given t.\n        // Assume for the first guess that t = x.\n        float currentt = x;\n        for (int i=0; i < 5; i++){\n        float currentx = xFromT (currentt, A,B,C,D); \n        float currentslope = slopeFromT (currentt, A,B,C);\n        currentt -= (currentx - x)*(currentslope);\n            currentt = clamp(currentt,0.0,1.0); \n        } \n    \n        float y = yFromT (currentt,  E,F,G,H);\n        return y;\n    }\n    \n    float cubicBezierNearlyThroughTwoPoints(float x, vec2 a, vec2 b){\n    \n        float y = 0.0;\n        float epsilon = 0.00001;\n        float min_param_a = 0.0 + epsilon;\n        float max_param_a = 1.0 - epsilon;\n        float min_param_b = 0.0 + epsilon;\n        float max_param_b = 1.0 - epsilon;\n        a.x = max(min_param_a, min(max_param_a, a.x));\n        a.y = max(min_param_b, min(max_param_b, a.y));\n    \n        float x0 = 0.0;  \n        float y0 = 0.0;\n        float x4 = a.x;  \n        float y4 = a.y;\n        float x5 = b.x;  \n        float y5 = b.y;\n        float x3 = 1.0;  \n        float y3 = 1.0;\n        float x1,y1,x2,y2; // to be solved.\n    \n        // arbitrary but reasonable \n        // t-values for interior control points\n        float t1 = 0.3;\n        float t2 = 0.7;\n    \n        float B0t1 = B0(t1);\n        float B1t1 = B1(t1);\n        float B2t1 = B2(t1);\n        float B3t1 = B3(t1);\n        float B0t2 = B0(t2);\n        float B1t2 = B1(t2);\n        float B2t2 = B2(t2);\n        float B3t2 = B3(t2);\n    \n        float ccx = x4 - x0*B0t1 - x3*B3t1;\n        float ccy = y4 - y0*B0t1 - y3*B3t1;\n        float ffx = x5 - x0*B0t2 - x3*B3t2;\n        float ffy = y5 - y0*B0t2 - y3*B3t2;\n    \n        x2 = (ccx - (ffx*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        y2 = (ccy - (ffy*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        x1 = (ccx - x2*B2t1) / B1t1;\n        y1 = (ccy - y2*B2t1) / B1t1;\n    \n        x1 = max(0.0+epsilon, min(1.0-epsilon, x1));\n        x2 = max(0.0+epsilon, min(1.0-epsilon, x2));\n    \n        y = cubicBezier (x, vec2(x1,y1), vec2(x2,y2));\n        y = max(0.0, min(1.0, y));\n        return y;\n    }\n\n    \n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        \n        uv2 -= 0.475;\n        // vec2 pic = texture2D(u_texture);\n\n        // float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * 2.75 +0.6) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 8.5);\n        uv2 = vec2(.003/r1 + u_time * 0.925 + r1, a );\n        // uv2.x -= 0.52;\n        // uv2 *= 1.9;\n        // uv2.x -= u_time*0.1;\n        // uv2.y += u_time * 0.2;\n\n        vec2 uv3 = vUv;\n        // uv3 *= 1.2;\n        // uv3.y += 2.5;\n        uv3.x += 0.5;\n\n        vec2 uv4 = uv3;\n        float rand = random(uv4);\n        uv4 = uv4 * rand;\n        \n        vec2 q = vec2(0.);\n        q.y = -fbm( uv2 + 0.2*u_time);\n        q.x = -fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        vec2 r2 = vec2(0.);\n        r2.x = fbm( uv2 + 1.0*q - vec2(1.7,0.2)+ 0.1*u_time );\n        r2.y = fbm( uv2 + 1.0*q - vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1 + cos(u_time * 0.3), skycolour2 + abs(sin(u_time * 0.1)/5.) - 0.5, clamp((f*f*f + f * f * 0.8),0.,.8));\n\n        \n        color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        gl_FragColor = vec4(color, 1.);\n        // gl_FragColor = texture2D(u_texture, vUv);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function iA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:n,material:aA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.2,1.); // box position\n    b0p = p-b0p;\n    b0p.yz *=Rotate(u_time * .2);\n    b0p.xz *=Rotate(u_time * .2);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.85,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.2,1.); // box position\n    b1p = p-b1p;\n    b1p.yz *=Rotate(u_time * .2);\n    b1p.xz *=Rotate(u_time * .2);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.2,1.); // box position\n    b2p = p-b2p;\n    b2p.yz *=Rotate(u_time * .2);\n    b2p.xz *=Rotate(u_time * .2);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2.,1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0.,0.5,1.);\n    s1p=p-s1p;\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, b1, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, s0, 0.15 + sin(u_time * 1.5)/8.);\n     \n    csg2 = smoothDifferenceSDF(csg1, s1, 0.15 + cos(u_time * 1.5)/8.);\n\n    csg3 = smoothDifferenceSDF(csg0, b2, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg3, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.,-2.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function cA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:n,material:vA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    /////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n    // Primitives\n    ///////////////////////\n    \n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n        // Box0\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n        //Box1\n        vec3 b1s = vec3(.85,.5,.5); //box size\n        vec3 b1p = vec3(0.,1.2,1.); // box position\n        b1p = p-b1p;\n        b1p.yz *=Rotate(u_time * .2);\n        b1p.xz *=Rotate(u_time * .2);\n        vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n        //Box2\n        vec3 b2s = vec3(.5,.5,.85); //box size\n        vec3 b2p = vec3(0.,1.2,1.); // box position\n        b2p = p-b2p;\n        b2p.yz *=Rotate(u_time * 1.5);\n        b2p.xz *=Rotate(u_time * 1.5);\n        vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n        // p.xz *=Rotate(u_time * .2);\n    \n        // Sphere.\n        vec3 s0p=vec3(0.,2.,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n        vec3 s1p=vec3(0.,2.2,1.);\n        s1p=p-s1p;\n        s1p.yz *=Rotate(u_time * .2);\n        s1p.xz *=Rotate(u_time * .2);\n        vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.75));\n        \n        // Cylinders\n        float c0h = 1.,c0r = .55; // Cylinder height, radius.\n        vec3 c0p = p - vec3 (0,1,2.); // Position\n        vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n        \n        float c1h = 1.,c1r = .55; \n        vec3 c1p = p - vec3 (0,1,0); \n        c1p.xy *= Rotate(PI*.5);  // Rotate\n        vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n        \n        float c2h = 1.,c2r = .55; \n        vec3 c2p = p - vec3 (0,1,0);\n        c2p.xy *= Rotate(PI*.5);  \n        c2p.yz *= Rotate(PI*.5);  \n        vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n    \n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothDifferenceSDF(b0, s1, 0.15); // Intersect box with sphere creating a CSG object.\n\n        scene = unionSDF(csg0, p0);\n    \n        return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function sA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:n,material:lA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var uA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    /////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n    // Primitives\n    ///////////////////////\n    \n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n        // Box0\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n        //Box1\n        vec3 b1s = vec3(.85,.5,.5); //box size\n        vec3 b1p = vec3(0.,2.2 + sin(u_time) * 2.,1.); // box position\n        b1p = p-b1p;\n        b1p.yz *=Rotate(u_time * 1.2);\n        b1p.xz *=Rotate(u_time * 1.2);\n        vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n        //Box2\n        vec3 b2s = vec3(.5,.5,.85); //box size\n        vec3 b2p = vec3(0.,1.2,1.); // box position\n        b2p = p-b2p;\n        b2p.yz *=Rotate(u_time * 1.5);\n        b2p.xz *=Rotate(u_time * 1.5);\n        vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n        // p.xz *=Rotate(u_time * .2);\n    \n        // Sphere.\n        vec3 s0p=vec3(0.,2.,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n        vec3 s1p=vec3(0.,2.2,1.);\n        s1p=p-s1p;\n        s1p.yz *=Rotate(u_time * .2);\n        s1p.xz *=Rotate(u_time * .2);\n        vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.75));\n        \n        // Cylinders\n        float c0h = 1.,c0r = .55; // Cylinder height, radius.\n        vec3 c0p = p - vec3 (0,1,2.); // Position\n        vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n        \n        float c1h = 1.,c1r = .55; \n        vec3 c1p = p - vec3 (0,1,0); \n        c1p.xy *= Rotate(PI*.5);  // Rotate\n        vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n        \n        float c2h = 1.,c2r = .55; \n        vec3 c2p = p - vec3 (0,1,0);\n        c2p.xy *= Rotate(PI*.5);  \n        c2p.yz *= Rotate(PI*.5);  \n        vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n    \n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothDifferenceSDF(b0, s1, 0.15); // difference box with sphere creating a CSG object.\n\n        csg1 = smoothUnionSDF(csg0, b1, 0.15); //intersect\n\n        scene = unionSDF(csg1, p0);\n    \n        return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function fA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:n,material:uA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //Box2\n        vec3 b1s = vec3(0.25);\n        vec3 b1p = vec3(0., 2.2, 1.);\n        b1p = p - b1p;\n        b1p.yz *=Rotate(-u_time * 2.2);\n        b1p.xz *=Rotate(-u_time * 2.2);\n        vec4 b1 = vec4(BoxColor.rgb, boxSDF(b1p, b1s));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothDifferenceSDF(b0, s0, 0.15); // difference box with sphere creating a CSG object.\n\n        csg1 = smoothUnionSDF(csg0, b1, 0.15);\n\n        scene = smoothUnionSDF(csg1, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function dA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:n,material:pA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //Box2\n        vec3 b1s = vec3(0.25);\n        vec3 b1p = vec3(0., 2. + sin(u_time * 1.5) + 0.75 * 1.5, 1.);\n        b1p = p - b1p;\n        b1p.yz *=Rotate(-u_time * 2.2);\n        b1p.xz *=Rotate(-u_time * 2.2);\n        vec4 b1 = vec4(BoxColor.rgb, boxSDF(b1p, b1s));\n\n        //Box3\n        vec3 b2s = vec3(0.25);\n        vec3 b2p = vec3(0. + cos(u_time * 1.5) * 2.25, 2. + sin(u_time * 1.5) * 0.5, 1.);\n        b2p = p - b2p;\n        b2p.yz *=Rotate(u_time * 2.2);\n        b2p.xz *=Rotate(u_time * 2.2);\n        vec4 b2 = vec4(BoxColor.rgb, boxSDF(b2p, b2s));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothDifferenceSDF(b0, s0, 0.15); // difference box with sphere creating a CSG object.\n\n        csg1 = smoothUnionSDF(csg0, b1, 0.15);\n\n        csg2 = smoothUnionSDF(csg1, b2, 0.15);\n\n        scene = smoothUnionSDF(csg2, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        #ifdef ANTIALIASING\n        vec3 oh = vec3(0.0);\n        vec4 tmp = vec4(0.0);\n        #endif\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function hA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:n,material:mA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var xA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n        //Box2\n        vec3 b1s = vec3(0.25);\n        vec3 b1p = vec3(0. + sin(u_time * 1.5) * 2.25, 2. + cos(u_time * 1.5) * 0.5, 1.);\n        b1p = p - b1p;\n        b1p.yz *=Rotate(-u_time * 2.2);\n        b1p.xz *=Rotate(-u_time * 2.2);\n        vec4 b1 = vec4(BoxColor.rgb, boxSDF(b1p, b1s));\n\n        //Box3\n        vec3 b2s = vec3(0.25);\n        vec3 b2p = vec3(0. + cos(u_time * 1.5) * 2.25, 2. + sin(u_time * 1.5) * 0.5, 1.);\n        b2p = p - b2p;\n        b2p.yz *=Rotate(u_time * 2.2);\n        b2p.xz *=Rotate(u_time * 2.2);\n        vec4 b2 = vec4(BoxColor.rgb, boxSDF(b2p, b2s));\n        \n            \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        vec3 s1p=vec3(0. + sin(u_time * 1.5) * 2.25, 2. + cos(u_time * 1.5) * 0.5, 1.);\n        s1p=p-s1p;\n        vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.25));\n\n        vec3 s2p=vec3(0. + cos(u_time * 1.5) * 2.25, 2. + sin(u_time * 1.5) * 0.5, 1.);\n        s2p=p-s2p;\n        vec4 s2 = vec4(SphereColor.rgb,sphereSDF(s2p,.25));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0);\n        \n        csg0 = smoothDifferenceSDF(b0, s0, 0.15); // difference box with sphere creating a CSG object.\n\n        csg1 = smoothUnionSDF(csg0, b1, 0.15);\n\n        csg2 = smoothUnionSDF(csg1, b2, 0.15);\n\n        csg3 = smoothDifferenceSDF(csg2, s1, 0.15);\n\n        csg4 = smoothDifferenceSDF(csg3, s2, 0.15);\n\n        scene = smoothUnionSDF(csg4, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    vec4 fC(vec2 vUv){\n        vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-6.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        return vec4(color, 1.);\n    }\n\n    void main()\n    {\n        //https://www.shadertoy.com/view/wtjfRV\n        //anti-alias\n        gl_FragColor = vec4(0.);\n        float A = 4.;  // Change A to define the level of anti-aliasing (1 to 16) ... higher numbers are REALLY slow!  \n        float s = 1./A, x, y;\n        for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) gl_FragColor += min ( fC(vec2(vUv.x,vUv.y)), 1.0);\n        gl_FragColor /= A*A;\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function gA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:n,material:xA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var yA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(.75,.75,.75); //box size\n        vec3 bfp = vec3(0.,2.2,1.); // box position\n        bfp = p - bfp;\n        bfp.yz *=Rotate(u_time * 1.2);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.025));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        // csg0 = smoothDifferenceSDF(bf, s0, 0.15); \n\n        scene = smoothUnionSDF(bf, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        #ifdef ANTIALIASING\n        vec3 oh = vec3(0.0);\n        vec4 tmp = vec4(0.0);\n        #endif\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function bA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:n,material:yA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _A=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(1.5,1.5,1.5); //box size\n        vec3 bfp = vec3(0.,2.2,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time + 0.5) * 1.25);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.05));\n\n        //box frame\n        vec3 bfs2 = vec3(.75,.75,.75); //box size\n        vec3 bfp2 = vec3(0.,2.2,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time + 0.25) * 1.25);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.05));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time) * 1.25);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.05));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(bf, bf2, 0.15); \n\n        scene = smoothUnionSDF(csg0, bf3, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,4.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n       \n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,5.,-8.0 + sin(u_time) + .45 * 15.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.3); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function UA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:n,material:_A,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var wA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(1.5,1.5,1.5); //box size\n        vec3 bfp = vec3(0.,2.2,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.075));\n\n        //box frame\n        vec3 bfs2 = vec3(.75,.75,.75); //box size\n        vec3 bfp2 = vec3(0.,2.2,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time * 1.125) * 1.5);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.075));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time * 1.) * 1.5);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.075));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(bf, bf2, 0.15); \n\n        csg1 = smoothUnionSDF(csg0, bf3, 0.15);\n\n        scene = smoothUnionSDF(csg1, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,6.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n       \n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-4. + sin(u_time * 0.25 + 0.5)  * 5.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // rd.zy *= Rotate(PI*-.2); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function SA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:n,material:wA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(0.75 * cos(u_time)/ 2. + 0.75); //box size\n        vec3 bfp = vec3(0.,2.2 + abs(cos(u_time * 0.25)) * 2. ,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.095));\n\n        //box frame\n        vec3 bfs2 = vec3(0.75 * sin(u_time)/2. + 0.75); //box size\n        vec3 bfp2 = vec3(0.,2.2 + abs(sin(u_time * 0.25)) * 2.,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.095));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time * 1.) * 1.5);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.075));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(bf, bf2, 0.15); \n\n        scene = smoothUnionSDF(csg0, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8.,-2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 2.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n       \n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-5.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // rd.zy *= Rotate(PI*-.2); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function MA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:n,material:kA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var zA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //hex prism\n    float sdHexPrism( vec3 p, vec2 h )\n    {\n        const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        p = abs(p);\n        p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n        vec2 d = vec2(\n            length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n            p.z-h.y );\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(0.75 * cos(u_time)/ 2. + 0.75); //box size\n        vec3 bfp = vec3(0.,2.2 + abs(cos(u_time * 0.25)) * 2. ,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.095));\n\n        //hex prism\n        vec2 hexPrismSize = vec2(0.5);\n        vec3 hexPrismPosition = vec3(0., 2., 0.);\n        hexPrismPosition = p - hexPrismPosition;\n        hexPrismPosition.yz *=Rotate(u_time * 1.2);\n        hexPrismPosition.xz *=Rotate(u_time * 1.2);\n        vec4 hexPrism = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition, hexPrismSize));\n\n        //box frame\n        vec3 bfs2 = vec3(0.75 * sin(u_time)/2. + 0.75); //box size\n        vec3 bfp2 = vec3(0.,2.2 + abs(sin(u_time * 0.25)) * 2.,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.095));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time * 1.) * 1.5);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.075));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        // csg0 = smoothUnionSDF(hexPrism, bf2, 0.15); \n\n        scene = smoothUnionSDF(hexPrism, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8., -2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 1.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n       \n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-5.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // ro.zx *= Rotate(sin(u_time)); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function CA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:n,material:zA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var TA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //hex prism\n    float sdHexPrism( vec3 p, vec2 h )\n    {\n        const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        p = abs(p);\n        p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n        vec2 d = vec2(\n            length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n            p.z-h.y );\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(0.75 * cos(u_time)/ 2. + 0.75); //box size\n        vec3 bfp = vec3(0.,2.2 + abs(cos(u_time * 0.25)) * 2. ,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.095));\n\n        //hex prism\n        vec2 hexPrismSize = vec2(0.5, 0.9 + (sin(u_time)/2.) + 0.75);\n        vec3 hexPrismPosition = vec3(0., 2., 0.);\n        hexPrismPosition = p - hexPrismPosition;\n        hexPrismPosition.yz *=Rotate(cos(u_time * 1.2));\n        hexPrismPosition.xz *=Rotate(sin(u_time * 1.2));\n        vec4 hexPrism = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition, hexPrismSize));\n\n        //hex prism2\n        vec2 hexPrismSize2 = vec2(0.5, 0.9 + (sin(u_time)/2. )+ 0.75);\n        vec3 hexPrismPosition2 = vec3(0., 2., 0.);\n        hexPrismPosition2 = p - hexPrismPosition2;\n        hexPrismPosition2.yz *=Rotate(sin(u_time * 1.2));\n        hexPrismPosition2.xz *=Rotate(cos(u_time * 1.2));\n        vec4 hexPrism2 = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition2, hexPrismSize2));\n\n        //hex prism3\n        vec2 hexPrismSize3 = vec2(0.5, 0.9 + (sin(u_time)/2. )+ 0.75);\n        vec3 hexPrismPosition3 = vec3(0., 2., 0.);\n        hexPrismPosition3 = p - hexPrismPosition3;\n        hexPrismPosition3.yz *=Rotate(sin(u_time * 1.2));\n        hexPrismPosition3.xy *=Rotate(cos(u_time * 1.2));\n        vec4 hexPrism3 = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition3, hexPrismSize3));\n\n        //box frame\n        vec3 bfs2 = vec3(0.75 * sin(u_time)/2. + 0.75); //box size\n        vec3 bfp2 = vec3(0.,2.2 + abs(sin(u_time * 0.25)) * 2.,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.095));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time * 1.) * 1.5);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.075));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(hexPrism, hexPrism2, 0.15); \n\n        csg1 = smoothUnionSDF(csg0, hexPrism3, 0.15);\n\n        scene = smoothUnionSDF(csg1, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8., -2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 1.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n       \n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-8.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // ro.zx *= Rotate(sin(u_time)); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function RA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:n,material:TA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var DA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //hex prism\n    float sdHexPrism( vec3 p, vec2 h )\n    {\n        const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        p = abs(p);\n        p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n        vec2 d = vec2(\n            length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n            p.z-h.y );\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.,0.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(0.75 * cos(u_time)/ 2. + 0.75); //box size\n        vec3 bfp = vec3(0.,2.2 + abs(cos(u_time * 0.25)) * 2. ,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.095));\n\n        //hex prism\n        vec2 hexPrismSize = vec2(0.5, 0.9 + (sin(u_time)/4.) + 0.75);\n        vec3 hexPrismPosition = vec3(0., 2., 0.);\n        hexPrismPosition = p - hexPrismPosition;\n        hexPrismPosition.yz *=Rotate(cos(u_time * 1.2));\n        hexPrismPosition.xz *=Rotate(sin(u_time * 1.2));\n        vec4 hexPrism = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition, hexPrismSize));\n\n        //hex prism2\n        vec2 hexPrismSize2 = vec2(0.5, 0.9 + (sin(u_time)/4. )+ 0.75);\n        vec3 hexPrismPosition2 = vec3(0., 2., 0.);\n        hexPrismPosition2 = p - hexPrismPosition2;\n        hexPrismPosition2.yz *=Rotate(sin(u_time * 1.2));\n        hexPrismPosition2.xz *=Rotate(cos(u_time * 1.2));\n        vec4 hexPrism2 = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition2, hexPrismSize2));\n\n        //hex prism3\n        vec2 hexPrismSize3 = vec2(0.5, 0.9 + (sin(u_time)/4. )+ 0.75);\n        vec3 hexPrismPosition3 = vec3(0., 2., 0.);\n        hexPrismPosition3 = p - hexPrismPosition3;\n        hexPrismPosition3.yz *=Rotate(sin(u_time * 1.2));\n        hexPrismPosition3.xy *=Rotate(cos(u_time * 1.2));\n        vec4 hexPrism3 = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition3, hexPrismSize3));\n\n        //box frame\n        vec3 bfs2 = vec3(0.75 * sin(u_time)/2. + 0.75); //box size\n        vec3 bfp2 = vec3(0.,2.2 + abs(sin(u_time * 0.25)) * 2.,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.095));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time * 1.) * 1.5);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.075));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(hexPrism, hexPrism2, 0.15); \n\n        csg1 = smoothUnionSDF(csg0, hexPrism3, 0.15);\n\n        csg2 = smoothDifferenceSDF(csg1, s0, 0.15);\n\n        scene = smoothUnionSDF(csg2, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8., -2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 1.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-8.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // ro.zx *= Rotate(sin(u_time)); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function PA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:n,material:DA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //hex prism\n    float sdHexPrism( vec3 p, vec2 h )\n    {\n        const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        p = abs(p);\n        p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n        vec2 d = vec2(\n            length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n            p.z-h.y );\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.25); //box size\n        vec3 b0p = vec3(0.,2.0,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.,0.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //hex prism\n        vec2 hexPrismSize = vec2(0.5, 0.9 + (sin(u_time)/4.) + 0.75);\n        vec3 hexPrismPosition = vec3(0., 2., 0.);\n        hexPrismPosition = p - hexPrismPosition;\n        hexPrismPosition.yz *=Rotate(cos(u_time * 1.2));\n        hexPrismPosition.xz *=Rotate(sin(u_time * 1.2));\n        vec4 hexPrism = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition, hexPrismSize));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(hexPrism, hexPrism, 0.15); \n\n        csg1 = smoothDifferenceSDF(csg0, s0, 0.15);\n\n        csg2 = smoothUnionSDF(csg1, b0, 0.15);\n\n        scene = smoothUnionSDF(csg2, csg2, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8., -2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 1.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-8.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // ro.zx *= Rotate(sin(u_time)); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function FA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:n,material:jA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    float opOnion( in float sdf, in float thickness )\n    {\n        return abs(sdf)-thickness;\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        float n = cnoise(p + (u_time)) * 0.1;\n        p.x += n;\n        p.y += n * 2.;\n        p.z += n * 5.;\n        vec3 q = abs(p) - b;\n        \n        \n        return length(max(q ,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //hex prism\n    float sdHexPrism( vec3 p, vec2 h )\n    {\n        const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        p = abs(p);\n        p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n        vec2 d = vec2(\n            length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n            p.z-h.y );\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.25); //box size\n        vec3 b0p = vec3(0.,2.0,1.); // box position\n        // float n = cnoise(b0s) + sin(u_time);\n        // b0s += n;\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        float box = boxSDF(b0p, b0s);\n        vec4 b0 = vec4(BoxColor.rgb, box); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.,0.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //hex prism\n        vec2 hexPrismSize = vec2(0.5, 0.9 + (sin(u_time)/4.) + 0.75);\n        vec3 hexPrismPosition = vec3(0., 2., 0.);\n        hexPrismPosition = p - hexPrismPosition;\n        hexPrismPosition.yz *=Rotate(cos(u_time * 1.2));\n        hexPrismPosition.xz *=Rotate(sin(u_time * 1.2));\n        vec4 hexPrism = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition, hexPrismSize));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(b0, p0, 0.15); \n\n        csg1 = smoothDifferenceSDF(csg0, s0, 0.15);\n\n        csg2 = smoothUnionSDF(csg1, b0, 0.15);\n\n        scene = smoothUnionSDF(csg0, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8., -2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 1.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.,-2.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // ro.zx *= Rotate(sin(u_time)); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function IA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:n,material:EA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var OA=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n    #define S smoothstep\n    #define T u_time\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float GetDist(vec3 p){\n        float d = sdBox(p, vec3(1.));\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.001, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy/u_resolution.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3);\n        ro.yz *= Rot(-T*PI + 1. * 0.125);\n        ro.xz *= Rot(-T*TWO_PI * 0.125);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        vec3 col = vec3(0.);\n\n        float d = RayMarch(ro, rd);\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d;\n            vec3 n = GetNormal(p);\n            vec3 r = reflect(rd, n);\n\n            float dif = dot(n , normalize(vec3(1., 2., 3.))) * .5 + .5;\n            col = vec3(dif);\n            color += col;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function LA(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),addEventListener("mousemove",(function(n){n.clientX,window.innerWidth,n.clientY,window.innerHeight})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:n,material:OA,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function AA(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new cf).load(e);console.log(t);var r,o,a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float GetDist(vec3 p){\n        float d = sdBox(p, vec3(1.));\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.001, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3);\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, rd).rgb;\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 reflectDir = reflect(rd, n);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n\n            vec3 reflTex = texture(u_cubemap, rdOut).rgb;\n\n            col = vec3(reflTex);\n            color += col;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:t}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(r,o)})),addEventListener("mousemove",(function(n){r=n.clientX/window.innerWidth,o=-n.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function NA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",r=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float GetDist(vec3 p){\n\n        p.xz *= Rot(u_time * .1);\n\n        float d = sdBox(p, vec3(1.));\n\n        float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        vec3 n = vec3(-0.5, -c, s);\n        p = abs(p);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, rd).rgb;\n        // vec3 col = vec3(0.);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            //col = n * .5 + .5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function GA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",r=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        vec3 p1 = p;\n        vec3 p2 = p;\n        // p1.x -= 0.65;\n        p2.x += sin(u_time) * 1.5;\n\n        p2.xy *= Rot(u_time * .4);\n        p2.yz *= Rot(u_time * .4);\n        p2.xz *= Rot(u_time * .4);\n\n        p1.xy *= Rot(u_time * .4);\n        p1.yz *= Rot(u_time * .4);\n        p1.xz *= Rot(u_time * .4);\n\n        float d1 = sdTorus(p2, vec2(0.5, 0.2));\n\n        float d2 = sdBox(p1, vec3(0.5));\n\n        float d = opSmoothUnion(d1, d2, 0.15);\n\n        // float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        // vec3 n = vec3(-0.5, -c, s);\n        // p = abs(p);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, rd).rgb;\n        // vec3 col = vec3(.6);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            //col = n * .5 + .5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function BA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",r=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        vec3 p1 = p;\n        vec3 p2 = p;\n        // p1.x -= 0.65;\n        // p2.x += sin(u_time) * 1.5;\n\n        p2.xy *= Rot(u_time * .4);\n        p2.yz *= Rot(u_time * .4);\n        p2.xz *= Rot(u_time * .4);\n\n        p1.xy *= Rot(u_time * .4);\n        p1.yz *= Rot(u_time * .4);\n        p1.xz *= Rot(u_time * .4);\n\n        float d1 = sdTorus(p2, vec2(0.5, 0.2));\n\n        float d2 = sdBox(p1, vec3(0.5));\n\n        float d = opSmoothSubtraction(d1, d2, 0.15);\n\n        \n\n        for(int i = 0; i < 4; i++){\n            float c = cos(PI/5.), s = sqrt(0.75-c*c);\n            vec3 n = vec3(-0.5, -c, s);\n            p1.xy = abs(p.xy);\n            p1 -= 2. * min(0., dot(p1, n)) * n;\n        }\n        // p = abs(p);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        // vec3 col = vec3(.6);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            //col = n * .5 + .5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function qA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",r=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        vec3 p1 = p;\n        vec3 p2 = p;\n        // p1.x -= 0.65;\n        // p2.x += sin(u_time) * 1.5;\n\n        p2.xy *= Rot(u_time * .4);\n        p2.yz *= Rot(u_time * .4);\n        p2.xz *= Rot(u_time * .4);\n\n        p1.xy *= Rot(u_time * .4);\n        p1.yz *= Rot(u_time * .4);\n        p1.xz *= Rot(u_time * .4);\n\n        float d1 = sdTorus(p2, vec2(0.5, 0.2));\n\n        float d2 = sdBox(p1, vec3(0.5));\n\n        // float d = opSmoothUnion(d1, d2, 0.15);\n\n        float d = d1;\n        \n\n        for(int i = 0; i < 4; i++){\n            float c = cos(PI/5.), s = sqrt(0.75-c*c);\n            vec3 n = vec3(-0.5, -c, s);\n            p1.xy = abs(p.xy);\n            p1 -= 2. * min(0., dot(p1, n)) * n;\n        }\n        // p = abs(p);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        // vec3 col = vec3(.6);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            //col = n * .5 + .5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function VA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",r=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        p.xz *= Rot(u_time * .1);\n\n        float d = sdBox(p, vec3(1.));\n\n        float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        vec3 n = vec3(-0.5, -c, s);\n        p = abs(p);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.5);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            // vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            // col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function WA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",r=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        p.xz *= Rot(u_time * .1);\n\n        float d = sdBox(p, vec3(1.));\n\n        float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        vec3 n = vec3(-0.5, -c, s);\n        p = abs(p);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.5);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            // vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            // col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        color  = vec3(dif * col);\n\n        // color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function HA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",r=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        p.xz *= Rot(u_time * .1);\n\n        float d = sdBox(p, vec3(1.));\n\n        float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        vec3 n = vec3(-0.5, -c, s);\n        // p = abs(p);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,4.,0.);// Light Position\n        vec3 lightPos2=vec3(2.,4.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 l2=normalize(lightPos2-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        float dif2=dot(n,l2);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        dif2=clamp(dif2,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.5);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            // vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            // col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.25 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif * col);\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function XA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",r=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    // uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        p.xy *= Rot(u_time * .1);\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p, vec2(0.5, 0.15));\n\n        float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        vec3 n = vec3(-0.5, -c, s);\n        // p = abs(p);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // d = p.z - 1.;\n\n        return d2;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,4.,0.);// Light Position\n        vec3 lightPos2=vec3(2.,4.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 l2=normalize(lightPos2-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        float dif2=dot(n,l2);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        dif2=clamp(dif2,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.yx *= Rot(-m.x*PI + 1.);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif * col);\n        // float m = 0.;\n        float t = u_time;\n        for (float i = 0.; i <=1.; i+= 1./4.){\n            float z = fract(i + t);\n            float size = mix(10., .5, z);\n            ro.z *= size;\n            color += col;\n        }\n        // color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function YA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",r=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    // uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p2 = p;\n        vec3 p3 = p;\n        p.xy *= Rot(u_time * .3);\n        p2.xy *= Rot(u_time * .5);\n        p3.xy *= Rot(u_time * .7);\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p, vec2(0.75, 0.15));\n\n        float d3 = sdTorus(p, vec2(1.25, 0.15));\n\n        float total = sdTorus(vec3(p2), vec2(0.25, 0.15));\n        total = opSmoothUnion(total, d2, 0.15);\n        total = opSmoothUnion(total, d3, 0.15);\n        return total;\n        \n\n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,4.,0.);// Light Position\n        vec3 lightPos2=vec3(2.,4.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 l2=normalize(lightPos2-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        float dif2=dot(n,l2);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        dif2=clamp(dif2,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.yx *= Rot(-m.x*PI + 1.);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        color  = vec3(dif * col);\n        // float m = 0.;\n        // float t = u_time;\n        // for (float i = 0.; i <=1.; i+= 1./4.){\n        //     float z = fract(i + t);\n        //     float size = mix(10., .5, z);\n        //     ro.z *= size;\n        //     color += col;\n        // }\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function $A(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",r=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],o=((new cf).load(r),new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    // uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p2 = p;\n        vec3 p3 = p;\n        p.xy *= Rot(u_time * 1.3);\n        p.yz *= Rot(u_time * 1.7);\n        p2.xy *= Rot(u_time * 1.5);\n        p2.xz *= Rot(u_time * 1.5);\n        p3.xy *= Rot(u_time * 1.7);\n        p3.yz *= Rot(u_time * 1.7);\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p2, vec2(0.75, 0.15));\n\n        float d3 = sdTorus(p3, vec2(1.25, 0.15));\n\n        float total = sdTorus(vec3(p), vec2(0.25, 0.15));\n\n        total = opSmoothUnion(total, d2, 0.15);\n        total = opSmoothUnion(total, d3, 0.15);\n        return total;\n        \n\n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,4.,0.);// Light Position\n        vec3 lightPos2=vec3(2.,4.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 l2=normalize(lightPos2-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        float dif2=dot(n,l2);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        dif2=clamp(dif2,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        // ro.yx *= Rot(-m.x*PI + 1.);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        color  = vec3(dif * col);\n        // float m = 0.;\n        // float t = u_time;\n        // for (float i = 0.; i <=1.; i+= 1./4.){\n        //     float z = fract(i + t);\n        //     float size = mix(10., .5, z);\n        //     ro.z *= size;\n        //     color += col;\n        // }\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}})),a=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=a.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[a.current]),Vm((function(t){var r=t.clock;a.current.material.uniforms.u_time.value=r.elapsedTime,a.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:a,material:o,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function ZA(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",r=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],o=((new cf).load(r),new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    // uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p2 = p;\n        vec3 p3 = p;\n        // p.xy *= Rot(u_time * 1.3);\n        // p.yz *= Rot(u_time * 1.7);\n        p2.xy *= Rot(u_time * 1.5);\n        p2.xz *= Rot(u_time * 1.5);\n        p3.xy *= Rot(u_time * 1.7);\n        p3.yz *= Rot(u_time * 1.7);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p2, vec2(0.75, 0.15));\n\n        float d3 = sdTorus(p3, vec2(1.25, 0.15));\n\n        float total = sdTorus(vec3(p), vec2(0.25, 0.15));\n\n        total = opSmoothUnion(total, d2, 0.15);\n        total = opSmoothUnion(total, d3, 0.15);\n        total = opSmoothUnion(total, plane, 0.15);\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,5.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        // ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // rd.y += sin(u_time)/3. - 0.5;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n            reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n            reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        color  = vec3(dif * col);\n       \n        // color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}})),a=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=a.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[a.current]),Vm((function(t){var r=t.clock;a.current.material.uniforms.u_time.value=r.elapsedTime,a.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:a,material:o,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function KA(){var n,e,t=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    // uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        p.xz *= Rot(PI * 0.5);\n        p1.xy *= Rot(u_time * 1.5);\n        p1.yz *= Rot(u_time * 1.5);\n        p2.xy *= Rot(u_time * 1.5);\n        p2.xz *= Rot(u_time * 1.5);\n        p3.xy *= Rot(u_time * 1.7);\n        p3.yz *= Rot(u_time * 1.7);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p2, vec2(0.75, 0.15));\n\n        float d3 = sdTorus(p3, vec2(1.25, 0.15));\n\n        float total = sdTorus(vec3(p1), vec2(0.25, 0.15));\n\n        total = opSmoothUnion(total, d2, 0.15);\n        total = opSmoothUnion(total, d3, 0.15);\n        total = opSmoothUnion(total, plane, 0.15);\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        // ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // rd.y += sin(u_time)/3. - 0.5;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n            reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n            reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        color  = vec3(dif + col);\n       \n        // color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}}),r=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=r.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[r.current]),Vm((function(t){var o=t.clock;r.current.material.uniforms.u_time.value=o.elapsedTime,r.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:r,material:t,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function JA(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new cf).load(e);console.log(t);var r,o,a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        p.xz *= Rot(PI * 0.5);\n        p1.xy *= Rot(u_time * 1.5);\n        p1.yz *= Rot(u_time * 1.5);\n        p2.xy *= Rot(u_time * 1.5);\n        p2.xz *= Rot(u_time * 1.5);\n        p3.xy *= Rot(u_time * 1.7);\n        p3.yz *= Rot(u_time * 1.7);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p2, vec2(0.75, 0.15));\n\n        float d3 = sdTorus(p3, vec2(1.25, 0.15));\n\n        float total = sdTorus(vec3(p1), vec2(0.25, 0.15));\n\n        total = opSmoothUnion(total, d2, 0.15);\n        total = opSmoothUnion(total, d3, 0.15);\n        // total = opSmoothUnion(total, plane, 0.15);\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // rd.y += sin(u_time)/3. - 0.5;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:t}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(r,o)})),addEventListener("mousemove",(function(n){r=n.clientX/window.innerWidth,o=-n.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function QA(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new cf).load(e);console.log(t);var r,o,a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n\n        p2.zy *= Rot(PI * 0.5);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float total = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 0.75);\n\n        total = opSmoothSubtraction(total, d2, 0.15);\n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // rd.y += sin(u_time)/3. - 0.5;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:t}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(r,o)})),addEventListener("mousemove",(function(n){r=n.clientX/window.innerWidth,o=-n.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function nN(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new cf).load(e);console.log(t);var r,o,a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n\n        p2.zy *= Rot(PI * 0.5 + u_time);\n        p2.xy *= Rot(PI * 0.5 + u_time);\n        p2.zx *= Rot(PI * 0.5 + u_time);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 0.75);\n\n        float total = opSmoothSubtraction(d1, d2, 0.15);\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // rd.y += sin(u_time)/3. - 0.5;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:t}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(r,o)})),addEventListener("mousemove",(function(n){r=n.clientX/window.innerWidth,o=-n.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function eN(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new cf).load(e);console.log(t);var r,o,a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n\n        p2.zy *= Rot(PI * 0.5 + u_time);\n        p2.xy *= Rot(PI * 0.5 + u_time);\n        p2.zx *= Rot(PI * 0.5 + u_time);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5 + sin(u_time)/4. + 0.2));\n\n        float d2 = sdSphere(p, 0.75 + sin(u_time)/4. + 0.2);\n\n        float total = opSmoothSubtraction(d1, d2, 0.15);\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        // ro.yz *= Rot(PI * 0.5);\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, rd).rgb;\n        // vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:t}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(r,o)})),addEventListener("mousemove",(function(n){r=n.clientX/window.innerWidth,o=-n.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function tN(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new cf).load(e);console.log(t);var r,o,a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        // p.y += 1.;\n\n        \n        p2.zy *= Rot(PI * 0.5 + u_time);\n        p2.xy *= Rot(PI * 0.5 + u_time);\n        p2.zx *= Rot(PI * 0.5 + u_time);\n\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 0.75 + sin(u_time)/4. + 0.2);\n\n        float total = d1;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        // ro.yz *= Rot(PI * 0.5);\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.8);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:t}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(r,o)})),addEventListener("mousemove",(function(n){r=n.clientX/window.innerWidth,o=-n.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function rN(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new cf).load(e);console.log(t);var r,o,a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        // p.y += 1.;\n\n        \n        // p.zy *= Rot(PI * 0.5 + u_time);\n        p.xy *= Rot(PI * 0.5 + u_time);\n        p.zx *= Rot(PI * 0.5 + u_time);\n\n        p.xz *= Rot(PI * 0.5);\n\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 1.75);\n\n        float total = d2;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yx *= Rot(PI * 0.5);\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        rd.y *= -1.;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.8);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:t}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(r,o)})),addEventListener("mousemove",(function(n){r=n.clientX/window.innerWidth,o=-n.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function oN(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new cf).load(e);console.log(t);var r,o,a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        // p.y += 1.;\n\n        \n        // p.zy *= Rot(PI * 0.5 + u_time);\n        p.xy *= Rot(PI * 0.5 + u_time);\n        p.zx *= Rot(PI * 0.5 + u_time);\n\n        p.xz *= Rot(PI * 0.5);\n\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 1.75);\n\n        float total = d2;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yx *= Rot(PI * 0.5);\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        rd.y *= -1.;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.3);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:t}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(r,o)})),addEventListener("mousemove",(function(n){r=n.clientX/window.innerWidth,o=-n.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function aN(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new cf).load(e);console.log(t);var r,o,a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        \n\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 1.75);\n\n        float total = d2;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        \n\n        vec3 ro = vec3 (0., 3., -4) * .9;\n        ro.yx *= Rot(PI * 0.5);\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        rd.y *= -1.;\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap,-rd).rgb;\n        // vec3 col = vec3(.3);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:t}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(r,o)})),addEventListener("mousemove",(function(n){r=n.clientX/window.innerWidth,o=-n.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function iN(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new cf).load(e);console.log(t);var r,o,a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        \n        p += cnoise(p) * (0.2 * sin(u_time));\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 1.75);\n\n        float total = d2;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        \n\n        vec3 ro = vec3 (0., 3., -4) * .9;\n        ro.yx *= Rot(PI * 0.5);\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        rd.y *= -1.;\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap,-rd).rgb;\n        // vec3 col = vec3(.3);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            // p += cnoise(p) * 0.1;\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r += cnoise(reflTex);\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:t}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(r,o)})),addEventListener("mousemove",(function(n){r=n.clientX/window.innerWidth,o=-n.clientY/window.innerHeight+1})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function vN(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new cf).load(e);console.log(t);var r,o,a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        \n        p1 += (cnoise(p1 + sin(u_time)) * 0.1) * (sin(u_time) / 10. + 1.);\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p1, 1.75);\n\n        float total = d2;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        \n\n        vec3 ro = vec3 (0., 3., -4) * .9;\n        ro.yx *= Rot(PI * 0.5);\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        rd.y *= -1.;\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap,-rd).rgb;\n        // vec3 col = vec3(.3);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            // p += cnoise(p) * 0.1;\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            reflTex.r += cnoise(reflTex) * 0.5;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            reflTex.g += cnoise(reflTex) * 0.2;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            reflTex.b += cnoise(reflTex) * 0.2;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:t}}}),i=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Vm((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(r,o)})),addEventListener("mousemove",(function(n){r=n.clientX/window.innerWidth,o=-n.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(n){r=n.changedTouches[0].clientX/window.innerWidth,o=-n.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cN=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (PI) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) * u_time, angle );\n    \n    return radialUv;\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n\n    #define S(a, b, t) smoothstep(a, b, t)\n\n    float DistLine(vec2 p, vec2 a, vec2 b)\n    {\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n        return length(pa - ba * t);\n    }\n\n    float N21(vec2 p)\n    {\n        p = fract(p * vec2(445.23, 789.92));\n        p += dot(p, p + 54.23 );\n        return fract(p.x * p.y);\n    }\n\n    vec2 N22(vec2 p)\n    {\n        float n = N21(p);\n        return vec2(n, N21(p + n));\n    }\n\n    vec2 GetPos(vec2 id, vec2 offset)\n    {\n        vec2 n = N22(id+offset) * u_time;\n        // float x = sin(u_time* n.x);\n        // float y = cos(u_time*n.y);\n        return offset + sin(n) * .4;\n    }\n\n    float Line(vec2 p, vec2 a, vec2 b)\n    {\n        float d = DistLine(p, a, b);\n        float m = S(.03, 0.01, d);\n        float d2 = length(a - b);\n        m *= S(1.2, .8, d2) * .5 + S(.05, .03, abs(d2-.75));\n        return m;\n    }\n\n    float Layer(vec2 uv2)\n    {\n        float m;\n        vec2 gv = fract(uv2) - 0.5;\n        vec2 id = floor(uv2);\n\n        // vec2 p = N22(id) - 0.5;\n\n        vec2 p[9];\n\n        // vec2 p = GetPos(id);\n        // float d = length(gv - p);\n        // m = S(0.1, 0.05, d);\n\n        int i = 0;\n        for(float y=-1.; y <=1.; y++)\n        {\n            for(float x=-1.; x<=1.; x++)\n            {\n                p[i++]= GetPos(id, vec2(x, y));\n            }\n        }\n\n        float t = u_time * 10.;\n\n        for(int i=0; i < 9; i++)\n        {\n            m += Line(gv, p[4], p[i]);\n            \n            vec2 j = (p[i] - gv) * 40.;\n            float sparkle = 1. / dot(j, j);\n\n            m += sparkle * (sin(t+fract(p[i].x) * 10.) * .5 + .5);\n        }\n        m += Line(gv, p[1], p[3]);\n        m += Line(gv, p[1], p[5]);\n        m += Line(gv, p[7], p[3]);\n        m += Line(gv, p[7], p[5]);\n\n        return m;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        \n\n        float an = -u_time * 0.5;\n        float r1 = length(uv2 * 3.5) ;\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 * 1.25 + r1, a );\n\n        float m = 0.;\n        float t = u_time * 0.05;\n        \n        for(float i =0.; i <1.; i+= 1./4.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(10., .1, z);\n            float fade = S(0., 0.5, z) * S(1., 0.8, z);\n            m += Layer(uv2 * size + i * 20.) * fade;\n        }\n\n        vec3 base = sin(t * vec3(.345, .456, .678)) * .4 + .6;\n        vec3 col = m * base;\n        // col += uv2.y * base * 0.2;\n        // col -= uv2.x  * base * 0.2;\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function lN(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:cN,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var sN=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (PI) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) * u_time, angle );\n    \n    return radialUv;\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n\n    #define S(a, b, t) smoothstep(a, b, t)\n\n    float DistLine(vec2 p, vec2 a, vec2 b)\n    {\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n        return length(pa - ba * t);\n    }\n\n    float N21(vec2 p)\n    {\n        p = fract(p * vec2(445.23, 789.92));\n        p += dot(p, p + 54.23 );\n        return fract(p.x * p.y);\n    }\n\n    vec2 N22(vec2 p)\n    {\n        float n = N21(p);\n        return vec2(n, N21(p + n));\n    }\n\n    vec2 GetPos(vec2 id, vec2 offset)\n    {\n        vec2 n = N22(id+offset) * u_time;\n        // float x = sin(u_time* n.x);\n        // float y = cos(u_time*n.y);\n        return offset + sin(n) * .4;\n    }\n\n    float Line(vec2 p, vec2 a, vec2 b)\n    {\n        float d = DistLine(p, a, b);\n        float m = S(.03, 0.01, d);\n        float d2 = length(a - b);\n        m *= S(1.2, .8, d2) * .5 + S(.05, .03, abs(d2-.75));\n        return m;\n    }\n\n    float Layer(vec2 uv2)\n    {\n        float m;\n        vec2 gv = fract(uv2) - 0.5;\n        vec2 id = floor(uv2);\n\n        // vec2 p = N22(id) - 0.5;\n\n        vec2 p[9];\n\n        // vec2 p = GetPos(id);\n        // float d = length(gv - p);\n        // m = S(0.1, 0.05, d);\n\n        int i = 0;\n        for(float y=-1.; y <=1.; y++)\n        {\n            for(float x=-1.; x<=1.; x++)\n            {\n                p[i++]= GetPos(id, vec2(x, y));\n            }\n        }\n\n        float t = u_time * 10.;\n\n        for(int i=0; i < 9; i++)\n        {\n            m += Line(gv, p[4], p[i]);\n            \n            vec2 j = (p[i] - gv) * 40.;\n            float sparkle = 1. / dot(j, j);\n\n            m += sparkle * (sin(t+fract(p[i].x) * 10.) * .5 + .5);\n        }\n        m += Line(gv, p[1], p[3]);\n        m += Line(gv, p[1], p[5]);\n        m += Line(gv, p[7], p[3]);\n        m += Line(gv, p[7], p[5]);\n\n        return m;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        \n        uv2 *= 1.5;\n\n        float an = -u_time * 0.5;\n        float r1 = length(uv2 * 1.75) ;\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.25);\n        uv2 = vec2(0.053/r1 + .95 * .25 + r1, a * 0.15);\n\n        float m = 0.;\n        float t = u_time * 0.05;\n        \n        for(float i =0.; i <1.; i+= 1./4.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(10., .1, z);\n            float fade = S(0., 0.5, z) * S(1., 0.8, z);\n            m += Layer(uv2 * size + i * 20.) * fade;\n        }\n\n        vec3 base = sin(t * vec3(.345, .456, .678)) * .4 + .6;\n        vec3 col = m * base;\n        // col += uv2.y * base * 0.2;\n        // col -= uv2.x  * base * 0.2;\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir},u_mouse:{type:"v2",value:new ir}}});function uN(){var n=(0,Ad.useRef)();return Vm((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{ref:n,material:sN,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function fN(){var n,e,t="./Models/EnvMaps/0/",r=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    \n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(0.);\n        vec2 m = u_mouse.xy;\n        vec2 uv2 = vUv;\n        uv2 -= .5;\n\n        vec3 col = vec3((sin(u_time)/2.) + 0.5, 0.5, 0.);\n\n        float d = length(vUv - abs(u_mouse.xy)) - 0.2;\n        color += (step(0., -d)) * col;\n\n        float glow = 0.005/ d;\n        glow = clamp(glow, 0., 1.);\n        glow = glow * 15. * (sin(u_time)/10. + 0.75);\n\n        color += col * glow ;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)(),v=new Or,c=new Or(-1,-1,0),l=new Or(1,-1,0);new Or(-1,1,0),new Or(1,1,0);(0,Ad.useEffect)((function(){(new Nr).setFromObject(i.current).getSize(v)}),[i.current]),qm((function(n){var e=n.camera;c&&(v.project(e),c.project(e))}));v.x,window.innerWidth,v.y,window.innerHeight,c.x,window.innerWidth,c.y,window.innerHeight,l.x,window.innerWidth,l.y,window.innerHeight;return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function pN(){var n,e,t="./Models/EnvMaps/0/",r=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    \n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(0.);\n        vec2 m = u_mouse.xy;\n        vec2 uv2 = vUv;\n        uv2 += .5;\n\n        vec3 col = vec3((sin(u_time))/2. + 1., 0.3, 0.);\n\n        float n = noise2D(uv2 + u_time) * .5;\n        \n\n        float cir = circle(uv2 - abs(u_mouse.xy), 0.05) * n;\n        float d = length(vUv  - abs(u_mouse.xy) ) - 0.25 ;\n        color = (step(0., -d)) * col * n;\n        // color += cir * col;\n\n        \n\n        float glow = 0.001/ -d * n;\n        float glow2 = 0.01/ d * n;\n        glow = clamp(glow, 0., 1.);\n        glow2 = clamp(glow2, 0., 1.);\n        glow = glow * 15. * (sin(u_time * 1.)/10. + 0.75);\n        glow2 = glow2 * 15. * (sin(u_time * 1.)/10. + 0.75);\n\n        color += col * glow * 2.;\n        color += col * glow2 * 2.;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)(),v=new Or,c=new Or(-1,-1,0),l=new Or(1,-1,0);new Or(-1,1,0),new Or(1,1,0);(0,Ad.useEffect)((function(){(new Nr).setFromObject(i.current).getSize(v)}),[i.current]),qm((function(n){var e=n.camera;c&&(v.project(e),c.project(e))}));v.x,window.innerWidth,v.y,window.innerHeight,c.x,window.innerWidth,c.y,window.innerHeight,l.x,window.innerWidth,l.y,window.innerHeight;return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function dN(){var n,e,t="./Models/EnvMaps/0/",r=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    // float rand(vec2 n) { \n    //     return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    // }\n    \n    // float noise2D(vec2 p){\n    //     vec2 ip = floor(p);\n    //     vec2 u = fract(p);\n    //     u = u*u*(3.0-2.0*u);\n        \n    //     float res = mix(\n    //         mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n    //         mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    //     return res*res;\n    // }\n\n    float glow(vec2 uv2, vec2 m){\n        m = vec2(u_mouse.xy);\n        float n = noise2D(uv2 + u_time) * .5;\n        float d = length(vUv  - abs(u_mouse.xy) ) - 0.25 ;\n        //color = (step(0., -d)) * col * n;\n        //color += cir * col;\n\n        \n        float glow = 0.001/ -d * n;\n        float glow2 = 0.01/ d * n;\n        glow = clamp(glow, 0., 1.);\n        glow2 = clamp(glow2, 0., 1.);\n        glow = glow * 15. * (sin(u_time * 1.)/10. + 0.75);\n        glow2 = glow2 * 15. * (sin(u_time * 1.)/10. + 0.75);\n\n        return glow + glow2;\n    }\n\n    \n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n\n        vec3 colx = vec3((sin(u_time))/2. + 1., 0.3, 0.);\n\n        float x = 0.;\n        float t = u_time * 0.05;\n        \n        for(float i =0.; i <1.; i+= 1./4.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(10., .5, z);\n            float fade = S(0., 0.5, z) * S(1., 0.8, z);\n            x += glow(uv2 * size + i * 20., vec2(u_mouse.xy)) * fade;\n        }\n        \n        vec3 base = sin(t * vec3(.345, .456, .678)) * .4 + .6;\n        vec3 col = x * base;\n        col += uv2.y * base * 0.2;\n        col -= uv2.x  * base * 0.2;\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)(),v=new Or,c=new Or(-1,-1,0),l=new Or(1,-1,0);new Or(-1,1,0),new Or(1,1,0);(0,Ad.useEffect)((function(){(new Nr).setFromObject(i.current).getSize(v)}),[i.current]),qm((function(n){var e=n.camera;c&&(v.project(e),c.project(e))}));v.x,window.innerWidth,v.y,window.innerHeight,c.x,window.innerWidth,c.y,window.innerHeight,l.x,window.innerWidth,l.y,window.innerHeight;return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function mN(){var n,e,t="./Models/EnvMaps/0/",r=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float glow(vec2 uv2, vec2 m){\n        m = vec2(u_mouse.xy);\n        float n = noise2D(uv2 + u_time) * .5;\n        float d = length(vUv  - abs(u_mouse.xy) ) - 0.25 ;\n        //color = (step(0., -d)) * col * n;\n        //color += cir * col;\n\n        \n        float glow = 0.001/ -d * n;\n        float glow2 = 0.0001/ d * n;\n        glow = clamp(glow, 0., 1.);\n        glow2 = clamp(glow2, 0., 1.);\n        glow = glow * 15. * (sin(u_time * 1.)/10. + 0.75);\n        glow2 = glow2 * 15. * (sin(u_time * 1.)/10. + 0.75);\n\n        return glow + glow2;\n    }\n\n    #define S(a, b, t) smoothstep(a, b, t)\n\n    float DistLine(vec2 p, vec2 a, vec2 b)\n    {\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n        return length(pa - ba * t);\n    }\n\n    float N21(vec2 p)\n    {\n        p = fract(p * vec2(445.23, 789.92));\n        p += dot(p, p + 54.23 );\n        return fract(p.x * p.y);\n    }\n\n    vec2 N22(vec2 p)\n    {\n        float n = N21(p);\n        return vec2(n, N21(p + n));\n    }\n\n    vec2 GetPos(vec2 id, vec2 offset)\n    {\n        vec2 n = N22(id+offset) * u_time;\n        // float x = sin(u_time* n.x);\n        // float y = cos(u_time*n.y);\n        return offset + sin(n) * .4;\n    }\n\n    float Line(vec2 p, vec2 a, vec2 b)\n    {\n        float d = DistLine(p, a, b);\n        float m = S(.03, 0.01, d);\n        float d2 = length(a - b);\n        m *= S(1.2, .8, d2) * .5 + S(.05, .03, abs(d2-.75));\n        return m;\n    }\n\n    float Layer(vec2 uv2)\n    {\n        float m;\n        vec2 gv = fract(uv2) - 0.5;\n        vec2 id = floor(uv2);\n\n        // vec2 p = N22(id) - 0.5;\n\n        vec2 p[9];\n\n        // vec2 p = GetPos(id);\n        // float d = length(gv - p);\n        // m = S(0.1, 0.05, d);\n\n        int i = 0;\n        for(float y=-1.; y <=1.; y++)\n        {\n            for(float x=-1.; x<=1.; x++)\n            {\n                p[i++]= GetPos(id, vec2(x, y));\n            }\n        }\n\n        float t = u_time * 10.;\n\n        for(int i=0; i < 9; i++)\n        {\n            // m += Line(gv, p[4], p[i]);\n            \n            vec2 j = (p[i] - gv) * 40.;\n            float sparkle = 1. / dot(j, j);\n\n            m += glow(uv2, vec2(u_mouse.xy));\n            m += sparkle * (sin(t+fract(p[i].x) * 10.) * .5 + .5);\n        }\n        return m;\n    }\n\n    \n\n    \n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n\n        vec3 colx = vec3((sin(u_time))/2. + 1., 0.3, 0.);\n\n        float x = 0.;\n        float t = u_time * 0.05;\n        \n        for(float i =0.; i <1.; i+= 1./4.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(10., .5, z);\n            float fade = S(0., 0.5, z) * S(1., 0.8, z);\n            x += Layer(uv2 * size + i * 20.) * fade;\n        }\n        \n        vec3 base = sin(t * vec3(.345, .456, .678)) * .4 + .6;\n        vec3 col = x * base;\n        col += uv2.y * base * 0.2;\n        col -= uv2.x  * base * 0.2;\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)(),v=new Or,c=new Or(-1,-1,0),l=new Or(1,-1,0);new Or(-1,1,0),new Or(1,1,0);(0,Ad.useEffect)((function(){(new Nr).setFromObject(i.current).getSize(v)}),[i.current]),qm((function(n){var e=n.camera;c&&(v.project(e),c.project(e))}));v.x,window.innerWidth,v.y,window.innerHeight,c.x,window.innerWidth,c.y,window.innerHeight,l.x,window.innerWidth,l.y,window.innerHeight;return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hN=["children","eps","style","className","prepend","center","fullscreen","portal","distanceFactor","sprite","transform","occlude","onOcclude","zIndexRange","calculatePosition","as","wrapperClass","pointerEvents"],xN=new Or,gN=new Or,yN=new Or;function bN(n,e,t){var r=xN.setFromMatrixPosition(n.matrixWorld);r.project(e);var o=t.width/2,a=t.height/2;return[r.x*o+o,-r.y*a+a]}var _N=function(n){return Math.abs(n)<1e-10?0:n};function UN(n,e){for(var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",r="matrix3d(",o=0;16!==o;o++)r+=_N(e[o]*n.elements[o])+(15!==o?",":")");return t+r}var wN,SN=(wN=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],function(n){return UN(n,wN)}),kN=function(n,e){return UN(n,function(n){return[1/n,1/n,1/n,1,-1/n,-1/n,-1/n,-1,1/n,1/n,1/n,1,1,1,1,1]}(e),"translate(-50%,-50%)")},MN=Ad.forwardRef((function(n,e){var t=n.children,o=n.eps,a=void 0===o?.001:o,i=n.style,v=n.className,l=n.prepend,s=n.center,f=n.fullscreen,p=n.portal,d=n.distanceFactor,m=n.sprite,h=void 0!==m&&m,x=n.transform,g=void 0!==x&&x,y=n.occlude,b=n.onOcclude,_=n.zIndexRange,U=void 0===_?[16777271,0]:_,w=n.calculatePosition,S=void 0===w?bN:w,k=n.as,M=void 0===k?"div":k,z=n.wrapperClass,C=n.pointerEvents,T=void 0===C?"auto":C,R=r(n,hN),D=qm(),P=D.gl,j=D.camera,F=D.scene,E=D.size,I=D.raycaster,O=D.events,L=c(Ad.useState((function(){return document.createElement(M)})),1)[0],A=Ad.useRef(),N=Ad.useRef(null),G=Ad.useRef(0),B=Ad.useRef([0,0]),q=Ad.useRef(null),V=Ad.useRef(null),W=(null==p?void 0:p.current)||O.connected||P.domElement.parentNode;Ad.useLayoutEffect((function(){if(N.current){var n=A.current=Oh.s(L);if(F.updateMatrixWorld(),g)L.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{var e=S(N.current,j,E);L.style.cssText="position:absolute;top:0;left:0;transform:translate3d(".concat(e[0],"px,").concat(e[1],"px,0);transform-origin:0 0;")}return W&&(l?W.prepend(L):W.appendChild(L)),function(){W&&W.removeChild(L),n.unmount()}}}),[W,g]),Ad.useLayoutEffect((function(){z&&(L.className=z)}),[z]);var H=Ad.useMemo((function(){return g?{position:"absolute",top:0,left:0,width:E.width,height:E.height,transformStyle:"preserve-3d",pointerEvents:"none"}:u(u({position:"absolute",transform:s?"translate3d(-50%,-50%,0)":"none"},f&&{top:-E.height/2,left:-E.width/2,width:E.width,height:E.height}),i)}),[i,s,f,E,g]),X=Ad.useMemo((function(){return{position:"absolute",pointerEvents:T}}),[T]);Ad.useLayoutEffect((function(){var n,r;g?null==(n=A.current)||n.render(Ad.createElement("div",{ref:q,style:H},Ad.createElement("div",{ref:V,style:X},Ad.createElement("div",{ref:e,className:v,style:i,children:t})))):null==(r=A.current)||r.render(Ad.createElement("div",{ref:e,style:H,className:v,children:t}))}));var Y=Ad.useRef(!0);return Vm((function(){if(N.current){j.updateMatrixWorld(),N.current.updateWorldMatrix(!0,!1);var n=g?B.current:S(N.current,j,E);if(g||Math.abs(G.current-j.zoom)>a||Math.abs(B.current[0]-n[0])>a||Math.abs(B.current[1]-n[1])>a){var e=function(n,e){var t=xN.setFromMatrixPosition(n.matrixWorld),r=gN.setFromMatrixPosition(e.matrixWorld),o=t.sub(r),a=e.getWorldDirection(yN);return o.angleTo(a)>Math.PI/2}(N.current,j),t=!1;"boolean"===typeof y?!0===y&&(t=[F]):Array.isArray(y)&&(t=y.map((function(n){return n.current})));var r=Y.current;if(t){var o=function(n,e,t,r){var o=xN.setFromMatrixPosition(n.matrixWorld),a=o.clone();a.project(e),t.setFromCamera(a,e);var i=t.intersectObjects(r,!0);if(i.length){var v=i[0].distance;return o.distanceTo(t.ray.origin)<v}return!0}(N.current,j,I,t);Y.current=o&&!e}else Y.current=!e;if(r!==Y.current&&(b?b(!Y.current):L.style.display=Y.current?"block":"none"),L.style.zIndex="".concat(function(n,e,t){if(e instanceof Ha||e instanceof hi){var r=xN.setFromMatrixPosition(n.matrixWorld),o=gN.setFromMatrixPosition(e.matrixWorld),a=r.distanceTo(o),i=(t[1]-t[0])/(e.far-e.near),v=t[1]-i*e.far;return Math.round(i*a+v)}}(N.current,j,U)),g){var i=E.width/2,v=E.height/2,c=j.projectionMatrix.elements[5]*v,l=j.isOrthographicCamera,s=j.top,u=j.left,f=j.bottom,p=j.right,m=SN(j.matrixWorldInverse),x=l?"scale(".concat(c,")translate(").concat(_N(-(p+u)/2),"px,").concat(_N((s+f)/2),"px)"):"translateZ(".concat(c,"px)"),_=N.current.matrixWorld;h&&((_=j.matrixWorldInverse.clone().transpose().copyPosition(_).scale(N.current.scale)).elements[3]=_.elements[7]=_.elements[11]=0,_.elements[15]=1),L.style.width=E.width+"px",L.style.height=E.height+"px",L.style.perspective=l?"":"".concat(c,"px"),q.current&&V.current&&(q.current.style.transform="".concat(x).concat(m,"translate(").concat(i,"px,").concat(v,"px)"),V.current.style.transform=kN(_,1/((d||10)/400)))}else{var w=void 0===d?1:function(n,e){if(e instanceof hi)return e.zoom;if(e instanceof Ha){var t=xN.setFromMatrixPosition(n.matrixWorld),r=gN.setFromMatrixPosition(e.matrixWorld),o=e.fov*Math.PI/180,a=t.distanceTo(r);return 1/(2*Math.tan(o/2)*a)}return 1}(N.current,j)*d;L.style.transform="translate3d(".concat(n[0],"px,").concat(n[1],"px,0) scale(").concat(w,")")}B.current=n,G.current=j.zoom}}})),Ad.createElement("group",ih({},R,{ref:N}))}));function zN(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new cf).load(e),r=Vh((function(n){return n.currentShader}));console.log(r);var o=Vh((function(n){return n.setSongOn})),a=Vh((function(n){return n.startSong})),i=Vh((function(n){return n.setSongOff})),v=null,l=null;qm((function(n){v=n.camera,l=n.gl}));var s=c((0,Ad.useState)(!1),2),u=s[0],f=s[1],p=l.capabilities.isWebGL2?xe:pe,d=new Qf,m=(0,Ad.useRef)(),h=(0,Ad.useRef)(),x=(0,Ad.useRef)();x.current=new np(d),v&&v.add(d);var g,y,b=new Nf,_=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    uniform sampler2D u_audio;\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(.0, 0., 0.);\n        vec3 bckgdcl = vec3(0.825, 0.5, 0.6);\n        vec2 uv2 = vUv;\n        // uv2 -= .5;\n\n        float f = texture2D(u_audio, vec2(vUv.x, 0.)).r;\n        f = clamp(f, 0.1, 0.9);\n        float i = step( uv2.y, f ) * step( f - 0.0125, uv2.y );\n        \n        vec3 col = mix(color, bckgdcl, i);\n\n        color += col.g * i;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:t},u_audio:{value:h.current}}}),U=(0,Ad.useRef)();Vm((function(n){var e=n.clock;m.current&&m.current.getFrequencyData(),U.current.material.uniforms.u_time.value=e.elapsedTime,U.current.material.uniforms.u_mouse.value=new ir(g,y),U.current.material.uniforms.u_audio.value&&(U.current.material.uniforms.u_audio.value.needsUpdate=!0),d.needsUpdate=!0})),addEventListener("mousemove",(function(n){g=n.clientX/window.innerWidth,y=-n.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(n){g=n.changedTouches[0].clientX/window.innerWidth,y=-n.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1});return(0,Yh.jsxs)(Yh.Fragment,{children:[!u&&(0,Yh.jsx)(MN,{children:(0,Yh.jsx)("div",{className:"play",children:(0,Yh.jsx)("button",{onClick:function(){b.load("./Audio/new-adventure-matrika.ogg",(function(n){x.current.setBuffer(n),x.current.setLoop(!1),x.current.setVolume(.5),console.log(x.current),x.current.play(),m.current=new ip(x.current,128),h.current=new ml(m.current.data,64,1,p),x.current.isPlaying&&(console.log("playing"),f(!0),o(),a()),x.current.isPlaying||(console.log("ended"),f(!1),i())}))},style:{cursor:"pointer",color:"white",alignItems:"center",display:"inline-flex",justifyContent:"center",position:"absolute",left:"50%",top:"50%",transform:"translate(-50%, -50%)",backgroundColor:"#00000000",padding:"10px"},children:"Play"})})}),(0,Yh.jsx)("mesh",{dispose:null,ref:U,material:_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})]})}function CN(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new cf).load(e),r=Vh((function(n){return n.currentShader}));console.log(r);var o=Vh((function(n){return n.setSongOn})),a=Vh((function(n){return n.startSong})),i=Vh((function(n){return n.setSongOff})),v=null,l=null;qm((function(n){v=n.camera,l=n.gl}));var s=c((0,Ad.useState)(!1),2),u=s[0],f=s[1],p=l.capabilities.isWebGL2?xe:pe,d=new Qf,m=(0,Ad.useRef)(),h=(0,Ad.useRef)(),x=(0,Ad.useRef)();x.current=new np(d),v&&v.add(d);var g,y,b=new Nf,_=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    uniform sampler2D u_audio;\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float glow(vec2 uv2, vec2 m){\n        m = vec2(u_mouse.xy);\n        float f = texture2D(u_audio, m * 0.5).r;\n        float n = (noise2D(vUv + u_time) * .5 + f ) * 0.5;\n        float n2 = noise2D(vec2(uv2.x * f, uv2.y - f) ) * 0.125;\n        float d = length((vUv + n2) - abs(u_mouse.xy) ) - 0.25 ;\n        //color = (step(0., -d)) * col * n;\n        //color += cir * col;\n\n        \n        float glow = 0.002/ -d * n ;\n        float glow2 = 0.002/ d * n ;\n        glow = clamp(glow, 0., 1.);\n        glow2 = clamp(glow2, 0., 1.);\n        glow = glow * 15. * (sin(u_time * 1.)/10. + 0.75);\n        glow2 = glow2 * 15. * (sin(u_time * 1.)/10. + 0.75);\n\n        return glow + glow2;\n    }\n\n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(.0, 0., 0.);\n        vec3 bckgdcl = vec3(0.825, 0.5, 0.6);\n        vec2 uv2 = vUv;\n        // uv2 -= .5;\n\n        uv2 = Rot(uv2, u_time * 0.25);\n\n        float f = texture2D(u_audio, vec2(vUv.x* .75, 0.)).r;\n        // f = clamp(f, 0.1, 0.9);\n\n        float x = 0.;\n        float t = u_time * 0.05;\n        \n        for(float i =0.; i <1.; i+= 1./4.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(10., .5, z);\n            float fade = S(0., 0.5, z) * S(1., 0.8, z);\n            x += glow(uv2 * size + i * 20., vec2(u_mouse.xy)) * fade;\n        }\n        \n        vec3 base = sin(t * vec3(.345, .456, .678)) * .4 + .6;\n        vec3 col = x * base;\n        col += uv2.y * base * 0.2 ;\n        col -= uv2.x  * base * 0.2;\n        color += col;\n\n        \n        float i = step( uv2.y, f ) * step( f - 0.0125, uv2.y );\n        \n        // vec3 col = mix(color, bckgdcl, i);\n\n        // color += col.g * i;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:t},u_audio:{value:h.current}}}),U=(0,Ad.useRef)();Vm((function(n){var e=n.clock;m.current&&m.current.getFrequencyData(),U.current.material.uniforms.u_time.value=e.elapsedTime,U.current.material.uniforms.u_mouse.value=new ir(g,y),U.current.material.uniforms.u_audio.value&&(U.current.material.uniforms.u_audio.value.needsUpdate=!0),d.needsUpdate=!0})),addEventListener("mousemove",(function(n){g=n.clientX/window.innerWidth,y=-n.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(n){g=n.changedTouches[0].clientX/window.innerWidth,y=-n.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1});return(0,Yh.jsxs)(Yh.Fragment,{children:[!u&&(0,Yh.jsx)(MN,{children:(0,Yh.jsx)("div",{className:"play",children:(0,Yh.jsx)("button",{onClick:function(){b.load("./Audio/polaroid-arston.ogg",(function(n){x.current.setBuffer(n),x.current.setLoop(!1),x.current.setVolume(.5),console.log(x.current),x.current.play(),m.current=new ip(x.current,128),h.current=new ml(m.current.data,64,1,p),x.current.isPlaying&&(console.log("playing"),f(!0),o(),a()),x.current.isPlaying||(console.log("ended"),x.current.pause(),f(!1),i())}))},style:{cursor:"pointer",color:"white",alignItems:"center",display:"inline-flex",justifyContent:"center",position:"absolute",left:"50%",top:"50%",transform:"translate(-50%, -50%)",backgroundColor:"#00000000",padding:"10px"},children:"Play"})})}),(0,Yh.jsx)("mesh",{dispose:null,ref:U,material:_,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})]})}function TN(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new cf).load(e),r=Vh((function(n){return n.currentShader}));console.log(r);var o=Vh((function(n){return n.setSongOn})),a=Vh((function(n){return n.startSong})),i=(Vh((function(n){return n.setSongOff})),null),v=null;qm((function(n){i=n.camera,v=n.gl}));var l=c((0,Ad.useState)(!1),2),s=l[0],u=l[1],f=v.capabilities.isWebGL2?xe:pe,p=new Qf,d=(0,Ad.useRef)(),m=(0,Ad.useRef)(),h=(0,Ad.useRef)();h.current=new np(p),i&&i.add(p),(new Nf).load("./Audio/new-adventure-matrika.ogg",(function(n){h.current.setBuffer(n),h.current.setLoop(!1),h.current.setVolume(.5)}));var x,g,y=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    uniform sampler2D u_audio;\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float blob(vec2 vUv, float x, float y){\n        vec2 audioVal;\n        audioVal.x = texture2D(u_audio, vec2(vUv.x / 2., 0.)).r;\n        audioVal.y = texture2D(u_audio, vec2(vUv.y / 2., 0.)).r;\n        vUv *= y;\n        vec2 pos = vec2(y/2.) - vUv;\n        float r = length(pos) * 2.0;\n        float a = atan(pos.y, pos.x);\n        float f = abs(cos(a * 13. * audioVal.y) * sin(a * (x))) * .02  + .25 * audioVal.y;\n        return 1. - smoothstep(f, f+0.01, r);\n    }\n\n    float blobOutline(vec2 vUv, float x, float y){\n        vec2 audioVal;\n        audioVal.x = texture2D(u_audio, vec2(vUv.x / -2., 0.)).r;\n        audioVal.y = texture2D(u_audio, vec2(vUv.y / 2., 0.)).r;\n        vUv *= y;\n        float noise = (noise2D(vUv + audioVal)) * 15. * audioVal.x;\n        // x += noise;\n        vec2 pos = vec2(y/2.) - vUv;\n        float r = length(pos ) * 2.0;\n        float a = atan(pos.y , pos.x );\n        float f = abs(cos(a * 13. * audioVal.x ) * sin(a * (x))) * .02  + .25 * audioVal.x;\n        float m = 1. - smoothstep(f, f+0.01, r);\n        float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n        return n - m;\n    }\n\n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(.0, 0., 0.);\n        vec3 bckgdcl = vec3(0.825, 0.5, 0.6);\n        vec2 uv2 = vUv;\n        // uv2 -= .5;\n\n        float f = texture2D(u_audio, vec2(uv2.x * 0.5, 0.)).r;\n        // f = clamp(f * 2., 0.1, 1.1)* 2.;\n        // float noise = noise2D(uv2 * 0.5 * sin(u_time * f)) ;\n        float y = blob(uv2  , 10., 0.5);\n        float x = blobOutline(uv2, 10., 0.45);\n        color += vec3(y + x);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:t},u_audio:{value:m.current}}}),b=(0,Ad.useRef)();Vm((function(n){var e=n.clock;d.current&&d.current.getFrequencyData(),b.current.material.uniforms.u_time.value=e.elapsedTime,b.current.material.uniforms.u_mouse.value=new ir(x,g),b.current.material.uniforms.u_audio.value&&(b.current.material.uniforms.u_audio.value.needsUpdate=!0),p.needsUpdate=!0})),addEventListener("mousemove",(function(n){x=n.clientX/window.innerWidth,g=-n.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(n){x=n.changedTouches[0].clientX/window.innerWidth,g=-n.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1});return(0,Yh.jsxs)(Yh.Fragment,{children:[!s&&(0,Yh.jsx)(MN,{children:(0,Yh.jsx)("div",{className:"play",children:(0,Yh.jsx)("button",{onClick:function(){h.current.play(),d.current=new ip(h.current,128),m.current=new ml(d.current.data,64,1,f),u(!0),o(),a()},style:{cursor:"pointer",color:"white",alignItems:"center",display:"inline-flex",justifyContent:"center",position:"absolute",left:"50%",top:"50%",transform:"translate(-50%, -50%)",backgroundColor:"#000000",padding:"10px"},children:"Play"})})}),(0,Yh.jsx)("mesh",{dispose:null,ref:b,material:y,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})]})}function RN(){var n,e,t="./Models/EnvMaps/0/",r=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //simplex noise book of shaders\n    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n    vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n    vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n    \n    float snoise(vec2 v) {\n        const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                            0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                            -0.577350269189626,  // -1.0 + 2.0 * C.x\n                            0.024390243902439); // 1.0 / 41.0\n        vec2 i  = floor(v + dot(v, C.yy) );\n        vec2 x0 = v -   i + dot(i, C.xx);\n        vec2 i1;\n        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n        vec4 x12 = x0.xyxy + C.xxzz;\n        x12.xy -= i1;\n        i = mod289(i); // Avoid truncation effects in permutation\n        vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n            + i.x + vec3(0.0, i1.x, 1.0 ));\n    \n        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n        m = m*m ;\n        m = m*m ;\n        vec3 x = 2.0 * fract(p * C.www) - 1.0;\n        vec3 h = abs(x) - 0.5;\n        vec3 ox = floor(x + 0.5);\n        vec3 a0 = x - ox;\n        m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n        vec3 g;\n        g.x  = a0.x  * x0.x  + h.x  * x0.y;\n        g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n        return 130.0 * dot(m, g);\n    }\n\n    float glow(vec2 uv2, float d){\n        float dist = 1.0/length(uv2);\n        dist *= 0.2;\n        dist = pow(dist, 0.8);\n        d *= dist;\n        return d;\n    }\n\n    float plot(vec2 vUv,float p){\n        // float x=snoise(vUv+u_time*.25);\n        // p=x * .05 ;\n        return smoothstep(p + 0.015,p,vUv.y)-\n        smoothstep(p,p-(0.015),vUv.y);\n    }\n\n    \n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 *= 2.;\n        uv2 -= 1.;\n\n        // float y = vUv.x;\n        vec2 m = u_mouse;\n        float n = snoise(uv2 - u_mouse) * 4.0 ;\n        float y = sin((uv2.x * n) + u_time) / 10.0;\n        float p1 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.1), y));\n        float p2 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.2), y));\n        float p3 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.3), y));\n        float p4 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.4), y));\n        float p5 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.5), y));\n        float p6 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.0), y));\n        float p7 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.1), y));\n        float p8 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.2), y));\n        float p9 =  glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.3), y));\n        float p10 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.4), y));\n        float p11 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.5), y));\n        float p12 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.6), y));\n        float p13 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.7), y));\n        float p14 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.8), y));\n        float p15 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 0.9), y));\n        float p16 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 1.0), y));\n        float p17 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.6), y));\n        float p18 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.7), y));\n        float p19 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.8), y));\n        float p20 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 0.9), y));\n        float p21 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 1.0), y));\n        float p22 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y - 1.1), y));\n        float p23 = glow(uv2 + n, plot(vec2(uv2.x, uv2.y + 1.1), y));\n        color += p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9 + p10 + p11 + p12 + p13 + p14 + p15 + p16 + p17 + p18 + p19 + p20 + p21 + p22 + p23;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)(),v=new Or,c=new Or(-1,-1,0),l=new Or(1,-1,0);new Or(-1,1,0),new Or(1,1,0);(0,Ad.useEffect)((function(){(new Nr).setFromObject(i.current).getSize(v)}),[i.current]),qm((function(n){var e=n.camera;c&&(v.project(e),c.project(e))}));v.x,window.innerWidth,v.y,window.innerHeight,c.x,window.innerWidth,c.y,window.innerHeight,l.x,window.innerWidth,l.y,window.innerHeight;return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function DN(){var n,e,t="./Models/EnvMaps/0/",r=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define NUMBER_OF_STEPS 32;\n    #define MIN_HIT_DISTANCE 0.001;\n    #define MAX_TRACE_DISTANCE 1000;\n\n    float distance_from_sphere(vec3 point, vec3 center, float radius)\n    {\n        return length(point - center) - radius;\n    }\n\n    float draw_scene(vec3 p)\n    {\n\n        //distortion\n        float displacement = sin((5.0 + cos(u_time)) * p.x) * sin((5.0 + sin(u_time)) * p.y) * sin((5.0 + cos(u_time)) * p.z) * 0.25;\n\n        float sphere = distance_from_sphere(p, vec3(0.), 1.);\n        sphere += displacement;\n\n        float total_map;\n\n        total_map += sphere;\n\n        return total_map;\n    }\n\n    vec3 calculate_normal(vec3 p)\n    {\n        vec3 small_step = vec3(0.001, 0., 0.);\n\n        float gradient_x = draw_scene(p + small_step.xyy) - draw_scene(p - small_step.xyy);\n        float gradient_y = draw_scene(p + small_step.yxy) - draw_scene(p - small_step.yxy);\n        float gradient_z = draw_scene(p + small_step.yyx) - draw_scene(p - small_step.yyx);\n\n        vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n        return normalize(normal);\n    }\n\n    vec3 ray_march(vec3 ray_origin, vec3 ray_direction)\n    {\n        float total_distance_traveled = 0.;\n\n        for(int i = 0; i < 1000; ++i)\n        {\n            vec3 current_position = ray_origin + total_distance_traveled * ray_direction;\n\n            float distance_to_closest = draw_scene(current_position);\n\n            if(distance_to_closest < 0.001)\n            {\n                // return vec3(1., 0., 0.);\n                //normal range is between -1 to 1 needs to be remapped to be 0 to 1\n                vec3 normal = calculate_normal(current_position);\n                // return normal * 0.5 + 0.5;\n\n                //diffuse lighting\n                vec3 light_position = vec3(2., -5., 3.);\n                vec3 direction_to_light = normalize(current_position - light_position);\n                float diffuse_intesity = max(0., dot(normal, direction_to_light));\n\n                return vec3(1. + cos(u_time), 0.2 + sin(u_time), 0.4) * diffuse_intesity;\n            }\n\n            if(total_distance_traveled > 1000.)\n            {\n                break;\n            }\n\n            total_distance_traveled += distance_to_closest;\n        }\n\n        return vec3(0.);\n    }\n    \n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 camera_position = vec3(0., 0., -5.);\n        vec3 ray_origin = camera_position;\n        vec3 ray_direction = vec3(uv2, 1.);\n\n        vec3 ray_march_scene = ray_march(ray_origin, ray_direction);\n\n        color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function PN(){var n,e,t="./Models/EnvMaps/0/",r=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float smoothDifferenceSDF(float shape1, float shape2, float value) \n    {\n        float h = clamp(0.5 - 0.5 * (shape2 + shape1) / value, 0., 1.);\n        return mix(shape2, -shape1, h) + value * h * (1. - h);\n    }\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float sdf_sphere(vec3 point, float size)\n    {\n        return length(point) - size;\n    }\n\n    float sdf_box(vec3 point, vec3 box_size)\n    {\n        point.xy *= Rotate(u_time * 0.5);\n        point.yz *= Rotate(u_time * 0.5); \n        vec3 q = abs(point) - box_size;\n        return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.);\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point));\n        float displacement = sin((noise + sin(u_time) * 3.) * point.x) * sin((noise + sin(u_time)) * point.y) * cos((noise + cos(u_time)) * point.z) * 0.25;\n\n        float box = sdf_box(point, vec3(1.));\n        box += displacement;\n\n        float sphere = sdf_sphere(point, 1.2);\n        sphere += displacement;\n\n        float new_shape = smoothDifferenceSDF(sphere, box, 0.15);\n\n        float total_map;\n\n        total_map += new_shape;\n\n        return total_map;\n    }\n\n    vec3 calculate_normal(vec3 point)\n    {\n        vec3 small_step = vec3(0.0001, 0., 0.);\n        float gradient_x = draw_scene(point + small_step.xyy) - draw_scene(point - small_step.xyy);\n        float gradient_y = draw_scene(point + small_step.yxy) - draw_scene(point - small_step.yxy);\n        float gradient_z = draw_scene(point + small_step.yyx) - draw_scene(point - small_step.yyx);\n        vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n        return normalize(normal);\n    }\n\n    vec3 ray_march(vec3 ray_origin, vec3 ray_direction)\n    {\n        float total_distance = 0.;\n        for(int i = 0; i < 1000; ++i){\n            vec3 current_position = ray_origin + total_distance * ray_direction;\n            float distance_to_closest = draw_scene(current_position);\n\n            if(distance_to_closest < 0.0001)\n            {\n                //normal\n                vec3 normal = calculate_normal(current_position);\n                //return normal * 0.5 + 0.5;\n\n                //diffuse lighting\n                vec3 light_position = vec3(2., -5., 3.);\n                vec3 direction_to_light = normalize(current_position - light_position);\n                float diffuse_intesity = max(0., dot(normal, direction_to_light));\n\n                return vec3(1., 0.2, 0.5) * diffuse_intesity;\n            }\n\n            if(total_distance > 1000.)\n            {\n                break;\n            }\n\n            total_distance += distance_to_closest;\n        }\n\n        return vec3(0.);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 color = vec3(0.);\n\n        vec3 camera_position = vec3(0., 0., -5.);\n        vec3 ray_origin = camera_position;\n        vec3 ray_direction = vec3(uv2, 1.);\n\n        vec3 ray_march_scene = ray_march(ray_origin, ray_direction);\n\n        color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function jN(){var n,e,t="./Models/EnvMaps/0/",r=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float smoothDifferenceSDF(float shape1, float shape2, float value) \n    {\n        float h = clamp(0.5 - 0.5 * (shape2 + shape1) / value, 0., 1.);\n        return mix(shape2, -shape1, h) + value * h * (1. - h);\n    }\n\n    float smoothUnion( float shape1, float shape2, float value)\n    {\n        float h = clamp( 0.5 + 0.5 * (shape2 - shape1)/value, 0., 1.);\n        return mix(shape2, shape1, h) - value * h * (1. - h);\n    }\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float sdf_box(vec3 point, vec3 box_size)\n    {\n        point.xy *= Rotate(u_time * 0.5);\n        point.yz *= Rotate(u_time * 0.5); \n        vec3 q = abs(point) - box_size;\n        return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.);\n    }\n\n    float sdf_sphere(vec3 point, float radius)\n    {\n        point.xy *= Rotate(u_time * 0.5);\n        point.yz *= Rotate(u_time * 0.5); \n        return length(point) - radius;\n    }\n\n    float sdf_cone(vec3 p, vec2 c, float h)\n    {\n        p.yz *= Rotate(PI * 0.5);\n        p.xy *= Rotate(u_time * 0.5);\n        p.yz *= Rotate(u_time * 0.5); \n        vec2 q = h*vec2(c.x/c.y,-1.0);\n        vec2 w = vec2( length(p.xz), p.y );\n        vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n        vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n        float k = sign( q.y );\n        float d = min(dot( a, a ),dot(b, b));\n        float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n        return sqrt(d)*sign(s);\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point)) * 5.;\n        float displacement = sin((noise + sin(u_time) * 3.) * point.x) * sin((noise + sin(u_time)) * point.y) * cos((noise + cos(u_time) * 5.) * point.z) * 0.25;\n\n        float sphere = sdf_sphere(point, 0.75);\n        // sphere += displacement;\n\n        float box = sdf_box(point, vec3(0.5));\n        // box += displacement;\n\n        float box2 = sdf_box(point , vec3(1.));\n\n        float cone = sdf_cone(point, vec2(0.05), .5);\n\n        float total_map = box;\n        total_map = smoothUnion(sphere, total_map, 0.15);\n        total_map += displacement;\n        // total_map = smoothUnion(cone, total_map, 0.15);\n\n        return total_map;\n    }\n\n    vec3 calculate_normal(vec3 point)\n    {\n        vec3 small_step = vec3(0.0001, 0., 0.);\n        float grad_x = draw_scene(point + small_step.xyy) - draw_scene(point - small_step.xyy);\n        float grad_y = draw_scene(point + small_step.yxy) - draw_scene(point - small_step.yxy);\n        float grad_z = draw_scene(point + small_step.yyx) - draw_scene(point - small_step.yyx);\n        vec3 normal = vec3(grad_x, grad_y, grad_z);\n        return normalize(normal);\n    }\n\n    vec3 ray_march(vec3 ray_origin, vec3 ray_direction)\n    {\n        float total_distance = 0.;\n        for(int i = 0; i < 1000; ++i)\n        {\n            vec3 current_pos = ray_origin + total_distance * ray_direction;\n            float distance_to_closest = draw_scene(current_pos);\n\n            if(distance_to_closest < 0.0001)\n            {\n                //normal\n                vec3 normal = calculate_normal(current_pos);\n\n                //light\n                vec3 light_pos = vec3(2., -5., 3.);\n                vec3 dir_to_light = normalize(current_pos - light_pos);\n                float light_intensity = max(0., dot(normal, dir_to_light));\n\n                return vec3(1., 0.2 * sin(u_time), 0.5 * sin(u_time)) * light_intensity;\n            }\n\n            if(total_distance > 1000.)\n            {\n                break;\n            }\n\n            total_distance += distance_to_closest;\n        }\n\n        return vec3(0.);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -3.);\n        vec3 ray_origin = cam_pos;\n        vec3 ray_direction = vec3(uv2, 1.);\n\n        vec3 ray_march_scene = ray_march(ray_origin, ray_direction);\n\n        color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function FN(){var n,e,t="./Models/EnvMaps/0/",r=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float smoothDifferenceSDF(float shape1, float shape2, float value) \n    {\n        float h = clamp(0.5 - 0.5 * (shape2 + shape1) / value, 0., 1.);\n        return mix(shape2, -shape1, h) + value * h * (1. - h);\n    }\n\n    float smoothUnion( float shape1, float shape2, float value)\n    {\n        float h = clamp( 0.5 + 0.5 * (shape2 - shape1)/value, 0., 1.);\n        return mix(shape2, shape1, h) - value * h * (1. - h);\n    }\n\n    float smoothIntersection(float shape1, float shape2, float value)\n    {\n        float h = clamp(0.5 - 0.5 * (shape2 - shape1)/ value, 0., 1.);\n        return mix(shape2, shape1, h) + value * h * (1. - h);\n    }\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float sdf_box(vec3 point, vec3 box_size)\n    {\n        point.xy *= Rotate(u_time * 0.5);\n        point.yz *= Rotate(u_time * 0.5); \n        vec3 q = abs(point) - box_size;\n        return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.);\n    }\n\n    float sdf_sphere(vec3 point, float radius)\n    {\n        point.xy *= Rotate(u_time * 0.5);\n        point.yz *= Rotate(u_time * 0.5); \n        return length(point) - radius;\n    }\n\n    float sdf_cone(vec3 p, vec2 c, float h)\n    {\n        p.yz *= Rotate(PI * 0.5);\n        p.xy *= Rotate(u_time * 0.5);\n        p.yz *= Rotate(u_time * 0.5); \n        vec2 q = h*vec2(c.x/c.y,-1.0);\n        vec2 w = vec2( length(p.xz), p.y );\n        vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n        vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n        float k = sign( q.y );\n        float d = min(dot( a, a ),dot(b, b));\n        float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n        return sqrt(d)*sign(s);\n    }\n\n    float infiniteRepetitionBox(vec3 point, vec3 spacing)\n    {\n        vec3 q = point - spacing * round(point/spacing);\n        return sdf_box(q, vec3(0.25));\n    }\n\n    float repeatedBox(vec3 point)\n    {\n        float noise = cnoise(vec3(point)) * 1.;\n        float displacement = sin((noise + sin(u_time) * 3.) * point.x) * sin((noise + sin(u_time)) * point.y) * cos((noise + cos(u_time) * 5.) * point.z) * 0.25;\n\n        point.x = point.x - round(point.x);\n        point.y = point.y - round(point.y);\n        // point.z = point.z - round(point.z);\n        return sdf_box(point, vec3(0.25));\n    }\n\n    float draw_scene(vec3 point)\n    {\n        point.x = point.x - round(point.x);\n        point.y = point.y - round(point.y);\n        // point.z = point.z - round(point.z);\n        //distortion\n        float noise = cnoise(vec3(point)) * 5.;\n        float displacement = sin((noise + sin(u_time) * 3.) * point.x) * sin((noise + sin(u_time)) * point.y) * cos((noise + cos(u_time) * 5.) * point.z) * 0.25;\n\n        float sphere = sdf_sphere(point, 0.25);\n        // sphere += displacement;\n\n        float box = sdf_box(point, vec3(0.25));\n        // box += displacement;\n\n        float box2 = sdf_box(point , vec3(0.5));\n\n        float cone = sdf_cone(point, vec2(0.05), .5);\n\n        float total_map;\n        float v1 = smoothIntersection(sphere, box, 0.15);\n        total_map += v1;\n        // total_map = repeatedBox(point);\n        // total_map += displacement;\n        // total_map = smoothDifferenceSDF(cone, total_map, 0.15);\n\n        return total_map;\n    }\n\n    vec3 calculate_normal(vec3 point)\n    {\n        vec3 small_step = vec3(0.0001, 0., 0.);\n        float grad_x = draw_scene(point + small_step.xyy) - draw_scene(point - small_step.xyy);\n        float grad_y = draw_scene(point + small_step.yxy) - draw_scene(point - small_step.yxy);\n        float grad_z = draw_scene(point + small_step.yyx) - draw_scene(point - small_step.yyx);\n        vec3 normal = vec3(grad_x, grad_y, grad_z);\n        return normalize(normal);\n    }\n\n    vec3 ray_march(vec3 ray_origin, vec3 ray_direction)\n    {\n        float total_distance = 0.;\n        for(int i = 0; i < 1000; ++i)\n        {\n            ray_direction.xy *= Rotate(u_time * 0.5);\n            vec3 current_pos = ray_origin + total_distance * ray_direction;\n            float distance_to_closest = draw_scene(current_pos);\n\n            if(distance_to_closest < 0.0001)\n            {\n                //normal\n                vec3 normal = calculate_normal(current_pos);\n\n                //light\n                vec3 light_pos = vec3(2., -5., 3.);\n                vec3 dir_to_light = normalize(current_pos - light_pos);\n                float light_intensity = max(0., dot(normal, dir_to_light));\n\n                return vec3(1., 0.2 * sin(u_time), 0.5 * sin(u_time)) * light_intensity;\n            }\n\n            if(total_distance > 1000.)\n            {\n                break;\n            }\n\n            total_distance += distance_to_closest;\n        }\n\n        return vec3(0.);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -2. + sin(u_time));\n        vec3 ray_origin = cam_pos;\n        vec3 ray_direction = vec3(uv2, 1.);\n        // ray_direction.xy *= Rotate(u_time * 0.5);\n        vec3 ray_march_scene = ray_march(ray_origin, ray_direction);\n\n        color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function EN(){var n,e,t="./Models/EnvMaps/0/",r=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point)) * 2.;\n        float displacement = sin((noise + sin(u_time) * 1.) * point.x) * sin((noise + sin(u_time)) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.125;\n\n        float sphere = Sphere_SDF(vec3(point.x , point.y - 1.75, point.z), 1.25) + displacement * 2. ;\n        float sphere2 = Sphere_SDF(vec3(point.x, point.y + 1.75, point.z), 1.75) + displacement * 2. ;\n        float sphere3 = Sphere_SDF(vec3(point.x + 1.5, point.y + 1.75, point.z), 1.75) + displacement * 2. ;\n        float plane = Plane_SDF(point, vec3(0.0, 1., 0.0), 0.25) + displacement * 2.;\n\n        float plane2 = Plane_SDF(point, vec3(0., 1., 0.), 0.25);\n\n        float total_map;\n\n        total_map += plane;\n\n        total_map = Smooth_Intersection_SDF(plane, plane2, 0.15);\n\n        total_map = Smooth_Union_SDF(total_map, sphere, 0.15);\n        // total_map = Smooth_Union_SDF(total_map, sphere2, 0.15);\n        // total_map = Smooth_Union_SDF(total_map, sphere3, 0.15);\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    vec3 ray_march(vec3 ro, vec3 rd)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos);\n\n            if(dist < 0.001)\n            {\n                //normal\n                vec3 normal = getNormal(pos);\n\n                //light\n                vec3 light_pos = vec3(2., -5., 3.);\n                vec3 dir = normalize(pos - light_pos);\n                float intensity = max(0., dot(normal, dir));\n\n                return vec3(.45, .58, .6) * intensity;\n            }\n\n            if(tot_dist > 1000.)\n            {\n                break;\n            }\n\n            tot_dist += dist;\n        }\n\n        return vec3(0.11, 0.16, 0.19);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -7);\n        vec3 ray_origin = cam_pos;\n        vec3 ray_direction = vec3(uv2, 1.);\n\n        vec3 ray_march_scene = ray_march(ray_origin, ray_direction);\n\n        color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function IN(){var n,e,t="./Models/EnvMaps/0/",r=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + u_time)) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.3;\n\n        vec3 newpoint = point;\n        newpoint.xy *= Rotate(sin(u_time));\n        newpoint.zy *= Rotate(sin(u_time));\n        float sphere = Sphere_SDF(vec3(newpoint), 1.25) + displacement ;\n        float box = Box_SDF(newpoint, vec3(0.75) + displacement * 1.  );\n\n        float total_map;\n\n        total_map += sphere;\n\n        // total_map = Smooth_Difference_SDF(sphere, box, 0.15);\n        \n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -4.);\n        vec3 ray_origin = cam_pos;\n        vec3 ray_direction = vec3(uv2, 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        vec3 col = vec3(0.);\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            vec3 refOutside = vec3(1.);\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function ON(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + u_time)) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.3;\n\n        // point.xy *= Rotate(sin(u_time));\n        // point.zy *= Rotate(sin(u_time));\n\n        vec3 newpoint1 = point;\n        float sphere = Sphere_SDF(vec3(newpoint1), 1.) + displacement ;\n        \n        vec3 newpoint2 = point;\n        newpoint2.x += 0.35 + sin(u_time) * 1.25;\n        float sphere2 = Sphere_SDF(vec3(newpoint2), .25) + displacement ;\n\n        vec3 newpoint3 = point;\n        newpoint3.x -= 0.35 + sin(u_time) * 1.;\n        float sphere3 = Sphere_SDF(vec3(newpoint3), .25) + displacement ;\n\n        vec3 newpoint4 = point;\n        newpoint4.y -= 0.35 + sin(u_time) * 0.5;\n        float sphere4 = Sphere_SDF(vec3(newpoint4), .25) + displacement ;\n\n        vec3 newpoint5 = point;\n        newpoint5.y += 0.35 + sin(u_time) * 2.;\n        float sphere5 = Sphere_SDF(vec3(newpoint5), .25) + displacement ;\n\n        vec3 newpoint6 = point;\n        newpoint6.z -= 0.35 + sin(u_time) * 0.8;\n        float sphere6 = Sphere_SDF(vec3(newpoint6), .25) + displacement ;\n\n        vec3 newpoint7 = point;\n        newpoint7.z += 0.35 + sin(u_time) * 0.25;\n        float sphere7 = Sphere_SDF(vec3(newpoint7), .25) + displacement ;\n\n        vec3 newpoint8 = point;\n        newpoint8.y += 0.35 + sin(u_time) * 0.45;\n        newpoint8.z -= 0.35 + sin(u_time) * 1.25;\n        float sphere8 = Sphere_SDF(vec3(newpoint8), .25) + displacement ;\n\n        float total_map;\n\n        total_map += sphere;\n\n        total_map = Smooth_Union_SDF(sphere, sphere2, 0.15);\n        total_map = Smooth_Union_SDF(total_map, sphere3, 0.15);\n        total_map = Smooth_Union_SDF(total_map, sphere4, 0.15);\n        total_map = Smooth_Union_SDF(total_map, sphere5, 0.15);\n        total_map = Smooth_Union_SDF(total_map, sphere6, 0.15);\n        total_map = Smooth_Union_SDF(total_map, sphere7, 0.15);\n        total_map = Smooth_Union_SDF(total_map, sphere8, 0.15);\n        \n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -4.);\n        vec3 ray_origin = cam_pos;\n        ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = normal * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function LN(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + u_time)) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.3;\n\n        // point.xy *= Rotate(sin(u_time));\n        // point.zy *= Rotate(sin(u_time));\n\n        vec3 newpoint1 = point;\n        float sphere = Sphere_SDF(vec3(newpoint1), 1.) + displacement ;\n        \n        vec3 newpoint2 = point;\n        newpoint2.x += 0.35 + sin(u_time) * 1.25;\n        float sphere2 = Sphere_SDF(vec3(newpoint2), .25) + displacement ;\n\n        vec3 newpoint3 = point;\n        newpoint3.x -= 0.35 + sin(u_time) * 1.;\n        float sphere3 = Sphere_SDF(vec3(newpoint3), .25) + displacement ;\n\n        vec3 newpoint4 = point;\n        newpoint4.y -= 0.35 + sin(u_time) * 0.5;\n        float sphere4 = Sphere_SDF(vec3(newpoint4), .25) + displacement ;\n\n        vec3 newpoint5 = point;\n        newpoint5.y += 0.35 + sin(u_time) * 2.;\n        float sphere5 = Sphere_SDF(vec3(newpoint5), .25) + displacement ;\n\n        vec3 newpoint6 = point;\n        newpoint6.z -= 0.35 + sin(u_time) * 0.8;\n        float sphere6 = Sphere_SDF(vec3(newpoint6), .25) + displacement ;\n\n        vec3 newpoint7 = point;\n        newpoint7.z += 0.35 + sin(u_time) * 0.25;\n        float sphere7 = Sphere_SDF(vec3(newpoint7), .25) + displacement ;\n\n        vec3 newpoint8 = point;\n        newpoint8.y += 0.35 + sin(u_time) * 0.45;\n        newpoint8.z -= 0.35 + sin(u_time) * 1.25;\n        float sphere8 = Sphere_SDF(vec3(newpoint8), .25) + displacement ;\n\n        float total_map;\n\n        total_map += sphere;\n\n        \n\n        // total_map = Smooth_Union_SDF(sphere, sphere2, 0.15);\n        // total_map = Smooth_Union_SDF(total_map, sphere3, 0.15);\n        // total_map = Smooth_Union_SDF(total_map, sphere4, 0.15);\n        // total_map = Smooth_Union_SDF(total_map, sphere5, 0.15);\n        // total_map = Smooth_Union_SDF(total_map, sphere6, 0.15);\n        // total_map = Smooth_Union_SDF(total_map, sphere7, 0.15);\n        // total_map = Smooth_Union_SDF(total_map, sphere8, 0.15);\n\n        for(int i = 0; i < 20; i++)\n        {\n            float noise = cnoise(vec3(point + u_time)) * 1.;\n            float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.3;\n            vec3 newPoint = point;\n            float x = Sphere_SDF(vec3(newPoint.x + float(i/5) + (sin(u_time + float(i)) * 2.), newPoint.y + float(i/5) + (cos(u_time + float(i)) * 2.), newPoint.z + float(i/5) + (sin(u_time + float(i)) * 2.)), 0.25) + displacement;\n            total_map = Smooth_Union_SDF(total_map, x, 0.5);\n        }\n        \n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -4.);\n        vec3 ray_origin = cam_pos;\n        ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function AN(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + u_time)) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.3;\n\n        vec3 newPoint1 = point;\n        newPoint1.x -= 2.5;\n        float sphere = Sphere_SDF(vec3(newPoint1), 1.) + displacement ;\n        float box = Box_SDF(vec3(newPoint1), vec3(1.));\n\n        vec3 newPoint2 = point;\n        float sphere2 = Sphere_SDF(vec3(newPoint2), 1.) + displacement ;\n        float box2 = Box_SDF(vec3(newPoint2), vec3(1.));\n\n        vec3 newPoint3 = point;\n        newPoint3.x += 2.5;\n        float sphere3 = Sphere_SDF(vec3(newPoint3), 1.) + displacement ;\n        float box3 = Box_SDF(vec3(newPoint3), vec3(1.));\n\n        float total_map;\n\n        // total_map += box;\n        float map1 = Smooth_Intersection_SDF(sphere, box, 0.15);\n\n        float map2 = Smooth_Union_SDF(sphere2, box2, 0.15);\n\n        float map3 = Smooth_Difference_SDF(sphere3, box3, 0.15);\n\n        float map = Smooth_Union_SDF(map1, map2, 0.15);\n\n        map = Smooth_Union_SDF(map, map3, 0.15);\n        \n        total_map += map;\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -7.);\n        vec3 ray_origin = cam_pos;\n        ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function NN(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFive(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + u_time)) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.5;\n\n        vec3 newPoint1 = point;\n        // newPoint1.x -= 0.;\n        float sphere = Sphere_SDF(vec3(newPoint1), 0.5) + displacement ;\n        float box = Box_SDF(vec3(newPoint1), vec3(0.5)) + displacement;\n\n        vec3 newPoint2 = point;\n        float sphere2 = Sphere_SDF(vec3(newPoint2), 1.) + displacement ;\n        float box2 = Box_SDF(vec3(newPoint2), vec3(1.));\n\n        vec3 newPoint3 = point;\n        // newPoint3.x += 2.5;\n        float sphere3 = Sphere_SDF(vec3(newPoint3), 1.1) + displacement ;\n        float box3 = Box_SDF(vec3(newPoint3), vec3(1.)) + displacement;\n\n        float total_map;\n\n        // total_map += box;\n        float map1 = Smooth_Intersection_SDF(sphere, box, 0.15);\n\n        float map2 = Smooth_Union_SDF(sphere2, box2, 0.15);\n\n        float map3 = Smooth_Difference_SDF(sphere3, box3, 0.15);\n\n        float map = Smooth_Union_SDF(map1, map3, 0.15);\n\n        // map = Smooth_Union_SDF(map, map3, 0.15);\n        \n        total_map += map;\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -5.);\n        vec3 ray_origin = cam_pos;\n        ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function GN(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + u_time)) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.5;\n\n        vec3 newPoint1 = point;\n        newPoint1.x += sin(u_time) * 2.;\n        // newPoint1.y += cos(u_time) * 2.;\n        float sphere = Sphere_SDF(vec3(newPoint1), 0.5) ;\n        float box = Box_SDF(vec3(newPoint1), vec3(0.5)) ;\n\n        vec3 newPoint2 = point;\n        float sphere2 = Sphere_SDF(vec3(newPoint2), 1.) ;\n        float box2 = Box_SDF(vec3(newPoint2), vec3(1.));\n\n        vec3 newPoint3 = point;\n        // newPoint3.x += 2.5;\n        float sphere3 = Sphere_SDF(vec3(newPoint3), 1.1) ;\n        float box3 = Box_SDF(vec3(newPoint3), vec3(1.)) ;\n\n        float total_map;\n\n        // total_map += box;\n        float map1 = Smooth_Intersection_SDF(sphere, box, 0.15) + displacement;\n\n        float map2 = Smooth_Union_SDF(sphere2, box2, 0.15);\n\n        float map3 = Smooth_Difference_SDF(sphere3, box3, 0.15);\n\n        float map = Smooth_Union_SDF(map1, map3, 0.1);\n\n        // map = Smooth_Union_SDF(map, map3, 0.15);\n        \n        total_map += map;\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -5.);\n        vec3 ray_origin = cam_pos;\n        ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function BN(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + sin(u_time))) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.15;\n\n        float box = sdBoxFrame(point, vec3(1.0 + displacement), 0.05 );\n\n        float total_map;\n\n        total_map += box;\n        \n        // total_map += map;\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -6.);\n        vec3 ray_origin = cam_pos;\n        ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function qN(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float sdPyramid( vec3 p, float h )\n    {\n        float m2 = h*h + 0.25;\n            \n        p.xz = abs(p.xz);\n        p.xz = (p.z>p.x) ? p.zx : p.xz;\n        p.xz -= 0.5;\n\n        vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n        \n        float s = max(-q.x,0.0);\n        float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n            \n        float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n        float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n            \n        float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n            \n        return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n    }\n\n    float sdPlane( vec3 p, vec3 n, float h )\n    {\n        // n must be normalized\n        return dot(p,n) + h;\n    }\n\n   \n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + sin(u_time))) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.15;\n\n        vec3 newPoint = point;\n        newPoint.y += 0.5;\n        vec3 newPoint2 = point;\n        newPoint.y -= 1.5;\n        // float box = sdBoxFrame(point, vec3(1.0 + displacement), 0.05 );\n        float plane = sdPlane(newPoint, vec3(0,1,0), 1.);\n        float pyramid = sdPyramid(newPoint2 , 1.);\n        float total_map;\n\n        // total_map += box;\n        total_map += plane;\n        total_map = Smooth_Union_SDF(total_map, pyramid, 0.05);\n        // total_map += map;\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 5., -3.);\n        vec3 ray_origin = cam_pos;\n        // ray_origin.yz *= Rotate(-m.y*PI + 0.5);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI);\n        ray_origin.y = clamp(ray_origin.y, 0.1, 2.);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        col = pow(col, vec3(2.94545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function VN(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float sdPyramid( vec3 p, float h )\n    {\n        float m2 = h*h + 0.25;\n            \n        p.xz = abs(p.xz);\n        p.xz = (p.z>p.x) ? p.zx : p.xz;\n        p.xz -= 0.5;\n\n        vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n        \n        float s = max(-q.x,0.0);\n        float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n            \n        float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n        float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n            \n        float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n            \n        return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n    }\n\n    float sdPlane( vec3 p, vec3 n, float h )\n    {\n        // n must be normalized\n        return dot(p,n) + h;\n    }\n\n    float sdOctahedron( vec3 p, float s)\n    {\n        p = abs(p);\n        return (p.x+p.y+p.z-s)*0.57735027;\n    }\n    \n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + sin(u_time))) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.15;\n\n        vec3 newPoint = point;\n        newPoint.y += 0.5;\n        vec3 newPoint2 = point;\n        newPoint.y -= 1.5;\n        // float box = sdBoxFrame(point, vec3(1.0 + displacement), 0.05 );\n        float plane = sdPlane(newPoint, vec3(0,1,0), 1.);\n        float pyramid = sdPyramid(newPoint2 , 1.);\n        float octahedron = sdOctahedron(point, 1.);\n        float total_map;\n\n        // total_map += box;\n        // total_map += plane;\n        total_map += octahedron;\n        // total_map = Smooth_Union_SDF( pyramid, total_map, 0.05);\n        // total_map += map;\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -3.);\n        vec3 ray_origin = cam_pos;\n        ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI + (u_time * 0.1));\n        ray_origin.y = clamp(ray_origin.y, -1., 1.);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        col = pow(col, vec3(2.94545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function WN(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float sdPyramid( vec3 p, float h )\n    {\n        float m2 = h*h + 0.25;\n            \n        p.xz = abs(p.xz);\n        p.xz = (p.z>p.x) ? p.zx : p.xz;\n        p.xz -= 0.5;\n\n        vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n        \n        float s = max(-q.x,0.0);\n        float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n            \n        float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n        float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n            \n        float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n            \n        return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n    }\n\n    float sdPlane( vec3 p, vec3 n, float h )\n    {\n        // n must be normalized\n        return dot(p,n) + h;\n    }\n\n    float sdOctahedron( vec3 p, float s)\n    {\n        p = abs(p);\n        return (p.x+p.y+p.z-s)*0.57735027;\n    }\n\n    float sdKnot(vec3 p, float k) {\n        float r = length(p.xy);\n        float oa, a = atan(p.y, p.x); oa = k*a;\n        a = mod(a, 0.001*TWO_PI) - 0.001*TWO_PI/2.0;\n        p.xy = r*vec2(cos(a), sin(a)); p.x -= 6.0;\n        p.xz = cos(oa)*p.xz + sin(oa)*vec2(-p.z, p.x);\n        p.x = abs(p.x) - 1.35; \n        return length(p) - 1.0;\n    }    \n    \n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + sin(u_time))) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.15;\n\n        vec3 newPoint = point;\n        newPoint.y += 0.5;\n        vec3 newPoint2 = point;\n        newPoint.y -= 1.5;\n        // float box = sdBoxFrame(point, vec3(1.0 + displacement), 0.05 );\n        float plane = sdPlane(newPoint, vec3(0,1,0), 1.);\n        float pyramid = sdPyramid(newPoint2 , 1.);\n        float octahedron = sdOctahedron(point, 1.);\n        float knot = sdKnot(point, 2.5) + displacement;\n        float total_map;\n\n        // total_map += box;\n        // total_map += plane;\n        // total_map += octahedron;\n        total_map += knot;\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -20.);\n        vec3 ray_origin = cam_pos;\n        // ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI + (u_time * 0.25));\n        ray_origin.y = clamp(ray_origin.y, -1., 1.);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        col = pow(col, vec3(2.94545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function HN(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float sdPyramid( vec3 p, float h )\n    {\n        float m2 = h*h + 0.25;\n            \n        p.xz = abs(p.xz);\n        p.xz = (p.z>p.x) ? p.zx : p.xz;\n        p.xz -= 0.5;\n\n        vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n        \n        float s = max(-q.x,0.0);\n        float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n            \n        float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n        float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n            \n        float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n            \n        return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n    }\n\n    float sdPlane( vec3 p, vec3 n, float h )\n    {\n        // n must be normalized\n        return dot(p,n) + h;\n    }\n\n    float sdOctahedron( vec3 p, float s)\n    {\n        p = abs(p);\n        return (p.x+p.y+p.z-s)*0.57735027;\n    }\n\n    float sdKnot(vec3 p, float k) {\n        float r = length(p.xy);\n        float oa, a = atan(p.y, p.x); oa = k*a;\n        a = mod(a, 0.001*TWO_PI) - 0.001*TWO_PI/2.0;\n        p.xy = r*vec2(cos(a), sin(a)); p.x -= 6.0;\n        p.xz = cos(oa)*p.xz + sin(oa)*vec2(-p.z, p.x);\n        p.x = abs(p.x) - 1.35; \n        return length(p) - 1.0;\n    }    \n    \n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + sin(u_time))) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.1;\n\n        vec3 newPoint = point;\n        newPoint.x += 4.5;\n\n        newPoint.xz *= Rotate(PI * 0.5);\n        newPoint.yz *= Rotate(PI * 0.5);\n\n        newPoint.yx *= Rotate((u_time));\n        newPoint.yx *= Rotate((u_time));\n        point.yx *= Rotate((u_time));\n        point.yx *= Rotate((u_time));\n        \n\n        float knot = sdKnot(point, 1.5) + displacement;\n        \n        float knot2 = sdKnot(newPoint, 1.5) + displacement;\n        float total_map;\n\n        // total_map += box;\n        // total_map += plane;\n        // total_map += octahedron;\n        total_map += knot;\n        total_map = Smooth_Union_SDF(total_map, knot2, 0.015);\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -30.);\n        vec3 ray_origin = cam_pos;\n        // ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI + (u_time * 0.25));\n        ray_origin.y = clamp(ray_origin.y, -1., 1.);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        col = pow(col, vec3(2.94545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function XN(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float sdPyramid( vec3 p, float h )\n    {\n        float m2 = h*h + 0.25;\n            \n        p.xz = abs(p.xz);\n        p.xz = (p.z>p.x) ? p.zx : p.xz;\n        p.xz -= 0.5;\n\n        vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n        \n        float s = max(-q.x,0.0);\n        float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n            \n        float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n        float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n            \n        float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n            \n        return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n    }\n\n    float sdPlane( vec3 p, vec3 n, float h )\n    {\n        // n must be normalized\n        return dot(p,n) + h;\n    }\n\n    float sdOctahedron( vec3 p, float s)\n    {\n        p = abs(p);\n        return (p.x+p.y+p.z-s)*0.57735027;\n    }\n\n    float sdKnot(vec3 p, float k) {\n        float r = length(p.xy);\n        float oa, a = atan(p.y, p.x); oa = k*a;\n        a = mod(a, 0.001*TWO_PI) - 0.001*TWO_PI/2.0;\n        p.xy = r*vec2(cos(a), sin(a)); p.x -= 6.0;\n        p.xz = cos(oa)*p.xz + sin(oa)*vec2(-p.z, p.x);\n        p.x = abs(p.x) - 1.35; \n        return length(p) - 1.0;\n    }    \n    \n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + sin(u_time))) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.1;\n\n        vec3 newPoint = point;\n        newPoint.x += 4.5;\n\n        newPoint.xz *= Rotate(PI * 0.5);\n        newPoint.yz *= Rotate(PI * 0.5);\n\n        newPoint.yx *= Rotate((u_time * 0.3));\n        newPoint.yx *= Rotate((u_time* 0.3));\n        point.yx *= Rotate((u_time* 0.3));\n        point.yx *= Rotate((u_time* 0.3));\n        \n\n        float knot = sdKnot(point, 3. ) + displacement;\n        \n        float knot2 = sdKnot(newPoint, 3. ) + displacement;\n        float total_map;\n\n        // total_map += box;\n        // total_map += plane;\n        // total_map += octahedron;\n        total_map += knot;\n        total_map = Smooth_Union_SDF(total_map, knot2, 0.015);\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -30.);\n        vec3 ray_origin = cam_pos;\n        // ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI + (u_time * 0.25));\n        ray_origin.y = clamp(ray_origin.y, -1., 1.);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        col = pow(col, vec3(2.94545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function YN(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float sdPyramid( vec3 p, float h )\n    {\n        float m2 = h*h + 0.25;\n            \n        p.xz = abs(p.xz);\n        p.xz = (p.z>p.x) ? p.zx : p.xz;\n        p.xz -= 0.5;\n\n        vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n        \n        float s = max(-q.x,0.0);\n        float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n            \n        float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n        float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n            \n        float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n            \n        return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n    }\n\n    float sdPlane( vec3 p, vec3 n, float h )\n    {\n        // n must be normalized\n        return dot(p,n) + h;\n    }\n\n    float sdOctahedron( vec3 p, float s)\n    {\n        p = abs(p);\n        return (p.x+p.y+p.z-s)*0.57735027;\n    }\n\n    float sdKnot(vec3 p, float k) {\n        float r = length(p.xy);\n        float oa, a = atan(p.y, p.x); oa = k*a;\n        a = mod(a, 0.001*TWO_PI) - 0.001*TWO_PI/2.0;\n        p.xy = r*vec2(cos(a), sin(a)); p.x -= 6.0;\n        p.xz = cos(oa)*p.xz + sin(oa)*vec2(-p.z, p.x);\n        p.x = abs(p.x) - 1.35; \n        return length(p) - 1.0;\n    }    \n    \n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + sin(u_time))) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.01;\n\n        vec3 newPoint = point;\n        float plane = sdPlane(point, vec3(0., 1., 0.), 0.5) + displacement;\n        float total_map;\n        total_map += plane;\n\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -30.);\n        vec3 ray_origin = cam_pos;\n        // ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI );\n        ray_origin.y = clamp(ray_origin.y, -1., 1.);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        col = pow(col, vec3(2.94545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function $N(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float sdPyramid( vec3 p, float h )\n    {\n        float m2 = h*h + 0.25;\n            \n        p.xz = abs(p.xz);\n        p.xz = (p.z>p.x) ? p.zx : p.xz;\n        p.xz -= 0.5;\n\n        vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n        \n        float s = max(-q.x,0.0);\n        float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n            \n        float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n        float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n            \n        float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n            \n        return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n    }\n\n    float sdPlane( vec3 p, vec3 n, float h )\n    {\n        // n must be normalized\n        return dot(p,n) + h;\n    }\n\n    float sdOctahedron( vec3 p, float s)\n    {\n        p = abs(p);\n        return (p.x+p.y+p.z-s)*0.57735027;\n    }\n\n    float sdKnot(vec3 p, float k) {\n        float r = length(p.xy);\n        float oa, a = atan(p.y, p.x); oa = k*a;\n        a = mod(a, 0.001*TWO_PI) - 0.001*TWO_PI/2.0;\n        p.xy = r*vec2(cos(a), sin(a)); p.x -= 6.0;\n        p.xz = cos(oa)*p.xz + sin(oa)*vec2(-p.z, p.x);\n        p.x = abs(p.x) - 1.35; \n        return length(p) - 1.0;\n    }    \n    \n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + sin(u_time))) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.1;\n\n        vec3 newPoint = point;\n        newPoint.x += 4.5;\n\n        newPoint.xz *= Rotate(PI * 0.5);\n        newPoint.yz *= Rotate(PI * 0.5);\n\n        newPoint.yx *= Rotate((u_time));\n        newPoint.yx *= Rotate((u_time));\n        point.yx *= Rotate((u_time));\n        point.yx *= Rotate((u_time));\n        \n\n        float knot = sdKnot(point, 1.5) + displacement;\n        \n        float knot2 = sdKnot(newPoint, 1.5) + displacement;\n\n        float boxFrame = sdBoxFrame(point, vec3(10.), 0.5);\n        float total_map;\n\n        total_map = Smooth_Union_SDF(knot, knot2, 0.015);\n        total_map = Smooth_Union_SDF(total_map, boxFrame, 0.015);\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0., 0., -30.);\n        vec3 ray_origin = cam_pos;\n        // ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI );\n        ray_origin.y = clamp(ray_origin.y, -1., 1.);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        col = pow(col, vec3(2.94545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function ZN(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=(new cf).load(r),a=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform samplerCube u_cubemap;\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    float randomFunc(vec2 n) { \n        return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    }\n\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float sdPyramid( vec3 p, float h )\n    {\n        float m2 = h*h + 0.25;\n            \n        p.xz = abs(p.xz);\n        p.xz = (p.z>p.x) ? p.zx : p.xz;\n        p.xz -= 0.5;\n\n        vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n        \n        float s = max(-q.x,0.0);\n        float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n            \n        float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n        float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n            \n        float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n            \n        return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n    }\n\n    float sdPlane( vec3 p, vec3 n, float h )\n    {\n        // n must be normalized\n        return dot(p,n) + h;\n    }\n\n    float sdOctahedron( vec3 p, float s)\n    {\n        p = abs(p);\n        return (p.x+p.y+p.z-s)*0.57735027;\n    }\n\n    float sdKnot(vec3 p, float k) {\n        float r = length(p.xy);\n        float oa, a = atan(p.y, p.x); oa = k*a;\n        a = mod(a, 0.001*TWO_PI) - 0.001*TWO_PI/2.0;\n        p.xy = r*vec2(cos(a), sin(a)); p.x -= 6.0;\n        p.xz = cos(oa)*p.xz + sin(oa)*vec2(-p.z, p.x);\n        p.x = abs(p.x) - 1.35; \n        return length(p) - 1.0;\n    }    \n    \n\n    float draw_scene(vec3 point)\n    {\n        //distortion\n        float noise = cnoise(vec3(point + sin(u_time))) * 1.;\n        float displacement = sin((noise + cos(u_time) * 1.) * point.x) * sin((noise + sin(u_time) * 1.) * point.y) * cos((noise + cos(u_time) * 1.) * point.z) * 0.01;\n\n        vec3 newPoint = point;\n        vec3 newPoint2 = point;\n\n        newPoint.xz *= Rotate(PI * 0.5);\n        newPoint.yz *= Rotate(PI * 0.5);\n        newPoint2.xz *= Rotate(PI * 0.25);\n        newPoint2.yz *= Rotate(PI * 0.25);\n\n        newPoint.yx *= Rotate((u_time * 0.5));\n        newPoint.yx *= Rotate((u_time * 0.5));\n        newPoint2.yx *= Rotate((u_time * 0.5));\n        newPoint2.yx *= Rotate((u_time * 0.5));\n        point.yx *= Rotate((u_time * 0.5));\n        point.yx *= Rotate((u_time * 0.5));\n        \n        float boxFrame = sdBoxFrame(newPoint, vec3(10.), 0.5 ) ;\n        float boxFrame2 = sdBoxFrame(newPoint2, vec3(5.), 0.5);\n        float boxFrame3 = sdBoxFrame(point, vec3(2.), 0.5);\n        float total_map;\n\n        total_map = Smooth_Union_SDF(boxFrame2, boxFrame3, 0.015);\n        total_map = Smooth_Union_SDF(total_map, boxFrame, 0.015);\n        return total_map;\n    }\n\n    vec3 getNormal(vec3 point)\n    {\n        vec3 val = vec3(0.01, vec2(0.));\n        float x = draw_scene(point + val.xyy) - draw_scene(point - val.xyy);\n        float y = draw_scene(point + val.yxy) - draw_scene(point - val.yxy);\n        float z = draw_scene(point + val.yyx) - draw_scene(point - val.yyx);\n        vec3 normal = vec3(x, y, z);\n        return normalize(normal);\n    }\n\n    float ray_march(vec3 ro, vec3 rd, float side)\n    {\n        float tot_dist = 0.;\n        for(int i = 0; i < 1000; i++)\n        {\n            vec3 pos = ro + tot_dist * rd;\n            float dist = draw_scene(pos) * side;\n\n            tot_dist += dist;\n            if(tot_dist > 1000. || abs(dist) < 0.0001) break;\n        }\n        return tot_dist;\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n\n        vec3 color = vec3(0.);\n\n        vec3 cam_pos = vec3(0. , 0., -20. * sin(u_time * 0.5) * 2.);\n        vec3 ray_origin = cam_pos;\n        // ray_origin.yz *= Rotate(-m.y*PI + 1.);\n        ray_origin.xz *= Rotate(-m.x*TWO_PI );\n        ray_origin.y = clamp(ray_origin.y, -1., 1.);\n        // vec3 ray_direction = vec3(uv2, 1.);\n        vec3 ray_direction = GetRayDir(uv2, ray_origin, vec3(0.), 1.);\n\n        float ray_march_scene = ray_march(ray_origin, ray_direction, 1.);\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, ray_direction).rgb;\n        float IOR = 1.45;\n\n        if(ray_march_scene < 1000.){\n            vec3 point = ray_origin + ray_direction * ray_march_scene;\n            vec3 normal = getNormal(point);\n            vec3 r = reflect(ray_direction, normal);\n\n            // vec3 refOutside = vec3(1.);\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 rdIn = refract(ray_direction, normal, 1./IOR);\n\n            vec3 pEnter = point - normal * .00001 * 3.;\n            float dIn = ray_march(pEnter, rdIn, -1.);\n\n            vec3 pExit = pEnter + rdIn * dIn;\n            vec3 nExit = -getNormal(pExit);\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = 0.01;\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = 1.;\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = .5;\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = .5;\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(ray_direction, normal), 2.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = normal * .5 + .5;\n        }\n\n        col = pow(col, vec3(2.94545));\n\n        color += col;\n\n        // color += ray_march_scene;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o}}}),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KN=t(164);function JN(n,e){"function"===typeof n?n(e):null!==n&&void 0!==n&&(n.current=e)}function QN(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return function(n){return e.forEach((function(e){return JN(e,n)}))}}function nG(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return(0,Ad.useCallback)(QN.apply(void 0,e),e)}var eG=["children"],tG=["children"],rG=(0,Ad.forwardRef)((function(n,e){var t=n.children,o=r(n,eG),a=Ad.Children.toArray(t),i=a.find(iG);if(i){var v=i.props.children,c=a.map((function(n){return n===i?Ad.Children.count(v)>1?Ad.Children.only(null):(0,Ad.isValidElement)(v)?v.props.children:null:n}));return(0,Ad.createElement)(oG,ih({},o,{ref:e}),(0,Ad.isValidElement)(v)?(0,Ad.cloneElement)(v,void 0,c):null)}return(0,Ad.createElement)(oG,ih({},o,{ref:e}),t)}));rG.displayName="Slot";var oG=(0,Ad.forwardRef)((function(n,e){var t=n.children,o=r(n,tG);return(0,Ad.isValidElement)(t)?(0,Ad.cloneElement)(t,u(u({},function(n,e){var t=u({},e),r=function(r){var o=n[r],a=e[r];/^on[A-Z]/.test(r)?o&&a?t[r]=function(){a.apply(void 0,arguments),o.apply(void 0,arguments)}:o&&(t[r]=o):"style"===r?t[r]=u(u({},o),a):"className"===r&&(t[r]=[o,a].filter(Boolean).join(" "))};for(var o in e)r(o);return u(u({},n),t)}(o,t.props)),{},{ref:e?QN(e,t.ref):t.ref})):Ad.Children.count(t)>1?Ad.Children.only(null):null}));oG.displayName="SlotClone";var aG=function(n){var e=n.children;return(0,Ad.createElement)(Ad.Fragment,null,e)};function iG(n){return(0,Ad.isValidElement)(n)&&n.type===aG}var vG=["asChild"],cG=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","span","svg","ul"].reduce((function(n,e){var t=(0,Ad.forwardRef)((function(n,t){var o=n.asChild,a=r(n,vG),i=o?rG:e;return(0,Ad.useEffect)((function(){window[Symbol.for("radix-ui")]=!0}),[]),(0,Ad.createElement)(i,ih({},a,{ref:t}))}));return t.displayName="Primitive.".concat(e),u(u({},n),{},l({},e,t))}),{});var lG=["container"],sG=(0,Ad.forwardRef)((function(n,e){var t,o=n.container,a=void 0===o?null===globalThis||void 0===globalThis||null===(t=globalThis.document)||void 0===t?void 0:t.body:o,i=r(n,lG);return a?KN.createPortal((0,Ad.createElement)(cG.div,ih({},i,{ref:e})),a):null})),uG=sG,fG=Object.prototype.hasOwnProperty;function pG(n,e){var t,r;if(n===e)return!0;if(n&&e&&(t=n.constructor)===e.constructor){if(t===Date)return n.getTime()===e.getTime();if(t===RegExp)return n.toString()===e.toString();if(t===Array){if((r=n.length)===e.length)for(;r--&&pG(n[r],e[r]););return-1===r}if(!t||"object"===typeof n){for(t in r=0,n){if(fG.call(n,t)&&++r&&!fG.call(e,t))return!1;if(!(t in e)||!pG(n[t],e[t]))return!1}return Object.keys(e).length===r}}return n!==n&&e!==e}function dG(n,e){if(Object.is(n,e))return!0;if("object"!==typeof n||null===n||"object"!==typeof e||null===e)return!1;var t=Object.keys(n);if(t.length!==Object.keys(e).length)return!1;for(var r=0;r<t.length;r++)if(!Object.prototype.hasOwnProperty.call(e,t[r])||!Object.is(n[t[r]],e[t[r]]))return!1;return!0}var mG=function(n,e,t,r){this.name=n,this.fn=e,this.args=t,this.modifiers=r};function hG(n,e){return void 0===e&&(e="simple"),"object"===typeof n?n[e]:n}function xG(n,e,t){if(n.length){var r=n.shift(),o=xG(n,e,t);return r.perform(o,t)}return hG(e)}function gG(n,e,t){if(n.length){var r=n.shift(),o=gG(n,e,t);return r.performAsync(o,t)}return function(n){return Promise.resolve(hG(e,"async")(n))}}mG.prototype._test=function(n){var e=this.fn;try{xG(this.modifiers.slice(),e,this)(n)}catch(t){e=function(){return!1}}try{return xG(this.modifiers.slice(),e,this)(n)}catch(r){return!1}},mG.prototype._check=function(n){try{xG(this.modifiers.slice(),this.fn,this)(n)}catch(e){if(xG(this.modifiers.slice(),(function(n){return n}),this)(!1))return}if(!xG(this.modifiers.slice(),this.fn,this)(n))throw null},mG.prototype._testAsync=function(n){var e=this;return new Promise((function(t,r){gG(e.modifiers.slice(),e.fn,e)(n).then((function(e){e?t(n):r(null)})).catch((function(n){return r(n)}))}))};var yG=function(n,e,t){this.name=n,this.perform=e,this.performAsync=t},bG=function(n){function e(t,r,o,a){for(var i=[],v=arguments.length-4;v-- >0;)i[v]=arguments[v+4];n.call(this,i),n.captureStackTrace&&n.captureStackTrace(this,e),this.rule=t,this.value=r,this.cause=o,this.target=a}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e}(Error),_G=function(n,e){void 0===n&&(n=[]),void 0===e&&(e=[]),this.chain=n,this.nextRuleModifiers=e};function UG(n,e,t,r){if(e.length){var o=e.shift();o._testAsync(n).then((function(){UG(n,e,t,r)}),(function(e){r(new bG(o,n,e))}))}else t(n)}_G.prototype._applyRule=function(n,e){var t=this;return function(){for(var r=[],o=arguments.length;o--;)r[o]=arguments[o];return t.chain.push(new mG(e,n.apply(t,r),r,t.nextRuleModifiers)),t.nextRuleModifiers=[],t}},_G.prototype._applyModifier=function(n,e){return this.nextRuleModifiers.push(new yG(e,n.simple,n.async)),this},_G.prototype._clone=function(){return new _G(this.chain.slice(),this.nextRuleModifiers.slice())},_G.prototype.test=function(n){return this.chain.every((function(e){return e._test(n)}))},_G.prototype.testAll=function(n){var e=[];return this.chain.forEach((function(t){try{t._check(n)}catch(r){e.push(new bG(t,n,r))}})),e},_G.prototype.check=function(n){this.chain.forEach((function(e){try{e._check(n)}catch(t){throw new bG(e,n,t)}}))},_G.prototype.testAsync=function(n){var e=this;return new Promise((function(t,r){UG(n,e.chain.slice(),t,r)}))};var wG=function(n,e){return!(!e||"string"!==typeof n||0!==n.trim().length)||(void 0===n||null===n)};function SG(){return"undefined"!==typeof Proxy?MG(new _G):zG(new _G)}var kG={};function MG(n){return new Proxy(n,{get:function(e,t){if(t in e)return e[t];var r=MG(n._clone());return t in CG?r._applyModifier(CG[t],t):t in kG?r._applyRule(kG[t],t):t in DG?r._applyRule(DG[t],t):void 0}})}function zG(n){var e=function(n,e){return Object.keys(n).forEach((function(t){e[t]=function(){for(var r=[],o=arguments.length;o--;)r[o]=arguments[o];var a=zG(e._clone()),i=a._applyRule(n[t],t).apply(void 0,r);return i}})),e},t=e(DG,n),r=e(kG,t);return Object.keys(CG).forEach((function(n){Object.defineProperty(r,n,{get:function(){return zG(r._clone())._applyModifier(CG[n],n)}})})),r}SG.extend=function(n){Object.assign(kG,n)},SG.clearCustomRules=function(){kG={}};var CG={not:{simple:function(n){return function(e){return!n(e)}},async:function(n){return function(e){return Promise.resolve(n(e)).then((function(n){return!n})).catch((function(){return!0}))}}},some:{simple:function(n){return function(e){return RG(e).some((function(e){try{return n(e)}catch(t){return!1}}))}},async:function(n){return function(e){return Promise.all(RG(e).map((function(e){try{return n(e).catch((function(){return!1}))}catch(t){return!1}}))).then((function(n){return n.some(Boolean)}))}}},every:{simple:function(n){return function(e){return!1!==e&&RG(e).every(n)}},async:function(n){return function(e){return Promise.all(RG(e).map(n)).then((function(n){return n.every(Boolean)}))}}},strict:{simple:function(n,e){return function(t){return TG(e)&&t&&"object"===typeof t?Object.keys(e.args[0]).length===Object.keys(t).length&&n(t):n(t)}},async:function(n,e){return function(t){return Promise.resolve(n(t)).then((function(n){return TG(e)&&t&&"object"===typeof t?Object.keys(e.args[0]).length===Object.keys(t).length&&n:n})).catch((function(){return!1}))}}}};function TG(n){return n&&"schema"===n.name&&n.args.length>0&&"object"===typeof n.args[0]}function RG(n){return"string"===typeof n?n.split(""):n}var DG={equal:function(n){return function(e){return e==n}},exact:function(n){return function(e){return e===n}},number:function(n){return void 0===n&&(n=!0),function(e){return"number"===typeof e&&(n||isFinite(e))}},integer:function(){return function(n){return(Number.isInteger||jG)(n)}},numeric:function(){return function(n){return!isNaN(parseFloat(n))&&isFinite(n)}},string:function(){return PG("string")},boolean:function(){return PG("boolean")},undefined:function(){return PG("undefined")},null:function(){return PG("null")},array:function(){return PG("array")},object:function(){return PG("object")},instanceOf:function(n){return function(e){return e instanceof n}},pattern:function(n){return function(e){return n.test(e)}},lowercase:function(){return function(n){return"boolean"===typeof n||n===n.toLowerCase()&&""!==n.trim()}},uppercase:function(){return function(n){return n===n.toUpperCase()&&""!==n.trim()}},vowel:function(){return function(n){return/^[aeiou]+$/i.test(n)}},consonant:function(){return function(n){return/^(?=[^aeiou])([a-z]+)$/i.test(n)}},first:function(n){return function(e){return e[0]==n}},last:function(n){return function(e){return e[e.length-1]==n}},empty:function(){return function(n){return 0===n.length}},length:function(n,e){return function(t){return t.length>=n&&t.length<=(e||n)}},minLength:function(n){return function(e){return e.length>=n}},maxLength:function(n){return function(e){return e.length<=n}},negative:function(){return function(n){return n<0}},positive:function(){return function(n){return n>=0}},between:function(n,e){return function(t){return t>=n&&t<=e}},range:function(n,e){return function(t){return t>=n&&t<=e}},lessThan:function(n){return function(e){return e<n}},lessThanOrEqual:function(n){return function(e){return e<=n}},greaterThan:function(n){return function(e){return e>n}},greaterThanOrEqual:function(n){return function(e){return e>=n}},even:function(){return function(n){return n%2===0}},odd:function(){return function(n){return n%2!==0}},includes:function(n){return function(e){return~e.indexOf(n)}},schema:function(n){return function(n){return{simple:function(e){var t=[];if(Object.keys(n).forEach((function(r){var o=n[r];try{o.check((e||{})[r])}catch(a){a.target=r,t.push(a)}})),t.length>0)throw t;return!0},async:function(e){var t=[],r=Object.keys(n).map((function(r){return n[r].testAsync((e||{})[r]).catch((function(n){n.target=r,t.push(n)}))}));return Promise.all(r).then((function(){if(t.length>0)throw t;return!0}))}}}(n)},passesAnyOf:function(){for(var n=[],e=arguments.length;e--;)n[e]=arguments[e];return function(e){return n.some((function(n){return n.test(e)}))}},optional:function(n,e){return void 0===e&&(e=!1),{simple:function(t){return wG(t,e)||void 0===n.check(t)},async:function(t){return wG(t,e)||n.testAsync(t)}}}};function PG(n){return function(e){return Array.isArray(e)&&"array"===n||null===e&&"null"===n||typeof e===n}}function jG(n){return"number"===typeof n&&isFinite(n)&&Math.floor(n)===n}var FG=SG,EG=["variants","compoundVariants","defaultVariants"],IG=["css"],OG=["css"],LG="colors",AG="sizes",NG="space",GG={gap:NG,gridGap:NG,columnGap:NG,gridColumnGap:NG,rowGap:NG,gridRowGap:NG,inset:NG,insetBlock:NG,insetBlockEnd:NG,insetBlockStart:NG,insetInline:NG,insetInlineEnd:NG,insetInlineStart:NG,margin:NG,marginTop:NG,marginRight:NG,marginBottom:NG,marginLeft:NG,marginBlock:NG,marginBlockEnd:NG,marginBlockStart:NG,marginInline:NG,marginInlineEnd:NG,marginInlineStart:NG,padding:NG,paddingTop:NG,paddingRight:NG,paddingBottom:NG,paddingLeft:NG,paddingBlock:NG,paddingBlockEnd:NG,paddingBlockStart:NG,paddingInline:NG,paddingInlineEnd:NG,paddingInlineStart:NG,top:NG,right:NG,bottom:NG,left:NG,scrollMargin:NG,scrollMarginTop:NG,scrollMarginRight:NG,scrollMarginBottom:NG,scrollMarginLeft:NG,scrollMarginX:NG,scrollMarginY:NG,scrollMarginBlock:NG,scrollMarginBlockEnd:NG,scrollMarginBlockStart:NG,scrollMarginInline:NG,scrollMarginInlineEnd:NG,scrollMarginInlineStart:NG,scrollPadding:NG,scrollPaddingTop:NG,scrollPaddingRight:NG,scrollPaddingBottom:NG,scrollPaddingLeft:NG,scrollPaddingX:NG,scrollPaddingY:NG,scrollPaddingBlock:NG,scrollPaddingBlockEnd:NG,scrollPaddingBlockStart:NG,scrollPaddingInline:NG,scrollPaddingInlineEnd:NG,scrollPaddingInlineStart:NG,fontSize:"fontSizes",background:LG,backgroundColor:LG,backgroundImage:LG,borderImage:LG,border:LG,borderBlock:LG,borderBlockEnd:LG,borderBlockStart:LG,borderBottom:LG,borderBottomColor:LG,borderColor:LG,borderInline:LG,borderInlineEnd:LG,borderInlineStart:LG,borderLeft:LG,borderLeftColor:LG,borderRight:LG,borderRightColor:LG,borderTop:LG,borderTopColor:LG,caretColor:LG,color:LG,columnRuleColor:LG,fill:LG,outline:LG,outlineColor:LG,stroke:LG,textDecorationColor:LG,fontFamily:"fonts",fontWeight:"fontWeights",lineHeight:"lineHeights",letterSpacing:"letterSpacings",blockSize:AG,minBlockSize:AG,maxBlockSize:AG,inlineSize:AG,minInlineSize:AG,maxInlineSize:AG,width:AG,minWidth:AG,maxWidth:AG,height:AG,minHeight:AG,maxHeight:AG,flexBasis:AG,gridTemplateColumns:AG,gridTemplateRows:AG,borderWidth:"borderWidths",borderTopWidth:"borderWidths",borderRightWidth:"borderWidths",borderBottomWidth:"borderWidths",borderLeftWidth:"borderWidths",borderStyle:"borderStyles",borderTopStyle:"borderStyles",borderRightStyle:"borderStyles",borderBottomStyle:"borderStyles",borderLeftStyle:"borderStyles",borderRadius:"radii",borderTopLeftRadius:"radii",borderTopRightRadius:"radii",borderBottomRightRadius:"radii",borderBottomLeftRadius:"radii",boxShadow:"shadows",textShadow:"shadows",transition:"transitions",zIndex:"zIndices"},BG=function(n,e){return"function"==typeof e?{"()":Function.prototype.toString.call(e)}:e},qG=function(){var n=Object.create(null);return function(e,t){for(var r=function(n){return JSON.stringify(n,BG)}(e),o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];return r in n?n[r]:n[r]=t.apply(void 0,[e].concat(a))}},VG=Symbol.for("sxs.internal"),WG=function(n,e){return Object.defineProperties(n,Object.getOwnPropertyDescriptors(e))},HG=function(n){for(var e in n)return!0;return!1},XG=Object.prototype.hasOwnProperty,YG=function(n){return n.includes("-")?n:n.replace(/[A-Z]/g,(function(n){return"-"+n.toLowerCase()}))},$G=/\s+(?![^()]*\))/,ZG=function(n){return function(e){return n.apply(void 0,x("string"==typeof e?String(e).split($G):[e]))}},KG={appearance:function(n){return{WebkitAppearance:n,appearance:n}},backfaceVisibility:function(n){return{WebkitBackfaceVisibility:n,backfaceVisibility:n}},backdropFilter:function(n){return{WebkitBackdropFilter:n,backdropFilter:n}},backgroundClip:function(n){return{WebkitBackgroundClip:n,backgroundClip:n}},boxDecorationBreak:function(n){return{WebkitBoxDecorationBreak:n,boxDecorationBreak:n}},clipPath:function(n){return{WebkitClipPath:n,clipPath:n}},content:function(n){return{content:n.includes('"')||n.includes("'")||/^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(n)?n:'"'.concat(n,'"')}},hyphens:function(n){return{WebkitHyphens:n,hyphens:n}},maskImage:function(n){return{WebkitMaskImage:n,maskImage:n}},maskSize:function(n){return{WebkitMaskSize:n,maskSize:n}},tabSize:function(n){return{MozTabSize:n,tabSize:n}},textSizeAdjust:function(n){return{WebkitTextSizeAdjust:n,textSizeAdjust:n}},userSelect:function(n){return{WebkitUserSelect:n,userSelect:n}},marginBlock:ZG((function(n,e){return{marginBlockStart:n,marginBlockEnd:e||n}})),marginInline:ZG((function(n,e){return{marginInlineStart:n,marginInlineEnd:e||n}})),maxSize:ZG((function(n,e){return{maxBlockSize:n,maxInlineSize:e||n}})),minSize:ZG((function(n,e){return{minBlockSize:n,minInlineSize:e||n}})),paddingBlock:ZG((function(n,e){return{paddingBlockStart:n,paddingBlockEnd:e||n}})),paddingInline:ZG((function(n,e){return{paddingInlineStart:n,paddingInlineEnd:e||n}}))},JG=/([\d.]+)([^]*)/,QG=function(n,e){return n.length?n.reduce((function(n,t){return n.push.apply(n,x(e.map((function(n){return n.includes("&")?n.replace(/&/g,/[ +>|~]/.test(t)&&/&.*&/.test(n)?":is(".concat(t,")"):t):t+" "+n})))),n}),[]):e},nB=function(n,e){return n in eB&&"string"==typeof e?e.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/,(function(e,t,r,o){return t+("stretch"===r?"-moz-available".concat(o,";").concat(YG(n),":").concat(t,"-webkit-fill-available"):"-moz-fit-content".concat(o,";").concat(YG(n),":").concat(t,"fit-content"))+o})):String(e)},eB={blockSize:1,height:1,inlineSize:1,maxBlockSize:1,maxHeight:1,maxInlineSize:1,maxWidth:1,minBlockSize:1,minHeight:1,minInlineSize:1,minWidth:1,width:1},tB=function(n){return n?n+"-":""},rB=function(n,e,t){return n.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g,(function(n,r,o,a,i){return"$"==a==!!o?n:(r||"--"==a?"calc(":"")+"var(--"+("$"===a?tB(e)+(i.includes("$")?"":tB(t))+i.replace(/\$/g,"-"):i)+")"+(r||"--"==a?"*"+(r||"")+(o||"1")+")":"")}))},oB=/\s*,\s*(?![^()]*\))/,aB=Object.prototype.toString,iB=function(n,e,t,r,o){var a,i,v;!function n(e,t,l){var s,u;(function e(p){for(s in p){var d,m=64===s.charCodeAt(0),h=f(m&&Array.isArray(p[s])?p[s]:[p[s]]);try{for(h.s();!(d=h.n()).done;){u=d.value;var g=/[A-Z]/.test(k=s)?k:k.replace(/-[^]/g,(function(n){return n[1].toUpperCase()})),y="object"==typeof u&&u&&u.toString===aB&&(!r.utils[g]||!t.length);if(g in r.utils&&!y){var b=r.utils[g];if(b!==i){i=b,e(b(u)),i=null;continue}}else if(g in KG){var _=KG[g];if(_!==v){v=_,e(_(u)),v=null;continue}}if(m&&(S=s.slice(1)in r.media?"@media "+r.media[s.slice(1)]:s,s=S.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g,(function(n,e,t,r,o,a){var i=JG.test(e),v=.0625*(i?-1:1),l=c(i?[r,e]:[e,r],2),s=l[0],u=l[1];return"("+("="===t[0]?"":">"===t[0]===i?"max-":"min-")+s+":"+("="!==t[0]&&1===t.length?u.replace(JG,(function(n,e,r){return Number(e)+v*(">"===t?1:-1)+r})):u)+(o?") and ("+(">"===o[0]?"min-":"max-")+s+":"+(1===o.length?a.replace(JG,(function(n,e,t){return Number(e)+v*(">"===o?-1:1)+t})):a):"")+")"}))),y){var U=m?l.concat(s):x(l),w=m?x(t):QG(t,s.split(oB));void 0!==a&&o(vB.apply(void 0,x(a))),a=void 0,n(u,w,U)}else void 0===a&&(a=[[],t,l]),s=m||36!==s.charCodeAt(0)?s:"--".concat(tB(r.prefix)).concat(s.slice(1).replace(/\$/g,"-")),u=y?u:"number"==typeof u?u&&g in cB?String(u)+"px":String(u):rB(nB(g,null==u?"":u),r.prefix,r.themeMap[g]),a[0].push("".concat(m?"".concat(s," "):"".concat(YG(s),":")).concat(u))}}catch(M){h.e(M)}finally{h.f()}}var S,k})(e),void 0!==a&&o(vB.apply(void 0,x(a))),a=void 0}(n,e,t)},vB=function(n,e,t){return"".concat(t.map((function(n){return"".concat(n,"{")})).join("")).concat(e.length?"".concat(e.join(","),"{"):"").concat(n.join(";")).concat(e.length?"}":"").concat(Array(t.length?t.length+1:0).join("}"))},cB={animationDelay:1,animationDuration:1,backgroundSize:1,blockSize:1,border:1,borderBlock:1,borderBlockEnd:1,borderBlockEndWidth:1,borderBlockStart:1,borderBlockStartWidth:1,borderBlockWidth:1,borderBottom:1,borderBottomLeftRadius:1,borderBottomRightRadius:1,borderBottomWidth:1,borderEndEndRadius:1,borderEndStartRadius:1,borderInlineEnd:1,borderInlineEndWidth:1,borderInlineStart:1,borderInlineStartWidth:1,borderInlineWidth:1,borderLeft:1,borderLeftWidth:1,borderRadius:1,borderRight:1,borderRightWidth:1,borderSpacing:1,borderStartEndRadius:1,borderStartStartRadius:1,borderTop:1,borderTopLeftRadius:1,borderTopRightRadius:1,borderTopWidth:1,borderWidth:1,bottom:1,columnGap:1,columnRule:1,columnRuleWidth:1,columnWidth:1,containIntrinsicSize:1,flexBasis:1,fontSize:1,gap:1,gridAutoColumns:1,gridAutoRows:1,gridTemplateColumns:1,gridTemplateRows:1,height:1,inlineSize:1,inset:1,insetBlock:1,insetBlockEnd:1,insetBlockStart:1,insetInline:1,insetInlineEnd:1,insetInlineStart:1,left:1,letterSpacing:1,margin:1,marginBlock:1,marginBlockEnd:1,marginBlockStart:1,marginBottom:1,marginInline:1,marginInlineEnd:1,marginInlineStart:1,marginLeft:1,marginRight:1,marginTop:1,maxBlockSize:1,maxHeight:1,maxInlineSize:1,maxWidth:1,minBlockSize:1,minHeight:1,minInlineSize:1,minWidth:1,offsetDistance:1,offsetRotate:1,outline:1,outlineOffset:1,outlineWidth:1,overflowClipMargin:1,padding:1,paddingBlock:1,paddingBlockEnd:1,paddingBlockStart:1,paddingBottom:1,paddingInline:1,paddingInlineEnd:1,paddingInlineStart:1,paddingLeft:1,paddingRight:1,paddingTop:1,perspective:1,right:1,rowGap:1,scrollMargin:1,scrollMarginBlock:1,scrollMarginBlockEnd:1,scrollMarginBlockStart:1,scrollMarginBottom:1,scrollMarginInline:1,scrollMarginInlineEnd:1,scrollMarginInlineStart:1,scrollMarginLeft:1,scrollMarginRight:1,scrollMarginTop:1,scrollPadding:1,scrollPaddingBlock:1,scrollPaddingBlockEnd:1,scrollPaddingBlockStart:1,scrollPaddingBottom:1,scrollPaddingInline:1,scrollPaddingInlineEnd:1,scrollPaddingInlineStart:1,scrollPaddingLeft:1,scrollPaddingRight:1,scrollPaddingTop:1,shapeMargin:1,textDecoration:1,textDecorationThickness:1,textIndent:1,textUnderlineOffset:1,top:1,transitionDelay:1,transitionDuration:1,verticalAlign:1,width:1,wordSpacing:1},lB=function(n){return String.fromCharCode(n+(n>25?39:97))},sB=function(n){return function(n){var e,t="";for(e=Math.abs(n);e>52;e=e/52|0)t=lB(e%52)+t;return lB(e%52)+t}(function(n,e){for(var t=e.length;t;)n=33*n^e.charCodeAt(--t);return n}(5381,JSON.stringify(n))>>>0)},uB=["themed","global","styled","onevar","resonevar","allvar","inline"],fB=function(n){if(n.href&&!n.href.startsWith(location.origin))return!1;try{return!!n.cssRules}catch(n){return!1}},pB=function(n){var e=n.group,t=e.cssRules.length;n.apply=function(n){try{e.insertRule(n,t),++t}catch(n){}}},dB=Symbol(),mB=qG(),hB=function(n,e){return mB(n,(function(){return function(){for(var t={type:null,composers:new Set},r=arguments.length,o=new Array(r),a=0;a<r;a++)o[a]=arguments[a];for(var i=0,v=o;i<v.length;i++){var c=v[i];if(null!=c)if(c[VG]){null==t.type&&(t.type=c[VG].type);var l,s=f(c[VG].composers);try{for(s.s();!(l=s.n()).done;){var u=l.value;t.composers.add(u)}}catch(p){s.e(p)}finally{s.f()}}else c.constructor!==Object||c.$$typeof?null==t.type&&(t.type=c):t.composers.add(xB(c,n))}return null==t.type&&(t.type="span"),t.composers.size||t.composers.add(["PJLV",{},[],[],{},[]]),gB(n,t,e)}}))},xB=function(n,e){var t,o,a=n.variants,i=n.compoundVariants,v=n.defaultVariants,c=r(n,EG),s="".concat(tB(e.prefix),"c-").concat(sB(c)),u=[],p=[],d=Object.create(null),m=[];for(var h in v)d[h]=String(v[h]);if("object"==typeof a&&a)for(var x in a){t=d,o=x,XG.call(t,o)||(d[x]="undefined");var g=a[x];for(var y in g){var b=l({},x,String(y));"undefined"===String(y)&&m.push(x);var _=g[y],U=[b,_,!HG(_)];u.push(U)}}if("object"==typeof i&&i){var w,S=f(i);try{for(S.s();!(w=S.n()).done;){var k=w.value,M=k.css,z=r(k,IG);for(var C in M="object"==typeof M&&M||{},z)z[C]=String(z[C]);var T=[z,M,!HG(M)];p.push(T)}}catch(R){S.e(R)}finally{S.f()}}return[s,c,u,p,d,m]},gB=function(n,e,t){var o,a=c(yB(e.composers),4),i=a[0],v=a[1],s=a[2],p=a[3],d="function"==typeof e.type||e.type.$$typeof?function(n){function e(){for(var t=0;t<e[dB].length;t++){var r=c(e[dB][t],2),o=r[0],a=r[1];n.rules[o].apply(a)}return e[dB]=[],null}return e[dB]=[],e.rules={},uB.forEach((function(n){return e.rules[n]={apply:function(t){return e[dB].push([n,t])}}})),e}(t):null,m=(d||t).rules,h=".".concat(i).concat(v.length>1?":where(.".concat(v.slice(1).join("."),")"):""),g=function(o){var a=o="object"==typeof o&&o||_B,l=a.css,g=r(a,OG),y={};for(var b in s)if(delete g[b],b in o){var _=o[b];"object"==typeof _&&_?y[b]=u({"@initial":s[b]},_):(_=String(_),y[b]="undefined"!==_||p.has(b)?_:s[b])}else y[b]=s[b];var U,w=new Set(x(v)),S=f(e.composers);try{for(S.s();!(U=S.n()).done;){var k=c(U.value,4),M=k[0],z=k[1],C=k[2],T=k[3];t.rules.styled.cache.has(M)||(t.rules.styled.cache.add(M),iB(z,[".".concat(M)],[],n,(function(n){m.styled.apply(n)})));var R,D=bB(C,y,n.media),P=bB(T,y,n.media,!0),j=f(D);try{for(j.s();!(R=j.n()).done;){var F=R.value;if(void 0!==F){var E,I=f(F);try{var O=function(){var e=c(E.value,3),r=e[0],o=e[1],a=e[2],i="".concat(M,"-").concat(sB(o),"-").concat(r);w.add(i);var v=(a?t.rules.resonevar:t.rules.onevar).cache,l=a?m.resonevar:m.onevar;v.has(i)||(v.add(i),iB(o,[".".concat(i)],[],n,(function(n){l.apply(n)})))};for(I.s();!(E=I.n()).done;)O()}catch(J){I.e(J)}finally{I.f()}}}}catch(J){j.e(J)}finally{j.f()}var L,A=f(P);try{for(A.s();!(L=A.n()).done;){var N=L.value;if(void 0!==N){var G,B=f(N);try{for(B.s();!(G=B.n()).done;){var q=c(G.value,2),V=q[0],W=q[1],H="".concat(M,"-").concat(sB(W),"-").concat(V);w.add(H),t.rules.allvar.cache.has(H)||(t.rules.allvar.cache.add(H),iB(W,[".".concat(H)],[],n,(function(n){m.allvar.apply(n)})))}}catch(J){B.e(J)}finally{B.f()}}}}catch(J){A.e(J)}finally{A.f()}}}catch(J){S.e(J)}finally{S.f()}if("object"==typeof l&&l){var X="".concat(i,"-i").concat(sB(l),"-css");w.add(X),t.rules.inline.cache.has(X)||(t.rules.inline.cache.add(X),iB(l,[".".concat(X)],[],n,(function(n){m.inline.apply(n)})))}var Y,$=f(String(o.className||"").trim().split(/\s+/));try{for($.s();!(Y=$.n()).done;){var Z=Y.value;Z&&w.add(Z)}}catch(J){$.e(J)}finally{$.f()}var K=g.className=x(w).join(" ");return{type:e.type,className:K,selector:h,props:g,toString:function(){return K},deferredInjector:d}};return WG(g,(l(o={className:i,selector:h},VG,e),l(o,"toString",(function(){return t.rules.styled.cache.has(i)||g(),i})),o))},yB=function(n){var e,t="",r=[],o={},a=[],i=f(n);try{for(i.s();!(e=i.n()).done;){var v=c(e.value,6),l=v[0],s=v[4],u=v[5];for(var p in""===t&&(t=l),r.push(l),a.push.apply(a,x(u)),s){var d=s[p];(void 0===o[p]||"undefined"!==d||u.includes(d))&&(o[p]=d)}}}catch(m){i.e(m)}finally{i.f()}return[t,r,o,new Set(a)]},bB=function(n,e,t,r){var o,a=[],i=f(n);try{n:for(i.s();!(o=i.n()).done;){var v=c(o.value,3),s=v[0],u=v[1];if(!v[2]){var p=void 0,d=0,m=!1;for(p in s){var h=s[p],x=e[p];if(x!==h){if("object"!=typeof x||!x)continue n;var g=void 0,y=void 0,b=0;for(var _ in x){if(h===String(x[_])){if("@initial"!==_){var U=_.slice(1);(y=y||[]).push(U in t?t[U]:_.replace(/^@media ?/,"")),m=!0}d+=b,g=!0}++b}if(y&&y.length&&(u=l({},"@media "+y.join(", "),u)),!g)continue n}}(a[d]=a[d]||[]).push([r?"cv":"".concat(p,"-").concat(s[p]),u,m])}}}catch(w){i.e(w)}finally{i.f()}return a},_B={},UB=qG(),wB=function(n,e){return UB(n,(function(){return function(){for(var t=arguments.length,r=new Array(t),o=0;o<t;o++)r[o]=arguments[o];var a=function(){var t,o=f(r);try{for(o.s();!(t=o.n()).done;){var a=t.value,i=sB(a="object"==typeof a&&a||{});if(!e.rules.global.cache.has(i)){if(e.rules.global.cache.add(i),"@import"in a){var v,c=[].indexOf.call(e.sheet.cssRules,e.rules.themed.group)-1,l=f([].concat(a["@import"]));try{for(l.s();!(v=l.n()).done;){var s=v.value;s=s.includes('"')||s.includes("'")?s:'"'.concat(s,'"'),e.sheet.insertRule("@import ".concat(s,";"),c++)}}catch(u){l.e(u)}finally{l.f()}delete a["@import"]}iB(a,[],[],n,(function(n){e.rules.global.apply(n)}))}}}catch(u){o.e(u)}finally{o.f()}return""};return WG(a,{toString:a})}}))},SB=qG(),kB=function(n,e){return SB(n,(function(){return function(t){var r="".concat(tB(n.prefix),"k-").concat(sB(t)),o=function(){if(!e.rules.global.cache.has(r)){e.rules.global.cache.add(r);var o=[];iB(t,[],[],n,(function(n){return o.push(n)}));var a="@keyframes ".concat(r,"{").concat(o.join(""),"}");e.rules.global.apply(a)}return r};return WG(o,{get name(){return o()},toString:o})}}))},MB=function(){function n(e,t,r,o){y(this,n),this.token=null==e?"":String(e),this.value=null==t?"":String(t),this.scale=null==r?"":String(r),this.prefix=null==o?"":String(o)}return _(n,[{key:"computedValue",get:function(){return"var("+this.variable+")"}},{key:"variable",get:function(){return"--"+tB(this.prefix)+tB(this.scale)+this.token}},{key:"toString",value:function(){return this.computedValue}}]),n}(),zB=qG(),CB=function(n,e){return zB(n,(function(){return function(t,r){r="object"==typeof t&&t||Object(r);var o=".".concat(t=(t="string"==typeof t?t:"")||"".concat(tB(n.prefix),"t-").concat(sB(r))),a={},i=[];for(var v in r)for(var c in a[v]={},r[v]){var l="--".concat(tB(n.prefix)).concat(v,"-").concat(c),s=rB(String(r[v][c]),n.prefix,v);a[v][c]=new MB(c,s,v,n.prefix),i.push("".concat(l,":").concat(s))}var f=function(){if(i.length&&!e.rules.themed.cache.has(t)){e.rules.themed.cache.add(t);var o="".concat(r===n.theme?":root,":"",".").concat(t,"{").concat(i.join(";"),"}");e.rules.themed.apply(o)}return t};return u(u({},a),{},{get className(){return f()},selector:o,toString:f})}}))},TB=qG(),RB=qG(),DB=function(n){var e=function(n){var e=!1,t=TB(n,(function(n){e=!0;var t="prefix"in(n="object"==typeof n&&n||{})?String(n.prefix):"",r="object"==typeof n.media&&n.media||{},o="object"==typeof n.root?n.root||null:globalThis.document||null,a="object"==typeof n.theme&&n.theme||{},i={prefix:t,media:r,theme:a,themeMap:"object"==typeof n.themeMap&&n.themeMap||u({},GG),utils:"object"==typeof n.utils&&n.utils||{}},v=function(n){var e,t=function(){var n=e.sheet.cssRules;return[].map.call(n,(function(t,r){var o=t.cssText,a="";if(o.startsWith("--sxs"))return"";if(n[r-1]&&(a=n[r-1].cssText).startsWith("--sxs")){if(!t.cssRules.length)return"";for(var i in e.rules)if(e.rules[i].group===t)return"--sxs{--sxs:".concat(x(e.rules[i].cache).join(" "),"}").concat(o);return t.cssRules.length?"".concat(a).concat(o):""}return o})).join("")};return function r(){if(e){var o=e,a=o.rules,i=o.sheet;if(!i.deleteRule){for(;3===Object(Object(i.cssRules)[0]).type;)i.cssRules.splice(0,1);i.cssRules=[]}for(var v in a)delete a[v]}var c,l=f(Object(n).styleSheets||[]);try{for(l.s();!(c=l.n()).done;){var s=c.value;if(fB(s)){for(var u=0,p=s.cssRules;p[u];++u){var d=Object(p[u]);if(1===d.type){var m=Object(p[u+1]);if(4===m.type){++u;var h=d.cssText;if(h.startsWith("--sxs")){var x=h.slice(14,-3).trim().split(/\s+/),g=uB[x[0]];g&&(e||(e={sheet:s,reset:r,rules:{},toString:t}),e.rules[g]={group:m,index:u,cache:new Set(x)})}}}}if(e)break}}}catch(M){l.e(M)}finally{l.f()}e||(e={sheet:n?(n.head||n).appendChild(document.createElement("style")).sheet:function n(e,t){return{type:t,cssRules:[],insertRule:function(e,t){this.cssRules.splice(t,0,n(e,{import:3,undefined:1}[(e.toLowerCase().match(/^@([a-z]+)/)||[])[1]]||4))},get cssText(){return"@media{}"===e?"@media{".concat([].map.call(this.cssRules,(function(n){return n.cssText})).join(""),"}"):e}}}("","text/css"),rules:{},reset:r,toString:t});for(var y=e,b=y.sheet,_=y.rules,U=uB.length-1;U>=0;--U){var w=uB[U];if(!_[w]){var S=uB[U+1],k=_[S]?_[S].index:b.cssRules.length;b.insertRule("@media{}",k),b.insertRule("--sxs{--sxs:".concat(U,"}"),k),_[w]={group:b.cssRules[k+1],index:k,cache:new Set([U])}}pB(_[w])}}(),e}(o),c={css:hB(i,v),globalCss:wB(i,v),keyframes:kB(i,v),createTheme:CB(i,v),reset:function(){v.reset(),c.theme.toString()},theme:{},sheet:v,config:i,prefix:t,getCssText:v.toString,toString:v.toString};return String(c.theme=c.createTheme(a)),c}));return e||t.reset(),t}(n);return e.styled=function(n){var e=n.config,t=n.sheet;return RB(e,(function(){var n=hB(e,t);return function(){var e=n.apply(void 0,arguments),t=e[VG].type,r=Ad.forwardRef((function(n,r){var o=n&&n.as||t,a=e(n),i=a.props,v=a.deferredInjector;return delete i.as,i.ref=r,v?Ad.createElement(Ad.Fragment,null,Ad.createElement(o,i),Ad.createElement(v,null)):Ad.createElement(o,i)}));return r.className=e.className,r.displayName="Styled.".concat(t.displayName||t.name||t),r.selector=e.selector,r.toString=function(){return e.selector},r[VG]=e[VG],r}}))}(e),e};function PB(n,e,t){return Math.max(e,Math.min(n,t))}var jB=function(n,e){return void 0===n&&(n=e),Array.isArray(n)?n:[n,n]},FB=function(n,e){return[n[0]+e[0],n[1]+e[1]]},EB=function(n,e){return[n[0]-e[0],n[1]-e[1]]},IB=function(n,e){n[0]+=e[0],n[1]+=e[1]};function OB(n,e,t){return 0===e||Math.abs(e)===1/0?Math.pow(n,5*t):n*e*t/(e+t*n)}function LB(n,e,t){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.15;return 0===r?PB(n,e,t):n<e?-OB(e-n,t-e,r)+e:n>t?+OB(n-t,t-e,r)+t:n}function AB(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function NB(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function GB(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?NB(Object(t),!0).forEach((function(e){AB(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):NB(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var BB={pointer:{start:"down",change:"move",end:"up"},mouse:{start:"down",change:"move",end:"up"},touch:{start:"start",change:"move",end:"end"},gesture:{start:"start",change:"change",end:"end"}};function qB(n){return n?n[0].toUpperCase()+n.slice(1):""}var VB=["enter","leave"];function WB(){var n=arguments.length>0&&void 0!==arguments[0]&&arguments[0],e=arguments.length>1?arguments[1]:void 0;return n&&!VB.includes(e)}function HB(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",t=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=BB[n],o=r&&r[e]||e;return"on"+qB(n)+qB(o)+(WB(t,o)?"Capture":"")}var XB=["gotpointercapture","lostpointercapture"];function YB(n){var e=n.substring(2).toLowerCase(),t=!!~e.indexOf("passive");t&&(e=e.replace("passive",""));var r=XB.includes(e)?"capturecapture":"capture",o=!!~e.indexOf(r);return o&&(e=e.replace("capture","")),{device:e,capture:o,passive:t}}function $B(n){return"touches"in n}function ZB(n){return $B(n)?"touch":"pointerType"in n?n.pointerType:"mouse"}function KB(n){return $B(n)?function(n){return"touchend"===n.type||"touchcancel"===n.type?n.changedTouches:n.targetTouches}(n)[0]:n}function JB(n){return function(n){return Array.from(n.touches).filter((function(e){var t,r;return e.target===n.currentTarget||(null===(t=n.currentTarget)||void 0===t||null===(r=t.contains)||void 0===r?void 0:r.call(t,e.target))}))}(n).map((function(n){return n.identifier}))}function QB(n){var e=KB(n);return $B(n)?e.identifier:e.pointerId}function nq(n){var e=KB(n);return[e.clientX,e.clientY]}function eq(n){if("function"===typeof n){for(var e=arguments.length,t=new Array(e>1?e-1:0),r=1;r<e;r++)t[r-1]=arguments[r];return n.apply(void 0,t)}return n}function tq(){}function rq(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return 0===e.length?tq:1===e.length?e[0]:function(){var n,t,r=f(e);try{for(r.s();!(t=r.n()).done;){var o=t.value;n=o.apply(this,arguments)||n}}catch(a){r.e(a)}finally{r.f()}return n}}function oq(n,e){return Object.assign({},e,n||{})}var aq=function(){function n(e,t,r){y(this,n),this.ctrl=e,this.args=t,this.key=r,this.state||(this.state={},this.computeValues([0,0]),this.computeInitial(),this.init&&this.init(),this.reset())}return _(n,[{key:"state",get:function(){return this.ctrl.state[this.key]},set:function(n){this.ctrl.state[this.key]=n}},{key:"shared",get:function(){return this.ctrl.state.shared}},{key:"eventStore",get:function(){return this.ctrl.gestureEventStores[this.key]}},{key:"timeoutStore",get:function(){return this.ctrl.gestureTimeoutStores[this.key]}},{key:"config",get:function(){return this.ctrl.config[this.key]}},{key:"sharedConfig",get:function(){return this.ctrl.config.shared}},{key:"handler",get:function(){return this.ctrl.handlers[this.key]}},{key:"reset",value:function(){var n=this.state,e=this.shared,t=this.ingKey,r=this.args;e[t]=n._active=n.active=n._blocked=n._force=!1,n._step=[!1,!1],n.intentional=!1,n._movement=[0,0],n._distance=[0,0],n._direction=[0,0],n._delta=[0,0],n._bounds=[[-1/0,1/0],[-1/0,1/0]],n.args=r,n.axis=void 0,n.memo=void 0,n.elapsedTime=0,n.direction=[0,0],n.distance=[0,0],n.overflow=[0,0],n._movementBound=[!1,!1],n.velocity=[0,0],n.movement=[0,0],n.delta=[0,0],n.timeStamp=0}},{key:"start",value:function(n){var e=this.state,t=this.config;e._active||(this.reset(),this.computeInitial(),e._active=!0,e.target=n.target,e.currentTarget=n.currentTarget,e.lastOffset=t.from?eq(t.from,e):e.offset,e.offset=e.lastOffset),e.startTime=e.timeStamp=n.timeStamp}},{key:"computeValues",value:function(n){var e=this.state;e._values=n,e.values=this.config.transform(n)}},{key:"computeInitial",value:function(){var n=this.state;n._initial=n._values,n.initial=n.values}},{key:"compute",value:function(n){var e=this.state,t=this.config,r=this.shared;e.args=this.args;var o=0;if(n&&(e.event=n,t.preventDefault&&n.cancelable&&e.event.preventDefault(),e.type=n.type,r.touches=this.ctrl.pointerIds.size||this.ctrl.touchIds.size,r.locked=!!document.pointerLockElement,Object.assign(r,function(n){var e={};if("buttons"in n&&(e.buttons=n.buttons),"shiftKey"in n){var t=n.shiftKey,r=n.altKey,o=n.metaKey,a=n.ctrlKey;Object.assign(e,{shiftKey:t,altKey:r,metaKey:o,ctrlKey:a})}return e}(n)),r.down=r.pressed=r.buttons%2===1||r.touches>0,o=n.timeStamp-e.timeStamp,e.timeStamp=n.timeStamp,e.elapsedTime=e.timeStamp-e.startTime),e._active){var a=e._delta.map(Math.abs);IB(e._distance,a)}this.axisIntent&&this.axisIntent(n);var i=c(e._movement,2),v=i[0],l=i[1],s=c(t.threshold,2),u=s[0],f=s[1],p=e._step,d=e.values;if(t.hasCustomTransform?(!1===p[0]&&(p[0]=Math.abs(v)>=u&&d[0]),!1===p[1]&&(p[1]=Math.abs(l)>=f&&d[1])):(!1===p[0]&&(p[0]=Math.abs(v)>=u&&Math.sign(v)*u),!1===p[1]&&(p[1]=Math.abs(l)>=f&&Math.sign(l)*f)),e.intentional=!1!==p[0]||!1!==p[1],e.intentional){var m=[0,0];if(t.hasCustomTransform){var h=c(d,2),x=h[0],g=h[1];m[0]=!1!==p[0]?x-p[0]:0,m[1]=!1!==p[1]?g-p[1]:0}else m[0]=!1!==p[0]?v-p[0]:0,m[1]=!1!==p[1]?l-p[1]:0;this.restrictToAxis&&!e._blocked&&this.restrictToAxis(m);var y=e.offset,b=e._active&&!e._blocked||e.active;b&&(e.first=e._active&&!e.active,e.last=!e._active&&e.active,e.active=r[this.ingKey]=e._active,n&&(e.first&&("bounds"in t&&(e._bounds=eq(t.bounds,e)),this.setup&&this.setup()),e.movement=m,this.computeOffset()));var _=c(e.offset,2),U=_[0],w=_[1],S=c(e._bounds,2),k=c(S[0],2),M=k[0],z=k[1],C=c(S[1],2),T=C[0],R=C[1];e.overflow=[U<M?-1:U>z?1:0,w<T?-1:w>R?1:0],e._movementBound[0]=!!e.overflow[0]&&(!1===e._movementBound[0]?e._movement[0]:e._movementBound[0]),e._movementBound[1]=!!e.overflow[1]&&(!1===e._movementBound[1]?e._movement[1]:e._movementBound[1]);var D=e._active&&t.rubberband||[0,0];if(e.offset=function(n,e,t){var r=c(e,2),o=r[0],a=r[1],i=c(t,2),v=i[0],l=i[1],s=c(n,2),u=c(s[0],2),f=u[0],p=u[1],d=c(s[1],2),m=d[0],h=d[1];return[LB(o,f,p,v),LB(a,m,h,l)]}(e._bounds,e.offset,D),e.delta=EB(e.offset,y),this.computeMovement(),b&&(!e.last||o>32)){e.delta=EB(e.offset,y);var P=e.delta.map(Math.abs);IB(e.distance,P),e.direction=e.delta.map(Math.sign),e._direction=e._delta.map(Math.sign),!e.first&&o>0&&(e.velocity=[P[0]/o,P[1]/o])}}}},{key:"emit",value:function(){var n=this.state,e=this.shared,t=this.config;if(n._active||this.clean(),!n._blocked&&n.intentional||n._force||t.triggerAllEvents){var r=this.handler(GB(GB(GB({},e),n),{},l({},this.aliasKey,n.values)));void 0!==r&&(n.memo=r)}}},{key:"clean",value:function(){this.eventStore.clean(),this.timeoutStore.clean()}}]),n}();var iq=function(n){U(t,n);var e=z(t);function t(){var n;y(this,t);for(var r=arguments.length,o=new Array(r),a=0;a<r;a++)o[a]=arguments[a];return AB(k(n=e.call.apply(e,[this].concat(o))),"aliasKey","xy"),n}return _(t,[{key:"reset",value:function(){P(w(t.prototype),"reset",this).call(this),this.state.axis=void 0}},{key:"init",value:function(){this.state.offset=[0,0],this.state.lastOffset=[0,0]}},{key:"computeOffset",value:function(){this.state.offset=FB(this.state.lastOffset,this.state.movement)}},{key:"computeMovement",value:function(){this.state.movement=EB(this.state.offset,this.state.lastOffset)}},{key:"axisIntent",value:function(n){var e=this.state,t=this.config;if(!e.axis&&n){var r="object"===typeof t.axisThreshold?t.axisThreshold[ZB(n)]:t.axisThreshold;e.axis=function(n,e){var t=c(n,2),r=t[0],o=t[1],a=Math.abs(r),i=Math.abs(o);return a>i&&a>e?"x":i>a&&i>e?"y":void 0}(e._movement,r)}e._blocked=(t.lockDirection||!!t.axis)&&!e.axis||!!t.axis&&t.axis!==e.axis}},{key:"restrictToAxis",value:function(n){if(this.config.axis||this.config.lockDirection)switch(this.state.axis){case"x":n[1]=0;break;case"y":n[0]=0}}}]),t}(aq),vq=function(n){return n},cq=.15,lq={enabled:function(){var n=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return n},eventOptions:function(n,e,t){return GB(GB({},t.shared.eventOptions),n)},preventDefault:function(){var n=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return n},triggerAllEvents:function(){var n=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return n},rubberband:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(n){case!0:return[cq,cq];case!1:return[0,0];default:return jB(n)}},from:function(n){return"function"===typeof n?n:null!=n?jB(n):void 0},transform:function(n,e,t){var r=n||t.shared.transform;return this.hasCustomTransform=!!r,r||vq},threshold:function(n){return jB(n,0)}};var sq=GB(GB({},lq),{},{axis:function(n,e,t){var r=t.axis;if(this.lockDirection="lock"===r,!this.lockDirection)return r},axisThreshold:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return n},bounds:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("function"===typeof n)return function(e){return sq.bounds(n(e))};if("current"in n)return function(){return n.current};if("function"===typeof HTMLElement&&n instanceof HTMLElement)return n;var e=n.left,t=void 0===e?-1/0:e,r=n.right,o=void 0===r?1/0:r,a=n.top,i=void 0===a?-1/0:a,v=n.bottom,c=void 0===v?1/0:v;return[[t,o],[i,c]]}}),uq=10,fq={ArrowRight:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return[uq*n,0]},ArrowLeft:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return[-10*n,0]},ArrowUp:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return[0,-10*n]},ArrowDown:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return[0,uq*n]}},pq=function(n){U(t,n);var e=z(t);function t(){var n;y(this,t);for(var r=arguments.length,o=new Array(r),a=0;a<r;a++)o[a]=arguments[a];return AB(k(n=e.call.apply(e,[this].concat(o))),"ingKey","dragging"),n}return _(t,[{key:"reset",value:function(){P(w(t.prototype),"reset",this).call(this);var n=this.state;n._pointerId=void 0,n._pointerActive=!1,n._keyboardActive=!1,n._preventScroll=!1,n._delayed=!1,n.swipe=[0,0],n.tap=!1,n.canceled=!1,n.cancel=this.cancel.bind(this)}},{key:"setup",value:function(){var n=this.state;if(n._bounds instanceof HTMLElement){var e=n._bounds.getBoundingClientRect(),t=n.currentTarget.getBoundingClientRect(),r={left:e.left-t.left+n.offset[0],right:e.right-t.right+n.offset[0],top:e.top-t.top+n.offset[1],bottom:e.bottom-t.bottom+n.offset[1]};n._bounds=sq.bounds(r)}}},{key:"cancel",value:function(){var n=this,e=this.state;e.canceled||(e.canceled=!0,e._active=!1,setTimeout((function(){n.compute(),n.emit()}),0))}},{key:"setActive",value:function(){this.state._active=this.state._pointerActive||this.state._keyboardActive}},{key:"clean",value:function(){this.pointerClean(),this.state._pointerActive=!1,this.state._keyboardActive=!1,P(w(t.prototype),"clean",this).call(this)}},{key:"pointerDown",value:function(n){var e=this.config,t=this.state;if(null==n.buttons||(Array.isArray(e.pointerButtons)?e.pointerButtons.includes(n.buttons):-1===e.pointerButtons||e.pointerButtons===n.buttons)){var r=this.ctrl.setEventIds(n);e.pointerCapture&&n.target.setPointerCapture(n.pointerId),r&&r.size>1&&t._pointerActive||(this.start(n),this.setupPointer(n),t._pointerId=QB(n),t._pointerActive=!0,this.computeValues(nq(n)),this.computeInitial(),e.preventScrollAxis&&"mouse"!==ZB(n)?(t._active=!1,this.setupScrollPrevention(n)):e.delay>0?(this.setupDelayTrigger(n),e.triggerAllEvents&&(this.compute(n),this.emit())):this.startPointerDrag(n))}}},{key:"startPointerDrag",value:function(n){var e=this.state;e._active=!0,e._preventScroll=!0,e._delayed=!1,this.compute(n),this.emit()}},{key:"pointerMove",value:function(n){var e=this.state,t=this.config;if(e._pointerActive&&(e.type!==n.type||n.timeStamp!==e.timeStamp)){var r=QB(n);if(void 0===e._pointerId||r===e._pointerId){var o=nq(n);return document.pointerLockElement===n.target?e._delta=[n.movementX,n.movementY]:(e._delta=EB(o,e._values),this.computeValues(o)),IB(e._movement,e._delta),this.compute(n),e._delayed&&e.intentional?(this.timeoutStore.remove("dragDelay"),e.active=!1,void this.startPointerDrag(n)):t.preventScrollAxis&&!e._preventScroll?e.axis?e.axis===t.preventScrollAxis||"xy"===t.preventScrollAxis?(e._active=!1,void this.clean()):(this.timeoutStore.remove("startPointerDrag"),void this.startPointerDrag(n)):void 0:void this.emit()}}}},{key:"pointerUp",value:function(n){this.ctrl.setEventIds(n);try{this.config.pointerCapture&&n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId)}catch(S){0}var e=this.state,t=this.config;if(e._active&&e._pointerActive){var r=QB(n);if(void 0===e._pointerId||r===e._pointerId){this.state._pointerActive=!1,this.setActive(),this.compute(n);var o=c(e._distance,2),a=o[0],i=o[1];if(e.tap=a<=t.tapsThreshold&&i<=t.tapsThreshold,e.tap&&t.filterTaps)e._force=!0;else{var v=c(e.direction,2),l=v[0],s=v[1],u=c(e.velocity,2),f=u[0],p=u[1],d=c(e.movement,2),m=d[0],h=d[1],x=c(t.swipe.velocity,2),g=x[0],y=x[1],b=c(t.swipe.distance,2),_=b[0],U=b[1],w=t.swipe.duration;e.elapsedTime<w&&(Math.abs(f)>g&&Math.abs(m)>_&&(e.swipe[0]=l),Math.abs(p)>y&&Math.abs(h)>U&&(e.swipe[1]=s))}this.emit()}}}},{key:"pointerClick",value:function(n){!this.state.tap&&n.detail>0&&(n.preventDefault(),n.stopPropagation())}},{key:"setupPointer",value:function(n){var e=this.config,t=e.device;e.pointerLock&&n.currentTarget.requestPointerLock(),e.pointerCapture||(this.eventStore.add(this.sharedConfig.window,t,"change",this.pointerMove.bind(this)),this.eventStore.add(this.sharedConfig.window,t,"end",this.pointerUp.bind(this)),this.eventStore.add(this.sharedConfig.window,t,"cancel",this.pointerUp.bind(this)))}},{key:"pointerClean",value:function(){this.config.pointerLock&&document.pointerLockElement===this.state.currentTarget&&document.exitPointerLock()}},{key:"preventScroll",value:function(n){this.state._preventScroll&&n.cancelable&&n.preventDefault()}},{key:"setupScrollPrevention",value:function(n){this.state._preventScroll=!1,function(n){"persist"in n&&"function"===typeof n.persist&&n.persist()}(n);var e=this.eventStore.add(this.sharedConfig.window,"touch","change",this.preventScroll.bind(this),{passive:!1});this.eventStore.add(this.sharedConfig.window,"touch","end",e),this.eventStore.add(this.sharedConfig.window,"touch","cancel",e),this.timeoutStore.add("startPointerDrag",this.startPointerDrag.bind(this),this.config.preventScrollDelay,n)}},{key:"setupDelayTrigger",value:function(n){var e=this;this.state._delayed=!0,this.timeoutStore.add("dragDelay",(function(){e.state._step=[0,0],e.startPointerDrag(n)}),this.config.delay)}},{key:"keyDown",value:function(n){var e=fq[n.key];if(e){var t=this.state,r=n.shiftKey?10:n.altKey?.1:1;this.start(n),t._delta=e(r),t._keyboardActive=!0,IB(t._movement,t._delta),this.compute(n),this.emit()}}},{key:"keyUp",value:function(n){n.key in fq&&(this.state._keyboardActive=!1,this.setActive(),this.compute(n),this.emit())}},{key:"bind",value:function(n){var e=this.config.device;n(e,"start",this.pointerDown.bind(this)),this.config.pointerCapture&&(n(e,"change",this.pointerMove.bind(this)),n(e,"end",this.pointerUp.bind(this)),n(e,"cancel",this.pointerUp.bind(this)),n("lostPointerCapture","",this.pointerUp.bind(this))),this.config.keys&&(n("key","down",this.keyDown.bind(this)),n("key","up",this.keyUp.bind(this))),this.config.filterTaps&&n("click","",this.pointerClick.bind(this),{capture:!0,passive:!1})}}]),t}(iq);var dq="undefined"!==typeof window&&window.document&&window.document.createElement;function mq(){return dq&&"ontouchstart"in window||dq&&window.navigator.maxTouchPoints>1}var hq={isBrowser:dq,gesture:function(){try{return"constructor"in GestureEvent}catch(n){return!1}}(),touch:mq(),touchscreen:mq(),pointer:dq&&"onpointerdown"in window,pointerLock:dq&&"exitPointerLock"in window.document},xq={mouse:0,touch:0,pen:8},gq=GB(GB({},sq),{},{device:function(n,e,t){var r=t.pointer,o=(r=void 0===r?{}:r).touch,a=void 0!==o&&o,i=r.lock,v=void 0!==i&&i,c=r.mouse,l=void 0!==c&&c;return this.pointerLock=v&&hq.pointerLock,hq.touch&&a?"touch":this.pointerLock?"mouse":hq.pointer&&!l?"pointer":hq.touch?"touch":"mouse"},preventScrollAxis:function(n,e,t){var r=t.preventScroll;if(this.preventScrollDelay="number"===typeof r?r:r||void 0===r&&n?250:void 0,hq.touchscreen&&!1!==r)return n||(void 0!==r?"y":void 0)},pointerCapture:function(n,e,t){var r=t.pointer,o=(r=void 0===r?{}:r).capture,a=void 0===o||o,i=r.buttons,v=void 0===i?1:i,c=r.keys,l=void 0===c||c;return this.pointerButtons=v,this.keys=l,!this.pointerLock&&"pointer"===this.device&&a},threshold:function(n,e,t){var r=t.filterTaps,o=void 0!==r&&r,a=t.tapsThreshold,i=void 0===a?3:a,v=t.axis,c=jB(n,o?i:(void 0===v?void 0:v)?1:0);return this.filterTaps=o,this.tapsThreshold=i,c},swipe:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.velocity,t=void 0===e?.5:e,r=n.distance,o=void 0===r?50:r,a=n.duration,i=void 0===a?250:a;return{velocity:this.transform(jB(t)),distance:this.transform(jB(o)),duration:i}},delay:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;switch(n){case!0:return 180;case!1:return 0;default:return n}},axisThreshold:function(n){return n?GB(GB({},xq),n):xq}});GB(GB({},lq),{},{device:function(n,e,t){var r=t.shared,o=t.pointer,a=(o=void 0===o?{}:o).touch,i=void 0!==a&&a;if(r.target&&!hq.touch&&hq.gesture)return"gesture";if(hq.touch&&i)return"touch";if(hq.touchscreen){if(hq.pointer)return"pointer";if(hq.touch)return"touch"}},bounds:function(n,e,t){var r=t.scaleBounds,o=void 0===r?{}:r,a=t.angleBounds,i=void 0===a?{}:a,v=function(n){var e=oq(eq(o,n),{min:-1/0,max:1/0});return[e.min,e.max]},c=function(n){var e=oq(eq(i,n),{min:-1/0,max:1/0});return[e.min,e.max]};return"function"!==typeof o&&"function"!==typeof i?[v(),c()]:function(n){return[v(n),c(n)]}},threshold:function(n,e,t){this.lockDirection="lock"===t.axis;var r=jB(n,this.lockDirection?[.1,3]:0);return r},modifierKey:function(n){return void 0===n?"ctrlKey":n},pinchOnWheel:function(){var n=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return n}}),GB(GB({},sq),{},{mouseOnly:function(){var n=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return n}}),GB(GB({},sq),{},{mouseOnly:function(){var n=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return n}});var yq=new Map,bq=new Map;var _q={key:"drag",engine:pq,resolver:gq};function Uq(n,e){if(null==n)return{};var t,r,o=function(n,e){if(null==n)return{};var t,r,o={},a=Object.keys(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||(o[t]=n[t]);return o}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(o[t]=n[t])}return o}var wq={target:function(n){if(n)return function(){return"current"in n?n.current:n}},enabled:function(){var n=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return n},window:function(n){function e(){return n.apply(this,arguments)}return e.toString=function(){return n.toString()},e}((function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:hq.isBrowser?window:void 0;return n})),eventOptions:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.passive,t=void 0===e||e,r=n.capture,o=void 0!==r&&r;return{passive:t,capture:o}},transform:function(n){return n}},Sq=["target","eventOptions","window","enabled","transform"];function kq(){for(var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments.length>1?arguments[1]:void 0,t={},r=0,o=Object.entries(e);r<o.length;r++){var a=c(o[r],2),i=a[0],v=a[1];switch(typeof v){case"function":t[i]=v.call(t,n[i],i,n);break;case"object":t[i]=kq(n[i],v);break;case"boolean":v&&(t[i]=n[i])}}return t}var Mq=function(){function n(e,t){y(this,n),AB(this,"_listeners",new Set),this._ctrl=e,this._gestureKey=t}return _(n,[{key:"add",value:function(n,e,t,r,o){var a=this._listeners,i=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",t=BB[n],r=t&&t[e]||e;return n+r}(e,t),v=GB(GB({},this._gestureKey?this._ctrl.config[this._gestureKey].eventOptions:{}),o);n.addEventListener(i,r,v);var c=function e(){n.removeEventListener(i,r,v),a.delete(e)};return a.add(c),c}},{key:"clean",value:function(){this._listeners.forEach((function(n){return n()})),this._listeners.clear()}}]),n}(),zq=function(){function n(){y(this,n),AB(this,"_timeouts",new Map)}return _(n,[{key:"add",value:function(n,e){var t,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:140;this.remove(n);for(var o=arguments.length,a=new Array(o>3?o-3:0),i=3;i<o;i++)a[i-3]=arguments[i];this._timeouts.set(n,(t=window).setTimeout.apply(t,[e,r].concat(a)))}},{key:"remove",value:function(n){var e=this._timeouts.get(n);e&&window.clearTimeout(e)}},{key:"clean",value:function(){this._timeouts.forEach((function(n){window.clearTimeout(n)})),this._timeouts.clear()}}]),n}(),Cq=function(){function n(e){y(this,n),AB(this,"gestures",new Set),AB(this,"_targetEventStore",new Mq(this)),AB(this,"gestureEventStores",{}),AB(this,"gestureTimeoutStores",{}),AB(this,"handlers",{}),AB(this,"config",{}),AB(this,"pointerIds",new Set),AB(this,"touchIds",new Set),AB(this,"state",{shared:{shiftKey:!1,metaKey:!1,ctrlKey:!1,altKey:!1}}),function(n,e){e.drag&&Tq(n,"drag");e.wheel&&Tq(n,"wheel");e.scroll&&Tq(n,"scroll");e.move&&Tq(n,"move");e.pinch&&Tq(n,"pinch");e.hover&&Tq(n,"hover")}(this,e)}return _(n,[{key:"setEventIds",value:function(n){return $B(n)?(this.touchIds=new Set(JB(n)),this.touchIds):"pointerId"in n?("pointerup"===n.type||"pointercancel"===n.type?this.pointerIds.delete(n.pointerId):"pointerdown"===n.type&&this.pointerIds.add(n.pointerId),this.pointerIds):void 0}},{key:"applyHandlers",value:function(n,e){this.handlers=n,this.nativeHandlers=e}},{key:"applyConfig",value:function(n,e){this.config=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=n,o=r.target,a=r.eventOptions,i=r.window,v=r.enabled,c=r.transform,l=Uq(r,Sq);if(t.shared=kq({target:o,eventOptions:a,window:i,enabled:v,transform:c},wq),e){var s=bq.get(e);t[e]=kq(GB({shared:t.shared},l),s)}else for(var u in l){var f=bq.get(u);f&&(t[u]=kq(GB({shared:t.shared},l[u]),f))}return t}(n,e,this.config)}},{key:"clean",value:function(){this._targetEventStore.clean();var n,e=f(this.gestures);try{for(e.s();!(n=e.n()).done;){var t=n.value;this.gestureEventStores[t].clean(),this.gestureTimeoutStores[t].clean()}}catch(r){e.e(r)}finally{e.f()}}},{key:"effect",value:function(){var n=this;return this.config.shared.target&&this.bind(),function(){return n._targetEventStore.clean()}}},{key:"bind",value:function(){for(var n=this,e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];var o,a=this.config.shared,i={};if(!a.target||(o=a.target())){if(a.enabled){var v,c=f(this.gestures);try{for(c.s();!(v=c.n()).done;){var l=v.value,s=this.config[l],u=Rq(i,s.eventOptions,!!o);if(s.enabled){var p=yq.get(l);new p(this,t,l).bind(u)}}}catch(S){c.e(S)}finally{c.f()}var d=Rq(i,a.eventOptions,!!o),m=function(e){d(e,"",(function(r){return n.nativeHandlers[e](GB(GB({},n.state.shared),{},{event:r,args:t}))}),void 0,!0)};for(var h in this.nativeHandlers)m(h)}for(var g in i)i[g]=rq.apply(void 0,x(i[g]));if(!o)return i;for(var y in i){var b=YB(y),_=b.device,U=b.capture,w=b.passive;this._targetEventStore.add(o,_,"",i[y],{capture:U,passive:w})}}}}]),n}();function Tq(n,e){n.gestures.add(e),n.gestureEventStores[e]=new Mq(n,e),n.gestureTimeoutStores[e]=new zq}var Rq=function(n,e,t){return function(r,o,a){var i,v,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},l=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=null!==(i=c.capture)&&void 0!==i?i:e.capture,u=null!==(v=c.passive)&&void 0!==v?v:e.passive,f=l?r:HB(r,o,s);t&&u&&(f+="Passive"),n[f]=n[f]||[],n[f].push(a)}};function Dq(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,o=Ad.useMemo((function(){return new Cq(n)}),[]);if(o.applyHandlers(n,r),o.applyConfig(e,t),Ad.useEffect(o.effect.bind(o)),Ad.useEffect((function(){return o.clean.bind(o)}),[]),void 0===e.target)return o.bind.bind(o)}function Pq(n,e){var t;return t=_q,yq.set(t.key,t.engine),bq.set(t.key,t.resolver),Dq({drag:n},e||{},"drag")}function jq(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=t.checkForDefaultPrevented,o=void 0===r||r;return function(t){if(null===n||void 0===n||n(t),!1===o||!t.defaultPrevented)return null===e||void 0===e?void 0:e(t)}}var Fq=["scope","children"];function Eq(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],t=[];function o(e,o){var a=(0,Ad.createContext)(o),i=t.length;function v(e){var t=e.scope,o=e.children,v=r(e,Fq),c=(null===t||void 0===t?void 0:t[n][i])||a,l=(0,Ad.useMemo)((function(){return v}),Object.values(v));return(0,Ad.createElement)(c.Provider,{value:l},o)}return t=[].concat(x(t),[o]),v.displayName=e+"Provider",[v,function(t,r){var v=(null===r||void 0===r?void 0:r[n][i])||a,c=(0,Ad.useContext)(v);if(c)return c;if(void 0!==o)return o;throw new Error("`".concat(t,"` must be used within `").concat(e,"`"))}]}var a=function(){var e=t.map((function(n){return(0,Ad.createContext)(n)}));return function(t){var r=(null===t||void 0===t?void 0:t[n])||e;return(0,Ad.useMemo)((function(){return l({},"__scope".concat(n),u(u({},t),{},l({},n,r)))}),[t,r])}};return a.scopeName=n,[o,Iq.apply(void 0,[a].concat(x(e)))]}function Iq(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];var r=e[0];if(1===e.length)return r;var o=function(){var n=e.map((function(n){return{useScope:n(),scopeName:n.scopeName}}));return function(e){var t=n.reduce((function(n,t){var r=t.useScope,o=t.scopeName,a=r(e)["__scope".concat(o)];return u(u({},n),a)}),{});return(0,Ad.useMemo)((function(){return l({},"__scope".concat(r.scopeName),t)}),[t])}};return o.scopeName=r.scopeName,o}function Oq(n){var e=(0,Ad.useRef)(n);return(0,Ad.useEffect)((function(){e.current=n})),(0,Ad.useMemo)((function(){return function(){for(var n,t,r=arguments.length,o=new Array(r),a=0;a<r;a++)o[a]=arguments[a];return null===(t=e.current)||void 0===t?void 0:(n=t).call.apply(n,[e].concat(o))}}),[])}var Lq,Aq=["disableOutsidePointerEvents","onEscapeKeyDown","onPointerDownOutside","onFocusOutside","onInteractOutside","onDismiss"],Nq="dismissableLayer.update",Gq="dismissableLayer.pointerDownOutside",Bq="dismissableLayer.focusOutside",qq=(0,Ad.createContext)({layers:new Set,layersWithOutsidePointerEventsDisabled:new Set,branches:new Set}),Vq=(0,Ad.forwardRef)((function(n,e){var t,o=n.disableOutsidePointerEvents,a=void 0!==o&&o,i=n.onEscapeKeyDown,v=n.onPointerDownOutside,l=n.onFocusOutside,s=n.onInteractOutside,f=n.onDismiss,p=r(n,Aq),d=(0,Ad.useContext)(qq),m=c((0,Ad.useState)(null),2),h=m[0],g=m[1],y=null!==(t=null===h||void 0===h?void 0:h.ownerDocument)&&void 0!==t?t:null===globalThis||void 0===globalThis?void 0:globalThis.document,b=c((0,Ad.useState)({}),2)[1],_=nG(e,(function(n){return g(n)})),U=Array.from(d.layers),w=c(x(d.layersWithOutsidePointerEventsDisabled).slice(-1),1)[0],S=U.indexOf(w),k=h?U.indexOf(h):-1,M=d.layersWithOutsidePointerEventsDisabled.size>0,z=k>=S,C=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null===globalThis||void 0===globalThis?void 0:globalThis.document,t=Oq(n),r=(0,Ad.useRef)(!1),o=(0,Ad.useRef)((function(){}));return(0,Ad.useEffect)((function(){var n=function(n){if(n.target&&!r.current){var a=function(){Hq(Gq,t,i,{discrete:!0})},i={originalEvent:n};"touch"===n.pointerType?(e.removeEventListener("click",o.current),o.current=a,e.addEventListener("click",o.current,{once:!0})):a()}else e.removeEventListener("click",o.current);r.current=!1},a=window.setTimeout((function(){e.addEventListener("pointerdown",n)}),0);return function(){window.clearTimeout(a),e.removeEventListener("pointerdown",n),e.removeEventListener("click",o.current)}}),[e,t]),{onPointerDownCapture:function(){return r.current=!0}}}((function(n){var e=n.target,t=x(d.branches).some((function(n){return n.contains(e)}));z&&!t&&(null===v||void 0===v||v(n),null===s||void 0===s||s(n),n.defaultPrevented||null===f||void 0===f||f())}),y),T=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null===globalThis||void 0===globalThis?void 0:globalThis.document,t=Oq(n),r=(0,Ad.useRef)(!1);return(0,Ad.useEffect)((function(){var n=function(n){n.target&&!r.current&&Hq(Bq,t,{originalEvent:n},{discrete:!1})};return e.addEventListener("focusin",n),function(){return e.removeEventListener("focusin",n)}}),[e,t]),{onFocusCapture:function(){return r.current=!0},onBlurCapture:function(){return r.current=!1}}}((function(n){var e=n.target;x(d.branches).some((function(n){return n.contains(e)}))||(null===l||void 0===l||l(n),null===s||void 0===s||s(n),n.defaultPrevented||null===f||void 0===f||f())}),y);return function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null===globalThis||void 0===globalThis?void 0:globalThis.document,t=Oq(n);(0,Ad.useEffect)((function(){var n=function(n){"Escape"===n.key&&t(n)};return e.addEventListener("keydown",n),function(){return e.removeEventListener("keydown",n)}}),[t,e])}((function(n){k===d.layers.size-1&&(null===i||void 0===i||i(n),!n.defaultPrevented&&f&&(n.preventDefault(),f()))}),y),(0,Ad.useEffect)((function(){if(h)return a&&(0===d.layersWithOutsidePointerEventsDisabled.size&&(Lq=y.body.style.pointerEvents,y.body.style.pointerEvents="none"),d.layersWithOutsidePointerEventsDisabled.add(h)),d.layers.add(h),Wq(),function(){a&&1===d.layersWithOutsidePointerEventsDisabled.size&&(y.body.style.pointerEvents=Lq)}}),[h,y,a,d]),(0,Ad.useEffect)((function(){return function(){h&&(d.layers.delete(h),d.layersWithOutsidePointerEventsDisabled.delete(h),Wq())}}),[h,d]),(0,Ad.useEffect)((function(){var n=function(){return b({})};return document.addEventListener(Nq,n),function(){return document.removeEventListener(Nq,n)}}),[]),(0,Ad.createElement)(cG.div,ih({},p,{ref:_,style:u({pointerEvents:M?z?"auto":"none":void 0},n.style),onFocusCapture:jq(n.onFocusCapture,T.onFocusCapture),onBlurCapture:jq(n.onBlurCapture,T.onBlurCapture),onPointerDownCapture:jq(n.onPointerDownCapture,C.onPointerDownCapture)}))}));function Wq(){var n=new CustomEvent(Nq);document.dispatchEvent(n)}function Hq(n,e,t,r){var o=r.discrete,a=t.originalEvent.target,i=new CustomEvent(n,{bubbles:!1,cancelable:!0,detail:t});e&&a.addEventListener(n,e,{once:!0}),o?function(n,e){n&&(0,KN.flushSync)((function(){return n.dispatchEvent(e)}))}(a,i):a.dispatchEvent(i)}var Xq=Boolean(null===globalThis||void 0===globalThis?void 0:globalThis.document)?Ad.useLayoutEffect:function(){},Yq=Nd["useId".toString()]||function(){},$q=0;var Zq=["top","right","bottom","left"],Kq=Math.min,Jq=Math.max,Qq=Math.round,nV=Math.floor,eV=function(n){return{x:n,y:n}},tV={left:"right",right:"left",bottom:"top",top:"bottom"},rV={start:"end",end:"start"};function oV(n,e,t){return Jq(n,Kq(e,t))}function aV(n,e){return"function"===typeof n?n(e):n}function iV(n){return n.split("-")[0]}function vV(n){return n.split("-")[1]}function cV(n){return"x"===n?"y":"x"}function lV(n){return"y"===n?"height":"width"}function sV(n){return["top","bottom"].includes(iV(n))?"y":"x"}function uV(n){return cV(sV(n))}function fV(n,e,t){void 0===t&&(t=!1);var r=vV(n),o=uV(n),a=lV(o),i="x"===o?r===(t?"end":"start")?"right":"left":"start"===r?"bottom":"top";return e.reference[a]>e.floating[a]&&(i=hV(i)),[i,hV(i)]}function pV(n){var e=hV(n);return[dV(n),e,dV(e)]}function dV(n){return n.replace(/start|end/g,(function(n){return rV[n]}))}function mV(n,e,t,r){var o=vV(n),a=function(n,e,t){var r=["left","right"],o=["right","left"];switch(n){case"top":case"bottom":return t?e?o:r:e?r:o;case"left":case"right":return e?["top","bottom"]:["bottom","top"];default:return[]}}(iV(n),"start"===t,r);return o&&(a=a.map((function(n){return n+"-"+o})),e&&(a=a.concat(a.map(dV)))),a}function hV(n){return n.replace(/left|right|bottom|top/g,(function(n){return tV[n]}))}function xV(n){return"number"!==typeof n?function(n){return u({top:0,right:0,bottom:0,left:0},n)}(n):{top:n,right:n,bottom:n,left:n}}function gV(n){return u(u({},n),{},{top:n.y,left:n.x,right:n.x+n.width,bottom:n.y+n.height})}var yV=["mainAxis","crossAxis","fallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment"],bV=["strategy"],_V=["mainAxis","crossAxis","limiter"],UV=["apply"];function wV(n,e,t){var r,o=n.reference,a=n.floating,i=sV(e),v=uV(e),c=lV(v),l=iV(e),s="y"===i,u=o.x+o.width/2-a.width/2,f=o.y+o.height/2-a.height/2,p=o[c]/2-a[c]/2;switch(l){case"top":r={x:u,y:o.y-a.height};break;case"bottom":r={x:u,y:o.y+o.height};break;case"right":r={x:o.x+o.width,y:f};break;case"left":r={x:o.x-a.width,y:f};break;default:r={x:o.x,y:o.y}}switch(vV(e)){case"start":r[v]-=p*(t&&s?-1:1);break;case"end":r[v]+=p*(t&&s?-1:1)}return r}var SV=function(){var n=R(j().mark((function n(e,t,r){var o,a,i,v,c,s,f,p,d,m,h,x,g,y,b,_,U,w,S,k,M,z,C,T,R,D;return j().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return o=r.placement,a=void 0===o?"bottom":o,i=r.strategy,v=void 0===i?"absolute":i,c=r.middleware,s=void 0===c?[]:c,f=r.platform,p=s.filter(Boolean),n.next=4,null==f.isRTL?void 0:f.isRTL(t);case 4:return d=n.sent,n.next=7,f.getElementRects({reference:e,floating:t,strategy:v});case 7:m=n.sent,h=wV(m,a,d),x=h.x,g=h.y,y=a,b={},_=0,U=0;case 13:if(!(U<p.length)){n.next=46;break}return w=p[U],S=w.name,k=w.fn,n.next=17,k({x:x,y:g,initialPlacement:a,placement:y,strategy:v,middlewareData:b,rects:m,platform:f,elements:{reference:e,floating:t}});case 17:if(M=n.sent,z=M.x,C=M.y,T=M.data,R=M.reset,x=null!=z?z:x,g=null!=C?C:g,b=u(u({},b),{},l({},S,u(u({},b[S]),T))),!(R&&_<=50)){n.next=43;break}if(_++,"object"!==typeof R){n.next=41;break}if(R.placement&&(y=R.placement),!R.rects){n.next=38;break}if(!0!==R.rects){n.next=36;break}return n.next=33,f.getElementRects({reference:e,floating:t,strategy:v});case 33:n.t0=n.sent,n.next=37;break;case 36:n.t0=R.rects;case 37:m=n.t0;case 38:D=wV(m,y,d),x=D.x,g=D.y;case 41:return U=-1,n.abrupt("continue",43);case 43:U++,n.next=13;break;case 46:return n.abrupt("return",{x:x,y:g,placement:y,strategy:v,middlewareData:b});case 47:case"end":return n.stop()}}),n)})));return function(e,t,r){return n.apply(this,arguments)}}();function kV(n,e){return MV.apply(this,arguments)}function MV(){return MV=R(j().mark((function n(e,t){var r,o,a,i,v,c,l,s,f,p,d,m,h,x,g,y,b,_,U,w,S,k,M,z,C;return j().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return void 0===t&&(t={}),o=e.x,a=e.y,i=e.platform,v=e.rects,c=e.elements,l=e.strategy,s=aV(t,e),f=s.boundary,p=void 0===f?"clippingAncestors":f,d=s.rootBoundary,m=void 0===d?"viewport":d,h=s.elementContext,x=void 0===h?"floating":h,g=s.altBoundary,y=void 0!==g&&g,b=s.padding,_=xV(void 0===b?0:b),U="floating"===x?"reference":"floating",w=c[y?U:x],n.t0=gV,n.t1=i,n.next=10,null==i.isElement?void 0:i.isElement(w);case 10:if(n.t2=r=n.sent,null==n.t2){n.next=15;break}n.t3=r,n.next=16;break;case 15:n.t3=!0;case 16:if(!n.t3){n.next=20;break}n.t4=w,n.next=26;break;case 20:if(n.t5=w.contextElement,n.t5){n.next=25;break}return n.next=24,null==i.getDocumentElement?void 0:i.getDocumentElement(c.floating);case 24:n.t5=n.sent;case 25:n.t4=n.t5;case 26:return n.t6=n.t4,n.t7=p,n.t8=m,n.t9=l,n.t10={element:n.t6,boundary:n.t7,rootBoundary:n.t8,strategy:n.t9},n.next=33,n.t1.getClippingRect.call(n.t1,n.t10);case 33:return n.t11=n.sent,S=(0,n.t0)(n.t11),k="floating"===x?u(u({},v.floating),{},{x:o,y:a}):v.reference,n.next=38,null==i.getOffsetParent?void 0:i.getOffsetParent(c.floating);case 38:return M=n.sent,n.next=41,null==i.isElement?void 0:i.isElement(M);case 41:if(!n.sent){n.next=50;break}return n.next=44,null==i.getScale?void 0:i.getScale(M);case 44:if(n.t13=n.sent,n.t13){n.next=47;break}n.t13={x:1,y:1};case 47:n.t12=n.t13,n.next=51;break;case 50:n.t12={x:1,y:1};case 51:if(z=n.t12,n.t14=gV,!i.convertOffsetParentRelativeRectToViewportRelativeRect){n.next=59;break}return n.next=56,i.convertOffsetParentRelativeRectToViewportRelativeRect({rect:k,offsetParent:M,strategy:l});case 56:n.t15=n.sent,n.next=60;break;case 59:n.t15=k;case 60:return n.t16=n.t15,C=(0,n.t14)(n.t16),n.abrupt("return",{top:(S.top-C.top+_.top)/z.y,bottom:(C.bottom-S.bottom+_.bottom)/z.y,left:(S.left-C.left+_.left)/z.x,right:(C.right-S.right+_.right)/z.x});case 63:case"end":return n.stop()}}),n)}))),MV.apply(this,arguments)}var zV=function(n){return{name:"arrow",options:n,fn:function(e){return R(j().mark((function t(){var r,o,a,i,v,c,s,f,p,d,m,h,x,g,y,b,_,U,w,S,k,M,z,C,T,R,D,P,F,E,I,O,L,A,N,G;return j().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(a=e.x,i=e.y,v=e.placement,c=e.rects,s=e.platform,f=e.elements,p=e.middlewareData,d=aV(n,e)||{},m=d.element,h=d.padding,x=void 0===h?0:h,null!=m){t.next=4;break}return t.abrupt("return",{});case 4:return g=xV(x),y={x:a,y:i},b=uV(v),_=lV(b),t.next=10,s.getDimensions(m);case 10:return U=t.sent,S=(w="y"===b)?"top":"left",k=w?"bottom":"right",M=w?"clientHeight":"clientWidth",z=c.reference[_]+c.reference[b]-y[b]-c.floating[_],C=y[b]-c.reference[b],t.next=19,null==s.getOffsetParent?void 0:s.getOffsetParent(m);case 19:if(T=t.sent,R=T?T[M]:0,t.t0=!R,t.t0){t.next=26;break}return t.next=25,null==s.isElement?void 0:s.isElement(T);case 25:t.t0=!t.sent;case 26:if(!t.t0){t.next=28;break}R=f.floating[M]||c.floating[_];case 28:return D=z/2-C/2,P=R/2-U[_]/2-1,F=Kq(g[S],P),E=Kq(g[k],P),I=F,O=R-U[_]-E,L=R/2-U[_]/2+D,A=oV(I,L,O),N=!p.arrow&&null!=vV(v)&&L!=A&&c.reference[_]/2-(L<I?F:E)-U[_]/2<0,G=N?L<I?L-I:L-O:0,t.abrupt("return",(l(o={},b,y[b]+G),l(o,"data",u((l(r={},b,A),l(r,"centerOffset",L-A-G),r),N&&{alignmentOffset:G})),l(o,"reset",N),o));case 39:case"end":return t.stop()}}),t)})))()}}};var CV=function(n){return void 0===n&&(n={}),{name:"flip",options:n,fn:function(e){return R(j().mark((function t(){var o,a,i,v,c,l,s,u,f,p,d,m,h,g,y,b,_,U,w,S,k,M,z,C,T,R,D,P,F,E,I,O,L,A,N,G,B;return j().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(i=e.placement,v=e.middlewareData,c=e.rects,l=e.initialPlacement,s=e.platform,u=e.elements,f=aV(n,e),p=f.mainAxis,d=void 0===p||p,m=f.crossAxis,h=void 0===m||m,g=f.fallbackPlacements,y=f.fallbackStrategy,b=void 0===y?"bestFit":y,_=f.fallbackAxisSideDirection,U=void 0===_?"none":_,w=f.flipAlignment,S=void 0===w||w,k=r(f,yV),null==(o=v.arrow)||!o.alignmentOffset){t.next=4;break}return t.abrupt("return",{});case 4:return M=iV(i),z=iV(l)===l,t.next=8,null==s.isRTL?void 0:s.isRTL(u.floating);case 8:return C=t.sent,T=g||(z||!S?[hV(l)]:pV(l)),g||"none"===U||T.push.apply(T,x(mV(l,S,U,C))),R=[l].concat(x(T)),t.next=14,kV(e,k);case 14:if(D=t.sent,P=[],F=(null==(a=v.flip)?void 0:a.overflows)||[],d&&P.push(D[M]),h&&(E=fV(i,c,C),P.push(D[E[0]],D[E[1]])),F=[].concat(x(F),[{placement:i,overflows:P}]),P.every((function(n){return n<=0}))){t.next=37;break}if(L=((null==(I=v.flip)?void 0:I.index)||0)+1,!(A=R[L])){t.next=25;break}return t.abrupt("return",{data:{index:L,overflows:F},reset:{placement:A}});case 25:if(N=null==(O=F.filter((function(n){return n.overflows[0]<=0})).sort((function(n,e){return n.overflows[1]-e.overflows[1]}))[0])?void 0:O.placement,N){t.next=35;break}t.t0=b,t.next="bestFit"===t.t0?30:"initialPlacement"===t.t0?33:35;break;case 30:return B=null==(G=F.map((function(n){return[n.placement,n.overflows.filter((function(n){return n>0})).reduce((function(n,e){return n+e}),0)]})).sort((function(n,e){return n[1]-e[1]}))[0])?void 0:G[0],B&&(N=B),t.abrupt("break",35);case 33:return N=l,t.abrupt("break",35);case 35:if(i===N){t.next=37;break}return t.abrupt("return",{reset:{placement:N}});case 37:return t.abrupt("return",{});case 38:case"end":return t.stop()}}),t)})))()}}};function TV(n,e){return{top:n.top-e.height,right:n.right-e.width,bottom:n.bottom-e.height,left:n.left-e.width}}function RV(n){return Zq.some((function(e){return n[e]>=0}))}var DV=function(n){return void 0===n&&(n={}),{name:"hide",options:n,fn:function(e){return R(j().mark((function t(){var o,a,i,v,c,l,s,f,p;return j().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:o=e.rects,a=aV(n,e),i=a.strategy,v=void 0===i?"referenceHidden":i,c=r(a,bV),t.t0=v,t.next="referenceHidden"===t.t0?5:"escaped"===t.t0?10:15;break;case 5:return t.next=7,kV(e,u(u({},c),{},{elementContext:"reference"}));case 7:return l=t.sent,s=TV(l,o.reference),t.abrupt("return",{data:{referenceHiddenOffsets:s,referenceHidden:RV(s)}});case 10:return t.next=12,kV(e,u(u({},c),{},{altBoundary:!0}));case 12:return f=t.sent,p=TV(f,o.floating),t.abrupt("return",{data:{escapedOffsets:p,escaped:RV(p)}});case 15:return t.abrupt("return",{});case 16:case"end":return t.stop()}}),t)})))()}}};function PV(n,e){return jV.apply(this,arguments)}function jV(){return jV=R(j().mark((function n(e,t){var r,o,a,i,v,c,l,s,f,p,d,m,h,x;return j().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return r=e.placement,o=e.platform,a=e.elements,n.next=3,null==o.isRTL?void 0:o.isRTL(a.floating);case 3:return i=n.sent,v=iV(r),c=vV(r),l="y"===sV(r),s=["left","top"].includes(v)?-1:1,f=i&&l?-1:1,p=aV(t,e),d="number"===typeof p?{mainAxis:p,crossAxis:0,alignmentAxis:null}:u({mainAxis:0,crossAxis:0,alignmentAxis:null},p),m=d.mainAxis,h=d.crossAxis,x=d.alignmentAxis,c&&"number"===typeof x&&(h="end"===c?-1*x:x),n.abrupt("return",l?{x:h*f,y:m*s}:{x:m*s,y:h*f});case 13:case"end":return n.stop()}}),n)}))),jV.apply(this,arguments)}var FV=function(n){return void 0===n&&(n={}),{name:"shift",options:n,fn:function(e){return R(j().mark((function t(){var o,a,i,v,c,s,f,p,d,m,h,x,g,y,b,_,U,w,S,k,M,z,C,T,R;return j().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return a=e.x,i=e.y,v=e.placement,c=aV(n,e),s=c.mainAxis,f=void 0===s||s,p=c.crossAxis,d=void 0!==p&&p,m=c.limiter,h=void 0===m?{fn:function(n){return{x:n.x,y:n.y}}}:m,x=r(c,_V),g={x:a,y:i},t.next=5,kV(e,x);case 5:return y=t.sent,b=sV(iV(v)),_=cV(b),U=g[_],w=g[b],f&&(S="y"===_?"bottom":"right",k=U+y["y"===_?"top":"left"],M=U-y[S],U=oV(k,U,M)),d&&(z="y"===b?"bottom":"right",C=w+y["y"===b?"top":"left"],T=w-y[z],w=oV(C,w,T)),R=h.fn(u(u({},e),{},(l(o={},_,U),l(o,b,w),o))),t.abrupt("return",u(u({},R),{},{data:{x:R.x-a,y:R.y-i}}));case 14:case"end":return t.stop()}}),t)})))()}}},EV=function(n){return void 0===n&&(n={}),{options:n,fn:function(e){var t,r=e.x,o=e.y,a=e.placement,i=e.rects,v=e.middlewareData,c=aV(n,e),s=c.offset,f=void 0===s?0:s,p=c.mainAxis,d=void 0===p||p,m=c.crossAxis,h=void 0===m||m,x={x:r,y:o},g=sV(a),y=cV(g),b=x[y],_=x[g],U=aV(f,e),w="number"===typeof U?{mainAxis:U,crossAxis:0}:u({mainAxis:0,crossAxis:0},U);if(d){var S="y"===y?"height":"width",k=i.reference[y]-i.floating[S]+w.mainAxis,M=i.reference[y]+i.reference[S]-w.mainAxis;b<k?b=k:b>M&&(b=M)}if(h){var z,C,T="y"===y?"width":"height",R=["top","left"].includes(iV(a)),D=i.reference[g]-i.floating[T]+(R&&(null==(z=v.offset)?void 0:z[g])||0)+(R?0:w.crossAxis),P=i.reference[g]+i.reference[T]+(R?0:(null==(C=v.offset)?void 0:C[g])||0)-(R?w.crossAxis:0);_<D?_=D:_>P&&(_=P)}return l(t={},y,b),l(t,g,_),t}}},IV=function(n){return void 0===n&&(n={}),{name:"size",options:n,fn:function(e){return R(j().mark((function t(){var o,a,i,v,c,l,s,f,p,d,m,h,x,g,y,b,_,U,w,S,k,M,z,C,T,R,D,P,F;return j().wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return o=e.placement,a=e.rects,i=e.platform,v=e.elements,c=aV(n,e),l=c.apply,s=void 0===l?function(){}:l,f=r(c,UV),t.next=4,kV(e,f);case 4:if(p=t.sent,d=iV(o),m=vV(o),h="y"===sV(o),x=a.floating,g=x.width,y=x.height,"top"!==d&&"bottom"!==d){t.next=28;break}return b=d,t.t0=m,t.next=14,null==i.isRTL?void 0:i.isRTL(v.floating);case 14:if(!t.sent){t.next=18;break}t.t1="start",t.next=19;break;case 18:t.t1="end";case 19:if(t.t2=t.t1,t.t0!==t.t2){t.next=24;break}t.t3="left",t.next=25;break;case 24:t.t3="right";case 25:_=t.t3,t.next=30;break;case 28:_=d,b="end"===m?"top":"bottom";case 30:return U=y-p[b],w=g-p[_],S=!e.middlewareData.shift,k=U,M=w,h?(z=g-p.left-p.right,M=m||S?Kq(w,z):z):(C=y-p.top-p.bottom,k=m||S?Kq(U,C):C),S&&!m&&(T=Jq(p.left,0),R=Jq(p.right,0),D=Jq(p.top,0),P=Jq(p.bottom,0),h?M=g-2*(0!==T||0!==R?T+R:Jq(p.left,p.right)):k=y-2*(0!==D||0!==P?D+P:Jq(p.top,p.bottom))),t.next=39,s(u(u({},e),{},{availableWidth:M,availableHeight:k}));case 39:return t.next=41,i.getDimensions(v.floating);case 41:if(F=t.sent,g===F.width&&y===F.height){t.next=44;break}return t.abrupt("return",{reset:{rects:!0}});case 44:return t.abrupt("return",{});case 45:case"end":return t.stop()}}),t)})))()}}};function OV(n){return NV(n)?(n.nodeName||"").toLowerCase():"#document"}function LV(n){var e;return(null==n||null==(e=n.ownerDocument)?void 0:e.defaultView)||window}function AV(n){var e;return null==(e=(NV(n)?n.ownerDocument:n.document)||window.document)?void 0:e.documentElement}function NV(n){return n instanceof Node||n instanceof LV(n).Node}function GV(n){return n instanceof Element||n instanceof LV(n).Element}function BV(n){return n instanceof HTMLElement||n instanceof LV(n).HTMLElement}function qV(n){return"undefined"!==typeof ShadowRoot&&(n instanceof ShadowRoot||n instanceof LV(n).ShadowRoot)}function VV(n){var e=$V(n),t=e.overflow,r=e.overflowX,o=e.overflowY,a=e.display;return/auto|scroll|overlay|hidden|clip/.test(t+o+r)&&!["inline","contents"].includes(a)}function WV(n){return["table","td","th"].includes(OV(n))}function HV(n){var e=XV(),t=$V(n);return"none"!==t.transform||"none"!==t.perspective||!!t.containerType&&"normal"!==t.containerType||!e&&!!t.backdropFilter&&"none"!==t.backdropFilter||!e&&!!t.filter&&"none"!==t.filter||["transform","perspective","filter"].some((function(n){return(t.willChange||"").includes(n)}))||["paint","layout","strict","content"].some((function(n){return(t.contain||"").includes(n)}))}function XV(){return!("undefined"===typeof CSS||!CSS.supports)&&CSS.supports("-webkit-backdrop-filter","none")}function YV(n){return["html","body","#document"].includes(OV(n))}function $V(n){return LV(n).getComputedStyle(n)}function ZV(n){return GV(n)?{scrollLeft:n.scrollLeft,scrollTop:n.scrollTop}:{scrollLeft:n.pageXOffset,scrollTop:n.pageYOffset}}function KV(n){if("html"===OV(n))return n;var e=n.assignedSlot||n.parentNode||qV(n)&&n.host||AV(n);return qV(e)?e.host:e}function JV(n){var e=KV(n);return YV(e)?n.ownerDocument?n.ownerDocument.body:n.body:BV(e)&&VV(e)?e:JV(e)}function QV(n,e,t){var r;void 0===e&&(e=[]),void 0===t&&(t=!0);var o=JV(n),a=o===(null==(r=n.ownerDocument)?void 0:r.body),i=LV(o);return a?e.concat(i,i.visualViewport||[],VV(o)?o:[],i.frameElement&&t?QV(i.frameElement):[]):e.concat(o,QV(o,[],t))}function nW(n){var e=$V(n),t=parseFloat(e.width)||0,r=parseFloat(e.height)||0,o=BV(n),a=o?n.offsetWidth:t,i=o?n.offsetHeight:r,v=Qq(t)!==a||Qq(r)!==i;return v&&(t=a,r=i),{width:t,height:r,$:v}}function eW(n){return GV(n)?n:n.contextElement}function tW(n){var e=eW(n);if(!BV(e))return eV(1);var t=e.getBoundingClientRect(),r=nW(e),o=r.width,a=r.height,i=r.$,v=(i?Qq(t.width):t.width)/o,c=(i?Qq(t.height):t.height)/a;return v&&Number.isFinite(v)||(v=1),c&&Number.isFinite(c)||(c=1),{x:v,y:c}}var rW=eV(0);function oW(n){var e=LV(n);return XV()&&e.visualViewport?{x:e.visualViewport.offsetLeft,y:e.visualViewport.offsetTop}:rW}function aW(n,e,t,r){void 0===e&&(e=!1),void 0===t&&(t=!1);var o=n.getBoundingClientRect(),a=eW(n),i=eV(1);e&&(r?GV(r)&&(i=tW(r)):i=tW(n));var v=function(n,e,t){return void 0===e&&(e=!1),!(!t||e&&t!==LV(n))&&e}(a,t,r)?oW(a):eV(0),c=(o.left+v.x)/i.x,l=(o.top+v.y)/i.y,s=o.width/i.x,u=o.height/i.y;if(a)for(var f=LV(a),p=r&&GV(r)?LV(r):r,d=f.frameElement;d&&r&&p!==f;){var m=tW(d),h=d.getBoundingClientRect(),x=$V(d),g=h.left+(d.clientLeft+parseFloat(x.paddingLeft))*m.x,y=h.top+(d.clientTop+parseFloat(x.paddingTop))*m.y;c*=m.x,l*=m.y,s*=m.x,u*=m.y,c+=g,l+=y,d=LV(d).frameElement}return gV({width:s,height:u,x:c,y:l})}function iW(n){return aW(AV(n)).left+ZV(n).scrollLeft}function vW(n,e,t){var r;if("viewport"===e)r=function(n,e){var t=LV(n),r=AV(n),o=t.visualViewport,a=r.clientWidth,i=r.clientHeight,v=0,c=0;if(o){a=o.width,i=o.height;var l=XV();(!l||l&&"fixed"===e)&&(v=o.offsetLeft,c=o.offsetTop)}return{width:a,height:i,x:v,y:c}}(n,t);else if("document"===e)r=function(n){var e=AV(n),t=ZV(n),r=n.ownerDocument.body,o=Jq(e.scrollWidth,e.clientWidth,r.scrollWidth,r.clientWidth),a=Jq(e.scrollHeight,e.clientHeight,r.scrollHeight,r.clientHeight),i=-t.scrollLeft+iW(n),v=-t.scrollTop;return"rtl"===$V(r).direction&&(i+=Jq(e.clientWidth,r.clientWidth)-o),{width:o,height:a,x:i,y:v}}(AV(n));else if(GV(e))r=function(n,e){var t=aW(n,!0,"fixed"===e),r=t.top+n.clientTop,o=t.left+n.clientLeft,a=BV(n)?tW(n):eV(1);return{width:n.clientWidth*a.x,height:n.clientHeight*a.y,x:o*a.x,y:r*a.y}}(e,t);else{var o=oW(n);r=u(u({},e),{},{x:e.x-o.x,y:e.y-o.y})}return gV(r)}function cW(n,e){var t=KV(n);return!(t===e||!GV(t)||YV(t))&&("fixed"===$V(t).position||cW(t,e))}function lW(n,e,t){var r=BV(e),o=AV(e),a="fixed"===t,i=aW(n,!0,a,e),v={scrollLeft:0,scrollTop:0},c=eV(0);if(r||!r&&!a)if(("body"!==OV(e)||VV(o))&&(v=ZV(e)),r){var l=aW(e,!0,a,e);c.x=l.x+e.clientLeft,c.y=l.y+e.clientTop}else o&&(c.x=iW(o));return{x:i.left+v.scrollLeft-c.x,y:i.top+v.scrollTop-c.y,width:i.width,height:i.height}}function sW(n,e){return BV(n)&&"fixed"!==$V(n).position?e?e(n):n.offsetParent:null}function uW(n,e){var t=LV(n);if(!BV(n))return t;for(var r=sW(n,e);r&&WV(r)&&"static"===$V(r).position;)r=sW(r,e);return r&&("html"===OV(r)||"body"===OV(r)&&"static"===$V(r).position&&!HV(r))?t:r||function(n){for(var e=KV(n);BV(e)&&!YV(e);){if(HV(e))return e;e=KV(e)}return null}(n)||t}var fW=function(){var n=R(j().mark((function n(e){var t,r,o,a,i;return j().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t=e.reference,r=e.floating,o=e.strategy,a=this.getOffsetParent||uW,i=this.getDimensions,n.t0=lW,n.t1=t,n.next=7,a(r);case 7:return n.t2=n.sent,n.t3=o,n.t4=(0,n.t0)(n.t1,n.t2,n.t3),n.t5=u,n.t6={x:0,y:0},n.next=14,i(r);case 14:return n.t7=n.sent,n.t8=(0,n.t5)(n.t6,n.t7),n.abrupt("return",{reference:n.t4,floating:n.t8});case 17:case"end":return n.stop()}}),n,this)})));return function(e){return n.apply(this,arguments)}}();var pW={convertOffsetParentRelativeRectToViewportRelativeRect:function(n){var e=n.rect,t=n.offsetParent,r=n.strategy,o=BV(t),a=AV(t);if(t===a)return e;var i={scrollLeft:0,scrollTop:0},v=eV(1),c=eV(0);if((o||!o&&"fixed"!==r)&&(("body"!==OV(t)||VV(a))&&(i=ZV(t)),BV(t))){var l=aW(t);v=tW(t),c.x=l.x+t.clientLeft,c.y=l.y+t.clientTop}return{width:e.width*v.x,height:e.height*v.y,x:e.x*v.x-i.scrollLeft*v.x+c.x,y:e.y*v.y-i.scrollTop*v.y+c.y}},getDocumentElement:AV,getClippingRect:function(n){var e=n.element,t=n.boundary,r=n.rootBoundary,o=n.strategy,a="clippingAncestors"===t?function(n,e){var t=e.get(n);if(t)return t;for(var r=QV(n,[],!1).filter((function(n){return GV(n)&&"body"!==OV(n)})),o=null,a="fixed"===$V(n).position,i=a?KV(n):n;GV(i)&&!YV(i);){var v=$V(i),c=HV(i);c||"fixed"!==v.position||(o=null),(a?!c&&!o:!c&&"static"===v.position&&o&&["absolute","fixed"].includes(o.position)||VV(i)&&!c&&cW(n,i))?r=r.filter((function(n){return n!==i})):o=v,i=KV(i)}return e.set(n,r),r}(e,this._c):[].concat(t),i=[].concat(x(a),[r]),v=i[0],c=i.reduce((function(n,t){var r=vW(e,t,o);return n.top=Jq(r.top,n.top),n.right=Kq(r.right,n.right),n.bottom=Kq(r.bottom,n.bottom),n.left=Jq(r.left,n.left),n}),vW(e,v,o));return{width:c.right-c.left,height:c.bottom-c.top,x:c.left,y:c.top}},getOffsetParent:uW,getElementRects:fW,getClientRects:function(n){return Array.from(n.getClientRects())},getDimensions:function(n){return nW(n)},getScale:tW,isElement:GV,isRTL:function(n){return"rtl"===$V(n).direction}};function dW(n,e,t,r){void 0===r&&(r={});var o=r,a=o.ancestorScroll,i=void 0===a||a,v=o.ancestorResize,l=void 0===v||v,s=o.elementResize,f=void 0===s?"function"===typeof ResizeObserver:s,p=o.layoutShift,d=void 0===p?"function"===typeof IntersectionObserver:p,m=o.animationFrame,h=void 0!==m&&m,g=eW(n),y=i||l?[].concat(x(g?QV(g):[]),x(QV(e))):[];y.forEach((function(n){i&&n.addEventListener("scroll",t,{passive:!0}),l&&n.addEventListener("resize",t)}));var b,_=g&&d?function(n,e){var t,r=null,o=AV(n);function a(){clearTimeout(t),r&&r.disconnect(),r=null}return function i(v,c){void 0===v&&(v=!1),void 0===c&&(c=1),a();var l=n.getBoundingClientRect(),s=l.left,f=l.top,p=l.width,d=l.height;if(v||e(),p&&d){var m={rootMargin:-nV(f)+"px "+-nV(o.clientWidth-(s+p))+"px "+-nV(o.clientHeight-(f+d))+"px "+-nV(s)+"px",threshold:Jq(0,Kq(1,c))||1},h=!0;try{r=new IntersectionObserver(x,u(u({},m),{},{root:o.ownerDocument}))}catch(g){r=new IntersectionObserver(x,m)}r.observe(n)}function x(n){var e=n[0].intersectionRatio;if(e!==c){if(!h)return i();e?i(!1,e):t=setTimeout((function(){i(!1,1e-7)}),100)}h=!1}}(!0),a}(g,t):null,U=-1,w=null;f&&(w=new ResizeObserver((function(n){var r=c(n,1)[0];r&&r.target===g&&w&&(w.unobserve(e),cancelAnimationFrame(U),U=requestAnimationFrame((function(){w&&w.observe(e)}))),t()})),g&&!h&&w.observe(g),w.observe(e));var S=h?aW(n):null;return h&&function e(){var r=aW(n);!S||r.x===S.x&&r.y===S.y&&r.width===S.width&&r.height===S.height||t();S=r,b=requestAnimationFrame(e)}(),t(),function(){y.forEach((function(n){i&&n.removeEventListener("scroll",t),l&&n.removeEventListener("resize",t)})),_&&_(),w&&w.disconnect(),w=null,h&&cancelAnimationFrame(b)}}var mW=function(n,e,t){var r=new Map,o=u({platform:pW},t),a=u(u({},o.platform),{},{_c:r});return SV(n,e,u(u({},o),{},{platform:a}))},hW=function(n){return{name:"arrow",options:n,fn:function(e){var t,r="function"===typeof n?n(e):n,o=r.element,a=r.padding;return o&&(t=o,{}.hasOwnProperty.call(t,"current"))?null!=o.current?zV({element:o.current,padding:a}).fn(e):{}:o?zV({element:o,padding:a}).fn(e):{}}}},xW="undefined"!==typeof document?Ad.useLayoutEffect:Ad.useEffect;function gW(n,e){if(n===e)return!0;if(typeof n!==typeof e)return!1;if("function"===typeof n&&n.toString()===e.toString())return!0;var t,r,o;if(n&&e&&"object"==typeof n){if(Array.isArray(n)){if((t=n.length)!=e.length)return!1;for(r=t;0!==r--;)if(!gW(n[r],e[r]))return!1;return!0}if((t=(o=Object.keys(n)).length)!==Object.keys(e).length)return!1;for(r=t;0!==r--;)if(!{}.hasOwnProperty.call(e,o[r]))return!1;for(r=t;0!==r--;){var a=o[r];if(("_owner"!==a||!n.$$typeof)&&!gW(n[a],e[a]))return!1}return!0}return n!==n&&e!==e}function yW(n){return"undefined"===typeof window?1:(n.ownerDocument.defaultView||window).devicePixelRatio||1}function bW(n,e){var t=yW(n);return Math.round(e*t)/t}function _W(n){var e=Ad.useRef(n);return xW((function(){e.current=n})),e}var UW=["children","width","height"],wW=(0,Ad.forwardRef)((function(n,e){var t=n.children,o=n.width,a=void 0===o?10:o,i=n.height,v=void 0===i?5:i,c=r(n,UW);return(0,Ad.createElement)(cG.svg,ih({},c,{ref:e,width:a,height:v,viewBox:"0 0 30 10",preserveAspectRatio:"none"}),n.asChild?t:(0,Ad.createElement)("polygon",{points:"0,0 30,0 15,10"}))})),SW=wW;var kW=["__scopePopper","virtualRef"],MW=["__scopePopper","side","sideOffset","align","alignOffset","arrowPadding","avoidCollisions","collisionBoundary","collisionPadding","sticky","hideWhenDetached","updatePositionStrategy","onPlaced"],zW=["__scopePopper"],CW="Popper",TW=c(Eq(CW),2),RW=TW[0],DW=TW[1],PW=c(RW(CW),2),jW=PW[0],FW=PW[1],EW=function(n){var e=n.__scopePopper,t=n.children,r=c((0,Ad.useState)(null),2),o=r[0],a=r[1];return(0,Ad.createElement)(jW,{scope:e,anchor:o,onAnchorChange:a},t)},IW="PopperAnchor",OW=(0,Ad.forwardRef)((function(n,e){var t=n.__scopePopper,o=n.virtualRef,a=r(n,kW),i=FW(IW,t),v=(0,Ad.useRef)(null),c=nG(e,v);return(0,Ad.useEffect)((function(){i.onAnchorChange((null===o||void 0===o?void 0:o.current)||v.current)})),o?null:(0,Ad.createElement)(cG.div,ih({},a,{ref:c}))})),LW="PopperContent",AW=c(RW(LW),2),NW=AW[0],GW=AW[1],BW=(0,Ad.forwardRef)((function(n,e){var t,o,a,i,v,s,f,p,d,m=n.__scopePopper,h=n.side,x=void 0===h?"bottom":h,g=n.sideOffset,y=void 0===g?0:g,b=n.align,_=void 0===b?"center":b,U=n.alignOffset,w=void 0===U?0:U,S=n.arrowPadding,k=void 0===S?0:S,M=n.avoidCollisions,z=void 0===M||M,C=n.collisionBoundary,T=void 0===C?[]:C,D=n.collisionPadding,P=void 0===D?0:D,F=n.sticky,E=void 0===F?"partial":F,I=n.hideWhenDetached,O=void 0!==I&&I,L=n.updatePositionStrategy,A=void 0===L?"optimized":L,N=n.onPlaced,G=r(n,MW),B=FW(LW,m),q=c((0,Ad.useState)(null),2),V=q[0],W=q[1],H=nG(e,(function(n){return W(n)})),X=c((0,Ad.useState)(null),2),Y=X[0],$=X[1],Z=function(n){var e=c((0,Ad.useState)(void 0),2),t=e[0],r=e[1];return Xq((function(){if(n){r({width:n.offsetWidth,height:n.offsetHeight});var e=new ResizeObserver((function(e){if(Array.isArray(e)&&e.length){var t,o,a=e[0];if("borderBoxSize"in a){var i=a.borderBoxSize,v=Array.isArray(i)?i[0]:i;t=v.inlineSize,o=v.blockSize}else t=n.offsetWidth,o=n.offsetHeight;r({width:t,height:o})}}));return e.observe(n,{box:"border-box"}),function(){return e.unobserve(n)}}r(void 0)}),[n]),t}(Y),K=null!==(t=null===Z||void 0===Z?void 0:Z.width)&&void 0!==t?t:0,J=null!==(o=null===Z||void 0===Z?void 0:Z.height)&&void 0!==o?o:0,Q=x+("center"!==_?"-"+_:""),nn="number"===typeof P?P:u({top:0,right:0,bottom:0,left:0},P),en=Array.isArray(T)?T:[T],tn=en.length>0,rn={padding:nn,boundary:en.filter(HW),altBoundary:tn},on=function(n){void 0===n&&(n={});var e=n,t=e.placement,r=void 0===t?"bottom":t,o=e.strategy,a=void 0===o?"absolute":o,i=e.middleware,v=void 0===i?[]:i,l=e.platform,s=e.elements,f=(s=void 0===s?{}:s).reference,p=s.floating,d=e.transform,m=void 0===d||d,h=e.whileElementsMounted,x=e.open,g=c(Ad.useState({x:0,y:0,strategy:a,placement:r,middlewareData:{},isPositioned:!1}),2),y=g[0],b=g[1],_=c(Ad.useState(v),2),U=_[0],w=_[1];gW(U,v)||w(v);var S=c(Ad.useState(null),2),k=S[0],M=S[1],z=c(Ad.useState(null),2),C=z[0],T=z[1],R=Ad.useCallback((function(n){n!=F.current&&(F.current=n,M(n))}),[M]),D=Ad.useCallback((function(n){n!==E.current&&(E.current=n,T(n))}),[T]),P=f||k,j=p||C,F=Ad.useRef(null),E=Ad.useRef(null),I=Ad.useRef(y),O=_W(h),L=_W(l),A=Ad.useCallback((function(){if(F.current&&E.current){var n={placement:r,strategy:a,middleware:U};L.current&&(n.platform=L.current),mW(F.current,E.current,n).then((function(n){var e=u(u({},n),{},{isPositioned:!0});N.current&&!gW(I.current,e)&&(I.current=e,KN.flushSync((function(){b(e)})))}))}}),[U,r,a,L]);xW((function(){!1===x&&I.current.isPositioned&&(I.current.isPositioned=!1,b((function(n){return u(u({},n),{},{isPositioned:!1})})))}),[x]);var N=Ad.useRef(!1);xW((function(){return N.current=!0,function(){N.current=!1}}),[]),xW((function(){if(P&&(F.current=P),j&&(E.current=j),P&&j){if(O.current)return O.current(P,j,A);A()}}),[P,j,A,O]);var G=Ad.useMemo((function(){return{reference:F,floating:E,setReference:R,setFloating:D}}),[R,D]),B=Ad.useMemo((function(){return{reference:P,floating:j}}),[P,j]),q=Ad.useMemo((function(){var n={position:a,left:0,top:0};if(!B.floating)return n;var e=bW(B.floating,y.x),t=bW(B.floating,y.y);return m?u(u({},n),{},{transform:"translate("+e+"px, "+t+"px)"},yW(B.floating)>=1.5&&{willChange:"transform"}):{position:a,left:e,top:t}}),[a,m,B.floating,y.x,y.y]);return Ad.useMemo((function(){return u(u({},y),{},{update:A,refs:G,elements:B,floatingStyles:q})}),[y,A,G,B,q])}({strategy:"fixed",placement:Q,whileElementsMounted:function(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];var r=dW.apply(void 0,e.concat([{animationFrame:"always"===A}]));return r},elements:{reference:B.anchor},middleware:[(d={mainAxis:y+J,alignmentAxis:w},void 0===d&&(d=0),{name:"offset",options:d,fn:function(n){return R(j().mark((function e(){var t,r,o,a,i,v,c;return j().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return o=n.x,a=n.y,i=n.placement,v=n.middlewareData,e.next=3,PV(n,d);case 3:if(c=e.sent,i!==(null==(t=v.offset)?void 0:t.placement)||null==(r=v.arrow)||!r.alignmentOffset){e.next=6;break}return e.abrupt("return",{});case 6:return e.abrupt("return",{x:o+c.x,y:a+c.y,data:u(u({},c),{},{placement:i})});case 7:case"end":return e.stop()}}),e)})))()}}),z&&FV(u({mainAxis:!0,crossAxis:!1,limiter:"partial"===E?EV():void 0},rn)),z&&CV(u({},rn)),IV(u(u({},rn),{},{apply:function(n){var e=n.elements,t=n.rects,r=n.availableWidth,o=n.availableHeight,a=t.reference,i=a.width,v=a.height,c=e.floating.style;c.setProperty("--radix-popper-available-width","".concat(r,"px")),c.setProperty("--radix-popper-available-height","".concat(o,"px")),c.setProperty("--radix-popper-anchor-width","".concat(i,"px")),c.setProperty("--radix-popper-anchor-height","".concat(v,"px"))}})),Y&&hW({element:Y,padding:k}),XW({arrowWidth:K,arrowHeight:J}),O&&DV(u({strategy:"referenceHidden"},rn))]}),an=on.refs,vn=on.floatingStyles,cn=on.placement,ln=on.isPositioned,sn=on.middlewareData,un=c(YW(cn),2),fn=un[0],pn=un[1],dn=Oq(N);Xq((function(){ln&&(null===dn||void 0===dn||dn())}),[ln,dn]);var mn=null===(a=sn.arrow)||void 0===a?void 0:a.x,hn=null===(i=sn.arrow)||void 0===i?void 0:i.y,xn=0!==(null===(v=sn.arrow)||void 0===v?void 0:v.centerOffset),gn=c((0,Ad.useState)(),2),yn=gn[0],bn=gn[1];return Xq((function(){V&&bn(window.getComputedStyle(V).zIndex)}),[V]),(0,Ad.createElement)("div",{ref:an.setFloating,"data-radix-popper-content-wrapper":"",style:u(u({},vn),{},l({transform:ln?vn.transform:"translate(0, -200%)",minWidth:"max-content",zIndex:yn},"--radix-popper-transform-origin",[null===(s=sn.transformOrigin)||void 0===s?void 0:s.x,null===(f=sn.transformOrigin)||void 0===f?void 0:f.y].join(" "))),dir:n.dir},(0,Ad.createElement)(NW,{scope:m,placedSide:fn,onArrowChange:$,arrowX:mn,arrowY:hn,shouldHideArrow:xn},(0,Ad.createElement)(cG.div,ih({"data-side":fn,"data-align":pn},G,{ref:H,style:u(u({},G.style),{},{animation:ln?void 0:"none",opacity:null!==(p=sn.hide)&&void 0!==p&&p.referenceHidden?0:void 0})}))))})),qW="PopperArrow",VW={top:"bottom",right:"left",bottom:"top",left:"right"},WW=(0,Ad.forwardRef)((function(n,e){var t,o=n.__scopePopper,a=r(n,zW),i=GW(qW,o),v=VW[i.placedSide];return(0,Ad.createElement)("span",{ref:i.onArrowChange,style:(t={position:"absolute",left:i.arrowX,top:i.arrowY},l(t,v,0),l(t,"transformOrigin",{top:"",right:"0 0",bottom:"center 0",left:"100% 0"}[i.placedSide]),l(t,"transform",{top:"translateY(100%)",right:"translateY(50%) rotate(90deg) translateX(-50%)",bottom:"rotate(180deg)",left:"translateY(50%) rotate(-90deg) translateX(50%)"}[i.placedSide]),l(t,"visibility",i.shouldHideArrow?"hidden":void 0),t)},(0,Ad.createElement)(SW,ih({},a,{ref:e,style:u(u({},a.style),{},{display:"block"})})))}));function HW(n){return null!==n}var XW=function(n){return{name:"transformOrigin",options:n,fn:function(e){var t,r,o,a,i,v=e.placement,l=e.rects,s=e.middlewareData,u=0!==(null===(t=s.arrow)||void 0===t?void 0:t.centerOffset),f=u?0:n.arrowWidth,p=u?0:n.arrowHeight,d=c(YW(v),2),m=d[0],h={start:"0%",center:"50%",end:"100%"}[d[1]],x=(null!==(r=null===(o=s.arrow)||void 0===o?void 0:o.x)&&void 0!==r?r:0)+f/2,g=(null!==(a=null===(i=s.arrow)||void 0===i?void 0:i.y)&&void 0!==a?a:0)+p/2,y="",b="";return"bottom"===m?(y=u?h:"".concat(x,"px"),b="".concat(-p,"px")):"top"===m?(y=u?h:"".concat(x,"px"),b="".concat(l.floating.height+p,"px")):"right"===m?(y="".concat(-p,"px"),b=u?h:"".concat(g,"px")):"left"===m&&(y="".concat(l.floating.width+p,"px"),b=u?h:"".concat(g,"px")),{data:{x:y,y:b}}}}};function YW(n){var e=c(n.split("-"),2),t=e[0],r=e[1];return[t,void 0===r?"center":r]}var $W=EW,ZW=OW,KW=BW,JW=WW;var QW=function(n){var e=n.present,t=n.children,r=function(n){var e=c((0,Ad.useState)(),2),t=e[0],r=e[1],o=(0,Ad.useRef)({}),a=(0,Ad.useRef)(n),i=(0,Ad.useRef)("none"),v=c(function(n,e){return(0,Ad.useReducer)((function(n,t){var r=e[n][t];return null!==r&&void 0!==r?r:n}),n)}(n?"mounted":"unmounted",{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}}),2),l=v[0],s=v[1];return(0,Ad.useEffect)((function(){var n=nH(o.current);i.current="mounted"===l?n:"none"}),[l]),Xq((function(){var e=o.current,t=a.current;if(t!==n){var r=i.current,v=nH(e);if(n)s("MOUNT");else if("none"===v||"none"===(null===e||void 0===e?void 0:e.display))s("UNMOUNT");else{s(t&&r!==v?"ANIMATION_OUT":"UNMOUNT")}a.current=n}}),[n,s]),Xq((function(){if(t){var n=function(n){var e=nH(o.current).includes(n.animationName);n.target===t&&e&&(0,KN.flushSync)((function(){return s("ANIMATION_END")}))},e=function(n){n.target===t&&(i.current=nH(o.current))};return t.addEventListener("animationstart",e),t.addEventListener("animationcancel",n),t.addEventListener("animationend",n),function(){t.removeEventListener("animationstart",e),t.removeEventListener("animationcancel",n),t.removeEventListener("animationend",n)}}s("ANIMATION_END")}),[t,s]),{isPresent:["mounted","unmountSuspended"].includes(l),ref:(0,Ad.useCallback)((function(n){n&&(o.current=getComputedStyle(n)),r(n)}),[])}}(e),o="function"===typeof t?t({present:r.isPresent}):Ad.Children.only(t),a=nG(r.ref,o.ref);return"function"===typeof t||r.isPresent?(0,Ad.cloneElement)(o,{ref:a}):null};function nH(n){return(null===n||void 0===n?void 0:n.animationName)||"none"}function eH(n){var e=n.prop,t=n.defaultProp,r=n.onChange,o=void 0===r?function(){}:r,a=function(n){var e=n.defaultProp,t=n.onChange,r=(0,Ad.useState)(e),o=c(r,1)[0],a=(0,Ad.useRef)(o),i=Oq(t);return(0,Ad.useEffect)((function(){a.current!==o&&(i(o),a.current=o)}),[o,a,i]),r}({defaultProp:t,onChange:o}),i=c(a,2),v=i[0],l=i[1],s=void 0!==e,u=s?e:v,f=Oq(o);return[u,(0,Ad.useCallback)((function(n){if(s){var t="function"===typeof n?n(e):n;t!==e&&f(t)}else l(n)}),[s,e,l,f])]}QW.displayName="Presence";var tH=(0,Ad.forwardRef)((function(n,e){return(0,Ad.createElement)(cG.span,ih({},n,{ref:e,style:u({position:"absolute",border:0,width:1,height:1,padding:0,margin:-1,overflow:"hidden",clip:"rect(0, 0, 0, 0)",whiteSpace:"nowrap",wordWrap:"normal"},n.style)}))})),rH=tH,oH=["__scopeTooltip"],aH=["forceMount","side"],iH=["__scopeTooltip","children","aria-label","onEscapeKeyDown","onPointerDownOutside"],vH=["__scopeTooltip"],cH=c(Eq("Tooltip",[DW]),2),lH=cH[0],sH=(cH[1],DW()),uH="TooltipProvider",fH="tooltip.open",pH=c(lH(uH),2),dH=(pH[0],pH[1]),mH="Tooltip",hH=c(lH(mH),2),xH=hH[0],gH=hH[1],yH=function(n){var e=n.__scopeTooltip,t=n.children,r=n.open,o=n.defaultOpen,a=void 0!==o&&o,i=n.onOpenChange,v=n.disableHoverableContent,l=n.delayDuration,s=dH(mH,n.__scopeTooltip),u=sH(e),f=c((0,Ad.useState)(null),2),p=f[0],d=f[1],m=function(n){var e=c(Ad.useState(Yq()),2),t=e[0],r=e[1];return Xq((function(){n||r((function(n){return null!==n&&void 0!==n?n:String($q++)}))}),[n]),n||(t?"radix-".concat(t):"")}(),h=(0,Ad.useRef)(0),x=null!==v&&void 0!==v?v:s.disableHoverableContent,g=null!==l&&void 0!==l?l:s.delayDuration,y=(0,Ad.useRef)(!1),b=c(eH({prop:r,defaultProp:a,onChange:function(n){n?(s.onOpen(),document.dispatchEvent(new CustomEvent(fH))):s.onClose(),null===i||void 0===i||i(n)}}),2),_=b[0],U=void 0!==_&&_,w=b[1],S=(0,Ad.useMemo)((function(){return U?y.current?"delayed-open":"instant-open":"closed"}),[U]),k=(0,Ad.useCallback)((function(){window.clearTimeout(h.current),y.current=!1,w(!0)}),[w]),M=(0,Ad.useCallback)((function(){window.clearTimeout(h.current),w(!1)}),[w]),z=(0,Ad.useCallback)((function(){window.clearTimeout(h.current),h.current=window.setTimeout((function(){y.current=!0,w(!0)}),g)}),[g,w]);return(0,Ad.useEffect)((function(){return function(){return window.clearTimeout(h.current)}}),[]),(0,Ad.createElement)($W,u,(0,Ad.createElement)(xH,{scope:e,contentId:m,open:U,stateAttribute:S,trigger:p,onTriggerChange:d,onTriggerEnter:(0,Ad.useCallback)((function(){s.isOpenDelayed?z():k()}),[s.isOpenDelayed,z,k]),onTriggerLeave:(0,Ad.useCallback)((function(){x?M():window.clearTimeout(h.current)}),[M,x]),onOpen:k,onClose:M,disableHoverableContent:x},t))},bH="TooltipTrigger",_H=(0,Ad.forwardRef)((function(n,e){var t=n.__scopeTooltip,o=r(n,oH),a=gH(bH,t),i=dH(bH,t),v=sH(t),c=nG(e,(0,Ad.useRef)(null),a.onTriggerChange),l=(0,Ad.useRef)(!1),s=(0,Ad.useRef)(!1),u=(0,Ad.useCallback)((function(){return l.current=!1}),[]);return(0,Ad.useEffect)((function(){return function(){return document.removeEventListener("pointerup",u)}}),[u]),(0,Ad.createElement)(ZW,ih({asChild:!0},v),(0,Ad.createElement)(cG.button,ih({"aria-describedby":a.open?a.contentId:void 0,"data-state":a.stateAttribute},o,{ref:c,onPointerMove:jq(n.onPointerMove,(function(n){"touch"!==n.pointerType&&(s.current||i.isPointerInTransitRef.current||(a.onTriggerEnter(),s.current=!0))})),onPointerLeave:jq(n.onPointerLeave,(function(){a.onTriggerLeave(),s.current=!1})),onPointerDown:jq(n.onPointerDown,(function(){l.current=!0,document.addEventListener("pointerup",u,{once:!0})})),onFocus:jq(n.onFocus,(function(){l.current||a.onOpen()})),onBlur:jq(n.onBlur,a.onClose),onClick:jq(n.onClick,a.onClose)})))})),UH="TooltipPortal",wH=c(lH(UH,{forceMount:void 0}),2),SH=(wH[0],wH[1]),kH="TooltipContent",MH=(0,Ad.forwardRef)((function(n,e){var t=SH(kH,n.__scopeTooltip),o=n.forceMount,a=void 0===o?t.forceMount:o,i=n.side,v=void 0===i?"top":i,c=r(n,aH),l=gH(kH,n.__scopeTooltip);return(0,Ad.createElement)(QW,{present:a||l.open},l.disableHoverableContent?(0,Ad.createElement)(DH,ih({side:v},c,{ref:e})):(0,Ad.createElement)(zH,ih({side:v},c,{ref:e})))})),zH=(0,Ad.forwardRef)((function(n,e){var t=gH(kH,n.__scopeTooltip),r=dH(kH,n.__scopeTooltip),o=(0,Ad.useRef)(null),a=nG(e,o),i=c((0,Ad.useState)(null),2),v=i[0],l=i[1],s=t.trigger,u=t.onClose,f=o.current,p=r.onPointerInTransitChange,d=(0,Ad.useCallback)((function(){l(null),p(!1)}),[p]),m=(0,Ad.useCallback)((function(n,e){var t=n.currentTarget,r={x:n.clientX,y:n.clientY},o=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:5,r=[];switch(e){case"top":r.push({x:n.x-t,y:n.y+t},{x:n.x+t,y:n.y+t});break;case"bottom":r.push({x:n.x-t,y:n.y-t},{x:n.x+t,y:n.y-t});break;case"left":r.push({x:n.x+t,y:n.y-t},{x:n.x+t,y:n.y+t});break;case"right":r.push({x:n.x-t,y:n.y-t},{x:n.x-t,y:n.y+t})}return r}(r,function(n,e){var t=Math.abs(e.top-n.y),r=Math.abs(e.bottom-n.y),o=Math.abs(e.right-n.x),a=Math.abs(e.left-n.x);switch(Math.min(t,r,o,a)){case a:return"left";case o:return"right";case t:return"top";case r:return"bottom";default:throw new Error("unreachable")}}(r,t.getBoundingClientRect())),a=function(n){var e=n.top,t=n.right,r=n.bottom,o=n.left;return[{x:o,y:e},{x:t,y:e},{x:t,y:r},{x:o,y:r}]}(e.getBoundingClientRect()),i=function(n){var e=n.slice();return e.sort((function(n,e){return n.x<e.x?-1:n.x>e.x?1:n.y<e.y?-1:n.y>e.y?1:0})),function(n){if(n.length<=1)return n.slice();for(var e=[],t=0;t<n.length;t++){for(var r=n[t];e.length>=2;){var o=e[e.length-1],a=e[e.length-2];if(!((o.x-a.x)*(r.y-a.y)>=(o.y-a.y)*(r.x-a.x)))break;e.pop()}e.push(r)}e.pop();for(var i=[],v=n.length-1;v>=0;v--){for(var c=n[v];i.length>=2;){var l=i[i.length-1],s=i[i.length-2];if(!((l.x-s.x)*(c.y-s.y)>=(l.y-s.y)*(c.x-s.x)))break;i.pop()}i.push(c)}return i.pop(),1===e.length&&1===i.length&&e[0].x===i[0].x&&e[0].y===i[0].y?e:e.concat(i)}(e)}([].concat(x(o),x(a)));l(i),p(!0)}),[p]);return(0,Ad.useEffect)((function(){return function(){return d()}}),[d]),(0,Ad.useEffect)((function(){if(s&&f){var n=function(n){return m(n,f)},e=function(n){return m(n,s)};return s.addEventListener("pointerleave",n),f.addEventListener("pointerleave",e),function(){s.removeEventListener("pointerleave",n),f.removeEventListener("pointerleave",e)}}}),[s,f,m,d]),(0,Ad.useEffect)((function(){if(v){var n=function(n){var e=n.target,t={x:n.clientX,y:n.clientY},r=(null===s||void 0===s?void 0:s.contains(e))||(null===f||void 0===f?void 0:f.contains(e)),o=!function(n,e){for(var t=n.x,r=n.y,o=!1,a=0,i=e.length-1;a<e.length;i=a++){var v=e[a].x,c=e[a].y,l=e[i].x,s=e[i].y;c>r!==s>r&&t<(l-v)*(r-c)/(s-c)+v&&(o=!o)}return o}(t,v);r?d():o&&(d(),u())};return document.addEventListener("pointermove",n),function(){return document.removeEventListener("pointermove",n)}}}),[s,f,v,u,d]),(0,Ad.createElement)(DH,ih({},n,{ref:a}))})),CH=c(lH(mH,{isInside:!1}),2),TH=CH[0],RH=CH[1],DH=(0,Ad.forwardRef)((function(n,e){var t=n.__scopeTooltip,o=n.children,a=n["aria-label"],i=n.onEscapeKeyDown,v=n.onPointerDownOutside,c=r(n,iH),l=gH(kH,t),s=sH(t),f=l.onClose;return(0,Ad.useEffect)((function(){return document.addEventListener(fH,f),function(){return document.removeEventListener(fH,f)}}),[f]),(0,Ad.useEffect)((function(){if(l.trigger){var n=function(n){var e=n.target;null!==e&&void 0!==e&&e.contains(l.trigger)&&f()};return window.addEventListener("scroll",n,{capture:!0}),function(){return window.removeEventListener("scroll",n,{capture:!0})}}}),[l.trigger,f]),(0,Ad.createElement)(Vq,{asChild:!0,disableOutsidePointerEvents:!1,onEscapeKeyDown:i,onPointerDownOutside:v,onFocusOutside:function(n){return n.preventDefault()},onDismiss:f},(0,Ad.createElement)(KW,ih({"data-state":l.stateAttribute},s,c,{ref:e,style:u(u({},c.style),{},{"--radix-tooltip-content-transform-origin":"var(--radix-popper-transform-origin)","--radix-tooltip-content-available-width":"var(--radix-popper-available-width)","--radix-tooltip-content-available-height":"var(--radix-popper-available-height)","--radix-tooltip-trigger-width":"var(--radix-popper-anchor-width)","--radix-tooltip-trigger-height":"var(--radix-popper-anchor-height)"})}),(0,Ad.createElement)(aG,null,o),(0,Ad.createElement)(TH,{scope:t,isInside:!0},(0,Ad.createElement)(rH,{id:l.contentId,role:"tooltip"},a||o))))})),PH="TooltipArrow",jH=(0,Ad.forwardRef)((function(n,e){var t=n.__scopeTooltip,o=r(n,vH),a=sH(t);return RH(PH,t).isInside?null:(0,Ad.createElement)(JW,ih({},a,o,{ref:e}))}));var FH,EH,IH,OH,LH,AH=yH,NH=_H,GH=MH,BH=jH;function qH(n,e){if(null==n)return{};var t,r,o=function(n,e){if(null==n)return{};var t,r,o={},a=Object.keys(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||(o[t]=n[t]);return o}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(o[t]=n[t])}return o}!function(n){n[n.UNSUPPORTED_INPUT=0]="UNSUPPORTED_INPUT",n[n.NO_COMPONENT_FOR_TYPE=1]="NO_COMPONENT_FOR_TYPE",n[n.UNKNOWN_INPUT=2]="UNKNOWN_INPUT",n[n.DUPLICATE_KEYS=3]="DUPLICATE_KEYS",n[n.ALREADY_REGISTERED_TYPE=4]="ALREADY_REGISTERED_TYPE",n[n.CLIPBOARD_ERROR=5]="CLIPBOARD_ERROR",n[n.THEME_ERROR=6]="THEME_ERROR",n[n.PATH_DOESNT_EXIST=7]="PATH_DOESNT_EXIST",n[n.INPUT_TYPE_OVERRIDE=8]="INPUT_TYPE_OVERRIDE",n[n.EMPTY_KEY=9]="EMPTY_KEY"}(LH||(LH={}));var VH=(l(FH={},LH.UNSUPPORTED_INPUT,(function(n,e){return["An input with type `".concat(n,"` input was found at path `").concat(e,"` but it's not supported yet.")]})),l(FH,LH.NO_COMPONENT_FOR_TYPE,(function(n,e){return["Type `".concat(n,"` found at path `").concat(e,"` can't be displayed in panel because no component supports it yet.")]})),l(FH,LH.UNKNOWN_INPUT,(function(n,e){return["input at path `".concat(n,"` is not recognized."),e]})),l(FH,LH.DUPLICATE_KEYS,(function(n,e,t){return["Key `".concat(n,"` of path `").concat(e,"` already exists at path `").concat(t,"`. Even nested keys need to be unique. Rename one of the keys.")]})),l(FH,LH.ALREADY_REGISTERED_TYPE,(function(n){return["Type ".concat(n," has already been registered. You can't register a component with the same type.")]})),l(FH,LH.CLIPBOARD_ERROR,(function(n){return["Error copying the value",n]})),l(FH,LH.THEME_ERROR,(function(n,e){return["Error accessing the theme `".concat(n,".").concat(e,"` value.")]})),l(FH,LH.PATH_DOESNT_EXIST,(function(n){return["Error getting the value at path `".concat(n,"`. There is probably an error in your `render` function.")]})),l(FH,LH.PATH_DOESNT_EXIST,(function(n){return["Error accessing the value at path `".concat(n,"`")]})),l(FH,LH.INPUT_TYPE_OVERRIDE,(function(n,e,t){return["Input at path `".concat(n,"` already exists with type: `").concat(e,"`. Its type cannot be overridden with type `").concat(t,"`.")]})),l(FH,LH.EMPTY_KEY,(function(){return["Keys can not be empty, if you want to hide a label use whitespace."]})),FH);function WH(n,e){for(var t,r=arguments.length,o=new Array(r>2?r-2:0),a=2;a<r;a++)o[a-2]=arguments[a];var i=VH[e].apply(VH,o),v=g(i),c=v[0],l=v.slice(1);(t=console)[n].apply(t,["LEVA: "+c].concat(x(l)))}var HH=WH.bind(null,"warn"),XH=WH.bind(null,"log"),YH=["value"],$H=["schema"],ZH=["value"],KH=[],JH={};function QH(n){var e,t=n.value,r=qH(n,YH),o=f(KH);try{for(o.s();!(e=o.n()).done;){var a=(0,e.value)(t,r);if(a)return a}}catch(i){o.e(i)}finally{o.f()}}function nX(n,e){var t=e.schema,r=qH(e,$H);n in JH?HH(LH.ALREADY_REGISTERED_TYPE,n):(KH.push((function(e,r){return t(e,r)&&n})),JH[n]=r)}function eX(n,e,t,r){var o=JH[n].normalize;return o?o(e,t,r):"object"===typeof e&&"value"in e?{value:e.value,settings:qH(e,ZH)}:{value:e}}function tX(n,e,t){var r=JH[n].format;return r?r(e,t):e}function rX(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function oX(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function aX(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?oX(Object(t),!0).forEach((function(e){rX(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):oX(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}var iX=function(n,e,t){return n>t?t:n<e?e:n},vX=function(n){if(""===n||"number"===typeof n)return n;try{var e=gX(n);if(!isNaN(e))return e}catch(t){}return parseFloat(n)},cX=Math.log(10);function lX(n){var e=Math.abs(+String(n).replace(".",""));if(0===e)return.01;for(;0!==e&&e%10===0;)e/=10;var t=Math.floor(Math.log(e)/cX)+1,r=Math.floor(Math.log10(Math.abs(n))),o=Math.pow(10,r-t);return Math.max(o,.001)}var sX=function(n,e,t){return t===e?0:(iX(n,e,t)-e)/(t-e)},uX=function(n,e,t){return n*(t-e)+e},fX=/\(([0-9+\-*/^ .]+)\)/,pX=/(\d+(?:\.\d+)?) ?\^ ?(\d+(?:\.\d+)?)/,dX=/(\d+(?:\.\d+)?) ?\* ?(\d+(?:\.\d+)?)/,mX=/(\d+(?:\.\d+)?) ?\/ ?(\d+(?:\.\d+)?)/,hX=/(\d+(?:\.\d+)?) ?\+ ?(\d+(?:\.\d+)?)/,xX=/(\d+(?:\.\d+)?) ?- ?(\d+(?:\.\d+)?)/;function gX(n){if(isNaN(Number(n))){if(fX.test(n)){var e=n.replace(fX,(function(n,e){return String(gX(e))}));return gX(e)}if(pX.test(n))return gX(n.replace(pX,(function(n,e,t){return String(Math.pow(Number(e),Number(t)))})));if(dX.test(n)){var t=n.replace(dX,(function(n,e,t){return String(Number(e)*Number(t))}));return gX(t)}if(mX.test(n)){var r=n.replace(mX,(function(n,e,t){if(0!=t)return String(Number(e)/Number(t));throw new Error("Division by zero")}));return gX(r)}if(hX.test(n)){var o=n.replace(hX,(function(n,e,t){return String(Number(e)+Number(t))}));return gX(o)}if(xX.test(n)){var a=n.replace(xX,(function(n,e,t){return String(Number(e)-Number(t))}));return gX(a)}return Number(n)}return Number(n)}function yX(n){return"[object Object]"===Object.prototype.toString.call(n)}var bX,_X,UX=function(n){return yX(n)&&0===Object.keys(n).length};!function(n){n.BUTTON="BUTTON",n.BUTTON_GROUP="BUTTON_GROUP",n.MONITOR="MONITOR",n.FOLDER="FOLDER"}(bX||(bX={})),function(n){n.SELECT="SELECT",n.IMAGE="IMAGE",n.NUMBER="NUMBER",n.COLOR="COLOR",n.STRING="STRING",n.BOOLEAN="BOOLEAN",n.INTERVAL="INTERVAL",n.VECTOR3D="VECTOR3D",n.VECTOR2D="VECTOR2D"}(_X||(_X={}));var wX=["type","__customInput"],SX=["render","label","optional","order","disabled","hint","onChange","onEditStart","onEditEnd","transient"],kX=["type"];function MX(n,e){var t,r,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3?arguments[3]:void 0;if("object"!==typeof n||Array.isArray(n))return{type:a,input:n,options:aX({key:e,label:e,optional:!1,disabled:!1,order:0},o)};if("__customInput"in n){var i=n.type,v=n.__customInput,c=qH(n,wX);return MX(v,e,c,i)}var l=n.render,s=n.label,u=n.optional,f=n.order,p=void 0===f?0:f,d=n.disabled,m=n.hint,h=n.onChange,x=n.onEditStart,g=n.onEditEnd,y=n.transient,b=qH(n,SX),_=aX({render:l,key:e,label:null!==s&&void 0!==s?s:e,hint:m,transient:null!==y&&void 0!==y?y:!!h,onEditStart:x,onEditEnd:g,disabled:d,optional:u,order:p},o),U=b.type,w=qH(b,kX);return(U=null!==a&&void 0!==a?a:U)in bX?{type:U,input:w,options:_}:{type:U,input:a&&yX(w)&&"value"in w?w.value:UX(w)?void 0:w,options:aX(aX({},_),{},{onChange:h,optional:null!==(t=_.optional)&&void 0!==t&&t,disabled:null!==(r=_.disabled)&&void 0!==r&&r})}}function zX(n,e,t,r){var o=MX(n,e),a=o.type,i=o.input,v=o.options;if(a)return a in bX?o:{type:a,input:eX(a,i,t,r),options:v};var c=QH(i);return c?{type:c,input:eX(c,i,t,r),options:v}:!!(c=QH({value:i}))&&{type:c,input:eX(c,{value:i},t,r),options:v}}function CX(n,e,t,r,o){var a=n.value,i=n.type,v=n.settings;n.value=RX({type:i,value:a,settings:v},e,t,r),n.fromPanel=o}var TX=function(n,e,t){this.type="LEVA_ERROR",this.message="LEVA: "+n,this.previousValue=e,this.error=t};function RX(n,e,t,r){var o,a=n.type,i=n.value,v=n.settings,c="SELECT"!==a&&"function"===typeof e?e(i):e;try{o=function(n,e,t,r,o,a){var i=JH[n].sanitize;return i?i(e,t,r,o,a):e}(a,c,v,i,t,r)}catch(l){throw new TX("The value `".concat(e,"` did not result in a correct value."),i,l)}return pG(o,i)?i:o}var DX=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=0;return function(){var o=this,a=arguments,i=t&&!r,v=function(){return n.apply(o,a)};window.clearTimeout(r),r=window.setTimeout(v,e),i&&v()}},PX=function(n){return n.shiftKey?5:n.altKey?.2:1};var jX=["value"],FX=["min","max"],EX=function(n,e){var t=e.min,r=void 0===t?-1/0:t,o=e.max,a=void 0===o?1/0:o,i=e.suffix,v=parseFloat(n);if(""===n||isNaN(v))throw Error("Invalid number");var c=iX(v,r,a);return i?c+i:c},IX=function(n){var e=n.value,t=qH(n,jX),r=t.min,o=void 0===r?-1/0:r,a=t.max,i=void 0===a?1/0:a,v=qH(t,FX),c=parseFloat(e),l="string"===typeof e?e.substring((""+c).length):void 0;c=iX(c,o,i);var s=t.step;s||(Number.isFinite(o)?s=Number.isFinite(i)?+(Math.abs(i-o)/100).toPrecision(1):+(Math.abs(c-o)/100).toPrecision(1):Number.isFinite(i)&&(s=+(Math.abs(i-c)/100).toPrecision(1)));var u=s?10*lX(s):lX(c);return{value:l?c+l:c,settings:aX({initialValue:c,step:s=s||u/10,pad:Math.round(iX(Math.log10(1/u),0,2)),min:o,max:i,suffix:l},v)}},OX=function(n,e){var t=e.step,r=e.initialValue;return r+Math.round((n-r)/t)*t},LX=Object.freeze({__proto__:null,schema:function(n){if("number"===typeof n)return!0;if("string"===typeof n){var e=parseFloat(n);return!isNaN(e)&&n.substring((""+e).length).trim().length<4}return!1},sanitize:EX,format:function(n,e){var t=e.pad,r=void 0===t?0:t,o=e.suffix,a=parseFloat(n).toFixed(r);return o?a+o:a},normalize:IX,sanitizeStep:OX});function AX(){return AX=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},AX.apply(this,arguments)}var NX=(0,Ad.createContext)({});function GX(){return(0,Ad.useContext)(NX)}var BX=(0,Ad.createContext)(null),qX=(0,Ad.createContext)(null),VX=(0,Ad.createContext)(null);function WX(){return(0,Ad.useContext)(qX)}function HX(n,e){var t=c(n.split(" "),2),r=t[0],o=t[1],a={};return"none"!==r&&(a.boxShadow="".concat(e.inset?"inset ":"","0 0 0 $borderWidths").concat([e.key]," $colors").concat("default"!==r&&r||e.borderColor)),o&&(a.backgroundColor=o),a}var XX={$inputStyle:function(){return function(n){return HX(n,{key:"$input",borderColor:"$highlight1",inset:!0})}},$focusStyle:function(){return function(n){return HX(n,{key:"$focus",borderColor:"$accent2"})}},$hoverStyle:function(){return function(n){return HX(n,{key:"$hover",borderColor:"$accent1",inset:!0})}},$activeStyle:function(){return function(n){return HX(n,{key:"$active",borderColor:"$accent1",inset:!0})}}},YX=DB({prefix:"leva",theme:{colors:{elevation1:"#292d39",elevation2:"#181c20",elevation3:"#373c4b",accent1:"#0066dc",accent2:"#007bff",accent3:"#3c93ff",highlight1:"#535760",highlight2:"#8c92a4",highlight3:"#fefefe",vivid1:"#ffcc00",folderWidgetColor:"$highlight2",folderTextColor:"$highlight3",toolTipBackground:"$highlight3",toolTipText:"$elevation2"},radii:{xs:"2px",sm:"3px",lg:"10px"},space:{xs:"3px",sm:"6px",md:"10px",rowGap:"7px",colGap:"7px"},fonts:{mono:"ui-monospace, SFMono-Regular, Menlo, 'Roboto Mono', monospace",sans:"system-ui, sans-serif"},fontSizes:{root:"11px",toolTip:"$root"},sizes:{rootWidth:"280px",controlWidth:"160px",numberInputMinWidth:"38px",scrubberWidth:"8px",scrubberHeight:"16px",rowHeight:"24px",folderTitleHeight:"20px",checkboxSize:"16px",joystickWidth:"100px",joystickHeight:"100px",colorPickerWidth:"$controlWidth",colorPickerHeight:"100px",imagePreviewWidth:"$controlWidth",imagePreviewHeight:"100px",monitorHeight:"60px",titleBarHeight:"39px"},shadows:{level1:"0 0 9px 0 #00000088",level2:"0 4px 14px #00000033"},borderWidths:{root:"0px",input:"1px",focus:"1px",hover:"1px",active:"1px",folder:"1px"},fontWeights:{label:"normal",folder:"normal",button:"normal"}},utils:aX(aX({},XX),{},{$flex:function(){return{display:"flex",alignItems:"center"}},$flexCenter:function(){return{display:"flex",alignItems:"center",justifyContent:"center"}},$reset:function(){return{outline:"none",fontSize:"inherit",fontWeight:"inherit",color:"inherit",fontFamily:"inherit",border:"none",backgroundColor:"transparent",appearance:"none"}},$draggable:function(){return{touchAction:"none",WebkitUserDrag:"none",userSelect:"none"}},$focus:function(n){return{"&:focus":XX.$focusStyle()(n)}},$focusWithin:function(n){return{"&:focus-within":XX.$focusStyle()(n)}},$hover:function(n){return{"&:hover":XX.$hoverStyle()(n)}},$active:function(n){return{"&:active":XX.$activeStyle()(n)}}})}),$X=YX.styled,ZX=(YX.css,YX.createTheme),KX=YX.globalCss,JX=(YX.keyframes,KX({".leva__panel__dragged":{WebkitUserDrag:"none",userSelect:"none",input:{userSelect:"none"},"*":{cursor:"ew-resize !important"}}}));function QX(n,e){var t=(0,Ad.useContext)(BX).theme;if(!(n in t)||!(e in t[n]))return HH(LH.THEME_ERROR,n,e),"";for(var r=e;;){var o=t[n][r];if("string"!==typeof o||"$"!==o.charAt(0))return o;r=o.substr(1)}}var nY=$X("input",{$reset:"",padding:"0 $sm",width:0,minWidth:0,flex:1,height:"100%",variants:{levaType:{number:{textAlign:"right"}},as:{textarea:{padding:"$sm"}}}}),eY=$X("div",l({$draggable:"",height:"100%",$flexCenter:"",position:"relative",padding:"0 $xs",fontSize:"0.8em",opacity:.8,cursor:"default",touchAction:"none"},"& + ".concat(nY),{paddingLeft:0})),tY=$X(eY,{cursor:"ew-resize",marginRight:"-$xs",textTransform:"uppercase",opacity:.3,"&:hover":{opacity:1},variants:{dragging:{true:{backgroundColor:"$accent2",opacity:1}}}}),rY=$X("div",{$flex:"",position:"relative",borderRadius:"$sm",overflow:"hidden",color:"inherit",height:"$rowHeight",backgroundColor:"$elevation3",$inputStyle:"$elevation1",$hover:"",$focusWithin:"",variants:{textArea:{true:{height:"auto"}}}}),oY=["innerLabel","value","onUpdate","onChange","onKeyDown","type","id","inputType","rows"],aY=["onUpdate"];function iY(n){var e=n.innerLabel,t=n.value,r=n.onUpdate,o=n.onChange,a=n.onKeyDown,i=n.type,v=n.id,c=n.inputType,l=void 0===c?"text":c,s=n.rows,u=void 0===s?0:s,f=qH(n,oY),p=GX(),d=p.id,m=p.emitOnEditStart,h=p.emitOnEditEnd,x=p.disabled,g=v||d,y=(0,Ad.useRef)(null),b=u>0,_=b?"textarea":"input",U=(0,Ad.useCallback)((function(n){return function(e){var t=e.currentTarget.value;n(t)}}),[]);Ad.useEffect((function(){var n=y.current,e=U((function(n){r(n),h()}));return null===n||void 0===n||n.addEventListener("blur",e),function(){return null===n||void 0===n?void 0:n.removeEventListener("blur",e)}}),[U,r,h]);var w=(0,Ad.useCallback)((function(n){"Enter"===n.key&&U(r)(n)}),[U,r]),S=Object.assign({as:_},b?{rows:u}:{},f);return Ad.createElement(rY,{textArea:b},e&&"string"===typeof e?Ad.createElement(eY,null,e):e,Ad.createElement(nY,AX({levaType:i,ref:y,id:g,type:l,autoComplete:"off",spellCheck:"false",value:t,onChange:U(o),onFocus:function(){return m()},onKeyPress:w,onKeyDown:a,disabled:x},S)))}function vY(n){var e=n.onUpdate,t=qH(n,aY),r=(0,Ad.useCallback)((function(n){return e(vX(n))}),[e]),o=(0,Ad.useCallback)((function(n){var t="ArrowUp"===n.key?1:"ArrowDown"===n.key?-1:0;if(t){n.preventDefault();var r=n.altKey?.1:n.shiftKey?10:1;e((function(n){return parseFloat(n)+t*r}))}}),[e]);return Ad.createElement(iY,AX({},t,{onUpdate:r,onKeyDown:o,type:"number"}))}var cY=$X("div",{}),lY=$X("div",{position:"relative",background:"$elevation2",transition:"height 300ms ease",variants:{fill:{true:{},false:{}},flat:{false:{},true:{}},isRoot:{true:{},false:{paddingLeft:"$md","&::after":{content:'""',position:"absolute",left:0,top:0,width:"$borderWidths$folder",height:"100%",backgroundColor:"$folderWidgetColor",opacity:.4,transform:"translateX(-50%)"}}}},compoundVariants:[{isRoot:!0,fill:!1,css:{overflowY:"auto",maxHeight:"calc(100vh - 20px - $$titleBarHeight)"}},{isRoot:!0,flat:!1,css:{borderRadius:"$lg"}}]}),sY=$X("div",(l(EH={$flex:"",color:"$folderTextColor",userSelect:"none",cursor:"pointer",height:"$folderTitleHeight",fontWeight:"$folder","> svg":{marginLeft:-4,marginRight:4,cursor:"pointer",fill:"$folderWidgetColor",opacity:.6},"&:hover > svg":{fill:"$folderWidgetColor"}},"&:hover + ".concat(lY,"::after"),{opacity:.6}),l(EH,"".concat(cY,":hover > & + ").concat(lY,"::after"),{opacity:.6}),l(EH,"".concat(cY,":hover > & > svg"),{opacity:1}),EH)),uY=$X("div",{position:"relative",display:"grid",gridTemplateColumns:"100%",rowGap:"$rowGap",transition:"opacity 250ms ease",variants:{toggled:{true:{opacity:1,transitionDelay:"250ms"},false:{opacity:0,transitionDelay:"0ms",pointerEvents:"none"}},isRoot:{true:l({"& > div":{paddingLeft:"$md",paddingRight:"$md"},"& > div:first-of-type":{paddingTop:"$sm"},"& > div:last-of-type":{paddingBottom:"$sm"}},"> ".concat(cY,":not(:first-of-type)"),{paddingTop:"$sm",marginTop:"$md",borderTop:"$borderWidths$folder solid $colors$elevation1"})}}}),fY=$X("div",(l(IH={position:"relative",zIndex:100,display:"grid",rowGap:"$rowGap",gridTemplateRows:"minmax($sizes$rowHeight, max-content)",alignItems:"center",color:"$highlight2"},"".concat(uY," > &"),{"&:first-of-type":{marginTop:"$rowGap"},"&:last-of-type":{marginBottom:"$rowGap"}}),l(IH,"variants",{disabled:{true:{pointerEvents:"none"},false:{"&:hover,&:focus-within":{color:"$highlight3"}}}}),IH)),pY=$X(fY,{gridTemplateColumns:"auto $sizes$controlWidth",columnGap:"$colGap"}),dY=$X("div",{$flex:"",height:"100%",position:"relative",overflow:"hidden","& > div":{marginLeft:"$colGap",padding:"0 $xs",opacity:.4},"& > div:hover":{opacity:.8},"& > div > svg":{display:"none",cursor:"pointer",width:13,minWidth:13,height:13,backgroundColor:"$elevation2"},"&:hover > div > svg":{display:"block"},variants:{align:{top:{height:"100%",alignItems:"flex-start",paddingTop:"$sm"}}}}),mY=$X("input",{$reset:"",height:0,width:0,opacity:0,margin:0,"& + label":{position:"relative",$flexCenter:"",height:"100%",userSelect:"none",cursor:"pointer",paddingLeft:2,paddingRight:"$sm",pointerEvents:"auto"},"& + label:after":{content:'""',width:6,height:6,backgroundColor:"$elevation3",borderRadius:"50%",$activeStyle:""},"&:focus + label:after":{$focusStyle:""},"& + label:active:after":{backgroundColor:"$accent1",$focusStyle:""},"&:checked + label:after":{backgroundColor:"$accent1"}}),hY=$X("label",{fontWeight:"$label",overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap","& > svg":{display:"block"}}),xY=$X("div",{opacity:1,variants:{disabled:{true:l({opacity:.6,pointerEvents:"none"},"& ".concat(hY),{pointerEvents:"auto"})}}}),gY=$X("div",{position:"fixed",top:0,bottom:0,right:0,left:0,zIndex:1e3,userSelect:"none"}),yY=$X("div",{background:"$toolTipBackground",fontFamily:"$sans",fontSize:"$toolTip",padding:"$xs $sm",color:"$toolTipText",borderRadius:"$xs",boxShadow:"$level2",maxWidth:260}),bY=$X(BH,{fill:"$toolTipBackground"});function _Y(n){var e=n.children,t=(0,Ad.useContext)(BX).className;return Ad.createElement(uG,{className:t},e)}var UY=["align"];function wY(){var n=GX(),e=n.id,t=n.disable,r=n.disabled;return Ad.createElement(Ad.Fragment,null,Ad.createElement(mY,{id:e+"__disable",type:"checkbox",checked:!r,onChange:function(){return t(!r)}}),Ad.createElement("label",{htmlFor:e+"__disable"}))}function SY(n){var e=GX(),t=e.id,r=e.optional,o=e.hint,a=n.htmlFor||(t?{htmlFor:t}:null),i=o||"string"!==typeof n.children?null:{title:n.children};return Ad.createElement(Ad.Fragment,null,r&&Ad.createElement(wY,null),void 0!==o?Ad.createElement(AH,null,Ad.createElement(NH,{asChild:!0},Ad.createElement(hY,AX({},a,n))),Ad.createElement(GH,{side:"top",sideOffset:2},Ad.createElement(yY,null,o,Ad.createElement(bY,null)))):Ad.createElement(hY,AX({},a,i,n)))}function kY(n){var e=n.align,t=qH(n,UY),r=GX(),o=r.value,a=r.label,i=r.key,v=r.disabled,s=!(0,Ad.useContext)(VX).hideCopyButton&&void 0!==i,u=c((0,Ad.useState)(!1),2),f=u[0],p=u[1],d=function(){var n=R(j().mark((function n(){return j().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.prev=0,n.next=3,navigator.clipboard.writeText(JSON.stringify(l({},i,null!==o&&void 0!==o?o:"")));case 3:p(!0),n.next=9;break;case 6:n.prev=6,n.t0=n.catch(0),HH(LH.CLIPBOARD_ERROR,l({},i,o));case 9:case"end":return n.stop()}}),n,null,[[0,6]])})));return function(){return n.apply(this,arguments)}}();return Ad.createElement(dY,{align:e,onPointerLeave:function(){return p(!1)}},Ad.createElement(SY,t),s&&!v&&Ad.createElement("div",{title:"Click to copy ".concat("string"===typeof a?a:i," value")},f?Ad.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor"},Ad.createElement("path",{d:"M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"}),Ad.createElement("path",{fillRule:"evenodd",d:"M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm9.707 5.707a1 1 0 00-1.414-1.414L9 12.586l-1.293-1.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z",clipRule:"evenodd"})):Ad.createElement("svg",{onClick:d,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor"},Ad.createElement("path",{d:"M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z"}),Ad.createElement("path",{d:"M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z"}))))}var MY=["toggled"],zY=$X("svg",{fill:"currentColor",transition:"transform 350ms ease, fill 250ms ease"});function CY(n){var e=n.toggled,t=qH(n,MY);return Ad.createElement(zY,AX({width:"9",height:"5",viewBox:"0 0 9 5",xmlns:"http://www.w3.org/2000/svg",style:{transform:"rotate(".concat(e?0:-90,"deg)")}},t),Ad.createElement("path",{d:"M3.8 4.4c.4.3 1 .3 1.4 0L8 1.7A1 1 0 007.4 0H1.6a1 1 0 00-.7 1.7l3 2.7z"}))}var TY=["input"];function RY(n){var e=n.input,t=qH(n,TY);return e?Ad.createElement(pY,t):Ad.createElement(fY,t)}function DY(n){var e=n.value,t=n.type,r=n.settings,o=n.setValue,a=c((0,Ad.useState)(tX(t,e,r)),2),i=a[0],v=a[1],l=(0,Ad.useRef)(e),s=(0,Ad.useRef)(r);s.current=r;var u=(0,Ad.useCallback)((function(n){return v(tX(t,n,s.current))}),[t]),f=(0,Ad.useCallback)((function(n){try{o(n)}catch(r){var e=r.type,t=r.previousValue;if("LEVA_ERROR"!==e)throw r;u(t)}}),[u,o]);return(0,Ad.useEffect)((function(){pG(e,l.current)||u(e),l.current=e}),[e,u]),{displayValue:i,onChange:v,onUpdate:f}}function PY(n,e){var t=GX(),r=t.emitOnEditStart,o=t.emitOnEditEnd;return Pq((function(e){e.first&&(document.body.classList.add("leva__panel__dragged"),null===r||void 0===r||r());var t=n(e);return e.last&&(document.body.classList.remove("leva__panel__dragged"),null===o||void 0===o||o()),t}),e)}function jY(){var n=(0,Ad.useRef)(null),e=(0,Ad.useRef)({x:0,y:0}),t=(0,Ad.useCallback)((function(t){Object.assign(e.current,t),n.current&&(n.current.style.transform="translate3d(".concat(e.current.x,"px, ").concat(e.current.y,"px, 0)"))}),[]);return[n,t]}var FY=["__refCount"],EY=function(n,e){return n[e]?qH(n[e],FY):null};var IY=$X("div",{variants:{hasRange:{true:{position:"relative",display:"grid",gridTemplateColumns:"auto $sizes$numberInputMinWidth",columnGap:"$colGap",alignItems:"center"}}}}),OY=$X("div",{position:"relative",width:"100%",height:2,borderRadius:"$xs",backgroundColor:"$elevation1"}),LY=$X("div",{position:"absolute",width:"$scrubberWidth",height:"$scrubberHeight",borderRadius:"$xs",boxShadow:"0 0 0 2px $colors$elevation2",backgroundColor:"$accent2",cursor:"pointer",$active:"none $accent1",$hover:"none $accent3",variants:{position:{left:{borderTopRightRadius:0,borderBottomRightRadius:0,transform:"translateX(calc(-0.5 * ($sizes$scrubberWidth + 4px)))"},right:{borderTopLeftRadius:0,borderBottomLeftRadius:0,transform:"translateX(calc(0.5 * ($sizes$scrubberWidth + 4px)))"}}}}),AY=$X("div",{position:"relative",$flex:"",height:"100%",cursor:"pointer",touchAction:"none"}),NY=$X("div",{position:"absolute",height:"100%",backgroundColor:"$accent2"});function GY(n){var e=n.value,t=n.min,r=n.max,o=n.onDrag,a=n.step,i=n.initialValue,v=(0,Ad.useRef)(null),l=(0,Ad.useRef)(null),s=(0,Ad.useRef)(0),u=QX("sizes","scrubberWidth"),f=PY((function(n){var f=n.event,p=n.first,d=c(n.xy,1)[0],m=c(n.movement,1)[0],h=n.memo;if(p){var x=v.current.getBoundingClientRect(),g=x.width,y=x.left;s.current=g-parseFloat(u),h=(null===f||void 0===f?void 0:f.target)===l.current?e:uX((d-y)/g,t,r)}var b=h+uX(m/s.current,0,r-t);return o(OX(b,{step:a,initialValue:i})),h})),p=sX(e,t,r);return Ad.createElement(AY,AX({ref:v},f()),Ad.createElement(OY,null,Ad.createElement(NY,{style:{left:0,right:"".concat(100*(1-p),"%")}})),Ad.createElement(LY,{ref:l,style:{left:"calc(".concat(p," * (100% - ").concat(u,"))")}}))}var BY=Ad.memo((function(n){var e=n.label,t=n.onUpdate,r=n.step,o=n.innerLabelTrim,a=c((0,Ad.useState)(!1),2),i=a[0],v=a[1],l=PY((function(n){var e=n.active,o=c(n.delta,1)[0],a=n.event,i=n.memo,l=void 0===i?0:i;return v(e),l+=o/2,Math.abs(l)>=1&&(t((function(n){return parseFloat(n)+Math.floor(l)*r*PX(a)})),l=0),l}));return Ad.createElement(tY,AX({dragging:i,title:e.length>1?e:""},l()),e.slice(0,o))}));function qY(n){var e=n.label,t=n.id,r=n.displayValue,o=n.onUpdate,a=n.onChange,i=n.settings,v=n.innerLabelTrim,c=void 0===v?1:v,l=c>0&&Ad.createElement(BY,{label:e,step:i.step,onUpdate:o,innerLabelTrim:c});return Ad.createElement(vY,{id:t,value:String(r),onUpdate:o,onChange:a,innerLabel:l})}var VY=LX.sanitizeStep,WY=aX({component:function(){var n=GX(),e=n.label,t=n.value,r=n.onUpdate,o=n.settings,a=n.id,i=o.min,v=o.max!==1/0&&i!==-1/0;return Ad.createElement(RY,{input:!0},Ad.createElement(kY,null,e),Ad.createElement(IY,{hasRange:v},v&&Ad.createElement(GY,AX({value:parseFloat(t),onDrag:r},o)),Ad.createElement(qY,AX({},n,{id:a,label:"value",innerLabelTrim:v?0:1}))))}},qH(LX,["sanitizeStep"])),HY=Object.freeze({__proto__:null,schema:function(n,e){return FG().schema({options:FG().passesAnyOf(FG().object(),FG().array())}).test(e)},sanitize:function(n,e){if(e.values.indexOf(n)<0)throw Error("Selected value doesn't match Select options");return n},format:function(n,e){return e.values.indexOf(n)},normalize:function(n){var e,t,r=n.value,o=n.options;return Array.isArray(o)?(t=o,e=o.map((function(n){return String(n)}))):(t=Object.values(o),e=Object.keys(o)),"value"in n?t.includes(r)||(e.unshift(String(r)),t.unshift(r)):r=t[0],Object.values(o).includes(r)||(o[String(r)]=r),{value:r,settings:{keys:e,values:t}}}}),XY=$X("div",{$flexCenter:"",position:"relative","> svg":{pointerEvents:"none",position:"absolute",right:"$md"}}),YY=$X("select",{position:"absolute",top:0,left:0,width:"100%",height:"100%",opacity:0}),$Y=$X("div",(l(OH={display:"flex",alignItems:"center",width:"100%",height:"$rowHeight",backgroundColor:"$elevation3",borderRadius:"$sm",padding:"0 $sm",cursor:"pointer"},"".concat(YY,":focus + &"),{$focusStyle:""}),l(OH,"".concat(YY,":hover + &"),{$hoverStyle:""}),OH));function ZY(n){var e=n.displayValue,t=n.value,r=n.onUpdate,o=n.id,a=n.settings,i=n.disabled,v=a.keys,c=a.values,l=(0,Ad.useRef)();return t===c[e]&&(l.current=v[e]),Ad.createElement(XY,null,Ad.createElement(YY,{id:o,value:e,onChange:function(n){return r(c[Number(n.currentTarget.value)])},disabled:i},v.map((function(n,e){return Ad.createElement("option",{key:n,value:e},n)}))),Ad.createElement($Y,null,l.current),Ad.createElement(CY,{toggled:!0}))}var KY=aX({component:function(){var n=GX(),e=n.label,t=n.value,r=n.displayValue,o=n.onUpdate,a=n.id,i=n.disabled,v=n.settings;return Ad.createElement(RY,{input:!0},Ad.createElement(kY,null,e),Ad.createElement(ZY,{id:a,value:t,displayValue:r,onUpdate:o,settings:v,disabled:i}))}},HY),JY=Object.freeze({__proto__:null,schema:function(n){return FG().string().test(n)},sanitize:function(n){if("string"!==typeof n)throw Error("Invalid string");return n},normalize:function(n){var e=n.value,t=n.editable,r=void 0===t||t,o=n.rows,a=void 0!==o&&o;return{value:e,settings:{editable:r,rows:"number"===typeof a?a:a?5:0}}}}),QY=["displayValue","onUpdate","onChange","editable"],n$=$X("div",{whiteSpace:"pre-wrap"});function e$(n){var e=n.displayValue,t=n.onUpdate,r=n.onChange,o=n.editable,a=void 0===o||o,i=qH(n,QY);return a?Ad.createElement(iY,AX({value:e,onUpdate:t,onChange:r},i)):Ad.createElement(n$,null,e)}var t$=aX({component:function(){var n=GX(),e=n.label,t=n.settings,r=n.displayValue,o=n.onUpdate,a=n.onChange;return Ad.createElement(RY,{input:!0},Ad.createElement(kY,null,e),Ad.createElement(e$,AX({displayValue:r,onUpdate:o,onChange:a},t)))}},JY),r$=Object.freeze({__proto__:null,schema:function(n){return FG().boolean().test(n)},sanitize:function(n){if("boolean"!==typeof n)throw Error("Invalid boolean");return n}}),o$=$X("div",{position:"relative",$flex:"",height:"$rowHeight",input:{$reset:"",height:0,width:0,opacity:0,margin:0},label:{position:"relative",$flexCenter:"",userSelect:"none",cursor:"pointer",height:"$checkboxSize",width:"$checkboxSize",backgroundColor:"$elevation3",borderRadius:"$sm",$hover:""},"input:focus + label":{$focusStyle:""},"input:focus:checked + label, input:checked + label:hover":{$hoverStyle:"$accent3"},"input + label:active":{backgroundColor:"$accent1"},"input:checked + label:active":{backgroundColor:"$accent1"},"label > svg":{display:"none",width:"90%",height:"90%",stroke:"$highlight3"},"input:checked + label":{backgroundColor:"$accent2"},"input:checked + label > svg":{display:"block"}});function a$(n){var e=n.value,t=n.onUpdate,r=n.id,o=n.disabled;return Ad.createElement(o$,null,Ad.createElement("input",{id:r,type:"checkbox",checked:e,onChange:function(n){return t(n.currentTarget.checked)},disabled:o}),Ad.createElement("label",{htmlFor:r},Ad.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24"},Ad.createElement("path",{strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:2,d:"M5 13l4 4L19 7"}))))}var i$=aX({component:function(){var n=GX(),e=n.label,t=n.value,r=n.onUpdate,o=n.disabled,a=n.id;return Ad.createElement(RY,{input:!0},Ad.createElement(kY,null,e),Ad.createElement(a$,{value:t,onUpdate:r,id:a,disabled:o}))}},r$),v$=["locked"];function c$(n){var e=n.value,t=n.id,r=n.valueKey,o=n.settings,a=n.onUpdate,i=n.innerLabelTrim,v=(0,Ad.useRef)(e[r]);v.current=e[r];var c=(0,Ad.useCallback)((function(n){return a(l({},r,RX({type:"NUMBER",value:v.current,settings:o},n)))}),[a,o,r]),s=DY({type:"NUMBER",value:e[r],settings:o,setValue:c});return Ad.createElement(qY,{id:t,label:r,value:e[r],displayValue:s.displayValue,onUpdate:s.onUpdate,onChange:s.onChange,settings:o,innerLabelTrim:i})}var l$=$X("div",{display:"grid",columnGap:"$colGap",gridAutoFlow:"column dense",alignItems:"center",variants:{withLock:{true:{gridTemplateColumns:"10px auto","> svg":{cursor:"pointer"}}}}});function s$(n){var e=n.locked,t=qH(n,v$);return Ad.createElement("svg",AX({width:"10",height:"10",viewBox:"0 0 15 15",fill:"none",xmlns:"http://www.w3.org/2000/svg"},t),e?Ad.createElement("path",{d:"M5 4.63601C5 3.76031 5.24219 3.1054 5.64323 2.67357C6.03934 2.24705 6.64582 1.9783 7.5014 1.9783C8.35745 1.9783 8.96306 2.24652 9.35823 2.67208C9.75838 3.10299 10 3.75708 10 4.63325V5.99999H5V4.63601ZM4 5.99999V4.63601C4 3.58148 4.29339 2.65754 4.91049 1.99307C5.53252 1.32329 6.42675 0.978302 7.5014 0.978302C8.57583 0.978302 9.46952 1.32233 10.091 1.99162C10.7076 2.65557 11 3.57896 11 4.63325V5.99999H12C12.5523 5.99999 13 6.44771 13 6.99999V13C13 13.5523 12.5523 14 12 14H3C2.44772 14 2 13.5523 2 13V6.99999C2 6.44771 2.44772 5.99999 3 5.99999H4ZM3 6.99999H12V13H3V6.99999Z",fill:"currentColor",fillRule:"evenodd",clipRule:"evenodd"}):Ad.createElement("path",{d:"M9 3.63601C9 2.76044 9.24207 2.11211 9.64154 1.68623C10.0366 1.26502 10.6432 1 11.5014 1C12.4485 1 13.0839 1.30552 13.4722 1.80636C13.8031 2.23312 14 2.84313 14 3.63325H15C15 2.68242 14.7626 1.83856 14.2625 1.19361C13.6389 0.38943 12.6743 0 11.5014 0C10.4294 0 9.53523 0.337871 8.91218 1.0021C8.29351 1.66167 8 2.58135 8 3.63601V6H1C0.447715 6 0 6.44772 0 7V13C0 13.5523 0.447715 14 1 14H10C10.5523 14 11 13.5523 11 13V7C11 6.44772 10.5523 6 10 6H9V3.63601ZM1 7H10V13H1V7Z",fill:"currentColor",fillRule:"evenodd",clipRule:"evenodd"}))}function u$(n){var e=n.value,t=n.onUpdate,r=n.settings,o=n.innerLabelTrim,a=GX(),i=a.id,v=a.setSettings,c=r.lock,l=r.locked;return Ad.createElement(l$,{withLock:c},c&&Ad.createElement(s$,{locked:l,onClick:function(){return v({locked:!l})}}),Object.keys(e).map((function(n,a){return Ad.createElement(c$,{id:0===a?i:"".concat(i,".").concat(n),key:n,valueKey:n,value:e,settings:r[n],onUpdate:t,innerLabelTrim:o})})))}var f$=function(n,e){var t={},r=0,o=1/0;for(var a in Object.entries(n).forEach((function(n){var a=c(n,2),i=a[0],v=a[1];t[i]=IX(aX({value:v},e[i])).settings,r=Math.max(r,t[i].step),o=Math.min(o,t[i].pad)})),t){var i=e[a]||{},v=i.step,l=i.min,s=i.max;isFinite(v)||isFinite(l)&&isFinite(s)||(t[a].step=r,t[a].pad=o)}return t},p$=["lock"],d$=["value"];function m$(n){var e=FG().array().length(n).every.number();return function(t){return e.test(t)||function(e){if(!e||"object"!==typeof e)return!1;var t=Object.values(e);return t.length===n&&t.every((function(n){return isFinite(n)}))}(t)}}function h$(n,e,t){return function(n){return Array.isArray(n)?"array":"object"}(n)===e?n:"array"===e?Object.values(n):function(n,e){return n.reduce((function(n,t,r){return Object.assign(n,l({},e[r],t))}),{})}(n,t)}var x$=function(n){return!!n&&("step"in n||"min"in n||"max"in n)};function g$(n){return{schema:m$(n.length),normalize:function(e){return function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=e.lock,o=void 0!==r&&r,a=qH(e,p$),i=Array.isArray(n)?"array":"object",v="object"===i?Object.keys(n):t,c=h$(n,"object",v),s=x$(a)?v.reduce((function(n,e){return Object.assign(n,l({},e,a))}),{}):a,u=f$(c,s);return{value:"array"===i?n:c,settings:aX(aX({},u),{},{format:i,keys:v,lock:o,locked:!1})}}(e.value,qH(e,d$),n)},format:function(n,e){return function(n,e){return h$(n,"object",e.keys)}(n,e)},sanitize:function(n,e,t){return function(n,e,t){var r=h$(n,"object",e.keys);for(var o in r)r[o]=EX(r[o],e[o]);var a=Object.keys(r),i={};if(a.length===e.keys.length)i=r;else{var v=h$(t,"object",e.keys);if(1===a.length&&e.locked){var c=a[0],l=r[c],s=v[c],u=0!==s?l/s:1;for(var f in v)f===c?i[c]=l:i[f]=v[f]*u}else i=aX(aX({},v),r)}return h$(i,e.format,e.keys)}(n,e,t)}}}var y$={grad:.9,turn:360,rad:360/(2*Math.PI)},b$=function(n){return"string"==typeof n?n.length>0:"number"==typeof n},_$=function(n,e,t){return void 0===e&&(e=0),void 0===t&&(t=Math.pow(10,e)),Math.round(t*n)/t+0},U$=function(n,e,t){return void 0===e&&(e=0),void 0===t&&(t=1),n>t?t:n>e?n:e},w$=function(n){return(n=isFinite(n)?n%360:0)>0?n:n+360},S$=function(n){return{r:U$(n.r,0,255),g:U$(n.g,0,255),b:U$(n.b,0,255),a:U$(n.a)}},k$=function(n){return{r:_$(n.r),g:_$(n.g),b:_$(n.b),a:_$(n.a,3)}},M$=/^#([0-9a-f]{3,8})$/i,z$=function(n){var e=n.toString(16);return e.length<2?"0"+e:e},C$=function(n){var e=n.r,t=n.g,r=n.b,o=n.a,a=Math.max(e,t,r),i=a-Math.min(e,t,r),v=i?a===e?(t-r)/i:a===t?2+(r-e)/i:4+(e-t)/i:0;return{h:60*(v<0?v+6:v),s:a?i/a*100:0,v:a/255*100,a:o}},T$=function(n){var e=n.h,t=n.s,r=n.v,o=n.a;e=e/360*6,t/=100,r/=100;var a=Math.floor(e),i=r*(1-t),v=r*(1-(e-a)*t),c=r*(1-(1-e+a)*t),l=a%6;return{r:255*[r,v,i,i,c,r][l],g:255*[c,r,r,v,i,i][l],b:255*[i,i,c,r,r,v][l],a:o}},R$=function(n){return{h:w$(n.h),s:U$(n.s,0,100),l:U$(n.l,0,100),a:U$(n.a)}},D$=function(n){return{h:_$(n.h),s:_$(n.s),l:_$(n.l),a:_$(n.a,3)}},P$=function(n){return T$((t=(e=n).s,{h:e.h,s:(t*=((r=e.l)<50?r:100-r)/100)>0?2*t/(r+t)*100:0,v:r+t,a:e.a}));var e,t,r},j$=function(n){return{h:(e=C$(n)).h,s:(o=(200-(t=e.s))*(r=e.v)/100)>0&&o<200?t*r/100/(o<=100?o:200-o)*100:0,l:o/2,a:e.a};var e,t,r,o},F$=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,E$=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,I$=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,O$=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,L$={string:[[function(n){var e=M$.exec(n);return e?(n=e[1]).length<=4?{r:parseInt(n[0]+n[0],16),g:parseInt(n[1]+n[1],16),b:parseInt(n[2]+n[2],16),a:4===n.length?_$(parseInt(n[3]+n[3],16)/255,2):1}:6===n.length||8===n.length?{r:parseInt(n.substr(0,2),16),g:parseInt(n.substr(2,2),16),b:parseInt(n.substr(4,2),16),a:8===n.length?_$(parseInt(n.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(n){var e=I$.exec(n)||O$.exec(n);return e?e[2]!==e[4]||e[4]!==e[6]?null:S$({r:Number(e[1])/(e[2]?100/255:1),g:Number(e[3])/(e[4]?100/255:1),b:Number(e[5])/(e[6]?100/255:1),a:void 0===e[7]?1:Number(e[7])/(e[8]?100:1)}):null},"rgb"],[function(n){var e=F$.exec(n)||E$.exec(n);if(!e)return null;var t,r,o=R$({h:(t=e[1],r=e[2],void 0===r&&(r="deg"),Number(t)*(y$[r]||1)),s:Number(e[3]),l:Number(e[4]),a:void 0===e[5]?1:Number(e[5])/(e[6]?100:1)});return P$(o)},"hsl"]],object:[[function(n){var e=n.r,t=n.g,r=n.b,o=n.a,a=void 0===o?1:o;return b$(e)&&b$(t)&&b$(r)?S$({r:Number(e),g:Number(t),b:Number(r),a:Number(a)}):null},"rgb"],[function(n){var e=n.h,t=n.s,r=n.l,o=n.a,a=void 0===o?1:o;if(!b$(e)||!b$(t)||!b$(r))return null;var i=R$({h:Number(e),s:Number(t),l:Number(r),a:Number(a)});return P$(i)},"hsl"],[function(n){var e=n.h,t=n.s,r=n.v,o=n.a,a=void 0===o?1:o;if(!b$(e)||!b$(t)||!b$(r))return null;var i=function(n){return{h:w$(n.h),s:U$(n.s,0,100),v:U$(n.v,0,100),a:U$(n.a)}}({h:Number(e),s:Number(t),v:Number(r),a:Number(a)});return T$(i)},"hsv"]]},A$=function(n,e){for(var t=0;t<e.length;t++){var r=e[t][0](n);if(r)return[r,e[t][1]]}return[null,void 0]},N$=function(n){return"string"==typeof n?A$(n.trim(),L$.string):"object"==typeof n&&null!==n?A$(n,L$.object):[null,void 0]},G$=function(n,e){var t=j$(n);return{h:t.h,s:U$(t.s+100*e,0,100),l:t.l,a:t.a}},B$=function(n){return(299*n.r+587*n.g+114*n.b)/1e3/255},q$=function(n,e){var t=j$(n);return{h:t.h,s:t.s,l:U$(t.l+100*e,0,100),a:t.a}},V$=function(){function n(n){this.parsed=N$(n)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return n.prototype.isValid=function(){return null!==this.parsed},n.prototype.brightness=function(){return _$(B$(this.rgba),2)},n.prototype.isDark=function(){return B$(this.rgba)<.5},n.prototype.isLight=function(){return B$(this.rgba)>=.5},n.prototype.toHex=function(){return e=(n=k$(this.rgba)).r,t=n.g,r=n.b,a=(o=n.a)<1?z$(_$(255*o)):"","#"+z$(e)+z$(t)+z$(r)+a;var n,e,t,r,o,a},n.prototype.toRgb=function(){return k$(this.rgba)},n.prototype.toRgbString=function(){return e=(n=k$(this.rgba)).r,t=n.g,r=n.b,(o=n.a)<1?"rgba("+e+", "+t+", "+r+", "+o+")":"rgb("+e+", "+t+", "+r+")";var n,e,t,r,o},n.prototype.toHsl=function(){return D$(j$(this.rgba))},n.prototype.toHslString=function(){return e=(n=D$(j$(this.rgba))).h,t=n.s,r=n.l,(o=n.a)<1?"hsla("+e+", "+t+"%, "+r+"%, "+o+")":"hsl("+e+", "+t+"%, "+r+"%)";var n,e,t,r,o},n.prototype.toHsv=function(){return n=C$(this.rgba),{h:_$(n.h),s:_$(n.s),v:_$(n.v),a:_$(n.a,3)};var n},n.prototype.invert=function(){return W$({r:255-(n=this.rgba).r,g:255-n.g,b:255-n.b,a:n.a});var n},n.prototype.saturate=function(n){return void 0===n&&(n=.1),W$(G$(this.rgba,n))},n.prototype.desaturate=function(n){return void 0===n&&(n=.1),W$(G$(this.rgba,-n))},n.prototype.grayscale=function(){return W$(G$(this.rgba,-1))},n.prototype.lighten=function(n){return void 0===n&&(n=.1),W$(q$(this.rgba,n))},n.prototype.darken=function(n){return void 0===n&&(n=.1),W$(q$(this.rgba,-n))},n.prototype.rotate=function(n){return void 0===n&&(n=15),this.hue(this.hue()+n)},n.prototype.alpha=function(n){return"number"==typeof n?W$({r:(e=this.rgba).r,g:e.g,b:e.b,a:n}):_$(this.rgba.a,3);var e},n.prototype.hue=function(n){var e=j$(this.rgba);return"number"==typeof n?W$({h:n,s:e.s,l:e.l,a:e.a}):_$(e.h)},n.prototype.isEqual=function(n){return this.toHex()===W$(n).toHex()},n}(),W$=function(n){return n instanceof V$?n:new V$(n)},H$=[];function X$(){return(X$=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n}).apply(this,arguments)}function Y$(n,e){if(null==n)return{};var t,r,o={},a=Object.keys(n);for(r=0;r<a.length;r++)e.indexOf(t=a[r])>=0||(o[t]=n[t]);return o}function $$(n){var e=(0,Ad.useRef)(n),t=(0,Ad.useRef)((function(n){e.current&&e.current(n)}));return e.current=n,t.current}var Z$=function(n,e,t){return void 0===e&&(e=0),void 0===t&&(t=1),n>t?t:n<e?e:n},K$=function(n){return"touches"in n},J$=function(n){return n&&n.ownerDocument.defaultView||self},Q$=function(n,e,t){var r=n.getBoundingClientRect(),o=K$(e)?function(n,e){for(var t=0;t<n.length;t++)if(n[t].identifier===e)return n[t];return n[0]}(e.touches,t):e;return{left:Z$((o.pageX-(r.left+J$(n).pageXOffset))/r.width),top:Z$((o.pageY-(r.top+J$(n).pageYOffset))/r.height)}},nZ=function(n){!K$(n)&&n.preventDefault()},eZ=Ad.memo((function(n){var e=n.onMove,t=n.onKey,r=Y$(n,["onMove","onKey"]),o=(0,Ad.useRef)(null),a=$$(e),i=$$(t),v=(0,Ad.useRef)(null),c=(0,Ad.useRef)(!1),l=(0,Ad.useMemo)((function(){var n=function(n){nZ(n),(K$(n)?n.touches.length>0:n.buttons>0)&&o.current?a(Q$(o.current,n,v.current)):t(!1)},e=function(){return t(!1)};function t(t){var r=c.current,a=J$(o.current),i=t?a.addEventListener:a.removeEventListener;i(r?"touchmove":"mousemove",n),i(r?"touchend":"mouseup",e)}return[function(n){var e=n.nativeEvent,r=o.current;if(r&&(nZ(e),!function(n,e){return e&&!K$(n)}(e,c.current)&&r)){if(K$(e)){c.current=!0;var i=e.changedTouches||[];i.length&&(v.current=i[0].identifier)}r.focus(),a(Q$(r,e,v.current)),t(!0)}},function(n){var e=n.which||n.keyCode;e<37||e>40||(n.preventDefault(),i({left:39===e?.05:37===e?-.05:0,top:40===e?.05:38===e?-.05:0}))},t]}),[i,a]),s=l[0],u=l[1],f=l[2];return(0,Ad.useEffect)((function(){return f}),[f]),Ad.createElement("div",X$({},r,{onTouchStart:s,onMouseDown:s,className:"react-colorful__interactive",ref:o,onKeyDown:u,tabIndex:0,role:"slider"}))})),tZ=function(n){return n.filter(Boolean).join(" ")},rZ=function(n){var e=n.color,t=n.left,r=n.top,o=void 0===r?.5:r,a=tZ(["react-colorful__pointer",n.className]);return Ad.createElement("div",{className:a,style:{top:100*o+"%",left:100*t+"%"}},Ad.createElement("div",{className:"react-colorful__pointer-fill",style:{backgroundColor:e}}))},oZ=function(n,e,t){return void 0===e&&(e=0),void 0===t&&(t=Math.pow(10,e)),Math.round(t*n)/t},aZ=(Math.PI,function(n){var e=n.s,t=n.v,r=n.a,o=(200-e)*t/100;return{h:oZ(n.h),s:oZ(o>0&&o<200?e*t/100/(o<=100?o:200-o)*100:0),l:oZ(o/2),a:oZ(r,2)}}),iZ=function(n){var e=aZ(n);return"hsl("+e.h+", "+e.s+"%, "+e.l+"%)"},vZ=function(n){var e=aZ(n);return"hsla("+e.h+", "+e.s+"%, "+e.l+"%, "+e.a+")"},cZ=function(n){var e=n.h,t=n.s,r=n.v,o=n.a;e=e/360*6,t/=100,r/=100;var a=Math.floor(e),i=r*(1-t),v=r*(1-(e-a)*t),c=r*(1-(1-e+a)*t),l=a%6;return{r:oZ(255*[r,v,i,i,c,r][l]),g:oZ(255*[c,r,r,v,i,i][l]),b:oZ(255*[i,i,c,r,r,v][l]),a:oZ(o,2)}},lZ=function(n){var e=n.r,t=n.g,r=n.b,o=n.a,a=Math.max(e,t,r),i=a-Math.min(e,t,r),v=i?a===e?(t-r)/i:a===t?2+(r-e)/i:4+(e-t)/i:0;return{h:oZ(60*(v<0?v+6:v)),s:oZ(a?i/a*100:0),v:oZ(a/255*100),a:o}},sZ=Ad.memo((function(n){var e=n.hue,t=n.onChange,r=tZ(["react-colorful__hue",n.className]);return Ad.createElement("div",{className:r},Ad.createElement(eZ,{onMove:function(n){t({h:360*n.left})},onKey:function(n){t({h:Z$(e+360*n.left,0,360)})},"aria-label":"Hue","aria-valuenow":oZ(e),"aria-valuemax":"360","aria-valuemin":"0"},Ad.createElement(rZ,{className:"react-colorful__hue-pointer",left:e/360,color:iZ({h:e,s:100,v:100,a:1})})))})),uZ=Ad.memo((function(n){var e=n.hsva,t=n.onChange,r={backgroundColor:iZ({h:e.h,s:100,v:100,a:1})};return Ad.createElement("div",{className:"react-colorful__saturation",style:r},Ad.createElement(eZ,{onMove:function(n){t({s:100*n.left,v:100-100*n.top})},onKey:function(n){t({s:Z$(e.s+100*n.left,0,100),v:Z$(e.v-100*n.top,0,100)})},"aria-label":"Color","aria-valuetext":"Saturation "+oZ(e.s)+"%, Brightness "+oZ(e.v)+"%"},Ad.createElement(rZ,{className:"react-colorful__saturation-pointer",top:1-e.v/100,left:e.s/100,color:iZ(e)})))})),fZ=function(n,e){if(n===e)return!0;for(var t in n)if(n[t]!==e[t])return!1;return!0};function pZ(n,e,t){var r=$$(t),o=(0,Ad.useState)((function(){return n.toHsva(e)})),a=o[0],i=o[1],v=(0,Ad.useRef)({color:e,hsva:a});(0,Ad.useEffect)((function(){if(!n.equal(e,v.current.color)){var t=n.toHsva(e);v.current={hsva:t,color:e},i(t)}}),[e,n]),(0,Ad.useEffect)((function(){var e;fZ(a,v.current.hsva)||n.equal(e=n.fromHsva(a),v.current.color)||(v.current={hsva:a,color:e},r(e))}),[a,n,r]);var c=(0,Ad.useCallback)((function(n){i((function(e){return Object.assign({},e,n)}))}),[]);return[a,c]}var dZ,mZ="undefined"!=typeof window?Ad.useLayoutEffect:Ad.useEffect,hZ=new Map,xZ=function(n){mZ((function(){var e=n.current?n.current.ownerDocument:document;if(void 0!==e&&!hZ.has(e)){var r=e.createElement("style");r.innerHTML='.react-colorful{position:relative;display:flex;flex-direction:column;width:200px;height:200px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.react-colorful__saturation{position:relative;flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(0deg,#000,transparent),linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.react-colorful__alpha-gradient,.react-colorful__pointer-fill{content:"";position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;border-radius:inherit}.react-colorful__alpha-gradient,.react-colorful__saturation{box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}.react-colorful__alpha,.react-colorful__hue{position:relative;height:24px}.react-colorful__hue{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.react-colorful__last-control{border-radius:0 0 8px 8px}.react-colorful__interactive{position:absolute;left:0;top:0;right:0;bottom:0;border-radius:inherit;outline:none;touch-action:none}.react-colorful__pointer{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}.react-colorful__interactive:focus .react-colorful__pointer{transform:translate(-50%,-50%) scale(1.1)}.react-colorful__alpha,.react-colorful__alpha-pointer{background-color:#fff;background-image:url(\'data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>\')}.react-colorful__saturation-pointer{z-index:3}.react-colorful__hue-pointer{z-index:2}',hZ.set(e,r);var o=dZ||t.nc;o&&r.setAttribute("nonce",o),e.head.appendChild(r)}}),[])},gZ=function(n){var e=n.className,t=n.colorModel,r=n.color,o=void 0===r?t.defaultColor:r,a=n.onChange,i=Y$(n,["className","colorModel","color","onChange"]),v=(0,Ad.useRef)(null);xZ(v);var c=pZ(t,o,a),l=c[0],s=c[1],u=tZ(["react-colorful",e]);return Ad.createElement("div",X$({},i,{ref:v,className:u}),Ad.createElement(uZ,{hsva:l,onChange:s}),Ad.createElement(sZ,{hue:l.h,onChange:s,className:"react-colorful__last-control"}))},yZ=function(n){var e=n.className,t=n.hsva,r=n.onChange,o={backgroundImage:"linear-gradient(90deg, "+vZ(Object.assign({},t,{a:0}))+", "+vZ(Object.assign({},t,{a:1}))+")"},a=tZ(["react-colorful__alpha",e]),i=oZ(100*t.a);return Ad.createElement("div",{className:a},Ad.createElement("div",{className:"react-colorful__alpha-gradient",style:o}),Ad.createElement(eZ,{onMove:function(n){r({a:n.left})},onKey:function(n){r({a:Z$(t.a+n.left)})},"aria-label":"Alpha","aria-valuetext":i+"%","aria-valuenow":i,"aria-valuemin":"0","aria-valuemax":"100"},Ad.createElement(rZ,{className:"react-colorful__alpha-pointer",left:t.a,color:vZ(t)})))},bZ=function(n){var e=n.className,t=n.colorModel,r=n.color,o=void 0===r?t.defaultColor:r,a=n.onChange,i=Y$(n,["className","colorModel","color","onChange"]),v=(0,Ad.useRef)(null);xZ(v);var c=pZ(t,o,a),l=c[0],s=c[1],u=tZ(["react-colorful",e]);return Ad.createElement("div",X$({},i,{ref:v,className:u}),Ad.createElement(uZ,{hsva:l,onChange:s}),Ad.createElement(sZ,{hue:l.h,onChange:s}),Ad.createElement(yZ,{hsva:l,onChange:s,className:"react-colorful__last-control"}))},_Z={defaultColor:{r:0,g:0,b:0,a:1},toHsva:lZ,fromHsva:cZ,equal:fZ},UZ=function(n){return Ad.createElement(bZ,X$({},n,{colorModel:_Z}))},wZ={defaultColor:{r:0,g:0,b:0},toHsva:function(n){return lZ({r:n.r,g:n.g,b:n.b,a:1})},fromHsva:function(n){return{r:(e=cZ(n)).r,g:e.g,b:e.b};var e},equal:fZ},SZ=function(n){return Ad.createElement(gZ,X$({},n,{colorModel:wZ}))},kZ=t(7),MZ=t.n(kZ);function zZ(n,e,t,r){return new(t||(t=Promise))((function(o,a){function i(n){try{c(r.next(n))}catch(e){a(e)}}function v(n){try{c(r.throw(n))}catch(e){a(e)}}function c(n){var e;n.done?o(n.value):(e=n.value,e instanceof t?e:new t((function(n){n(e)}))).then(i,v)}c((r=r.apply(n,e||[])).next())}))}function CZ(n,e){var t,r,o,a,i={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return a={next:v(0),throw:v(1),return:v(2)},"function"===typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function v(v){return function(c){return function(v){if(t)throw new TypeError("Generator is already executing.");for(;a&&(a=0,v[0]&&(i=0)),i;)try{if(t=1,r&&(o=2&v[0]?r.return:v[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,v[1])).done)return o;switch(r=0,o&&(v=[2&v[0],o.value]),v[0]){case 0:case 1:o=v;break;case 4:return i.label++,{value:v[1],done:!1};case 5:i.label++,r=v[1],v=[0];continue;case 7:v=i.ops.pop(),i.trys.pop();continue;default:if(!(o=(o=i.trys).length>0&&o[o.length-1])&&(6===v[0]||2===v[0])){i=0;continue}if(3===v[0]&&(!o||v[1]>o[0]&&v[1]<o[3])){i.label=v[1];break}if(6===v[0]&&i.label<o[1]){i.label=o[1],o=v;break}if(o&&i.label<o[2]){i.label=o[2],i.ops.push(v);break}o[2]&&i.ops.pop(),i.trys.pop();continue}v=e.call(n,i)}catch(c){v=[6,c],r=0}finally{t=o=0}if(5&v[0])throw v[1];return{value:v[0]?v[1]:void 0,done:!0}}([v,c])}}}Object.create;function TZ(n,e){var t="function"===typeof Symbol&&n[Symbol.iterator];if(!t)return n;var r,o,a=t.call(n),i=[];try{for(;(void 0===e||e-- >0)&&!(r=a.next()).done;)i.push(r.value)}catch(v){o={error:v}}finally{try{r&&!r.done&&(t=a.return)&&t.call(a)}finally{if(o)throw o.error}}return i}Object.create;var RZ=new Map([["aac","audio/aac"],["abw","application/x-abiword"],["arc","application/x-freearc"],["avif","image/avif"],["avi","video/x-msvideo"],["azw","application/vnd.amazon.ebook"],["bin","application/octet-stream"],["bmp","image/bmp"],["bz","application/x-bzip"],["bz2","application/x-bzip2"],["cda","application/x-cdf"],["csh","application/x-csh"],["css","text/css"],["csv","text/csv"],["doc","application/msword"],["docx","application/vnd.openxmlformats-officedocument.wordprocessingml.document"],["eot","application/vnd.ms-fontobject"],["epub","application/epub+zip"],["gz","application/gzip"],["gif","image/gif"],["heic","image/heic"],["heif","image/heif"],["htm","text/html"],["html","text/html"],["ico","image/vnd.microsoft.icon"],["ics","text/calendar"],["jar","application/java-archive"],["jpeg","image/jpeg"],["jpg","image/jpeg"],["js","text/javascript"],["json","application/json"],["jsonld","application/ld+json"],["mid","audio/midi"],["midi","audio/midi"],["mjs","text/javascript"],["mp3","audio/mpeg"],["mp4","video/mp4"],["mpeg","video/mpeg"],["mpkg","application/vnd.apple.installer+xml"],["odp","application/vnd.oasis.opendocument.presentation"],["ods","application/vnd.oasis.opendocument.spreadsheet"],["odt","application/vnd.oasis.opendocument.text"],["oga","audio/ogg"],["ogv","video/ogg"],["ogx","application/ogg"],["opus","audio/opus"],["otf","font/otf"],["png","image/png"],["pdf","application/pdf"],["php","application/x-httpd-php"],["ppt","application/vnd.ms-powerpoint"],["pptx","application/vnd.openxmlformats-officedocument.presentationml.presentation"],["rar","application/vnd.rar"],["rtf","application/rtf"],["sh","application/x-sh"],["svg","image/svg+xml"],["swf","application/x-shockwave-flash"],["tar","application/x-tar"],["tif","image/tiff"],["tiff","image/tiff"],["ts","video/mp2t"],["ttf","font/ttf"],["txt","text/plain"],["vsd","application/vnd.visio"],["wav","audio/wav"],["weba","audio/webm"],["webm","video/webm"],["webp","image/webp"],["woff","font/woff"],["woff2","font/woff2"],["xhtml","application/xhtml+xml"],["xls","application/vnd.ms-excel"],["xlsx","application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],["xml","application/xml"],["xul","application/vnd.mozilla.xul+xml"],["zip","application/zip"],["7z","application/x-7z-compressed"],["mkv","video/x-matroska"],["mov","video/quicktime"],["msg","application/vnd.ms-outlook"]]);function DZ(n,e){var t=function(n){var e=n.name;if(e&&-1!==e.lastIndexOf(".")&&!n.type){var t=e.split(".").pop().toLowerCase(),r=RZ.get(t);r&&Object.defineProperty(n,"type",{value:r,writable:!1,configurable:!1,enumerable:!0})}return n}(n);if("string"!==typeof t.path){var r=n.webkitRelativePath;Object.defineProperty(t,"path",{value:"string"===typeof e?e:"string"===typeof r&&r.length>0?r:n.name,writable:!1,configurable:!1,enumerable:!0})}return t}var PZ=[".DS_Store","Thumbs.db"];function jZ(n){return"object"===typeof n&&null!==n}function FZ(n){return LZ(n.target.files).map((function(n){return DZ(n)}))}function EZ(n){return zZ(this,void 0,void 0,(function(){return CZ(this,(function(e){switch(e.label){case 0:return[4,Promise.all(n.map((function(n){return n.getFile()})))];case 1:return[2,e.sent().map((function(n){return DZ(n)}))]}}))}))}function IZ(n,e){return zZ(this,void 0,void 0,(function(){var t;return CZ(this,(function(r){switch(r.label){case 0:return null===n?[2,[]]:n.items?(t=LZ(n.items).filter((function(n){return"file"===n.kind})),"drop"!==e?[2,t]:[4,Promise.all(t.map(AZ))]):[3,2];case 1:return[2,OZ(NZ(r.sent()))];case 2:return[2,OZ(LZ(n.files).map((function(n){return DZ(n)})))]}}))}))}function OZ(n){return n.filter((function(n){return-1===PZ.indexOf(n.name)}))}function LZ(n){if(null===n)return[];for(var e=[],t=0;t<n.length;t++){var r=n[t];e.push(r)}return e}function AZ(n){if("function"!==typeof n.webkitGetAsEntry)return GZ(n);var e=n.webkitGetAsEntry();return e&&e.isDirectory?qZ(e):GZ(n)}function NZ(n){return n.reduce((function(n,e){return function(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(TZ(arguments[e]));return n}(n,Array.isArray(e)?NZ(e):[e])}),[])}function GZ(n){var e=n.getAsFile();if(!e)return Promise.reject(n+" is not a File");var t=DZ(e);return Promise.resolve(t)}function BZ(n){return zZ(this,void 0,void 0,(function(){return CZ(this,(function(e){return[2,n.isDirectory?qZ(n):VZ(n)]}))}))}function qZ(n){var e=n.createReader();return new Promise((function(n,t){var r=[];!function o(){var a=this;e.readEntries((function(e){return zZ(a,void 0,void 0,(function(){var a,i,v;return CZ(this,(function(c){switch(c.label){case 0:if(e.length)return[3,5];c.label=1;case 1:return c.trys.push([1,3,,4]),[4,Promise.all(r)];case 2:return a=c.sent(),n(a),[3,4];case 3:return i=c.sent(),t(i),[3,4];case 4:return[3,6];case 5:v=Promise.all(e.map(BZ)),r.push(v),o(),c.label=6;case 6:return[2]}}))}))}),(function(n){t(n)}))}()}))}function VZ(n){return zZ(this,void 0,void 0,(function(){return CZ(this,(function(e){return[2,new Promise((function(e,t){n.file((function(t){var r=DZ(t,n.fullPath);e(r)}),(function(n){t(n)}))}))]}))}))}var WZ=t(998);function HZ(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function XZ(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?HZ(Object(t),!0).forEach((function(e){YZ(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):HZ(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function YZ(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function $Z(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!==typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null==t)return;var r,o,a=[],i=!0,v=!1;try{for(t=t.call(n);!(i=(r=t.next()).done)&&(a.push(r.value),!e||a.length!==e);i=!0);}catch(c){v=!0,o=c}finally{try{i||null==t.return||t.return()}finally{if(v)throw o}}return a}(n,e)||function(n,e){if(!n)return;if("string"===typeof n)return ZZ(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);"Object"===t&&n.constructor&&(t=n.constructor.name);if("Map"===t||"Set"===t)return Array.from(n);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return ZZ(n,e)}(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function ZZ(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}var KZ="file-invalid-type",JZ="file-too-large",QZ="file-too-small",nK="too-many-files",eK=function(n){n=Array.isArray(n)&&1===n.length?n[0]:n;var e=Array.isArray(n)?"one of ".concat(n.join(", ")):n;return{code:KZ,message:"File type must be ".concat(e)}},tK=function(n){return{code:JZ,message:"File is larger than ".concat(n," ").concat(1===n?"byte":"bytes")}},rK=function(n){return{code:QZ,message:"File is smaller than ".concat(n," ").concat(1===n?"byte":"bytes")}},oK={code:nK,message:"Too many files"};function aK(n,e){var t="application/x-moz-file"===n.type||(0,WZ.Z)(n,e);return[t,t?null:eK(e)]}function iK(n,e,t){if(vK(n.size))if(vK(e)&&vK(t)){if(n.size>t)return[!1,tK(t)];if(n.size<e)return[!1,rK(e)]}else{if(vK(e)&&n.size<e)return[!1,rK(e)];if(vK(t)&&n.size>t)return[!1,tK(t)]}return[!0,null]}function vK(n){return void 0!==n&&null!==n}function cK(n){var e=n.files,t=n.accept,r=n.minSize,o=n.maxSize,a=n.multiple,i=n.maxFiles;return!(!a&&e.length>1||a&&i>=1&&e.length>i)&&e.every((function(n){var e=$Z(aK(n,t),1)[0],a=$Z(iK(n,r,o),1)[0];return e&&a}))}function lK(n){return"function"===typeof n.isPropagationStopped?n.isPropagationStopped():"undefined"!==typeof n.cancelBubble&&n.cancelBubble}function sK(n){return n.dataTransfer?Array.prototype.some.call(n.dataTransfer.types,(function(n){return"Files"===n||"application/x-moz-file"===n})):!!n.target&&!!n.target.files}function uK(n){n.preventDefault()}function fK(n){return-1!==n.indexOf("MSIE")||-1!==n.indexOf("Trident/")}function pK(n){return-1!==n.indexOf("Edge/")}function dK(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:window.navigator.userAgent;return fK(n)||pK(n)}function mK(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return function(n){for(var t=arguments.length,r=new Array(t>1?t-1:0),o=1;o<t;o++)r[o-1]=arguments[o];return e.some((function(e){return!lK(n)&&e&&e.apply(void 0,[n].concat(r)),lK(n)}))}}function hK(){return"showOpenFilePicker"in window}function xK(n){return n="string"===typeof n?n.split(","):n,[{description:"everything",accept:Array.isArray(n)?n.filter((function(n){return"audio/*"===n||"video/*"===n||"image/*"===n||"text/*"===n||/\w+\/[-+.\w]+/g.test(n)})).reduce((function(n,e){return XZ(XZ({},n),{},YZ({},e,[]))}),{}):{}}]}function gK(n){return n instanceof DOMException&&("AbortError"===n.name||n.code===n.ABORT_ERR)}function yK(n){return n instanceof DOMException&&("SecurityError"===n.name||n.code===n.SECURITY_ERR)}var bK=["children"],_K=["open"],UK=["refKey","role","onKeyDown","onFocus","onBlur","onClick","onDragEnter","onDragOver","onDragLeave","onDrop"],wK=["refKey","onChange","onClick"];function SK(n){return function(n){if(Array.isArray(n))return zK(n)}(n)||function(n){if("undefined"!==typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||MK(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function kK(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!==typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null==t)return;var r,o,a=[],i=!0,v=!1;try{for(t=t.call(n);!(i=(r=t.next()).done)&&(a.push(r.value),!e||a.length!==e);i=!0);}catch(c){v=!0,o=c}finally{try{i||null==t.return||t.return()}finally{if(v)throw o}}return a}(n,e)||MK(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function MK(n,e){if(n){if("string"===typeof n)return zK(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?zK(n,e):void 0}}function zK(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}function CK(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function TK(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?CK(Object(t),!0).forEach((function(e){RK(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):CK(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function RK(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function DK(n,e){if(null==n)return{};var t,r,o=function(n,e){if(null==n)return{};var t,r,o={},a=Object.keys(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||(o[t]=n[t]);return o}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(r=0;r<a.length;r++)t=a[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(o[t]=n[t])}return o}var PK=(0,Ad.forwardRef)((function(n,e){var t=n.children,r=EK(DK(n,bK)),o=r.open,a=DK(r,_K);return(0,Ad.useImperativeHandle)(e,(function(){return{open:o}}),[o]),Ad.createElement(Ad.Fragment,null,t(TK(TK({},a),{},{open:o})))}));PK.displayName="Dropzone";var jK={disabled:!1,getFilesFromEvent:function(n){return zZ(this,void 0,void 0,(function(){return CZ(this,(function(e){return jZ(n)&&jZ(n.dataTransfer)?[2,IZ(n.dataTransfer,n.type)]:function(n){return jZ(n)&&jZ(n.target)}(n)?[2,FZ(n)]:Array.isArray(n)&&n.every((function(n){return"getFile"in n&&"function"===typeof n.getFile}))?[2,EZ(n)]:[2,[]]}))}))},maxSize:1/0,minSize:0,multiple:!0,maxFiles:0,preventDropOnDocument:!0,noClick:!1,noKeyboard:!1,noDrag:!1,noDragEventsBubbling:!1,validator:null,useFsAccessApi:!0};PK.defaultProps=jK,PK.propTypes={children:MZ().func,accept:MZ().oneOfType([MZ().string,MZ().arrayOf(MZ().string)]),multiple:MZ().bool,preventDropOnDocument:MZ().bool,noClick:MZ().bool,noKeyboard:MZ().bool,noDrag:MZ().bool,noDragEventsBubbling:MZ().bool,minSize:MZ().number,maxSize:MZ().number,maxFiles:MZ().number,disabled:MZ().bool,getFilesFromEvent:MZ().func,onFileDialogCancel:MZ().func,onFileDialogOpen:MZ().func,useFsAccessApi:MZ().bool,onDragEnter:MZ().func,onDragLeave:MZ().func,onDragOver:MZ().func,onDrop:MZ().func,onDropAccepted:MZ().func,onDropRejected:MZ().func,validator:MZ().func};var FK={isFocused:!1,isFileDialogActive:!1,isDragActive:!1,isDragAccept:!1,isDragReject:!1,draggedFiles:[],acceptedFiles:[],fileRejections:[]};function EK(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=TK(TK({},jK),n),t=e.accept,r=e.disabled,o=e.getFilesFromEvent,a=e.maxSize,i=e.minSize,v=e.multiple,c=e.maxFiles,l=e.onDragEnter,s=e.onDragLeave,u=e.onDragOver,f=e.onDrop,p=e.onDropAccepted,d=e.onDropRejected,m=e.onFileDialogCancel,h=e.onFileDialogOpen,x=e.useFsAccessApi,g=e.preventDropOnDocument,y=e.noClick,b=e.noKeyboard,_=e.noDrag,U=e.noDragEventsBubbling,w=e.validator,S=(0,Ad.useMemo)((function(){return"function"===typeof h?h:OK}),[h]),k=(0,Ad.useMemo)((function(){return"function"===typeof m?m:OK}),[m]),M=(0,Ad.useRef)(null),z=(0,Ad.useRef)(null),C=(0,Ad.useReducer)(IK,FK),T=kK(C,2),R=T[0],D=T[1],P=R.isFocused,j=R.isFileDialogActive,F=R.draggedFiles,E=(0,Ad.useRef)("undefined"!==typeof window&&window.isSecureContext&&x&&hK()),I=function(){!E.current&&j&&setTimeout((function(){z.current&&(z.current.files.length||(D({type:"closeDialog"}),k()))}),300)};(0,Ad.useEffect)((function(){return window.addEventListener("focus",I,!1),function(){window.removeEventListener("focus",I,!1)}}),[z,j,k,E]);var O=(0,Ad.useRef)([]),L=function(n){M.current&&M.current.contains(n.target)||(n.preventDefault(),O.current=[])};(0,Ad.useEffect)((function(){return g&&(document.addEventListener("dragover",uK,!1),document.addEventListener("drop",L,!1)),function(){g&&(document.removeEventListener("dragover",uK),document.removeEventListener("drop",L))}}),[M,g]);var A=(0,Ad.useCallback)((function(n){n.preventDefault(),n.persist(),J(n),O.current=[].concat(SK(O.current),[n.target]),sK(n)&&Promise.resolve(o(n)).then((function(e){lK(n)&&!U||(D({draggedFiles:e,isDragActive:!0,type:"setDraggedFiles"}),l&&l(n))}))}),[o,l,U]),N=(0,Ad.useCallback)((function(n){n.preventDefault(),n.persist(),J(n);var e=sK(n);if(e&&n.dataTransfer)try{n.dataTransfer.dropEffect="copy"}catch(t){}return e&&u&&u(n),!1}),[u,U]),G=(0,Ad.useCallback)((function(n){n.preventDefault(),n.persist(),J(n);var e=O.current.filter((function(n){return M.current&&M.current.contains(n)})),t=e.indexOf(n.target);-1!==t&&e.splice(t,1),O.current=e,e.length>0||(D({isDragActive:!1,type:"setDraggedFiles",draggedFiles:[]}),sK(n)&&s&&s(n))}),[M,s,U]),B=(0,Ad.useCallback)((function(n,e){var r=[],o=[];n.forEach((function(n){var e=kK(aK(n,t),2),v=e[0],c=e[1],l=kK(iK(n,i,a),2),s=l[0],u=l[1],f=w?w(n):null;if(v&&s&&!f)r.push(n);else{var p=[c,u];f&&(p=p.concat(f)),o.push({file:n,errors:p.filter((function(n){return n}))})}})),(!v&&r.length>1||v&&c>=1&&r.length>c)&&(r.forEach((function(n){o.push({file:n,errors:[oK]})})),r.splice(0)),D({acceptedFiles:r,fileRejections:o,type:"setFiles"}),f&&f(r,o,e),o.length>0&&d&&d(o,e),r.length>0&&p&&p(r,e)}),[D,v,t,i,a,c,f,p,d,w]),q=(0,Ad.useCallback)((function(n){n.preventDefault(),n.persist(),J(n),O.current=[],sK(n)&&Promise.resolve(o(n)).then((function(e){lK(n)&&!U||B(e,n)})),D({type:"reset"})}),[o,B,U]),V=(0,Ad.useCallback)((function(){if(E.current){D({type:"openDialog"}),S();var n={multiple:v,types:xK(t)};window.showOpenFilePicker(n).then((function(n){return o(n)})).then((function(n){B(n,null),D({type:"closeDialog"})})).catch((function(n){gK(n)?(k(n),D({type:"closeDialog"})):yK(n)&&(E.current=!1,z.current&&(z.current.value=null,z.current.click()))}))}else z.current&&(D({type:"openDialog"}),S(),z.current.value=null,z.current.click())}),[D,S,k,x,B,t,v]),W=(0,Ad.useCallback)((function(n){M.current&&M.current.isEqualNode(n.target)&&(" "!==n.key&&"Enter"!==n.key&&32!==n.keyCode&&13!==n.keyCode||(n.preventDefault(),V()))}),[M,V]),H=(0,Ad.useCallback)((function(){D({type:"focus"})}),[]),X=(0,Ad.useCallback)((function(){D({type:"blur"})}),[]),Y=(0,Ad.useCallback)((function(){y||(dK()?setTimeout(V,0):V())}),[y,V]),$=function(n){return r?null:n},Z=function(n){return b?null:$(n)},K=function(n){return _?null:$(n)},J=function(n){U&&n.stopPropagation()},Q=(0,Ad.useMemo)((function(){return function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.refKey,t=void 0===e?"ref":e,o=n.role,a=n.onKeyDown,i=n.onFocus,v=n.onBlur,c=n.onClick,l=n.onDragEnter,s=n.onDragOver,u=n.onDragLeave,f=n.onDrop,p=DK(n,UK);return TK(TK(RK({onKeyDown:Z(mK(a,W)),onFocus:Z(mK(i,H)),onBlur:Z(mK(v,X)),onClick:$(mK(c,Y)),onDragEnter:K(mK(l,A)),onDragOver:K(mK(s,N)),onDragLeave:K(mK(u,G)),onDrop:K(mK(f,q)),role:"string"===typeof o&&""!==o?o:"button"},t,M),r||b?{}:{tabIndex:0}),p)}}),[M,W,H,X,Y,A,N,G,q,b,_,r]),nn=(0,Ad.useCallback)((function(n){n.stopPropagation()}),[]),en=(0,Ad.useMemo)((function(){return function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.refKey,r=void 0===e?"ref":e,o=n.onChange,a=n.onClick,i=DK(n,wK),c=RK({accept:t,multiple:v,type:"file",style:{display:"none"},onChange:$(mK(o,q)),onClick:$(mK(a,nn)),tabIndex:-1},r,z);return TK(TK({},c),i)}}),[z,t,v,q,r]),tn=F.length,rn=tn>0&&cK({files:F,accept:t,minSize:i,maxSize:a,multiple:v,maxFiles:c}),on=tn>0&&!rn;return TK(TK({},R),{},{isDragAccept:rn,isDragReject:on,isFocused:P&&!r,getRootProps:Q,getInputProps:en,rootRef:M,inputRef:z,open:$(V)})}function IK(n,e){switch(e.type){case"focus":return TK(TK({},n),{},{isFocused:!0});case"blur":return TK(TK({},n),{},{isFocused:!1});case"openDialog":return TK(TK({},FK),{},{isFileDialogActive:!0});case"closeDialog":return TK(TK({},n),{},{isFileDialogActive:!1});case"setDraggedFiles":var t=e.isDragActive,r=e.draggedFiles;return TK(TK({},n),{},{draggedFiles:r,isDragActive:t});case"setFiles":return TK(TK({},n),{},{acceptedFiles:e.acceptedFiles,fileRejections:e.fileRejections});case"reset":return TK({},FK);default:return n}}function OK(){}function LK(n){var e,t=new Set,r=function(n,r){var o="function"===typeof n?n(e):n;if(o!==e){var a=e;e=r?o:Object.assign({},e,o),t.forEach((function(n){return n(e,a)}))}},o=function(){return e},a={setState:r,getState:o,subscribe:function(n,r,a){return r||a?function(n){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Object.is;console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");var i=r(e);function v(){var t=r(e);if(!a(i,t)){var o=i;n(i=t,o)}}return t.add(v),function(){return t.delete(v)}}(n,r,a):(t.add(n),function(){return t.delete(n)})},destroy:function(){return t.clear()}};return e=n(r,o,a),a}var AK="undefined"===typeof window||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent)?Ad.useEffect:Ad.useLayoutEffect;Object.defineProperty,Object.getOwnPropertySymbols,Object.prototype.hasOwnProperty,Object.prototype.propertyIsEnumerable;Object.defineProperty,Object.getOwnPropertySymbols,Object.prototype.hasOwnProperty,Object.prototype.propertyIsEnumerable;var NK,GK,BK=t(89),qK=t.n(BK),VK=function(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return e.filter(Boolean).join(".")};function WK(n,e){return(0,Ad.useMemo)(n,function(n,e){var t=(0,Ad.useRef)();return(e?pG:dG)(n,t.current)||(t.current=n),t.current}(e,!0))}function HK(n,e,t){var r=n.useStore((function(n){return function(n,e){return Object.entries(function(n,e){return e.reduce((function(e,t){return n&&n.hasOwnProperty(t)&&(e[t]=n[t]),e}),{})}(n,e)).reduce((function(n,e){var t=c(e,2)[1],r=t.value,o=t.disabled;return n[t.key]=o?void 0:r,n}),{})}(aX(aX({},t),n.data),e)}),dG);return r}function XK(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3,e=(0,Ad.useRef)(null),t=(0,Ad.useRef)(null),r=(0,Ad.useState)(!1),o=c(r,2),a=o[0],i=o[1],v=(0,Ad.useCallback)((function(){return i(!0)}),[]),l=(0,Ad.useCallback)((function(){return i(!1)}),[]);return(0,Ad.useLayoutEffect)((function(){if(a){var r=e.current.getBoundingClientRect(),o=r.bottom,i=r.top,v=r.left,c=o+t.current.getBoundingClientRect().height>window.innerHeight-40?"up":"down";t.current.style.position="fixed",t.current.style.zIndex="10000",t.current.style.left=v+"px","down"===c?t.current.style.top=o+n+"px":t.current.style.bottom=window.innerHeight-i+n+"px"}}),[n,a]),{popinRef:e,wrapperRef:t,shown:a,show:v,hide:l}}!function(n){n.forEach((function(n){H$.indexOf(n)<0&&(n(V$,L$),H$.push(n))}))}([function(n,e){var t={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},r={};for(var o in t)r[t[o]]=o;var a={};n.prototype.toName=function(e){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var o,i,v=r[this.toHex()];if(v)return v;if(null==e?void 0:e.closest){var c=this.toRgb(),l=1/0,s="black";if(!a.length)for(var u in t)a[u]=new n(t[u]).toRgb();for(var f in t){var p=(o=c,i=a[f],Math.pow(o.r-i.r,2)+Math.pow(o.g-i.g,2)+Math.pow(o.b-i.b,2));p<l&&(l=p,s=f)}return s}},e.string.push([function(e){var r=e.toLowerCase(),o="transparent"===r?"#0000":t[r];return o?new n(o).toRgb():null},"name"])}]);var YK={rgb:"toRgb",hsl:"toHsl",hsv:"toHsv",hex:"toHex"};FG.extend({color:function(){return function(n){return W$(n).isValid()}}});function $K(n,e){var t=e.format,r=e.hasAlpha,o=e.isString,a=n[YK[t]+(o&&"hex"!==t?"String":"")]();return"object"!==typeof a||r?a:function(n,e){var t=aX({},n);return e.forEach((function(e){return e in n&&delete t[e]})),t}(a,["a"])}var ZK=function(n,e){var t=W$(n);if(!t.isValid())throw Error("Invalid color");return $K(t,e)},KK=Object.freeze({__proto__:null,schema:function(n){return FG().color().test(n)},sanitize:ZK,format:function(n,e){return $K(W$(n),aX(aX({},e),{},{isString:!0,format:"hex"}))},normalize:function(n){var e=n.value,t=function(n){return N$(n)[1]}(e),r={format:"name"===t?"hex":t,hasAlpha:"object"===typeof e?"a"in e:"hex"===t&&8===e.length||/^(rgba)|(hsla)|(hsva)/.test(e),isString:"string"===typeof e};return{value:ZK(e,r),settings:r}}}),JK=$X("div",{position:"relative",boxSizing:"border-box",borderRadius:"$sm",overflow:"hidden",cursor:"pointer",height:"$rowHeight",width:"$rowHeight",backgroundColor:"#fff",backgroundImage:'url(\'data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><path d="M8 0h8v8H8zM0 8h8v8H0z"/></svg>\')',$inputStyle:"",$hover:"",zIndex:1,variants:{active:{true:{$inputStyle:"$accent1"}}},"&::before":{content:'""',position:"absolute",top:0,bottom:0,right:0,left:0,backgroundColor:"currentColor",zIndex:1}}),QK=$X("div",{position:"relative",display:"grid",gridTemplateColumns:"$sizes$rowHeight auto",columnGap:"$colGap",alignItems:"center"}),nJ=$X("div",{width:"$colorPickerWidth",height:"$colorPickerHeight",".react-colorful":{width:"100%",height:"100%",boxShadow:"$level2",cursor:"crosshair"},".react-colorful__saturation":{borderRadius:"$sm $sm 0 0"},".react-colorful__alpha, .react-colorful__hue":{height:10},".react-colorful__last-control":{borderRadius:"0 0 $sm $sm"},".react-colorful__pointer":{height:12,width:12}});function eJ(n,e){return"rgb"!==e?W$(n).toRgb():n}function tJ(n){var e=n.value,t=n.displayValue,r=n.settings,o=n.onUpdate,a=GX(),i=a.emitOnEditStart,v=a.emitOnEditEnd,l=r.format,s=r.hasAlpha,u=XK(),f=u.popinRef,p=u.wrapperRef,d=u.shown,m=u.show,h=u.hide,x=(0,Ad.useRef)(0),g=c((0,Ad.useState)((function(){return eJ(e,l)})),2),y=g[0],b=g[1],_=s?UZ:SZ,U=function(){h(),v(),window.clearTimeout(x.current)};return(0,Ad.useEffect)((function(){return function(){return window.clearTimeout(x.current)}}),[]),Ad.createElement(Ad.Fragment,null,Ad.createElement(JK,{ref:f,active:d,onClick:function(){return b(eJ(e,l)),m(),void i()},style:{color:t}}),d&&Ad.createElement(_Y,null,Ad.createElement(gY,{onPointerUp:U}),Ad.createElement(nJ,{ref:p,onMouseEnter:function(){return window.clearTimeout(x.current)},onMouseLeave:function(n){return 0===n.buttons&&void(x.current=window.setTimeout(U,500))}},Ad.createElement(_,{color:y,onChange:o}))))}var rJ=aX({component:function(){var n=GX(),e=n.value,t=n.displayValue,r=n.label,o=n.onChange,a=n.onUpdate,i=n.settings;return Ad.createElement(RY,{input:!0},Ad.createElement(kY,null,r),Ad.createElement(QK,null,Ad.createElement(tJ,{value:e,displayValue:t,onChange:o,onUpdate:a,settings:i}),Ad.createElement(iY,{value:t,onChange:o,onUpdate:a})))}},KK);var oJ=aX({component:function(){var n=GX(),e=n.label,t=n.displayValue,r=n.onUpdate,o=n.settings;return Ad.createElement(RY,{input:!0},Ad.createElement(kY,null,e),Ad.createElement(u$,{value:t,settings:o,onUpdate:r}))}},g$(["x","y","z"])),aJ=$X("div",{$flexCenter:"",position:"relative",backgroundColor:"$elevation3",borderRadius:"$sm",cursor:"pointer",height:"$rowHeight",width:"$rowHeight",touchAction:"none",$draggable:"",$hover:"","&:active":{cursor:"none"},"&::after":{content:'""',backgroundColor:"$accent2",height:4,width:4,borderRadius:2}}),iJ=$X("div",{$flexCenter:"",width:"$joystickWidth",height:"$joystickHeight",borderRadius:"$sm",boxShadow:"$level2",position:"fixed",zIndex:1e4,overflow:"hidden",$draggable:"",transform:"translate(-50%, -50%)",variants:{isOutOfBounds:{true:{backgroundColor:"$elevation1"},false:{backgroundColor:"$elevation3"}}},"> div":{position:"absolute",$flexCenter:"",borderStyle:"solid",borderWidth:1,borderColor:"$highlight1",backgroundColor:"$elevation3",width:"80%",height:"80%","&::after,&::before":{content:'""',position:"absolute",zindex:10,backgroundColor:"$highlight1"},"&::before":{width:"100%",height:1},"&::after":{height:"100%",width:1}},"> span":{position:"relative",zindex:100,width:10,height:10,backgroundColor:"$accent2",borderRadius:"50%"}});function vJ(n){var e=n.value,t=n.settings,r=n.onUpdate,o=(0,Ad.useRef)(),a=(0,Ad.useRef)(0),i=(0,Ad.useRef)(0),v=(0,Ad.useRef)(1),s=c((0,Ad.useState)(!1),2),u=s[0],f=s[1],p=c((0,Ad.useState)(!1),2),d=p[0],m=p[1],h=c(jY(),2),x=h[0],g=h[1],y=(0,Ad.useRef)(null),b=(0,Ad.useRef)(null);(0,Ad.useLayoutEffect)((function(){if(u){var n=y.current.getBoundingClientRect(),e=n.top,t=n.left,r=n.width,o=n.height;b.current.style.left=t+r/2+"px",b.current.style.top=e+o/2+"px"}}),[u]);var _=c(t.keys,2),U=_[0],w=_[1],S="invertY"===t.joystick?1:-1,k=t[U].step,M=t[w].step,z=QX("sizes","joystickWidth"),C=QX("sizes","joystickHeight"),T=.8*parseFloat(z)/2,R=.8*parseFloat(C)/2,D=(0,Ad.useCallback)((function(){o.current||(m(!0),a.current&&g({x:a.current*T}),i.current&&g({y:i.current*-R}),o.current=window.setInterval((function(){r((function(n){var e,t,r=k*a.current*v.current,o=S*M*i.current*v.current;return Array.isArray(n)?(l(e={},U,n[0]+r),l(e,w,n[1]+o),e):(l(t={},U,n[U]+r),l(t,w,n[w]+o),t)}))}),16))}),[T,R,r,g,k,M,U,w,S]),P=(0,Ad.useCallback)((function(){window.clearTimeout(o.current),o.current=void 0,m(!1)}),[]);(0,Ad.useEffect)((function(){function n(n){v.current=PX(n)}return window.addEventListener("keydown",n),window.addEventListener("keyup",n),function(){window.clearTimeout(o.current),window.removeEventListener("keydown",n),window.removeEventListener("keyup",n)}}),[]);var j=PY((function(n){var t=n.first,o=n.active,s=c(n.delta,2),u=s[0],p=s[1],d=c(n.movement,2),m=d[0],h=d[1];t&&f(!0);var x=iX(m,-T,T),y=iX(h,-R,R);a.current=Math.abs(m)>Math.abs(x)?Math.sign(m-x):0,i.current=Math.abs(h)>Math.abs(y)?Math.sign(y-h):0;var b,_=e[U],z=e[w];o?(a.current||(_+=u*k*v.current,g({x:x})),i.current||(z-=S*p*M*v.current,g({y:y})),a.current||i.current?D():P(),r((l(b={},U,_),l(b,w,z),b))):(f(!1),a.current=0,i.current=0,g({x:0,y:0}),P())}));return Ad.createElement(aJ,AX({ref:y},j()),u&&Ad.createElement(_Y,null,Ad.createElement(iJ,{ref:b,isOutOfBounds:d},Ad.createElement("div",null),Ad.createElement("span",{ref:x}))))}var cJ=$X("div",{display:"grid",columnGap:"$colGap",variants:{withJoystick:{true:{gridTemplateColumns:"$sizes$rowHeight auto"},false:{gridTemplateColumns:"auto"}}}});var lJ=["joystick"],sJ=g$(["x","y"]),uJ=aX(aX({component:function(){var n=GX(),e=n.label,t=n.displayValue,r=n.onUpdate,o=n.settings;return Ad.createElement(RY,{input:!0},Ad.createElement(kY,null,e),Ad.createElement(cJ,{withJoystick:!!o.joystick},o.joystick&&Ad.createElement(vJ,{value:t,settings:o,onUpdate:r}),Ad.createElement(u$,{value:t,settings:o,onUpdate:r})))}},sJ),{},{normalize:function(n){var e=n.joystick,t=void 0===e||e,r=qH(n,lJ),o=sJ.normalize(r);return{value:o.value,settings:aX(aX({},o.settings),{},{joystick:t})}}}),fJ=Object.freeze({__proto__:null,sanitize:function(n){if(void 0!==n){if(n instanceof File)try{return URL.createObjectURL(n)}catch(e){return}if("string"===typeof n&&0===n.indexOf("blob:"))return n;throw Error("Invalid image format [undefined | blob |\xa0File].")}},schema:function(n,e){return"object"===typeof e&&"image"in e},normalize:function(n){return{value:n.image}}}),pJ=$X("div",{position:"relative",display:"grid",gridTemplateColumns:"$sizes$rowHeight auto 20px",columnGap:"$colGap",alignItems:"center"}),dJ=$X("div",{$flexCenter:"",overflow:"hidden",height:"$rowHeight",background:"$elevation3",textAlign:"center",color:"inherit",borderRadius:"$sm",outline:"none",userSelect:"none",cursor:"pointer",$inputStyle:"",$hover:"",$focusWithin:"",$active:"$accent1 $elevation1",variants:{isDragAccept:{true:{$inputStyle:"$accent1",backgroundColor:"$elevation1"}}}}),mJ=$X("div",{boxSizing:"border-box",borderRadius:"$sm",height:"$rowHeight",width:"$rowHeight",$inputStyle:"",backgroundSize:"cover",backgroundPosition:"center",variants:{hasImage:{true:{cursor:"pointer",$hover:"",$active:""}}}}),hJ=$X("div",{$flexCenter:"",width:"$imagePreviewWidth",height:"$imagePreviewHeight",borderRadius:"$sm",boxShadow:"$level2",pointerEvents:"none",$inputStyle:"",backgroundSize:"cover",backgroundPosition:"center"}),xJ=$X("div",{fontSize:"0.8em",height:"100%",padding:"$rowGap $md"}),gJ=$X("div",{$flexCenter:"",top:"0",right:"0",marginRight:"$sm",height:"100%",cursor:"pointer",variants:{disabled:{true:{color:"$elevation3",cursor:"default"}}},"&::after,&::before":{content:'""',position:"absolute",height:2,width:10,borderRadius:1,backgroundColor:"currentColor"},"&::after":{transform:"rotate(45deg)"},"&::before":{transform:"rotate(-45deg)"}});var yJ=aX({component:function(){var n=GX(),e=n.label,t=n.value,r=n.onUpdate,o=n.disabled,a=XK(),i=a.popinRef,v=a.wrapperRef,c=a.shown,l=a.show,s=a.hide,u=(0,Ad.useCallback)((function(n){n.length&&r(n[0])}),[r]),f=(0,Ad.useCallback)((function(n){n.stopPropagation(),r(void 0)}),[r]),p=EK({maxFiles:1,accept:"image/*",onDrop:u,disabled:o}),d=p.getRootProps,m=p.getInputProps,h=p.isDragAccept;return Ad.createElement(RY,{input:!0},Ad.createElement(kY,null,e),Ad.createElement(pJ,null,Ad.createElement(mJ,{ref:i,hasImage:!!t,onPointerDown:function(){return!!t&&l()},onPointerUp:s,style:{backgroundImage:t?"url(".concat(t,")"):"none"}}),c&&!!t&&Ad.createElement(_Y,null,Ad.createElement(gY,{onPointerUp:s,style:{cursor:"pointer"}}),Ad.createElement(hJ,{ref:v,style:{backgroundImage:"url(".concat(t,")")}})),Ad.createElement(dJ,d({isDragAccept:h}),Ad.createElement("input",m()),Ad.createElement(xJ,null,h?"drop image":"click or drop")),Ad.createElement(gJ,{onClick:f,disabled:!t})))}},fJ),bJ=FG().number(),_J=function(n){return{min:n[0],max:n[1]}},UJ=function(n,e,t){var r=c(e.bounds,2),o=r[0],a=r[1],i=Array.isArray(n)?_J(n):n,v=aX(aX({},{min:t[0],max:t[1]}),i),l=v.min,s=v.max;return[iX(Number(l),o,Math.max(o,s)),iX(Number(s),Math.min(a,l),a)]},wJ=Object.freeze({__proto__:null,schema:function(n,e){return FG().array().length(2).every.number().test(n)&&FG().schema({min:bJ,max:bJ}).test(e)},format:_J,sanitize:UJ,normalize:function(n){var e=n.value,t=n.min,r=n.max,o={min:t,max:r},a=[t,r],i=aX(aX({},f$(_J(e),{min:o,max:o})),{},{bounds:a});return{value:UJ(_J(e),i,e),settings:i}}}),SJ=["value","bounds","onDrag"],kJ=["bounds"],MJ=$X("div",{display:"grid",columnGap:"$colGap",gridTemplateColumns:"auto calc($sizes$numberInputMinWidth * 2 + $space$rowGap)"});function zJ(n){var e=n.value,t=c(n.bounds,2),r=t[0],o=t[1],a=n.onDrag,i=qH(n,SJ),v=(0,Ad.useRef)(null),s=(0,Ad.useRef)(null),u=(0,Ad.useRef)(null),f=(0,Ad.useRef)(0),p=QX("sizes","scrubberWidth"),d=PY((function(n){var t=n.event,d=n.first,m=c(n.xy,1)[0],h=c(n.movement,1)[0],x=n.memo,g=void 0===x?{}:x;if(d){var y=v.current.getBoundingClientRect(),b=y.width,_=y.left;f.current=b-parseFloat(p);var U=(null===t||void 0===t?void 0:t.target)===s.current||(null===t||void 0===t?void 0:t.target)===u.current;g.pos=uX((m-_)/b,r,o);var w=Math.abs(g.pos-e.min)-Math.abs(g.pos-e.max);g.key=w<0||0===w&&g.pos<=e.min?"min":"max",U&&(g.pos=e[g.key])}var S=g.pos+uX(h/f.current,0,o-r);return a(l({},g.key,VY(S,i[g.key]))),g})),m="calc(".concat(sX(e.min,r,o)," * (100% - ").concat(p," - 8px) + 4px)"),h="calc(".concat(1-sX(e.max,r,o)," * (100% - ").concat(p," - 8px) + 4px)");return Ad.createElement(AY,AX({ref:v},d()),Ad.createElement(OY,null,Ad.createElement(NY,{style:{left:m,right:h}})),Ad.createElement(LY,{position:"left",ref:s,style:{left:m}}),Ad.createElement(LY,{position:"right",ref:u,style:{right:h}}))}var CJ=aX({component:function(){var n=GX(),e=n.label,t=n.displayValue,r=n.onUpdate,o=n.settings,a=qH(o,kJ);return Ad.createElement(Ad.Fragment,null,Ad.createElement(RY,{input:!0},Ad.createElement(kY,null,e),Ad.createElement(MJ,null,Ad.createElement(zJ,AX({value:t},o,{onDrag:r})),Ad.createElement(u$,{value:t,settings:a,onUpdate:r,innerLabelTrim:0}))))}},wJ),TJ=["type","value"],RJ=["onChange","transient","onEditStart","onEditEnd"],DJ=function(){var n,e=this,t=function(n){var e="function"===typeof n?LK(n):n,t=function(){var n,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:e.getState,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Object.is,o=(0,Ad.useReducer)((function(n){return n+1}),0),a=c(o,2)[1],i=e.getState(),v=(0,Ad.useRef)(i),l=(0,Ad.useRef)(t),s=(0,Ad.useRef)(r),u=(0,Ad.useRef)(!1),f=(0,Ad.useRef)();void 0===f.current&&(f.current=t(i));var p=!1;(v.current!==i||l.current!==t||s.current!==r||u.current)&&(n=t(i),p=!r(f.current,n)),AK((function(){p&&(f.current=n),v.current=i,l.current=t,s.current=r,u.current=!1}));var d=(0,Ad.useRef)(i);AK((function(){var n=function(){try{var n=e.getState(),t=l.current(n);s.current(f.current,t)||(v.current=n,f.current=t,a())}catch(r){u.current=!0,a()}},t=e.subscribe(n);return e.getState()!==d.current&&n(),t}),[]);var m=p?n:f.current;return(0,Ad.useDebugValue)(m),m};return Object.assign(t,e),t[Symbol.iterator]=function(){console.warn("[useStore, api] = create() is deprecated and will be removed in v4");var n=[t,e];return{next:function(){var e=n.length<=0;return{value:n.shift(),done:e}}}},t}((n=function(){return{data:{}}},function(e,t,r){var o=r.subscribe;return r.subscribe=function(n,e,t){var a=n;if(e){var i=(null==t?void 0:t.equalityFn)||Object.is,v=n(r.getState());a=function(t){var r=n(t);if(!i(v,r)){var o=v;e(v=r,o)}},(null==t?void 0:t.fireImmediately)&&e(v,v)}return o(a)},n(e,t,r)})),r=function(){var n=new Map;return{on:function(e,t){var r=n.get(e);void 0===r&&(r=new Set,n.set(e,r)),r.add(t)},off:function(e,t){var r=n.get(e);void 0!==r&&(r.delete(t),0===r.size&&n.delete(e))},emit:function(e){var t=n.get(e);if(void 0!==t){for(var r=arguments.length,o=new Array(r>1?r-1:0),a=1;a<r;a++)o[a-1]=arguments[a];var i,v=f(t);try{for(v.s();!(i=v.n()).done;){i.value.apply(void 0,o)}}catch(c){v.e(c)}finally{v.f()}}}}}();this.storeId="_"+Math.random().toString(36).substr(2,9),this.useStore=t;var o={},a=new Set;this.getVisiblePaths=function(){var n=e.getData(),t=Object.keys(n),r=[];Object.entries(o).forEach((function(n){var o=c(n,2),a=o[0],i=o[1];i.render&&t.some((function(n){return 0===n.indexOf(a)}))&&!i.render(e.get)&&r.push(a+".")}));var i=[];return a.forEach((function(t){t in n&&n[t].__refCount>0&&r.every((function(n){return-1===t.indexOf(n)}))&&(!n[t].render||n[t].render(e.get))&&i.push(t)})),i},this.setOrderedPaths=function(n){n.forEach((function(n){return a.add(n)}))},this.orderPaths=function(n){return e.setOrderedPaths(n),n},this.disposePaths=function(n){t.setState((function(e){var t=e.data;return n.forEach((function(n){if(n in t){var e=t[n];e.__refCount--,0===e.__refCount&&e.type in bX&&delete t[n]}})),{data:t}}))},this.dispose=function(){t.setState((function(){return{data:{}}}))},this.getFolderSettings=function(n){return o[n]||{}},this.getData=function(){return t.getState().data},this.addData=function(n,e){t.setState((function(t){var r=t.data;return Object.entries(n).forEach((function(n){var t=c(n,2),o=t[0],a=t[1],i=r[o];if(i){var v=a.type,l=(a.value,qH(a,TJ));v!==i.type?HH(LH.INPUT_TYPE_OVERRIDE,v):((0===i.__refCount||e)&&Object.assign(i,l),i.__refCount++)}else r[o]=aX(aX({},a),{},{__refCount:1})})),{data:r}}))},this.setValueAtPath=function(n,r,o){t.setState((function(t){var a=t.data;return CX(a[n],r,n,e,o),{data:a}}))},this.setSettingsAtPath=function(n,e){t.setState((function(t){var r=t.data;return r[n].settings=aX(aX({},r[n].settings),e),{data:r}}))},this.disableInputAtPath=function(n,e){t.setState((function(t){var r=t.data;return r[n].disabled=e,{data:r}}))},this.set=function(n,e){t.setState((function(t){var r=t.data;return Object.entries(n).forEach((function(n){var t=c(n,2),o=t[0],a=t[1];try{CX(r[o],a,void 0,void 0,e)}catch(i){0}})),{data:r}}))},this.getInput=function(n){try{return e.getData()[n]}catch(t){HH(LH.PATH_DOESNT_EXIST,n)}},this.get=function(n){var t;return null===(t=e.getInput(n))||void 0===t?void 0:t.value},this.emitOnEditStart=function(n){r.emit("onEditStart:".concat(n),e.get(n),n,aX(aX({},e.getInput(n)),{},{get:e.get}))},this.emitOnEditEnd=function(n){r.emit("onEditEnd:".concat(n),e.get(n),n,aX(aX({},e.getInput(n)),{},{get:e.get}))},this.subscribeToEditStart=function(n,e){var t="onEditStart:".concat(n);return r.on(t,e),function(){return r.off(t,e)}},this.subscribeToEditEnd=function(n,e){var t="onEditEnd:".concat(n);return r.on(t,e),function(){return r.off(t,e)}};var i=function n(e,t,r){var a={};return Object.entries(e).forEach((function(e){var i=c(e,2),v=i[0],l=i[1];if(""===v)return HH(LH.EMPTY_KEY);var s=VK(t,v);if(l.type===bX.FOLDER){var u=n(l.schema,s,r);Object.assign(a,u),s in o||(o[s]=l.settings)}else if(v in r)HH(LH.DUPLICATE_KEYS,v,s,r[v].path);else{var f=zX(l,v,s,a);if(f){var p=f.type,d=f.options,m=f.input,h=d.onChange,x=d.transient,g=d.onEditStart,y=d.onEditEnd,b=qH(d,RJ);a[s]=aX(aX(aX({type:p},b),m),{},{fromPanel:!0}),r[v]={path:s,onChange:h,transient:x,onEditStart:g,onEditEnd:y}}else HH(LH.UNKNOWN_INPUT,s,l)}})),a};this.getDataFromSchema=function(n){var e={};return[i(n,"",e),e]}},PJ=new DJ;var jJ={collapsed:!1};var FJ=function(n){return"__levaInput"in n},EJ=["type","label","path","valueKey","value","settings","setValue","disabled"];function IJ(n){var e=n.type,t=n.label,r=n.path,o=n.valueKey,a=n.value,i=n.settings,v=n.setValue,c=n.disabled,l=qH(n,EJ),s=DY({type:e,value:a,settings:i,setValue:v}),u=s.displayValue,f=s.onChange,p=s.onUpdate,d=JH[e].component;return d?Ad.createElement(NX.Provider,{value:aX({key:o,path:r,id:""+r,label:t,displayValue:u,value:a,onChange:f,onUpdate:p,settings:i,setValue:v,disabled:c},l)},Ad.createElement(xY,{disabled:c},Ad.createElement(d,null))):(HH(LH.NO_COMPONENT_FOR_TYPE,e,r),null)}var OJ=$X("button",{display:"block",$reset:"",fontWeight:"$button",height:"$rowHeight",borderStyle:"none",borderRadius:"$sm",backgroundColor:"$elevation1",color:"$highlight1","&:not(:disabled)":{color:"$highlight3",backgroundColor:"$accent2",cursor:"pointer",$hover:"$accent3",$active:"$accent3 $accent1",$focus:""}});var LJ=$X("div",{$flex:"",justifyContent:"flex-end",gap:"$colGap"}),AJ=$X("button",{$reset:"",cursor:"pointer",borderRadius:"$xs","&:hover":{backgroundColor:"$elevation3"}});var NJ=$X("canvas",{height:"$monitorHeight",width:"100%",display:"block",borderRadius:"$sm"});var GJ=(0,Ad.forwardRef)((function(n,e){var t=n.initialValue,r=QX("colors","highlight3"),o=QX("colors","elevation2"),a=QX("colors","highlight1"),i=c((0,Ad.useMemo)((function(){return[W$(a).alpha(.4).toRgbString(),W$(a).alpha(.1).toRgbString()]}),[a]),2),v=i[0],l=i[1],s=(0,Ad.useRef)([t]),u=(0,Ad.useRef)(t),f=(0,Ad.useRef)(t),p=(0,Ad.useRef)(),d=(0,Ad.useCallback)((function(n,e){if(n){for(var t=n.width,a=n.height,i=new Path2D,c=t/100,p=.05*a,d=0;d<s.current.length;d++){var m=c*d,h=a-sX(s.current[d],u.current,f.current)*(a-2*p)-p;i.lineTo(m,h)}e.clearRect(0,0,t,a);var x=new Path2D(i);x.lineTo(c*(s.current.length+1),a),x.lineTo(0,a),x.lineTo(0,0);var g=e.createLinearGradient(0,0,0,a);g.addColorStop(0,v),g.addColorStop(1,l),e.fillStyle=g,e.fill(x),e.strokeStyle=o,e.lineJoin="round",e.lineWidth=14,e.stroke(i),e.strokeStyle=r,e.lineWidth=2,e.stroke(i)}}),[r,o,v,l]),m=function(n){var e=(0,Ad.useRef)(null),t=(0,Ad.useRef)(null),r=(0,Ad.useRef)(!1);return(0,Ad.useEffect)((function(){var o=DX((function(){e.current.width=e.current.offsetWidth*window.devicePixelRatio,e.current.height=e.current.offsetHeight*window.devicePixelRatio,n(e.current,t.current)}),250);return window.addEventListener("resize",o),r.current||(o(),r.current=!0),function(){return window.removeEventListener("resize",o)}}),[n]),(0,Ad.useEffect)((function(){t.current=e.current.getContext("2d")}),[]),[e,t]}(d),h=c(m,2),x=h[0],g=h[1];return(0,Ad.useImperativeHandle)(e,(function(){return{frame:function(n){(void 0===u.current||n<u.current)&&(u.current=n),(void 0===f.current||n>f.current)&&(f.current=n),function(n,e){n.push(e),n.length>100&&n.shift()}(s.current,n),p.current=requestAnimationFrame((function(){return d(x.current,g.current)}))}}}),[x,g,d]),(0,Ad.useEffect)((function(){return function(){return cancelAnimationFrame(p.current)}}),[]),Ad.createElement(NJ,{ref:x})})),BJ=function(n){return Number.isFinite(n)?n.toPrecision(2):n.toString()},qJ=(0,Ad.forwardRef)((function(n,e){var t=n.initialValue,r=c((0,Ad.useState)(BJ(t)),2),o=r[0],a=r[1];return(0,Ad.useImperativeHandle)(e,(function(){return{frame:function(n){return a(BJ(n))}}}),[]),Ad.createElement("div",null,o)}));function VJ(n){return"function"===typeof n?n():n.current}var WJ=["type","label","key"],HJ=(l(NK={},bX.BUTTON,(function(n){var e=n.onClick,t=n.settings,r=n.label,o=WX();return Ad.createElement(RY,null,Ad.createElement(OJ,{disabled:t.disabled,onClick:function(){return e(o.get)}},r))})),l(NK,bX.BUTTON_GROUP,(function(n){var e=function(n){var e=n.label,t=n.opts,r="string"===typeof e&&""===e.trim()?null:e,o=t;return"object"===typeof t.opts&&(void 0!==o.label&&(r=t.label),o=t.opts),{label:r,opts:o}}(n),t=e.label,r=e.opts,o=WX();return Ad.createElement(RY,{input:!!t},t&&Ad.createElement(kY,null,t),Ad.createElement(LJ,null,Object.entries(r).map((function(n){var e=c(n,2),t=e[0],r=e[1];return Ad.createElement(AJ,{key:t,onClick:function(){return r(o.get)}},t)}))))})),l(NK,bX.MONITOR,(function(n){var e=n.label,t=n.objectOrFn,r=n.settings,o=(0,Ad.useRef)(),a=(0,Ad.useRef)(VJ(t));return(0,Ad.useEffect)((function(){var n=window.setInterval((function(){var n;document.hidden||null===(n=o.current)||void 0===n||n.frame(VJ(t))}),r.interval);return function(){return window.clearInterval(n)}}),[t,r.interval]),Ad.createElement(RY,{input:!0},Ad.createElement(kY,{align:"top"},e),r.graph?Ad.createElement(GJ,{ref:o,initialValue:a.current}):Ad.createElement(qJ,{ref:o,initialValue:a.current}))})),NK),XJ=Ad.memo((function(n){var e=n.path,t=function(n){var e=WX(),t=c((0,Ad.useState)(EY(e.getData(),n)),2),r=t[0],o=t[1],a=(0,Ad.useCallback)((function(t){return e.setValueAtPath(n,t,!0)}),[n,e]),i=(0,Ad.useCallback)((function(t){return e.setSettingsAtPath(n,t)}),[n,e]),v=(0,Ad.useCallback)((function(t){return e.disableInputAtPath(n,t)}),[n,e]),l=(0,Ad.useCallback)((function(){return e.emitOnEditStart(n)}),[n,e]),s=(0,Ad.useCallback)((function(){return e.emitOnEditEnd(n)}),[n,e]);return(0,Ad.useEffect)((function(){o(EY(e.getData(),n));var t=e.useStore.subscribe((function(e){return EY(e.data,n)}),o,{equalityFn:dG});return function(){return t()}}),[e,n]),[r,{set:a,setSettings:i,disable:v,storeId:e.storeId,emitOnEditStart:l,emitOnEditEnd:s}]}(e),r=c(t,2),o=r[0],a=r[1],i=a.set,v=a.setSettings,l=a.disable,s=a.storeId,u=a.emitOnEditStart,f=a.emitOnEditEnd;if(!o)return null;var p=o.type,d=o.label,m=o.key,h=qH(o,WJ);if(p in bX){var x=HJ[p];return Ad.createElement(x,AX({label:d,path:e},h))}return p in JH?Ad.createElement(IJ,AX({key:s+e,type:p,label:d,storeId:s,path:e,valueKey:m,setValue:i,setSettings:v,disable:l,emitOnEditStart:u,emitOnEditEnd:f},h)):(XH(LH.UNSUPPORTED_INPUT,p,e),null)}));function YJ(n){var e=n.toggle,t=n.toggled,r=n.name;return Ad.createElement(sY,{onClick:function(){return e()}},Ad.createElement(CY,{toggled:t}),Ad.createElement("div",null,r))}var $J=function(n){var e=n.name,t=n.path,r=n.tree,o=WX(),a=VK(t,e),i=o.getFolderSettings(a),v=i.collapsed,l=i.color,s=c((0,Ad.useState)(!v),2),u=s[0],f=s[1],p=(0,Ad.useRef)(null),d=QX("colors","folderWidgetColor"),m=QX("colors","folderTextColor");return(0,Ad.useLayoutEffect)((function(){p.current.style.setProperty("--leva-colors-folderWidgetColor",l||d),p.current.style.setProperty("--leva-colors-folderTextColor",l||m)}),[l,d,m]),Ad.createElement(cY,{ref:p},Ad.createElement(YJ,{name:e,toggled:u,toggle:function(){return f((function(n){return!n}))}}),Ad.createElement(ZJ,{parent:a,tree:r,toggled:u}))},ZJ=Ad.memo((function(n){var e=n.isRoot,t=void 0!==e&&e,r=n.fill,o=void 0!==r&&r,a=n.flat,i=void 0!==a&&a,v=n.parent,l=n.tree,s=n.toggled,u=function(n){var e=(0,Ad.useRef)(null),t=(0,Ad.useRef)(null),r=(0,Ad.useRef)(!0);return(0,Ad.useLayoutEffect)((function(){n||(e.current.style.height="0px",e.current.style.overflow="hidden")}),[]),(0,Ad.useEffect)((function(){if(!r.current){var o,a=e.current,i=function(){n&&(a.style.removeProperty("height"),a.style.removeProperty("overflow"),t.current.scrollIntoView({behavior:"smooth",block:"nearest"}))};a.addEventListener("transitionend",i,{once:!0});var v=t.current.getBoundingClientRect().height;return a.style.height=v+"px",n||(a.style.overflow="hidden",o=window.setTimeout((function(){return a.style.height="0px"}),50)),function(){a.removeEventListener("transitionend",i),clearTimeout(o)}}r.current=!1}),[n]),{wrapperRef:e,contentRef:t}}(s),f=u.wrapperRef,p=u.contentRef,d=WX(),m=function(n){var e,t=c(n,2),r=t[0],o=t[1];return(FJ(o)?null===(e=d.getInput(o.path))||void 0===e?void 0:e.order:d.getFolderSettings(VK(v,r)).order)||0},h=Object.entries(l).sort((function(n,e){return m(n)-m(e)}));return Ad.createElement(lY,{ref:f,isRoot:t,fill:o,flat:i},Ad.createElement(uY,{ref:p,isRoot:t,toggled:s},h.map((function(n){var e=c(n,2),t=e[0],r=e[1];return FJ(r)?Ad.createElement(XJ,{key:r.path,valueKey:r.valueKey,path:r.path}):Ad.createElement($J,{key:t,name:t,path:v,tree:r})}))))})),KJ=$X("div",{position:"relative",fontFamily:"$mono",fontSize:"$root",color:"$rootText",backgroundColor:"$elevation1",variants:{fill:{false:{position:"fixed",top:"10px",right:"10px",zIndex:1e3,width:"$rootWidth"},true:{position:"relative",width:"100%"}},flat:{false:{borderRadius:"$lg",boxShadow:"$level1"}},oneLineLabels:{true:l({},"".concat(pY),{gridTemplateColumns:"auto",gridAutoColumns:"minmax(max-content, 1fr)",gridAutoRows:"minmax($sizes$rowHeight), auto)",rowGap:0,columnGap:0,marginTop:"$rowGap"})},hideTitleBar:{true:{$$titleBarHeight:"0px"},false:{$$titleBarHeight:"$sizes$titleBarHeight"}}},"&,*,*:after,*:before":{boxSizing:"border-box"},"*::selection":{backgroundColor:"$accent2"}}),JJ=$X("i",{$flexCenter:"",width:40,userSelect:"none",cursor:"pointer","> svg":{fill:"$highlight1",transition:"transform 350ms ease, fill 250ms ease"},"&:hover > svg":{fill:"$highlight3"},variants:{active:{true:{"> svg":{fill:"$highlight2"}}}}}),QJ=$X("div",{display:"flex",alignItems:"stretch",justifyContent:"space-between",height:"$titleBarHeight",variants:{mode:{drag:{cursor:"grab"}}}}),nQ=$X("div",(l(GK={$flex:"",position:"relative",width:"100%",overflow:"hidden",transition:"height 250ms ease",color:"$highlight3",paddingLeft:"$md"},"> ".concat(JJ),{height:30}),l(GK,"variants",{toggled:{true:{height:30},false:{height:0}}}),GK)),eQ=$X("input",{$reset:"",flex:1,position:"relative",height:30,width:"100%",backgroundColor:"transparent",fontSize:"10px",borderRadius:"$root","&:focus":{},"&::placeholder":{color:"$highlight2"}}),tQ=$X("div",{touchAction:"none",$flexCenter:"",flex:1,"> svg":{fill:"$highlight1"},color:"$highlight1",variants:{drag:{true:{$draggable:"","> svg":{transition:"fill 250ms ease"},"&:hover":{color:"$highlight3"},"&:hover > svg":{fill:"$highlight3"}}},filterEnabled:{false:{paddingRight:40}}}}),rQ=Ad.forwardRef((function(n,e){var t=n.setFilter,r=n.toggle,o=c((0,Ad.useState)(""),2),a=o[0],i=o[1],v=(0,Ad.useMemo)((function(){return DX(t,250)}),[t]);return(0,Ad.useEffect)((function(){v(a)}),[a,v]),Ad.createElement(Ad.Fragment,null,Ad.createElement(eQ,{ref:e,value:a,placeholder:"[Open filter with CMD+SHIFT+L]",onPointerDown:function(n){return n.stopPropagation()},onChange:function(n){var e=n.currentTarget.value;r(!0),i(e)}}),Ad.createElement(JJ,{onClick:function(){return t(""),void i("")},style:{visibility:a?"visible":"hidden"}},Ad.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",height:"14",width:"14",viewBox:"0 0 20 20",fill:"currentColor"},Ad.createElement("path",{fillRule:"evenodd",d:"M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z",clipRule:"evenodd"}))))}));function oQ(n){var e=n.setFilter,t=n.onDrag,r=n.onDragStart,o=n.onDragEnd,a=n.toggle,i=n.toggled,v=n.title,l=n.drag,s=n.filterEnabled,u=n.from,f=c((0,Ad.useState)(!1),2),p=f[0],d=f[1],m=(0,Ad.useRef)(null);(0,Ad.useEffect)((function(){var n,e;p?null===(n=m.current)||void 0===n||n.focus():null===(e=m.current)||void 0===e||e.blur()}),[p]);var h=PY((function(n){var e=c(n.offset,2),a=e[0],i=e[1],v=n.first,l=n.last;t({x:a,y:i}),v&&r({x:a,y:i}),l&&o({x:a,y:i})}),{filterTaps:!0,from:function(n){var e=c(n.offset,2),t=e[0],r=e[1];return[(null===u||void 0===u?void 0:u.x)||t,(null===u||void 0===u?void 0:u.y)||r]}});return(0,Ad.useEffect)((function(){var n=function(n){"L"===n.key&&n.shiftKey&&n.metaKey&&d((function(n){return!n}))};return window.addEventListener("keydown",n),function(){return window.removeEventListener("keydown",n)}}),[]),Ad.createElement(Ad.Fragment,null,Ad.createElement(QJ,{mode:l?"drag":void 0},Ad.createElement(JJ,{active:!i,onClick:function(){return a()}},Ad.createElement(CY,{toggled:i,width:12,height:8})),Ad.createElement(tQ,AX({},l?h():{},{drag:l,filterEnabled:s}),void 0===v&&l?Ad.createElement("svg",{width:"20",height:"10",viewBox:"0 0 28 14",xmlns:"http://www.w3.org/2000/svg"},Ad.createElement("circle",{cx:"2",cy:"2",r:"2"}),Ad.createElement("circle",{cx:"14",cy:"2",r:"2"}),Ad.createElement("circle",{cx:"26",cy:"2",r:"2"}),Ad.createElement("circle",{cx:"2",cy:"12",r:"2"}),Ad.createElement("circle",{cx:"14",cy:"12",r:"2"}),Ad.createElement("circle",{cx:"26",cy:"12",r:"2"})):v),s&&Ad.createElement(JJ,{active:p,onClick:function(){return d((function(n){return!n}))}},Ad.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",height:"20",viewBox:"0 0 20 20"},Ad.createElement("path",{d:"M9 9a2 2 0 114 0 2 2 0 01-4 0z"}),Ad.createElement("path",{fillRule:"evenodd",d:"M10 18a8 8 0 100-16 8 8 0 000 16zm1-13a4 4 0 00-3.446 6.032l-2.261 2.26a1 1 0 101.414 1.415l2.261-2.261A4 4 0 1011 5z",clipRule:"evenodd"})))),Ad.createElement(nQ,{toggled:p},Ad.createElement(rQ,{ref:m,setFilter:e,toggle:a})))}var aQ=["store","hidden","theme","collapsed"];function iQ(n){var e=n.store,t=n.hidden,r=void 0!==t&&t,o=n.theme,a=n.collapsed,i=void 0!==a&&a,v=qH(n,aQ),l=WK((function(){return function(n){var e={colors:{elevation1:"#292d39",elevation2:"#181c20",elevation3:"#373c4b",accent1:"#0066dc",accent2:"#007bff",accent3:"#3c93ff",highlight1:"#535760",highlight2:"#8c92a4",highlight3:"#fefefe",vivid1:"#ffcc00",folderWidgetColor:"$highlight2",folderTextColor:"$highlight3",toolTipBackground:"$highlight3",toolTipText:"$elevation2"},radii:{xs:"2px",sm:"3px",lg:"10px"},space:{xs:"3px",sm:"6px",md:"10px",rowGap:"7px",colGap:"7px"},fonts:{mono:"ui-monospace, SFMono-Regular, Menlo, 'Roboto Mono', monospace",sans:"system-ui, sans-serif"},fontSizes:{root:"11px",toolTip:"$root"},sizes:{rootWidth:"280px",controlWidth:"160px",numberInputMinWidth:"38px",scrubberWidth:"8px",scrubberHeight:"16px",rowHeight:"24px",folderTitleHeight:"20px",checkboxSize:"16px",joystickWidth:"100px",joystickHeight:"100px",colorPickerWidth:"$controlWidth",colorPickerHeight:"100px",imagePreviewWidth:"$controlWidth",imagePreviewHeight:"100px",monitorHeight:"60px",titleBarHeight:"39px"},shadows:{level1:"0 0 9px 0 #00000088",level2:"0 4px 14px #00000033"},borderWidths:{root:"0px",input:"1px",focus:"1px",hover:"1px",active:"1px",folder:"1px"},fontWeights:{label:"normal",folder:"normal",button:"normal"}};if(!n)return{theme:e,className:""};Object.keys(n).forEach((function(t){Object.assign(e[t],n[t])}));var t=ZX(e);return{theme:e,className:t.className}}(o)}),[o]),s=c((0,Ad.useState)(!i),2),u=s[0],f=s[1],p="object"===typeof i?!i.collapsed:u,d=(0,Ad.useMemo)((function(){return"object"===typeof i?function(n){"function"===typeof n?i.onChange(!n(!i.collapsed)):i.onChange(!n)}:f}),[i]);return!e||r?null:Ad.createElement(BX.Provider,{value:l},Ad.createElement(vQ,AX({store:e},v,{toggled:p,setToggle:d,rootClass:l.className})))}var vQ=Ad.memo((function(n){var e,t,r=n.store,o=n.rootClass,a=n.fill,i=void 0!==a&&a,v=n.flat,s=void 0!==v&&v,u=n.neverHide,f=void 0!==u&&u,p=n.oneLineLabels,d=void 0!==p&&p,m=n.titleBar,h=void 0===m?{title:void 0,drag:!0,filter:!0,position:void 0,onDrag:void 0,onDragStart:void 0,onDragEnd:void 0}:m,x=n.hideCopyButton,g=void 0!==x&&x,y=n.toggled,b=n.setToggle,_=function(n){var e=c((0,Ad.useState)(n.getVisiblePaths()),2),t=e[0],r=e[1];return(0,Ad.useEffect)((function(){r(n.getVisiblePaths());var e=n.useStore.subscribe(n.getVisiblePaths,r,{equalityFn:dG});return function(){return e()}}),[n]),t}(r),U=c((0,Ad.useState)(""),2),w=U[0],S=U[1],k=(0,Ad.useMemo)((function(){return function(n,e){var t={},r=e?e.toLowerCase():null;return n.forEach((function(n){var e=function(n){var e=n.split(".");return[e.pop(),e.join(".")||void 0]}(n),o=c(e,2),a=o[0],i=o[1];(!r||a.toLowerCase().indexOf(r)>-1)&&qK()(t,i,l({},a,{__levaInput:!0,path:n}))})),t}(_,w)}),[_,w]),M=c(jY(),2),z=M[0],C=M[1],T=f||_.length>0,R="object"===typeof h&&h.title||void 0,D="object"!==typeof h||(null===(e=h.drag)||void 0===e||e),P="object"!==typeof h||(null===(t=h.filter)||void 0===t||t),j="object"===typeof h&&h.position||void 0,F="object"===typeof h&&h.onDrag||void 0,E="object"===typeof h&&h.onDragStart||void 0,I="object"===typeof h&&h.onDragEnd||void 0;return Ad.useEffect((function(){C({x:null===j||void 0===j?void 0:j.x,y:null===j||void 0===j?void 0:j.y})}),[j,C]),JX(),Ad.createElement(VX.Provider,{value:{hideCopyButton:g}},Ad.createElement(KJ,{ref:z,className:o,fill:i,flat:s,oneLineLabels:d,hideTitleBar:!h,style:{display:T?"block":"none"}},h&&Ad.createElement(oQ,{onDrag:function(n){C(n),null===F||void 0===F||F(n)},onDragStart:function(n){return null===E||void 0===E?void 0:E(n)},onDragEnd:function(n){return null===I||void 0===I?void 0:I(n)},setFilter:S,toggle:function(n){return b((function(e){return null!==n&&void 0!==n?n:!e}))},toggled:y,title:R,drag:D,filterEnabled:P,from:j}),T&&Ad.createElement(qX.Provider,{value:r},Ad.createElement(ZJ,{isRoot:!0,fill:i,flat:s,tree:k,toggled:y}))))})),cQ=["isRoot"],lQ=!1,sQ=null;function uQ(n){var e=n.isRoot,t=void 0!==e&&e,r=qH(n,cQ);return(0,Ad.useEffect)((function(){return lQ=!0,!t&&sQ&&(sQ.remove(),sQ=null),function(){t||(lQ=!1)}}),[t]),Ad.createElement(iQ,AX({store:PJ},r))}function fQ(n){(0,Ad.useEffect)((function(){n&&!lQ&&(sQ||(sQ=document.getElementById("leva__root")||Object.assign(document.createElement("div"),{id:"leva__root"}),document.body&&(document.body.appendChild(sQ),function(n,e){var t=console.error;console.error=function(){},KN.render(n,e),console.error=t}(Ad.createElement(uQ,{isRoot:!0}),sQ))),lQ=!0)}),[n])}function pQ(n,e,t,r,o){var a=function(n,e,t,r,o){var a,i,v,c,l=void 0;return"string"===typeof n?(l=n,a=e,Array.isArray(t)?c=t:t&&("store"in t?(v=t,c=r):(i=t,Array.isArray(r)?c=r:(v=r,c=o)))):(a=n,Array.isArray(e)?c=e:(v=e,c=t)),{schema:a,folderName:l,folderSettings:i,hookSettings:v,deps:c||[]}}(n,e,t,r,o),i=a.folderName,v=a.schema,s=a.folderSettings,u=a.hookSettings,f=a.deps,p="function"===typeof v,d=(0,Ad.useRef)(!1),m=(0,Ad.useRef)(!0),h=WK((function(){d.current=!0;var n="function"===typeof v?v():v;return i?l({},i,function(n,e){return{type:bX.FOLDER,schema:n,settings:aX(aX({},jJ),e)}}(n,s)):n}),f);fQ(!(null!==u&&void 0!==u&&u.store));var x=c((0,Ad.useState)((function(){return(null===u||void 0===u?void 0:u.store)||PJ})),1)[0],g=c((0,Ad.useMemo)((function(){return x.getDataFromSchema(h)}),[x,h]),2),y=g[0],b=g[1],_=(0,Ad.useMemo)((function(){var n=[],e=[],t={},r={},o={};return Object.values(b).forEach((function(a){var i=a.path,v=a.onChange,c=a.onEditStart,l=a.onEditEnd,s=a.transient;n.push(i),v?(t[i]=v,s||e.push(i)):e.push(i),c&&(r[i]=c),l&&(o[i]=l)})),[n,e,t,r,o]}),[b]),U=c(_,5),w=U[0],S=U[1],k=U[2],M=U[3],z=U[4],C=(0,Ad.useMemo)((function(){return x.orderPaths(w)}),[w,x]),T=HK(x,S,y),R=(0,Ad.useCallback)((function(n){var e=Object.entries(n).reduce((function(n,e){var t=c(e,2),r=t[0],o=t[1];return Object.assign(n,l({},b[r].path,o))}),{});x.set(e,!1)}),[x,b]),D=(0,Ad.useCallback)((function(n){return x.get(b[n].path)}),[x,b]);return(0,Ad.useEffect)((function(){var n=!m.current&&d.current;return x.addData(y,n),m.current=!1,d.current=!1,function(){return x.disposePaths(C)}}),[x,C,y]),(0,Ad.useEffect)((function(){var n=[];return Object.entries(k).forEach((function(e){var t=c(e,2),r=t[0],o=t[1];o(x.get(r),r,aX({initial:!0,get:x.get},x.getInput(r)));var a=x.useStore.subscribe((function(n){var e=n.data[r];return[e.disabled?void 0:e.value,e]}),(function(n){var e=c(n,2),t=e[0],a=e[1];return o(t,r,aX({initial:!1,get:x.get},a))}),{equalityFn:dG});n.push(a)})),function(){return n.forEach((function(n){return n()}))}}),[x,k]),(0,Ad.useEffect)((function(){var n=[];return Object.entries(M).forEach((function(e){var t=c(e,2),r=t[0],o=t[1];return n.push(x.subscribeToEditStart(r,o))})),Object.entries(z).forEach((function(e){var t=c(e,2),r=t[0],o=t[1];return n.push(x.subscribeToEditEnd(r,o))})),function(){return n.forEach((function(n){return n()}))}}),[M,z,x]),p?[T,R,D]:T}nX(_X.SELECT,KY),nX(_X.IMAGE,yJ),nX(_X.NUMBER,WY),nX(_X.COLOR,rJ),nX(_X.STRING,t$),nX(_X.BOOLEAN,i$),nX(_X.INTERVAL,CJ),nX(_X.VECTOR3D,oJ),nX(_X.VECTOR2D,uJ);function dQ(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=(new cf).load(r),a=pQ("Color1",{x:{value:.24,min:0,max:1,step:.01,label:"Color1.x"},y:{value:.21,min:0,max:1,step:.01,label:"Color1.y"},z:{value:.35,min:0,max:1,step:.01,label:"Color1.z"}}),i=a.x,v=a.y,c=a.z,l=pQ("Color2",{x2:{value:.76,min:0,max:1,step:.01,label:"Color2.x"},y2:{value:.48,min:0,max:1,step:.01,label:"Color2.y"},z2:{value:.49,min:0,max:1,step:.01,label:"Color2.z"}}),s=l.x2,u=l.y2,f=l.z2,p=new Va({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    uniform vec3 u_Color1;\n    uniform vec3 u_Color2;\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv * 5.0 - 2.5;\n        // uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n        vec3 color = vec3(0.);\n        float n = noise2D(uv2 + (u_time));\n        uv2 += n;\n        // color = vec3(vUv, 0.);\n        color = mix(\n            u_Color1,\n            u_Color2,\n            uv2.x + n + n\n        );\n\n        //mix\n        //mix(a, b, t) - linearly interpolate between a & b using t as a percentage\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:o},u_Color1:{value:new Or(i,v,c)},u_Color2:{value:new Or(s,u,f)}}}),d=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;d.current.material.uniforms.u_time.value=r.elapsedTime,d.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:d,material:p,children:(0,Yh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function mQ(){var n="./Models/EnvMaps/1/",e=[n+"px.png",n+"nx.png",n+"py.png",n+"ny.png",n+"pz.png",n+"nz.png"],t=(new cf).load(e),r=pQ("Colors",{color1:"#ff0000",color2:"#00ff00",color3:"#0000ff",color4:"#00ffff"}),o=r.color1,a=r.color2,i=r.color3,v=r.color4,c=pQ("Noise",{noiseVal:{value:1,min:1,max:10,step:.01,label:"Noise Val"}}).noiseVal,l=[new wr(o),new wr(a),new wr(i),new wr(v)].map((function(n){return n.toArray()})).flat(),s=new Va({vertexShader:"\nvarying vec2 vUv;\nattribute vec3 newColors;\n\nvarying vec3 vColor;\n\nvoid main()\n{\n    vColor = newColors;\n    vUv = uv;\n    // gl_Position = vec4(position, 1.);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    varying vec3 vColor;\n    uniform vec3 u_Color1;\n    uniform vec3 u_Color2;\n    uniform float u_noiseVal;\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv * 5.0 - 2.5;\n        // uv2 -= 0.5;\n\n        vec2 m = u_mouse.xy;\n        vec3 color = vec3(0.);\n        float n = noise2D(uv2 + (u_time + u_noiseVal));\n        uv2 += n;\n        color = vColor;\n        color *= uv2.x + n * u_noiseVal;\n        color *= uv2.y + n * u_noiseVal;\n       \n\n        //mix\n        //mix(a, b, t) - linearly interpolate between a & b using t as a percentage\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_cubemap:{value:t},u_noiseVal:{value:c}}}),u=new ii(2,2);u.setAttribute("newColors",new ua(l,3));var f,p,d=(0,Ad.useRef)();return Vm((function(n){var e=n.clock;d.current.material.uniforms.u_time.value=e.elapsedTime,d.current.material.uniforms.u_mouse.value=new ir(f,p)})),addEventListener("mousemove",(function(n){f=n.clientX/window.innerWidth,p=-n.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(n){f=n.changedTouches[0].clientX/window.innerWidth,p=-n.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:d,material:s,geometry:u})})}function hQ(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=(new cf).load(r),a=(new sf).load("./Models/Textures/Metal/color.jpg"),i=pQ("tint color",{x:{value:1,min:0,max:1,step:.01,label:"r"},y:{value:1,min:0,max:1,step:.01,label:"g"},z:{value:1,min:0,max:1,step:.01,label:"b"},w:{value:1,min:0,max:1,step:.01,label:"a"}}),v=i.x,c=i.y,l=i.z,s=i.w,u=new Va({vertexShader:"\nvarying vec2 vUv;\nattribute vec3 newColors;\n\nvarying vec3 vColor;\n\nvoid main()\n{\n    vColor = newColors;\n    \n    // gl_Position = vec4(position, 1.);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    vUv = uv;\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    uniform sampler2D u_diffuse;\n\n    varying vec3 vColor;\n    uniform vec3 u_Color1;\n    uniform vec3 u_Color2;\n    uniform float u_noiseVal;\n    uniform vec4 u_tint;\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        // uv2 -= 0.125;\n\n        vec2 m = u_mouse.xy;\n        vec3 color = vec3(0.);\n        float n = noise2D(uv2 + (u_time + u_noiseVal)) * 0.1;\n        // uv2 *= n;\n        // color = vColor;\n        color *= uv2.x + n * u_noiseVal;\n        color *= uv2.y + n * u_noiseVal;\n       \n        // vec4 textureColor = texture2D(u_diffuse, vUv);\n        // color += textureColor.xyz;\n\n        //mix\n        //mix(a, b, t) - linearly interpolate between a & b using t as a percentage\n        vec4 diffuseSample = texture2D(u_diffuse, uv2) * u_tint;\n        color += diffuseSample.rgb;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n        // gl_FragColor = texture2D(u_diffuse, vUv);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_diffuse:{value:a},u_cubemap:{value:o},u_tint:{value:new Tr(v,c,l,s)}}}),f=new ii(2,2),p=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;p.current.material.uniforms.u_time.value=r.elapsedTime,p.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:p,material:u,geometry:f})})}function xQ(){var n="./Models/EnvMaps/1/",e=[n+"px.png",n+"nx.png",n+"py.png",n+"ny.png",n+"pz.png",n+"nz.png"],t=(new cf).load(e),r=(new sf).load("./Models/Textures/Metal/color.jpg");r.wrapS=Nn,r.wrapT=Nn;var o,a,i=pQ("tint color",{x:{value:1,min:0,max:1,step:.01,label:"r"},y:{value:1,min:0,max:1,step:.01,label:"g"},z:{value:1,min:0,max:1,step:.01,label:"b"},scale:{value:1,min:1,max:5,step:.1,label:"scale"}}),v=i.x,c=i.y,l=i.z,s=i.scale,u=new Va({vertexShader:"\nvarying vec2 vUv;\nattribute vec3 newColors;\n\nvarying vec3 vColor;\n\nvoid main()\n{\n    vColor = newColors;\n    \n    // gl_Position = vec4(position, 1.);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    vUv = uv;\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    uniform sampler2D u_diffuse;\n\n    varying vec3 vColor;\n    uniform vec3 u_Color1;\n    uniform vec3 u_Color2;\n    uniform float u_noiseVal;\n    uniform vec4 u_tint;\n    uniform float u_scale;\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n        // uv2 -= 0.125;\n        // uv2 *= vec2(3., 2.);\n        uv2 = uv2 * u_scale - (u_scale / 2.);\n\n        vec2 m = u_mouse.xy;\n        vec3 color = vec3(0.);\n        float n = noise2D(uv2 + (u_time + u_noiseVal)) * 0.1;\n        // uv2 *= n;\n        // color = vColor;\n        // color *= uv2.x + n * u_noiseVal;\n        // color *= uv2.y + n * u_noiseVal;\n       \n        // vec4 textureColor = texture2D(u_diffuse, vUv);\n        // color += textureColor.xyz;\n\n        //mix\n        //mix(a, b, t) - linearly interpolate between a & b using t as a percentage\n        vec4 diffuseSample = texture2D(u_diffuse, uv2) * u_tint;\n        color += diffuseSample.rgb;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n        // gl_FragColor = texture2D(u_diffuse, vUv);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir},u_diffuse:{value:r},u_cubemap:{value:t},u_tint:{value:new Tr(v,c,l,1)},u_scale:{value:s}}}),f=new ii(2,2),p=(0,Ad.useRef)();return Vm((function(n){var e=n.clock;p.current.material.uniforms.u_time.value=e.elapsedTime,p.current.material.uniforms.u_mouse.value=new ir(o,a)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,a=-n.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(n){o=n.changedTouches[0].clientX/window.innerWidth,a=-n.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:p,material:u,geometry:f})})}function gQ(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=((new cf).load(r),new sf,new Va({vertexShader:"\nvarying vec2 vUv;\nattribute vec3 newColors;\n\nvarying vec3 vColor;\n\nvoid main()\n{\n    vColor = newColors;\n    \n    // gl_Position = vec4(position, 1.);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    vUv = uv;\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n  \n        vec3 color = vec3(0.);\n        vec3 red = vec3(1., 0., 0.);\n        vec3 blue = vec3(0., 0., 1.);\n        vec3 white = vec3(1.);\n\n        // //mix = lerp\n        // //gradual blending\n        // color = vec3(mix(red, blue, uv2.x));\n\n        // //smoothstep\n        // color = vec3(smoothstep(0., 1., uv2.x));\n\n        float value1 = uv2.x * abs(cos(u_time * 0.25));\n        float value2 = smoothstep(0., 1., uv2.x * abs(cos(u_time * 0.25)));\n        float value3 = step(0.5, uv2.x * abs(cos(u_time * 0.25)));\n        float line = smoothstep(0., 0.005, abs(uv2.y - 0.33));\n        float line2 = smoothstep(0., 0.005, abs(uv2.y - 0.66));\n        float linearLine = smoothstep(0., 0.0075, abs(uv2.y - mix(0.33, .66, value1)));\n        float smoothLine = smoothstep(0., 0.0075, abs(uv2.y - mix(0.0, 0.33, value2)));\n        float stepLine = smoothstep(0., 0.0075, abs(uv2.y - mix(0.66, 1.00, value3)));\n\n        if(uv2.y > 0.33 && uv2.y < 0.66){\n            color = mix(red,blue, value1);\n        } else if(uv2.y < 0.33){\n            color = mix(red, blue, value2);\n        } else {\n            color = mix(red,blue, value3);\n        }\n\n        color = mix(white,color, line);\n        color = mix(white,color, line2);\n        color = mix(white,color, linearLine);\n        color = mix(white,color, smoothLine);\n        color = mix(white,color, stepLine);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n        // gl_FragColor = texture2D(u_diffuse, vUv);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir}}})),a=new ii(2,2),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:o,geometry:a})})}function yQ(){var n,e,t="./Models/EnvMaps/1/",r=[t+"px.png",t+"nx.png",t+"py.png",t+"ny.png",t+"pz.png",t+"nz.png"],o=((new cf).load(r),new sf,new Va({vertexShader:"\nvarying vec2 vUv;\nattribute vec3 newColors;\n\nvarying vec3 vColor;\n\nvoid main()\n{\n    vColor = newColors;\n    \n    // gl_Position = vec4(position, 1.);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    vUv = uv;\n}",fragmentShader:Hh+Xh+Wh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 uv2 = vUv;\n  \n        vec3 color = vec3(0.);\n        vec3 red = vec3(1., 0., 0.);\n        vec3 blue = vec3(0., 0., 1.);\n        vec3 white = vec3(1.);\n\n        //min(x, y) return min\n        //max(x, y) return max\n        //clamp(a, minVal, maxVal) if < minVal -> 0, if < maxVal -> 1\n        //saturate(a) between 0 and 1\n\n        float value1 = min(uv2.x, 0.25);\n        float value2 = max(uv2.x, 0.75);\n        float value3 = clamp(uv2.x, 0.25, 0.75);\n\n        float bottomLine = smoothstep(0., 0.005, abs(uv2.y - 0.33));\n        float topLine = smoothstep(0., 0.005, abs(uv2.y - 0.66));\n        float maxLine = smoothstep(0., 0.0075, abs(uv2.y - mix(0.33, .66, value2)));\n        float clampLine = smoothstep(0., 0.0075, abs(uv2.y - mix(0.0, 0.33, value3)));\n        float minLine = smoothstep(0., 0.0075, abs(uv2.y - mix(0.66, 1.00, value1)));\n\n        if(uv2.y > 0.33 && uv2.y < 0.66){\n            color = mix(red,blue, value2);\n        } else if(uv2.y < 0.33){\n            color = mix(red, blue, value3);\n        } else {\n            color = mix(red,blue, value1);\n        }\n\n        color = mix(white,color, bottomLine);\n        color = mix(white,color, topLine);\n        color = mix(white,color, maxLine);\n        color = mix(white,color, clampLine);\n        color = mix(white,color, minLine);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n        // gl_FragColor = texture2D(u_diffuse, vUv);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ir(1,1)},u_mouse:{type:"v2",value:new ir}}})),a=new ii(2,2),i=(0,Ad.useRef)();return Vm((function(t){var r=t.clock;i.current.material.uniforms.u_time.value=r.elapsedTime,i.current.material.uniforms.u_mouse.value=new ir(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsx)("mesh",{dispose:null,ref:i,material:o,geometry:a})})}function bQ(){var n=Vh((function(n){return n.currentShader})),e=[(0,Yh.jsx)(Zh,{}),(0,Yh.jsx)(Jh,{}),(0,Yh.jsx)(nx,{}),(0,Yh.jsx)(tx,{}),(0,Yh.jsx)(ox,{}),(0,Yh.jsx)(ix,{}),(0,Yh.jsx)(cx,{}),(0,Yh.jsx)(sx,{}),(0,Yh.jsx)(fx,{}),(0,Yh.jsx)(dx,{}),(0,Yh.jsx)(hx,{}),(0,Yh.jsx)(gx,{}),(0,Yh.jsx)(bx,{}),(0,Yh.jsx)(Ux,{}),(0,Yh.jsx)(Sx,{}),(0,Yh.jsx)(Mx,{}),(0,Yh.jsx)(Cx,{}),(0,Yh.jsx)(Rx,{}),(0,Yh.jsx)(Px,{}),(0,Yh.jsx)(Fx,{}),(0,Yh.jsx)(Ix,{}),(0,Yh.jsx)(Lx,{}),(0,Yh.jsx)(Nx,{}),(0,Yh.jsx)(Bx,{}),(0,Yh.jsx)(Vx,{}),(0,Yh.jsx)(Hx,{}),(0,Yh.jsx)(Yx,{}),(0,Yh.jsx)(Zx,{}),(0,Yh.jsx)(Jx,{}),(0,Yh.jsx)(ng,{}),(0,Yh.jsx)(tg,{}),(0,Yh.jsx)(og,{}),(0,Yh.jsx)(ig,{}),(0,Yh.jsx)(cg,{}),(0,Yh.jsx)(sg,{}),(0,Yh.jsx)(fg,{}),(0,Yh.jsx)(dg,{}),(0,Yh.jsx)(hg,{}),(0,Yh.jsx)(gg,{}),(0,Yh.jsx)(bg,{}),(0,Yh.jsx)(Ug,{}),(0,Yh.jsx)(Sg,{}),(0,Yh.jsx)(Mg,{}),(0,Yh.jsx)(Cg,{}),(0,Yh.jsx)(Rg,{}),(0,Yh.jsx)(Pg,{}),(0,Yh.jsx)(Fg,{}),(0,Yh.jsx)(Ig,{}),(0,Yh.jsx)(Lg,{}),(0,Yh.jsx)(Ng,{}),(0,Yh.jsx)(Bg,{}),(0,Yh.jsx)(Vg,{}),(0,Yh.jsx)(Hg,{}),(0,Yh.jsx)(Yg,{}),(0,Yh.jsx)(Zg,{}),(0,Yh.jsx)(Jg,{}),(0,Yh.jsx)(ny,{}),(0,Yh.jsx)(ty,{}),(0,Yh.jsx)(oy,{}),(0,Yh.jsx)(iy,{}),(0,Yh.jsx)(cy,{}),(0,Yh.jsx)(sy,{}),(0,Yh.jsx)(fy,{}),(0,Yh.jsx)(dy,{}),(0,Yh.jsx)(hy,{}),(0,Yh.jsx)(gy,{}),(0,Yh.jsx)(by,{}),(0,Yh.jsx)(Uy,{}),(0,Yh.jsx)(Sy,{}),(0,Yh.jsx)(My,{}),(0,Yh.jsx)(Cy,{}),(0,Yh.jsx)(Ry,{}),(0,Yh.jsx)(Py,{}),(0,Yh.jsx)(Fy,{}),(0,Yh.jsx)(Iy,{}),(0,Yh.jsx)(Ly,{}),(0,Yh.jsx)(Ny,{}),(0,Yh.jsx)(By,{}),(0,Yh.jsx)(Vy,{}),(0,Yh.jsx)(Hy,{}),(0,Yh.jsx)(Yy,{}),(0,Yh.jsx)(Zy,{}),(0,Yh.jsx)(Jy,{}),(0,Yh.jsx)(nb,{}),(0,Yh.jsx)(tb,{}),(0,Yh.jsx)(ob,{}),(0,Yh.jsx)(ib,{}),(0,Yh.jsx)(cb,{}),(0,Yh.jsx)(sb,{}),(0,Yh.jsx)(fb,{}),(0,Yh.jsx)(db,{}),(0,Yh.jsx)(hb,{}),(0,Yh.jsx)(gb,{}),(0,Yh.jsx)(bb,{}),(0,Yh.jsx)(Ub,{}),(0,Yh.jsx)(Sb,{}),(0,Yh.jsx)(Mb,{}),(0,Yh.jsx)(Cb,{}),(0,Yh.jsx)(Rb,{}),(0,Yh.jsx)(Pb,{}),(0,Yh.jsx)(Fb,{}),(0,Yh.jsx)(Ib,{}),(0,Yh.jsx)(Lb,{}),(0,Yh.jsx)(Nb,{}),(0,Yh.jsx)(Bb,{}),(0,Yh.jsx)(Vb,{}),(0,Yh.jsx)(Hb,{}),(0,Yh.jsx)(Yb,{}),(0,Yh.jsx)(Zb,{}),(0,Yh.jsx)(Jb,{}),(0,Yh.jsx)(n_,{}),(0,Yh.jsx)(t_,{}),(0,Yh.jsx)(o_,{}),(0,Yh.jsx)(i_,{}),(0,Yh.jsx)(c_,{}),(0,Yh.jsx)(s_,{}),(0,Yh.jsx)(f_,{}),(0,Yh.jsx)(d_,{}),(0,Yh.jsx)(h_,{}),(0,Yh.jsx)(g_,{}),(0,Yh.jsx)(b_,{}),(0,Yh.jsx)(U_,{}),(0,Yh.jsx)(S_,{}),(0,Yh.jsx)(M_,{}),(0,Yh.jsx)(C_,{}),(0,Yh.jsx)(R_,{}),(0,Yh.jsx)(P_,{}),(0,Yh.jsx)(F_,{}),(0,Yh.jsx)(I_,{}),(0,Yh.jsx)(L_,{}),(0,Yh.jsx)(N_,{}),(0,Yh.jsx)(B_,{}),(0,Yh.jsx)(V_,{}),(0,Yh.jsx)(H_,{}),(0,Yh.jsx)(Y_,{}),(0,Yh.jsx)(Z_,{}),(0,Yh.jsx)(J_,{}),(0,Yh.jsx)(nU,{}),(0,Yh.jsx)(tU,{}),(0,Yh.jsx)(oU,{}),(0,Yh.jsx)(iU,{}),(0,Yh.jsx)(cU,{}),(0,Yh.jsx)(sU,{}),(0,Yh.jsx)(fU,{}),(0,Yh.jsx)(dU,{}),(0,Yh.jsx)(hU,{}),(0,Yh.jsx)(gU,{}),(0,Yh.jsx)(bU,{}),(0,Yh.jsx)(UU,{}),(0,Yh.jsx)(SU,{}),(0,Yh.jsx)(MU,{}),(0,Yh.jsx)(CU,{}),(0,Yh.jsx)(RU,{}),(0,Yh.jsx)(PU,{}),(0,Yh.jsx)(FU,{}),(0,Yh.jsx)(IU,{}),(0,Yh.jsx)(LU,{}),(0,Yh.jsx)(NU,{}),(0,Yh.jsx)(BU,{}),(0,Yh.jsx)(VU,{}),(0,Yh.jsx)(HU,{}),(0,Yh.jsx)(YU,{}),(0,Yh.jsx)(ZU,{}),(0,Yh.jsx)(JU,{}),(0,Yh.jsx)(nw,{}),(0,Yh.jsx)(tw,{}),(0,Yh.jsx)(ow,{}),(0,Yh.jsx)(iw,{}),(0,Yh.jsx)(cw,{}),(0,Yh.jsx)(sw,{}),(0,Yh.jsx)(fw,{}),(0,Yh.jsx)(dw,{}),(0,Yh.jsx)(hw,{}),(0,Yh.jsx)(gw,{}),(0,Yh.jsx)(bw,{}),(0,Yh.jsx)(Uw,{}),(0,Yh.jsx)(Sw,{}),(0,Yh.jsx)(Mw,{}),(0,Yh.jsx)(Cw,{}),(0,Yh.jsx)(Rw,{}),(0,Yh.jsx)(Pw,{}),(0,Yh.jsx)(Fw,{}),(0,Yh.jsx)(Iw,{}),(0,Yh.jsx)(Lw,{}),(0,Yh.jsx)(Nw,{}),(0,Yh.jsx)(Bw,{}),(0,Yh.jsx)(Vw,{}),(0,Yh.jsx)(Hw,{}),(0,Yh.jsx)(Yw,{}),(0,Yh.jsx)(Zw,{}),(0,Yh.jsx)(Jw,{}),(0,Yh.jsx)(nS,{}),(0,Yh.jsx)(tS,{}),(0,Yh.jsx)(oS,{}),(0,Yh.jsx)(iS,{}),(0,Yh.jsx)(cS,{}),(0,Yh.jsx)(sS,{}),(0,Yh.jsx)(fS,{}),(0,Yh.jsx)(dS,{}),(0,Yh.jsx)(hS,{}),(0,Yh.jsx)(gS,{}),(0,Yh.jsx)(bS,{}),(0,Yh.jsx)(US,{}),(0,Yh.jsx)(SS,{}),(0,Yh.jsx)(MS,{}),(0,Yh.jsx)(CS,{}),(0,Yh.jsx)(RS,{}),(0,Yh.jsx)(PS,{}),(0,Yh.jsx)(FS,{}),(0,Yh.jsx)(IS,{}),(0,Yh.jsx)(LS,{}),(0,Yh.jsx)(NS,{}),(0,Yh.jsx)(BS,{}),(0,Yh.jsx)(VS,{}),(0,Yh.jsx)(HS,{}),(0,Yh.jsx)(YS,{}),(0,Yh.jsx)(ZS,{}),(0,Yh.jsx)(JS,{}),(0,Yh.jsx)(nk,{}),(0,Yh.jsx)(tk,{}),(0,Yh.jsx)(ok,{}),(0,Yh.jsx)(ik,{}),(0,Yh.jsx)(ck,{}),(0,Yh.jsx)(sk,{}),(0,Yh.jsx)(fk,{}),(0,Yh.jsx)(dk,{}),(0,Yh.jsx)(hk,{}),(0,Yh.jsx)(gk,{}),(0,Yh.jsx)(bk,{}),(0,Yh.jsx)(Uk,{}),(0,Yh.jsx)(Sk,{}),(0,Yh.jsx)(Mk,{}),(0,Yh.jsx)(Ck,{}),(0,Yh.jsx)(Rk,{}),(0,Yh.jsx)(Pk,{}),(0,Yh.jsx)(Fk,{}),(0,Yh.jsx)(Ik,{}),(0,Yh.jsx)(Lk,{}),(0,Yh.jsx)(Nk,{}),(0,Yh.jsx)(Bk,{}),(0,Yh.jsx)(Vk,{}),(0,Yh.jsx)(Hk,{}),(0,Yh.jsx)(Yk,{}),(0,Yh.jsx)(Zk,{}),(0,Yh.jsx)(Jk,{}),(0,Yh.jsx)(nM,{}),(0,Yh.jsx)(tM,{}),(0,Yh.jsx)(oM,{}),(0,Yh.jsx)(iM,{}),(0,Yh.jsx)(cM,{}),(0,Yh.jsx)(sM,{}),(0,Yh.jsx)(fM,{}),(0,Yh.jsx)(dM,{}),(0,Yh.jsx)(hM,{}),(0,Yh.jsx)(gM,{}),(0,Yh.jsx)(bM,{}),(0,Yh.jsx)(UM,{}),(0,Yh.jsx)(SM,{}),(0,Yh.jsx)(MM,{}),(0,Yh.jsx)(CM,{}),(0,Yh.jsx)(RM,{}),(0,Yh.jsx)(PM,{}),(0,Yh.jsx)(FM,{}),(0,Yh.jsx)(IM,{}),(0,Yh.jsx)(LM,{}),(0,Yh.jsx)(NM,{}),(0,Yh.jsx)(BM,{}),(0,Yh.jsx)(VM,{}),(0,Yh.jsx)(HM,{}),(0,Yh.jsx)(YM,{}),(0,Yh.jsx)(ZM,{}),(0,Yh.jsx)(JM,{}),(0,Yh.jsx)(nz,{}),(0,Yh.jsx)(tz,{}),(0,Yh.jsx)(oz,{}),(0,Yh.jsx)(iz,{}),(0,Yh.jsx)(cz,{}),(0,Yh.jsx)(sz,{}),(0,Yh.jsx)(fz,{}),(0,Yh.jsx)(dz,{}),(0,Yh.jsx)(hz,{}),(0,Yh.jsx)(gz,{}),(0,Yh.jsx)(bz,{}),(0,Yh.jsx)(Uz,{}),(0,Yh.jsx)(Sz,{}),(0,Yh.jsx)(Mz,{}),(0,Yh.jsx)(Cz,{}),(0,Yh.jsx)(Rz,{}),(0,Yh.jsx)(Pz,{}),(0,Yh.jsx)(Fz,{}),(0,Yh.jsx)(Iz,{}),(0,Yh.jsx)(Lz,{}),(0,Yh.jsx)(Nz,{}),(0,Yh.jsx)(Bz,{}),(0,Yh.jsx)(Vz,{}),(0,Yh.jsx)(Hz,{}),(0,Yh.jsx)(Yz,{}),(0,Yh.jsx)(Zz,{}),(0,Yh.jsx)(Jz,{}),(0,Yh.jsx)(nC,{}),(0,Yh.jsx)(tC,{}),(0,Yh.jsx)(oC,{}),(0,Yh.jsx)(iC,{}),(0,Yh.jsx)(cC,{}),(0,Yh.jsx)(sC,{}),(0,Yh.jsx)(fC,{}),(0,Yh.jsx)(dC,{}),(0,Yh.jsx)(hC,{}),(0,Yh.jsx)(gC,{}),(0,Yh.jsx)(bC,{}),(0,Yh.jsx)(UC,{}),(0,Yh.jsx)(SC,{}),(0,Yh.jsx)(MC,{}),(0,Yh.jsx)(CC,{}),(0,Yh.jsx)(RC,{}),(0,Yh.jsx)(PC,{}),(0,Yh.jsx)(FC,{}),(0,Yh.jsx)(IC,{}),(0,Yh.jsx)(LC,{}),(0,Yh.jsx)(NC,{}),(0,Yh.jsx)(BC,{}),(0,Yh.jsx)(VC,{}),(0,Yh.jsx)(HC,{}),(0,Yh.jsx)(YC,{}),(0,Yh.jsx)(ZC,{}),(0,Yh.jsx)(JC,{}),(0,Yh.jsx)(nT,{}),(0,Yh.jsx)(tT,{}),(0,Yh.jsx)(oT,{}),(0,Yh.jsx)(iT,{}),(0,Yh.jsx)(cT,{}),(0,Yh.jsx)(sT,{}),(0,Yh.jsx)(fT,{}),(0,Yh.jsx)(dT,{}),(0,Yh.jsx)(hT,{}),(0,Yh.jsx)(gT,{}),(0,Yh.jsx)(bT,{}),(0,Yh.jsx)(UT,{}),(0,Yh.jsx)(ST,{}),(0,Yh.jsx)(MT,{}),(0,Yh.jsx)(CT,{}),(0,Yh.jsx)(RT,{}),(0,Yh.jsx)(PT,{}),(0,Yh.jsx)(FT,{}),(0,Yh.jsx)(IT,{}),(0,Yh.jsx)(LT,{}),(0,Yh.jsx)(NT,{}),(0,Yh.jsx)(BT,{}),(0,Yh.jsx)(VT,{}),(0,Yh.jsx)(HT,{}),(0,Yh.jsx)(YT,{}),(0,Yh.jsx)(ZT,{}),(0,Yh.jsx)(JT,{}),(0,Yh.jsx)(nR,{}),(0,Yh.jsx)(tR,{}),(0,Yh.jsx)(oR,{}),(0,Yh.jsx)(iR,{}),(0,Yh.jsx)(cR,{}),(0,Yh.jsx)(sR,{}),(0,Yh.jsx)(fR,{}),(0,Yh.jsx)(dR,{}),(0,Yh.jsx)(hR,{}),(0,Yh.jsx)(gR,{}),(0,Yh.jsx)(bR,{}),(0,Yh.jsx)(UR,{}),(0,Yh.jsx)(SR,{}),(0,Yh.jsx)(MR,{}),(0,Yh.jsx)(CR,{}),(0,Yh.jsx)(RR,{}),(0,Yh.jsx)(PR,{}),(0,Yh.jsx)(FR,{}),(0,Yh.jsx)(IR,{}),(0,Yh.jsx)(LR,{}),(0,Yh.jsx)(NR,{}),(0,Yh.jsx)(BR,{}),(0,Yh.jsx)(VR,{}),(0,Yh.jsx)(HR,{}),(0,Yh.jsx)(YR,{}),(0,Yh.jsx)(ZR,{}),(0,Yh.jsx)(JR,{}),(0,Yh.jsx)(nD,{}),(0,Yh.jsx)(tD,{}),(0,Yh.jsx)(oD,{}),(0,Yh.jsx)(iD,{}),(0,Yh.jsx)(cD,{}),(0,Yh.jsx)(sD,{}),(0,Yh.jsx)(fD,{}),(0,Yh.jsx)(dD,{}),(0,Yh.jsx)(hD,{}),(0,Yh.jsx)(gD,{}),(0,Yh.jsx)(bD,{}),(0,Yh.jsx)(UD,{}),(0,Yh.jsx)(SD,{}),(0,Yh.jsx)(MD,{}),(0,Yh.jsx)(CD,{}),(0,Yh.jsx)(RD,{}),(0,Yh.jsx)(PD,{}),(0,Yh.jsx)(FD,{}),(0,Yh.jsx)(ID,{}),(0,Yh.jsx)(LD,{}),(0,Yh.jsx)(ND,{}),(0,Yh.jsx)(BD,{}),(0,Yh.jsx)(VD,{}),(0,Yh.jsx)(HD,{}),(0,Yh.jsx)(YD,{}),(0,Yh.jsx)(ZD,{}),(0,Yh.jsx)(JD,{}),(0,Yh.jsx)(nP,{}),(0,Yh.jsx)(tP,{}),(0,Yh.jsx)(oP,{}),(0,Yh.jsx)(iP,{}),(0,Yh.jsx)(cP,{}),(0,Yh.jsx)(sP,{}),(0,Yh.jsx)(fP,{}),(0,Yh.jsx)(dP,{}),(0,Yh.jsx)(hP,{}),(0,Yh.jsx)(gP,{}),(0,Yh.jsx)(bP,{}),(0,Yh.jsx)(UP,{}),(0,Yh.jsx)(SP,{}),(0,Yh.jsx)(MP,{}),(0,Yh.jsx)(CP,{}),(0,Yh.jsx)(RP,{}),(0,Yh.jsx)(PP,{}),(0,Yh.jsx)(FP,{}),(0,Yh.jsx)(IP,{}),(0,Yh.jsx)(LP,{}),(0,Yh.jsx)(NP,{}),(0,Yh.jsx)(BP,{}),(0,Yh.jsx)(VP,{}),(0,Yh.jsx)(HP,{}),(0,Yh.jsx)(YP,{}),(0,Yh.jsx)(ZP,{}),(0,Yh.jsx)(JP,{}),(0,Yh.jsx)(nj,{}),(0,Yh.jsx)(tj,{}),(0,Yh.jsx)(oj,{}),(0,Yh.jsx)(ij,{}),(0,Yh.jsx)(cj,{}),(0,Yh.jsx)(sj,{}),(0,Yh.jsx)(fj,{}),(0,Yh.jsx)(dj,{}),(0,Yh.jsx)(hj,{}),(0,Yh.jsx)(gj,{}),(0,Yh.jsx)(bj,{}),(0,Yh.jsx)(Uj,{}),(0,Yh.jsx)(Sj,{}),(0,Yh.jsx)(Mj,{}),(0,Yh.jsx)(Cj,{}),(0,Yh.jsx)(Rj,{}),(0,Yh.jsx)(Pj,{}),(0,Yh.jsx)(Fj,{}),(0,Yh.jsx)(Ij,{}),(0,Yh.jsx)(Lj,{}),(0,Yh.jsx)(Nj,{}),(0,Yh.jsx)(Bj,{}),(0,Yh.jsx)(Vj,{}),(0,Yh.jsx)(Hj,{}),(0,Yh.jsx)(Yj,{}),(0,Yh.jsx)(Zj,{}),(0,Yh.jsx)(Jj,{}),(0,Yh.jsx)(nF,{}),(0,Yh.jsx)(tF,{}),(0,Yh.jsx)(oF,{}),(0,Yh.jsx)(iF,{}),(0,Yh.jsx)(cF,{}),(0,Yh.jsx)(sF,{}),(0,Yh.jsx)(fF,{}),(0,Yh.jsx)(dF,{}),(0,Yh.jsx)(hF,{}),(0,Yh.jsx)(gF,{}),(0,Yh.jsx)(bF,{}),(0,Yh.jsx)(UF,{}),(0,Yh.jsx)(SF,{}),(0,Yh.jsx)(MF,{}),(0,Yh.jsx)(CF,{}),(0,Yh.jsx)(RF,{}),(0,Yh.jsx)(PF,{}),(0,Yh.jsx)(FF,{}),(0,Yh.jsx)(IF,{}),(0,Yh.jsx)(LF,{}),(0,Yh.jsx)(NF,{}),(0,Yh.jsx)(BF,{}),(0,Yh.jsx)(VF,{}),(0,Yh.jsx)(HF,{}),(0,Yh.jsx)(YF,{}),(0,Yh.jsx)(ZF,{}),(0,Yh.jsx)(JF,{}),(0,Yh.jsx)(nE,{}),(0,Yh.jsx)(tE,{}),(0,Yh.jsx)(oE,{}),(0,Yh.jsx)(iE,{}),(0,Yh.jsx)(cE,{}),(0,Yh.jsx)(sE,{}),(0,Yh.jsx)(fE,{}),(0,Yh.jsx)(dE,{}),(0,Yh.jsx)(hE,{}),(0,Yh.jsx)(gE,{}),(0,Yh.jsx)(bE,{}),(0,Yh.jsx)(UE,{}),(0,Yh.jsx)(SE,{}),(0,Yh.jsx)(ME,{}),(0,Yh.jsx)(CE,{}),(0,Yh.jsx)(RE,{}),(0,Yh.jsx)(PE,{}),(0,Yh.jsx)(FE,{}),(0,Yh.jsx)(IE,{}),(0,Yh.jsx)(LE,{}),(0,Yh.jsx)(NE,{}),(0,Yh.jsx)(BE,{}),(0,Yh.jsx)(VE,{}),(0,Yh.jsx)(HE,{}),(0,Yh.jsx)(YE,{}),(0,Yh.jsx)(ZE,{}),(0,Yh.jsx)(JE,{}),(0,Yh.jsx)(nI,{}),(0,Yh.jsx)(tI,{}),(0,Yh.jsx)(oI,{}),(0,Yh.jsx)(iI,{}),(0,Yh.jsx)(cI,{}),(0,Yh.jsx)(sI,{}),(0,Yh.jsx)(fI,{}),(0,Yh.jsx)(dI,{}),(0,Yh.jsx)(hI,{}),(0,Yh.jsx)(gI,{}),(0,Yh.jsx)(bI,{}),(0,Yh.jsx)(UI,{}),(0,Yh.jsx)(SI,{}),(0,Yh.jsx)(MI,{}),(0,Yh.jsx)(CI,{}),(0,Yh.jsx)(RI,{}),(0,Yh.jsx)(PI,{}),(0,Yh.jsx)(FI,{}),(0,Yh.jsx)(II,{}),(0,Yh.jsx)(LI,{}),(0,Yh.jsx)(NI,{}),(0,Yh.jsx)(BI,{}),(0,Yh.jsx)(VI,{}),(0,Yh.jsx)(HI,{}),(0,Yh.jsx)(YI,{}),(0,Yh.jsx)(ZI,{}),(0,Yh.jsx)(JI,{}),(0,Yh.jsx)(nO,{}),(0,Yh.jsx)(tO,{}),(0,Yh.jsx)(oO,{}),(0,Yh.jsx)(iO,{}),(0,Yh.jsx)(cO,{}),(0,Yh.jsx)(sO,{}),(0,Yh.jsx)(fO,{}),(0,Yh.jsx)(dO,{}),(0,Yh.jsx)(hO,{}),(0,Yh.jsx)(gO,{}),(0,Yh.jsx)(bO,{}),(0,Yh.jsx)(UO,{}),(0,Yh.jsx)(SO,{}),(0,Yh.jsx)(MO,{}),(0,Yh.jsx)(CO,{}),(0,Yh.jsx)(RO,{}),(0,Yh.jsx)(PO,{}),(0,Yh.jsx)(FO,{}),(0,Yh.jsx)(IO,{}),(0,Yh.jsx)(LO,{}),(0,Yh.jsx)(NO,{}),(0,Yh.jsx)(BO,{}),(0,Yh.jsx)(VO,{}),(0,Yh.jsx)(HO,{}),(0,Yh.jsx)(YO,{}),(0,Yh.jsx)(ZO,{}),(0,Yh.jsx)(JO,{}),(0,Yh.jsx)(nL,{}),(0,Yh.jsx)(tL,{}),(0,Yh.jsx)(oL,{}),(0,Yh.jsx)(iL,{}),(0,Yh.jsx)(cL,{}),(0,Yh.jsx)(sL,{}),(0,Yh.jsx)(fL,{}),(0,Yh.jsx)(dL,{}),(0,Yh.jsx)(hL,{}),(0,Yh.jsx)(gL,{}),(0,Yh.jsx)(bL,{}),(0,Yh.jsx)(UL,{}),(0,Yh.jsx)(SL,{}),(0,Yh.jsx)(ML,{}),(0,Yh.jsx)(CL,{}),(0,Yh.jsx)(RL,{}),(0,Yh.jsx)(PL,{}),(0,Yh.jsx)(FL,{}),(0,Yh.jsx)(IL,{}),(0,Yh.jsx)(LL,{}),(0,Yh.jsx)(NL,{}),(0,Yh.jsx)(BL,{}),(0,Yh.jsx)(VL,{}),(0,Yh.jsx)(HL,{}),(0,Yh.jsx)(YL,{}),(0,Yh.jsx)(ZL,{}),(0,Yh.jsx)(JL,{}),(0,Yh.jsx)(nA,{}),(0,Yh.jsx)(tA,{}),(0,Yh.jsx)(oA,{}),(0,Yh.jsx)(iA,{}),(0,Yh.jsx)(cA,{}),(0,Yh.jsx)(sA,{}),(0,Yh.jsx)(fA,{}),(0,Yh.jsx)(dA,{}),(0,Yh.jsx)(hA,{}),(0,Yh.jsx)(gA,{}),(0,Yh.jsx)(bA,{}),(0,Yh.jsx)(UA,{}),(0,Yh.jsx)(SA,{}),(0,Yh.jsx)(MA,{}),(0,Yh.jsx)(CA,{}),(0,Yh.jsx)(RA,{}),(0,Yh.jsx)(PA,{}),(0,Yh.jsx)(FA,{}),(0,Yh.jsx)(IA,{}),(0,Yh.jsx)(LA,{}),(0,Yh.jsx)(AA,{}),(0,Yh.jsx)(NA,{}),(0,Yh.jsx)(GA,{}),(0,Yh.jsx)(BA,{}),(0,Yh.jsx)(qA,{}),(0,Yh.jsx)(VA,{}),(0,Yh.jsx)(WA,{}),(0,Yh.jsx)(HA,{}),(0,Yh.jsx)(XA,{}),(0,Yh.jsx)(YA,{}),(0,Yh.jsx)($A,{}),(0,Yh.jsx)(ZA,{}),(0,Yh.jsx)(KA,{}),(0,Yh.jsx)(JA,{}),(0,Yh.jsx)(QA,{}),(0,Yh.jsx)(nN,{}),(0,Yh.jsx)(eN,{}),(0,Yh.jsx)(tN,{}),(0,Yh.jsx)(rN,{}),(0,Yh.jsx)(oN,{}),(0,Yh.jsx)(aN,{}),(0,Yh.jsx)(iN,{}),(0,Yh.jsx)(vN,{}),(0,Yh.jsx)(lN,{}),(0,Yh.jsx)(uN,{}),(0,Yh.jsx)(fN,{}),(0,Yh.jsx)(pN,{}),(0,Yh.jsx)(dN,{}),(0,Yh.jsx)(mN,{}),(0,Yh.jsx)(zN,{}),(0,Yh.jsx)(CN,{}),(0,Yh.jsx)(TN,{}),(0,Yh.jsx)(RN,{}),(0,Yh.jsx)(DN,{}),(0,Yh.jsx)(PN,{}),(0,Yh.jsx)(jN,{}),(0,Yh.jsx)(FN,{}),(0,Yh.jsx)(EN,{}),(0,Yh.jsx)(IN,{}),(0,Yh.jsx)(ON,{}),(0,Yh.jsx)(LN,{}),(0,Yh.jsx)(AN,{}),(0,Yh.jsx)(NN,{}),(0,Yh.jsx)(GN,{}),(0,Yh.jsx)(BN,{}),(0,Yh.jsx)(qN,{}),(0,Yh.jsx)(VN,{}),(0,Yh.jsx)(WN,{}),(0,Yh.jsx)(HN,{}),(0,Yh.jsx)(XN,{}),(0,Yh.jsx)(YN,{}),(0,Yh.jsx)($N,{}),(0,Yh.jsx)(ZN,{}),(0,Yh.jsx)(dQ,{}),(0,Yh.jsx)(mQ,{}),(0,Yh.jsx)(hQ,{}),(0,Yh.jsx)(xQ,{}),(0,Yh.jsx)(gQ,{}),(0,Yh.jsx)(yQ,{})];return(0,Yh.jsx)(Yh.Fragment,{children:e[n-1]})}var _Q=Uint8Array,UQ=Uint16Array,wQ=Uint32Array,SQ=new _Q([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),kQ=new _Q([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),MQ=new _Q([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),zQ=function(n,e){for(var t=new UQ(31),r=0;r<31;++r)t[r]=e+=1<<n[r-1];var o=new wQ(t[30]);for(r=1;r<30;++r)for(var a=t[r];a<t[r+1];++a)o[a]=a-t[r]<<5|r;return[t,o]},CQ=zQ(SQ,2),TQ=CQ[0],RQ=CQ[1];TQ[28]=258,RQ[258]=28;for(var DQ=zQ(kQ,0),PQ=DQ[0],jQ=(DQ[1],new UQ(32768)),FQ=0;FQ<32768;++FQ){var EQ=(43690&FQ)>>>1|(21845&FQ)<<1;EQ=(61680&(EQ=(52428&EQ)>>>2|(13107&EQ)<<2))>>>4|(3855&EQ)<<4,jQ[FQ]=((65280&EQ)>>>8|(255&EQ)<<8)>>>1}var IQ=function(n,e,t){for(var r=n.length,o=0,a=new UQ(e);o<r;++o)++a[n[o]-1];var i,v=new UQ(e);for(o=0;o<e;++o)v[o]=v[o-1]+a[o-1]<<1;if(t){i=new UQ(1<<e);var c=15-e;for(o=0;o<r;++o)if(n[o])for(var l=o<<4|n[o],s=e-n[o],u=v[n[o]-1]++<<s,f=u|(1<<s)-1;u<=f;++u)i[jQ[u]>>>c]=l}else for(i=new UQ(r),o=0;o<r;++o)n[o]&&(i[o]=jQ[v[n[o]-1]++]>>>15-n[o]);return i},OQ=new _Q(288);for(FQ=0;FQ<144;++FQ)OQ[FQ]=8;for(FQ=144;FQ<256;++FQ)OQ[FQ]=9;for(FQ=256;FQ<280;++FQ)OQ[FQ]=7;for(FQ=280;FQ<288;++FQ)OQ[FQ]=8;var LQ=new _Q(32);for(FQ=0;FQ<32;++FQ)LQ[FQ]=5;var AQ=IQ(OQ,9,1),NQ=IQ(LQ,5,1),GQ=function(n){for(var e=n[0],t=1;t<n.length;++t)n[t]>e&&(e=n[t]);return e},BQ=function(n,e,t){var r=e/8|0;return(n[r]|n[r+1]<<8)>>(7&e)&t},qQ=function(n,e){var t=e/8|0;return(n[t]|n[t+1]<<8|n[t+2]<<16)>>(7&e)},VQ=function(n){return(n/8|0)+(7&n&&1)},WQ=function(n,e,t){(null==e||e<0)&&(e=0),(null==t||t>n.length)&&(t=n.length);var r=new(n instanceof UQ?UQ:n instanceof wQ?wQ:_Q)(t-e);return r.set(n.subarray(e,t)),r},HQ=function(n,e,t){var r=n.length;if(!r||t&&!t.l&&r<5)return e||new _Q(0);var o=!e||t,a=!t||t.i;t||(t={}),e||(e=new _Q(3*r));var i=function(n){var t=e.length;if(n>t){var r=new _Q(Math.max(2*t,n));r.set(e),e=r}},v=t.f||0,c=t.p||0,l=t.b||0,s=t.l,u=t.d,f=t.m,p=t.n,d=8*r;do{if(!s){t.f=v=BQ(n,c,1);var m=BQ(n,c+1,3);if(c+=3,!m){var h=n[(z=VQ(c)+4)-4]|n[z-3]<<8,x=z+h;if(x>r){if(a)throw"unexpected EOF";break}o&&i(l+h),e.set(n.subarray(z,x),l),t.b=l+=h,t.p=c=8*x;continue}if(1==m)s=AQ,u=NQ,f=9,p=5;else{if(2!=m)throw"invalid block type";var g=BQ(n,c,31)+257,y=BQ(n,c+10,15)+4,b=g+BQ(n,c+5,31)+1;c+=14;for(var _=new _Q(b),U=new _Q(19),w=0;w<y;++w)U[MQ[w]]=BQ(n,c+3*w,7);c+=3*y;var S=GQ(U),k=(1<<S)-1,M=IQ(U,S,1);for(w=0;w<b;){var z,C=M[BQ(n,c,k)];if(c+=15&C,(z=C>>>4)<16)_[w++]=z;else{var T=0,R=0;for(16==z?(R=3+BQ(n,c,3),c+=2,T=_[w-1]):17==z?(R=3+BQ(n,c,7),c+=3):18==z&&(R=11+BQ(n,c,127),c+=7);R--;)_[w++]=T}}var D=_.subarray(0,g),P=_.subarray(g);f=GQ(D),p=GQ(P),s=IQ(D,f,1),u=IQ(P,p,1)}if(c>d){if(a)throw"unexpected EOF";break}}o&&i(l+131072);for(var j=(1<<f)-1,F=(1<<p)-1,E=c;;E=c){var I=(T=s[qQ(n,c)&j])>>>4;if((c+=15&T)>d){if(a)throw"unexpected EOF";break}if(!T)throw"invalid length/literal";if(I<256)e[l++]=I;else{if(256==I){E=c,s=null;break}var O=I-254;if(I>264){var L=SQ[w=I-257];O=BQ(n,c,(1<<L)-1)+TQ[w],c+=L}var A=u[qQ(n,c)&F],N=A>>>4;if(!A)throw"invalid distance";c+=15&A;P=PQ[N];if(N>3){L=kQ[N];P+=qQ(n,c)&(1<<L)-1,c+=L}if(c>d){if(a)throw"unexpected EOF";break}o&&i(l+131072);for(var G=l+O;l<G;l+=4)e[l]=e[l-P],e[l+1]=e[l+1-P],e[l+2]=e[l+2-P],e[l+3]=e[l+3-P];l=G}}t.l=s,t.p=E,t.b=l,s&&(v=1,t.m=f,t.d=u,t.n=p)}while(!v);return l==e.length?e:WQ(e,0,l)},XQ=new _Q(0),YQ=function(n){if(8!=(15&n[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)throw"invalid zlib data";if(32&n[1])throw"invalid zlib data: preset dictionaries not supported"};function $Q(n,e){return HQ((YQ(n),n.subarray(2,-4)),e)}var ZQ="undefined"!=typeof TextDecoder&&new TextDecoder;try{ZQ.decode(XQ,{stream:!0}),1}catch(j0){}function KQ(n,e,t){var r=t.length-n-1;if(e>=t[r])return r-1;if(e<=t[n])return n;for(var o=n,a=r,i=Math.floor((o+a)/2);e<t[i]||e>=t[i+1];)e<t[i]?a=i:o=i,i=Math.floor((o+a)/2);return i}function JQ(n,e,t,r){var o=[],a=[],i=[];o[0]=1;for(var v=1;v<=t;++v){a[v]=e-r[n+1-v],i[v]=r[n+v]-e;for(var c=0,l=0;l<v;++l){var s=i[l+1],u=a[v-l],f=o[l]/(s+u);o[l]=c+s*f,c=u*f}o[v]=c}return o}function QQ(n,e){for(var t=1,r=2;r<=n;++r)t*=r;for(var o=1,a=2;a<=e;++a)o*=a;for(var i=2;i<=n-e;++i)o*=i;return t/o}function n0(n,e,t,r,o){var a=function(n,e,t,r,o){for(var a=o<n?o:n,i=[],v=KQ(n,r,e),c=function(n,e,t,r,o){for(var a=[],i=0;i<=t;++i)a[i]=0;for(var v=[],c=0;c<=r;++c)v[c]=a.slice(0);for(var l=[],s=0;s<=t;++s)l[s]=a.slice(0);l[0][0]=1;for(var u=a.slice(0),f=a.slice(0),p=1;p<=t;++p){u[p]=e-o[n+1-p],f[p]=o[n+p]-e;for(var d=0,m=0;m<p;++m){var h=f[m+1],x=u[p-m];l[p][m]=h+x;var g=l[m][p-1]/l[p][m];l[m][p]=d+h*g,d=x*g}l[p][p]=d}for(var y=0;y<=t;++y)v[0][y]=l[y][t];for(var b=0;b<=t;++b){for(var _=0,U=1,w=[],S=0;S<=t;++S)w[S]=a.slice(0);w[0][0]=1;for(var k=1;k<=r;++k){var M=0,z=b-k,C=t-k;b>=k&&(w[U][0]=w[_][0]/l[C+1][z],M=w[U][0]*l[z][C]);for(var T=b-1<=C?k-1:t-b,R=z>=-1?1:-z;R<=T;++R)w[U][R]=(w[_][R]-w[_][R-1])/l[C+1][z+R],M+=w[U][R]*l[z+R][C];b<=C&&(w[U][k]=-w[_][k-1]/l[C+1][b],M+=w[U][k]*l[b][C]),v[k][b]=M;var D=_;_=U,U=D}}for(var P=t,j=1;j<=r;++j){for(var F=0;F<=t;++F)v[j][F]*=P;P*=t-j}return v}(v,r,n,a,e),l=[],s=0;s<t.length;++s){var u=t[s].clone(),f=u.w;u.x*=f,u.y*=f,u.z*=f,l[s]=u}for(var p=0;p<=a;++p){for(var d=l[v-n].clone().multiplyScalar(c[p][0]),m=1;m<=n;++m)d.add(l[v-n+m].clone().multiplyScalar(c[p][m]));i[p]=d}for(var h=a+1;h<=o+1;++h)i[h]=new Tr(0,0,0);return i}(n,e,t,r,o);return function(n){for(var e=n.length,t=[],r=[],o=0;o<e;++o){var a=n[o];t[o]=new Or(a.x,a.y,a.z),r[o]=a.w}for(var i=[],v=0;v<e;++v){for(var c=t[v].clone(),l=1;l<=v;++l)c.sub(i[v-l].clone().multiplyScalar(QQ(v,l)*r[l]));i[v]=c.divideScalar(r[0])}return i}(a)}var e0,t0,r0,o0=function(n){U(t,n);var e=z(t);function t(n,r,o,a,i){var v;y(this,t),(v=e.call(this)).degree=n,v.knots=r,v.controlPoints=[],v.startKnot=a||0,v.endKnot=i||v.knots.length-1;for(var c=0;c<o.length;++c){var l=o[c];v.controlPoints[c]=new Tr(l.x,l.y,l.z,l.w)}return v}return _(t,[{key:"getPoint",value:function(n,e){var t=e||new Or,r=this.knots[this.startKnot]+n*(this.knots[this.endKnot]-this.knots[this.startKnot]),o=function(n,e,t,r){for(var o=KQ(n,r,e),a=JQ(o,r,n,e),i=new Tr(0,0,0,0),v=0;v<=n;++v){var c=t[o-n+v],l=a[v],s=c.w*l;i.x+=c.x*s,i.y+=c.y*s,i.z+=c.z*s,i.w+=c.w*l}return i}(this.degree,this.knots,this.controlPoints,r);return 1!=o.w&&o.divideScalar(o.w),t.set(o.x,o.y,o.z)}},{key:"getTangent",value:function(n,e){var t=e||new Or,r=this.knots[0]+n*(this.knots[this.knots.length-1]-this.knots[0]),o=n0(this.degree,this.knots,this.controlPoints,r,1);return t.copy(o[1]).normalize(),t}}]),t}($l),a0=function(n){U(t,n);var e=z(t);function t(n){return y(this,t),e.call(this,n)}return _(t,[{key:"load",value:function(n,e,t,r){var o=this,a=""===o.path?Df.extractUrlBase(n):o.path,i=new rf(this.manager);i.setPath(o.path),i.setResponseType("arraybuffer"),i.setRequestHeader(o.requestHeader),i.setWithCredentials(o.withCredentials),i.load(n,(function(t){try{e(o.parse(t,a))}catch(j0){r?r(j0):console.error(j0),o.manager.itemError(n)}}),t,r)}},{key:"parse",value:function(n,e){if(function(n){var e="Kaydara FBX Binary  \0";return n.byteLength>=e.length&&e===U0(n,0,e.length)}(n))e0=(new s0).parse(n);else{var t=U0(n);if(!function(n){var e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"],t=0;function r(e){var r=n[e-1];return n=n.slice(t+e),t++,r}for(var o=0;o<e.length;++o){if(r(1)===e[o])return!1}return!0}(t))throw new Error("THREE.FBXLoader: Unknown format.");if(p0(t)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+p0(t));e0=(new l0).parse(t)}var r=new sf(this.manager).setPath(this.resourcePath||e).setCrossOrigin(this.crossOrigin);return new i0(r,this.manager).parse(e0)}}]),t}(nf),i0=function(){function n(e,t){y(this,n),this.textureLoader=e,this.manager=t}return _(n,[{key:"parse",value:function(){t0=this.parseConnections();var n=this.parseImages(),e=this.parseTextures(n),t=this.parseMaterials(e),r=this.parseDeformers(),o=(new v0).parse(r);return this.parseScene(r,o,t),r0}},{key:"parseConnections",value:function(){var n=new Map;"Connections"in e0&&e0.Connections.connections.forEach((function(e){var t=e[0],r=e[1],o=e[2];n.has(t)||n.set(t,{parents:[],children:[]});var a={ID:r,relationship:o};n.get(t).parents.push(a),n.has(r)||n.set(r,{parents:[],children:[]});var i={ID:t,relationship:o};n.get(r).children.push(i)}));return n}},{key:"parseImages",value:function(){var n={},e={};if("Video"in e0.Objects){var t=e0.Objects.Video;for(var r in t){var o=t[r];if(n[parseInt(r)]=o.RelativeFilename||o.Filename,"Content"in o){var a=o.Content instanceof ArrayBuffer&&o.Content.byteLength>0,i="string"===typeof o.Content&&""!==o.Content;if(a||i){var v=this.parseImage(t[r]);e[o.RelativeFilename||o.Filename]=v}}}}for(var c in n){var l=n[c];void 0!==e[l]?n[c]=e[l]:n[c]=n[c].split("\\").pop()}return n}},{key:"parseImage",value:function(n){var e,t=n.Content,r=n.RelativeFilename||n.Filename,o=r.slice(r.lastIndexOf(".")+1).toLowerCase();switch(o){case"bmp":e="image/bmp";break;case"jpg":case"jpeg":e="image/jpeg";break;case"png":e="image/png";break;case"tif":e="image/tiff";break;case"tga":null===this.manager.getHandler(".tga")&&console.warn("FBXLoader: TGA loader not found, skipping ",r),e="image/tga";break;default:return void console.warn('FBXLoader: Image type "'+o+'" is not supported.')}if("string"===typeof t)return"data:"+e+";base64,"+t;var a=new Uint8Array(t);return window.URL.createObjectURL(new Blob([a],{type:e}))}},{key:"parseTextures",value:function(n){var e=new Map;if("Texture"in e0.Objects){var t=e0.Objects.Texture;for(var r in t){var o=this.parseTexture(t[r],n);e.set(parseInt(r),o)}}return e}},{key:"parseTexture",value:function(n,e){var t=this.loadTexture(n,e);t.ID=n.id,t.name=n.attrName;var r=n.WrapModeU,o=n.WrapModeV,a=void 0!==r?r.value:0,i=void 0!==o?o.value:0;if(t.wrapS=0===a?Nn:Gn,t.wrapT=0===i?Nn:Gn,"Scaling"in n){var v=n.Scaling.value;t.repeat.x=v[0],t.repeat.y=v[1]}return t}},{key:"loadTexture",value:function(n,e){var t,r,o=this.textureLoader.path,a=t0.get(n.id).children;void 0!==a&&a.length>0&&void 0!==e[a[0].ID]&&(0!==(t=e[a[0].ID]).indexOf("blob:")&&0!==t.indexOf("data:")||this.textureLoader.setPath(void 0));var i=n.FileName.slice(-3).toLowerCase();if("tga"===i){var v=this.manager.getHandler(".tga");null===v?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",n.RelativeFilename),r=new Cr):(v.setPath(this.textureLoader.path),r=v.load(t))}else"psd"===i?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",n.RelativeFilename),r=new Cr):r=this.textureLoader.load(t);return this.textureLoader.setPath(o),r}},{key:"parseMaterials",value:function(n){var e=new Map;if("Material"in e0.Objects){var t=e0.Objects.Material;for(var r in t){var o=this.parseMaterial(t[r],n);null!==o&&e.set(parseInt(r),o)}}return e}},{key:"parseMaterial",value:function(n,e){var t=n.id,r=n.attrName,o=n.ShadingModel;if("object"===typeof o&&(o=o.value),!t0.has(t))return null;var a,i=this.parseParameters(n,e,t);switch(o.toLowerCase()){case"phong":a=new wu;break;case"lambert":a=new Mu;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',o),a=new wu}return a.setValues(i),a.name=r,a}},{key:"parseParameters",value:function(n,e,t){var r={};n.BumpFactor&&(r.bumpScale=n.BumpFactor.value),n.Diffuse?r.color=(new wr).fromArray(n.Diffuse.value):!n.DiffuseColor||"Color"!==n.DiffuseColor.type&&"ColorRGB"!==n.DiffuseColor.type||(r.color=(new wr).fromArray(n.DiffuseColor.value)),n.DisplacementFactor&&(r.displacementScale=n.DisplacementFactor.value),n.Emissive?r.emissive=(new wr).fromArray(n.Emissive.value):!n.EmissiveColor||"Color"!==n.EmissiveColor.type&&"ColorRGB"!==n.EmissiveColor.type||(r.emissive=(new wr).fromArray(n.EmissiveColor.value)),n.EmissiveFactor&&(r.emissiveIntensity=parseFloat(n.EmissiveFactor.value)),n.Opacity&&(r.opacity=parseFloat(n.Opacity.value)),r.opacity<1&&(r.transparent=!0),n.ReflectionFactor&&(r.reflectivity=n.ReflectionFactor.value),n.Shininess&&(r.shininess=n.Shininess.value),n.Specular?r.specular=(new wr).fromArray(n.Specular.value):n.SpecularColor&&"Color"===n.SpecularColor.type&&(r.specular=(new wr).fromArray(n.SpecularColor.value));var o=this;return t0.get(t).children.forEach((function(n){var t=n.relationship;switch(t){case"Bump":r.bumpMap=o.getTexture(e,n.ID);break;case"Maya|TEX_ao_map":r.aoMap=o.getTexture(e,n.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":r.map=o.getTexture(e,n.ID),void 0!==r.map&&("colorSpace"in r.map?r.map.colorSpace="srgb":r.map.encoding=3001);break;case"DisplacementColor":r.displacementMap=o.getTexture(e,n.ID);break;case"EmissiveColor":r.emissiveMap=o.getTexture(e,n.ID),void 0!==r.emissiveMap&&("colorSpace"in r.emissiveMap?r.emissiveMap.colorSpace="srgb":r.emissiveMap.encoding=3001);break;case"NormalMap":case"Maya|TEX_normal_map":r.normalMap=o.getTexture(e,n.ID);break;case"ReflectionColor":r.envMap=o.getTexture(e,n.ID),void 0!==r.envMap&&(r.envMap.mapping=On,"colorSpace"in r.envMap?r.envMap.colorSpace="srgb":r.envMap.encoding=3001);break;case"SpecularColor":r.specularMap=o.getTexture(e,n.ID),void 0!==r.specularMap&&("colorSpace"in r.specularMap?r.specularMap.colorSpace="srgb":r.specularMap.encoding=3001);break;case"TransparentColor":case"TransparencyFactor":r.alphaMap=o.getTexture(e,n.ID),r.transparent=!0;break;default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",t)}})),r}},{key:"getTexture",value:function(n,e){return"LayeredTexture"in e0.Objects&&e in e0.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),e=t0.get(e).children[0].ID),n.get(e)}},{key:"parseDeformers",value:function(){var n={},e={};if("Deformer"in e0.Objects){var t=e0.Objects.Deformer;for(var r in t){var o=t[r],a=t0.get(parseInt(r));if("Skin"===o.attrType){var i=this.parseSkeleton(a,t);i.ID=r,a.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),i.geometryID=a.parents[0].ID,n[r]=i}else if("BlendShape"===o.attrType){var v={id:r};v.rawTargets=this.parseMorphTargets(a,t),v.id=r,a.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),e[r]=v}}}return{skeletons:n,morphTargets:e}}},{key:"parseSkeleton",value:function(n,e){var t=[];return n.children.forEach((function(n){var r=e[n.ID];if("Cluster"===r.attrType){var o={ID:n.ID,indices:[],weights:[],transformLink:(new po).fromArray(r.TransformLink.a)};"Indexes"in r&&(o.indices=r.Indexes.a,o.weights=r.Weights.a),t.push(o)}})),{rawBones:t,bones:[]}}},{key:"parseMorphTargets",value:function(n,e){for(var t=[],r=0;r<n.children.length;r++){var o=n.children[r],a=e[o.ID],i={name:a.attrName,initialWeight:a.DeformPercent,id:a.id,fullWeights:a.FullWeights.a};if("BlendShapeChannel"!==a.attrType)return;i.geoID=t0.get(parseInt(o.ID)).children.filter((function(n){return void 0===n.relationship}))[0].ID,t.push(i)}return t}},{key:"parseScene",value:function(n,e,t){r0=new zc;var r=this.parseModels(n.skeletons,e,t),o=e0.Objects.Model,a=this;r.forEach((function(n){var e=o[n.ID];a.setLookAtProperties(n,e),t0.get(n.ID).parents.forEach((function(e){var t=r.get(e.ID);void 0!==t&&t.add(n)})),null===n.parent&&r0.add(n)})),this.bindSkeleton(n.skeletons,e,r),this.createAmbientLight(),r0.traverse((function(n){if(n.userData.transformData){n.parent&&(n.userData.transformData.parentMatrix=n.parent.matrix,n.userData.transformData.parentMatrixWorld=n.parent.matrixWorld);var e=y0(n.userData.transformData);n.applyMatrix4(e),n.updateWorldMatrix()}}));var i=(new c0).parse();1===r0.children.length&&r0.children[0].isGroup&&(r0.children[0].animations=i,r0=r0.children[0]),r0.animations=i}},{key:"parseModels",value:function(n,e,t){var r=new Map,o=e0.Objects.Model;for(var a in o){var i=parseInt(a),v=o[a],c=t0.get(i),l=this.buildSkeleton(c,n,i,v.attrName);if(!l){switch(v.attrType){case"Camera":l=this.createCamera(c);break;case"Light":l=this.createLight(c);break;case"Mesh":l=this.createMesh(c,e,t);break;case"NurbsCurve":l=this.createCurve(c,e);break;case"LimbNode":case"Root":l=new dl;break;default:l=new zc}l.name=v.attrName?mp.sanitizeNodeName(v.attrName):"",l.ID=i}this.getTransformData(l,v),r.set(i,l)}return r}},{key:"buildSkeleton",value:function(n,e,t,r){var o=null;return n.parents.forEach((function(n){var a=function(a){var i=e[a];i.rawBones.forEach((function(e,a){if(e.ID===n.ID){var v=o;(o=new dl).matrixWorld.copy(e.transformLink),o.name=r?mp.sanitizeNodeName(r):"",o.ID=t,i.bones[a]=o,null!==v&&o.add(v)}}))};for(var i in e)a(i)})),o}},{key:"createCamera",value:function(n){var e,t;if(n.children.forEach((function(n){var e=e0.Objects.NodeAttribute[n.ID];void 0!==e&&(t=e)})),void 0===t)e=new Ao;else{var r=0;void 0!==t.CameraProjectionType&&1===t.CameraProjectionType.value&&(r=1);var o=1;void 0!==t.NearPlane&&(o=t.NearPlane.value/1e3);var a=1e3;void 0!==t.FarPlane&&(a=t.FarPlane.value/1e3);var i=window.innerWidth,v=window.innerHeight;void 0!==t.AspectWidth&&void 0!==t.AspectHeight&&(i=t.AspectWidth.value,v=t.AspectHeight.value);var c=i/v,l=45;void 0!==t.FieldOfView&&(l=t.FieldOfView.value);var s=t.FocalLength?t.FocalLength.value:null;switch(r){case 0:e=new Ha(l,c,o,a),null!==s&&e.setFocalLength(s);break;case 1:e=new hi(-i/2,i/2,v/2,-v/2,o,a);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+r+"."),e=new Ao}}return e}},{key:"createLight",value:function(n){var e,t;if(n.children.forEach((function(n){var e=e0.Objects.NodeAttribute[n.ID];void 0!==e&&(t=e)})),void 0===t)e=new Ao;else{var r;r=void 0===t.LightType?0:t.LightType.value;var o=16777215;void 0!==t.Color&&(o=(new wr).fromArray(t.Color.value));var a=void 0===t.Intensity?1:t.Intensity.value/100;void 0!==t.CastLightOnObject&&0===t.CastLightOnObject.value&&(a=0);var i=0;void 0!==t.FarAttenuationEnd&&(i=void 0!==t.EnableFarAttenuation&&0===t.EnableFarAttenuation.value?0:t.FarAttenuationEnd.value);switch(r){case 0:e=new wf(o,a,i,1);break;case 1:e=new kf(o,a);break;case 2:var v=Math.PI/3;void 0!==t.InnerAngle&&(v=ar.degToRad(t.InnerAngle.value));var c=0;void 0!==t.OuterAngle&&(c=ar.degToRad(t.OuterAngle.value),c=Math.max(c,1)),e=new gf(o,a,i,v,c,1);break;default:console.warn("THREE.FBXLoader: Unknown light type "+t.LightType.value+", defaulting to a PointLight."),e=new wf(o,a)}void 0!==t.CastShadows&&1===t.CastShadows.value&&(e.castShadow=!0)}return e}},{key:"createMesh",value:function(n,e,t){var r,o=null,a=null,i=[];return n.children.forEach((function(n){e.has(n.ID)&&(o=e.get(n.ID)),t.has(n.ID)&&i.push(t.get(n.ID))})),i.length>1?a=i:i.length>0?a=i[0]:(a=new wu({color:13421772}),i.push(a)),"color"in o.attributes&&i.forEach((function(n){n.vertexColors=!0})),o.FBX_Deformer?(r=new pl(o,a)).normalizeSkinWeights():r=new La(o,a),r}},{key:"createCurve",value:function(n,e){var t=n.children.reduce((function(n,t){return e.has(t.ID)&&(n=e.get(t.ID)),n}),null),r=new Ml({color:3342591,linewidth:1});return new Pl(t,r)}},{key:"getTransformData",value:function(n,e){var t={};"InheritType"in e&&(t.inheritType=parseInt(e.InheritType.value)),t.eulerOrder="RotationOrder"in e?b0(e.RotationOrder.value):"ZYX","Lcl_Translation"in e&&(t.translation=e.Lcl_Translation.value),"PreRotation"in e&&(t.preRotation=e.PreRotation.value),"Lcl_Rotation"in e&&(t.rotation=e.Lcl_Rotation.value),"PostRotation"in e&&(t.postRotation=e.PostRotation.value),"Lcl_Scaling"in e&&(t.scale=e.Lcl_Scaling.value),"ScalingOffset"in e&&(t.scalingOffset=e.ScalingOffset.value),"ScalingPivot"in e&&(t.scalingPivot=e.ScalingPivot.value),"RotationOffset"in e&&(t.rotationOffset=e.RotationOffset.value),"RotationPivot"in e&&(t.rotationPivot=e.RotationPivot.value),n.userData.transformData=t}},{key:"setLookAtProperties",value:function(n,e){"LookAtProperty"in e&&t0.get(n.ID).children.forEach((function(e){if("LookAtProperty"===e.relationship){var t=e0.Objects.Model[e.ID];if("Lcl_Translation"in t){var r=t.Lcl_Translation.value;void 0!==n.target?(n.target.position.fromArray(r),r0.add(n.target)):n.lookAt((new Or).fromArray(r))}}}))}},{key:"bindSkeleton",value:function(n,e,t){var r=this.parsePoseNodes(),o=function(o){var a=n[o];t0.get(parseInt(a.ID)).parents.forEach((function(n){if(e.has(n.ID)){var o=n.ID;t0.get(o).parents.forEach((function(n){t.has(n.ID)&&t.get(n.ID).bind(new gl(a.bones),r[n.ID])}))}}))};for(var a in n)o(a)}},{key:"parsePoseNodes",value:function(){var n={};if("Pose"in e0.Objects){var e=e0.Objects.Pose;for(var t in e)if("BindPose"===e[t].attrType&&e[t].NbPoseNodes>0){var r=e[t].PoseNode;Array.isArray(r)?r.forEach((function(e){n[e.Node]=(new po).fromArray(e.Matrix.a)})):n[r.Node]=(new po).fromArray(r.Matrix.a)}}return n}},{key:"createAmbientLight",value:function(){if("GlobalSettings"in e0&&"AmbientColor"in e0.GlobalSettings){var n=e0.GlobalSettings.AmbientColor.value,e=n[0],t=n[1],r=n[2];if(0!==e||0!==t||0!==r){var o=new wr(e,t,r);r0.add(new Mf(o,1))}}}}]),n}(),v0=function(){function n(){y(this,n)}return _(n,[{key:"parse",value:function(n){var e=new Map;if("Geometry"in e0.Objects){var t=e0.Objects.Geometry;for(var r in t){var o=t0.get(parseInt(r)),a=this.parseGeometry(o,t[r],n);e.set(parseInt(r),a)}}return e}},{key:"parseGeometry",value:function(n,e,t){switch(e.attrType){case"Mesh":return this.parseMeshGeometry(n,e,t);case"NurbsCurve":return this.parseNurbsGeometry(e)}}},{key:"parseMeshGeometry",value:function(n,e,t){var r=t.skeletons,o=[],a=n.parents.map((function(n){return e0.Objects.Model[n.ID]}));if(0!==a.length){var i=n.children.reduce((function(n,e){return void 0!==r[e.ID]&&(n=r[e.ID]),n}),null);n.children.forEach((function(n){void 0!==t.morphTargets[n.ID]&&o.push(t.morphTargets[n.ID])}));var v=a[0],c={};"RotationOrder"in v&&(c.eulerOrder=b0(v.RotationOrder.value)),"InheritType"in v&&(c.inheritType=parseInt(v.InheritType.value)),"GeometricTranslation"in v&&(c.translation=v.GeometricTranslation.value),"GeometricRotation"in v&&(c.rotation=v.GeometricRotation.value),"GeometricScaling"in v&&(c.scale=v.GeometricScaling.value);var l=y0(c);return this.genGeometry(e,i,o,l)}}},{key:"genGeometry",value:function(n,e,t,r){var o=new ba;n.attrName&&(o.name=n.attrName);var a=this.parseGeoNode(n,e),i=this.genBuffers(a),v=new ua(i.vertex,3);if(v.applyMatrix4(r),o.setAttribute("position",v),i.colors.length>0&&o.setAttribute("color",new ua(i.colors,3)),e&&(o.setAttribute("skinIndex",new va(i.weightsIndices,4)),o.setAttribute("skinWeight",new ua(i.vertexWeights,4)),o.FBX_Deformer=e),i.normal.length>0){var c=(new vr).getNormalMatrix(r),l=new ua(i.normal,3);l.applyNormalMatrix(c),o.setAttribute("normal",l)}if(i.uvs.forEach((function(n,e){var t="uv"+(e+1).toString();0===e&&(t="uv"),o.setAttribute(t,new ua(i.uvs[e],2))})),a.material&&"AllSame"!==a.material.mappingType){var s=i.materialIndex[0],u=0;if(i.materialIndex.forEach((function(n,e){n!==s&&(o.addGroup(u,e-u,s),s=n,u=e)})),o.groups.length>0){var f=o.groups[o.groups.length-1],p=f.start+f.count;p!==i.materialIndex.length&&o.addGroup(p,i.materialIndex.length-p,s)}0===o.groups.length&&o.addGroup(0,i.materialIndex.length,i.materialIndex[0])}return this.addMorphTargets(o,n,t,r),o}},{key:"parseGeoNode",value:function(n,e){var t={};if(t.vertexPositions=void 0!==n.Vertices?n.Vertices.a:[],t.vertexIndices=void 0!==n.PolygonVertexIndex?n.PolygonVertexIndex.a:[],n.LayerElementColor&&(t.color=this.parseVertexColors(n.LayerElementColor[0])),n.LayerElementMaterial&&(t.material=this.parseMaterialIndices(n.LayerElementMaterial[0])),n.LayerElementNormal&&(t.normal=this.parseNormals(n.LayerElementNormal[0])),n.LayerElementUV){t.uv=[];for(var r=0;n.LayerElementUV[r];)n.LayerElementUV[r].UV&&t.uv.push(this.parseUVs(n.LayerElementUV[r])),r++}return t.weightTable={},null!==e&&(t.skeleton=e,e.rawBones.forEach((function(n,e){n.indices.forEach((function(r,o){void 0===t.weightTable[r]&&(t.weightTable[r]=[]),t.weightTable[r].push({id:e,weight:n.weights[o]})}))}))),t}},{key:"genBuffers",value:function(n){var e={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]},t=0,r=0,o=!1,a=[],i=[],v=[],c=[],l=[],s=[],u=this;return n.vertexIndices.forEach((function(f,p){var d,m=!1;f<0&&(f^=-1,m=!0);var h=[],x=[];if(a.push(3*f,3*f+1,3*f+2),n.color){var g=h0(p,t,f,n.color);v.push(g[0],g[1],g[2])}if(n.skeleton){if(void 0!==n.weightTable[f]&&n.weightTable[f].forEach((function(n){x.push(n.weight),h.push(n.id)})),x.length>4){o||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),o=!0);var y=[0,0,0,0],b=[0,0,0,0];x.forEach((function(n,e){var t=n,r=h[e];b.forEach((function(n,e,o){if(t>n){o[e]=t,t=n;var a=y[e];y[e]=r,r=a}}))})),h=y,x=b}for(;x.length<4;)x.push(0),h.push(0);for(var _=0;_<4;++_)l.push(x[_]),s.push(h[_])}if(n.normal){var U=h0(p,t,f,n.normal);i.push(U[0],U[1],U[2])}n.material&&"AllSame"!==n.material.mappingType&&(d=h0(p,t,f,n.material)[0]),n.uv&&n.uv.forEach((function(n,e){var r=h0(p,t,f,n);void 0===c[e]&&(c[e]=[]),c[e].push(r[0]),c[e].push(r[1])})),r++,m&&(u.genFace(e,n,a,d,i,v,c,l,s,r),t++,r=0,a=[],i=[],v=[],c=[],l=[],s=[])})),e}},{key:"genFace",value:function(n,e,t,r,o,a,i,v,c,l){for(var s=function(l){n.vertex.push(e.vertexPositions[t[0]]),n.vertex.push(e.vertexPositions[t[1]]),n.vertex.push(e.vertexPositions[t[2]]),n.vertex.push(e.vertexPositions[t[3*(l-1)]]),n.vertex.push(e.vertexPositions[t[3*(l-1)+1]]),n.vertex.push(e.vertexPositions[t[3*(l-1)+2]]),n.vertex.push(e.vertexPositions[t[3*l]]),n.vertex.push(e.vertexPositions[t[3*l+1]]),n.vertex.push(e.vertexPositions[t[3*l+2]]),e.skeleton&&(n.vertexWeights.push(v[0]),n.vertexWeights.push(v[1]),n.vertexWeights.push(v[2]),n.vertexWeights.push(v[3]),n.vertexWeights.push(v[4*(l-1)]),n.vertexWeights.push(v[4*(l-1)+1]),n.vertexWeights.push(v[4*(l-1)+2]),n.vertexWeights.push(v[4*(l-1)+3]),n.vertexWeights.push(v[4*l]),n.vertexWeights.push(v[4*l+1]),n.vertexWeights.push(v[4*l+2]),n.vertexWeights.push(v[4*l+3]),n.weightsIndices.push(c[0]),n.weightsIndices.push(c[1]),n.weightsIndices.push(c[2]),n.weightsIndices.push(c[3]),n.weightsIndices.push(c[4*(l-1)]),n.weightsIndices.push(c[4*(l-1)+1]),n.weightsIndices.push(c[4*(l-1)+2]),n.weightsIndices.push(c[4*(l-1)+3]),n.weightsIndices.push(c[4*l]),n.weightsIndices.push(c[4*l+1]),n.weightsIndices.push(c[4*l+2]),n.weightsIndices.push(c[4*l+3])),e.color&&(n.colors.push(a[0]),n.colors.push(a[1]),n.colors.push(a[2]),n.colors.push(a[3*(l-1)]),n.colors.push(a[3*(l-1)+1]),n.colors.push(a[3*(l-1)+2]),n.colors.push(a[3*l]),n.colors.push(a[3*l+1]),n.colors.push(a[3*l+2])),e.material&&"AllSame"!==e.material.mappingType&&(n.materialIndex.push(r),n.materialIndex.push(r),n.materialIndex.push(r)),e.normal&&(n.normal.push(o[0]),n.normal.push(o[1]),n.normal.push(o[2]),n.normal.push(o[3*(l-1)]),n.normal.push(o[3*(l-1)+1]),n.normal.push(o[3*(l-1)+2]),n.normal.push(o[3*l]),n.normal.push(o[3*l+1]),n.normal.push(o[3*l+2])),e.uv&&e.uv.forEach((function(e,t){void 0===n.uvs[t]&&(n.uvs[t]=[]),n.uvs[t].push(i[t][0]),n.uvs[t].push(i[t][1]),n.uvs[t].push(i[t][2*(l-1)]),n.uvs[t].push(i[t][2*(l-1)+1]),n.uvs[t].push(i[t][2*l]),n.uvs[t].push(i[t][2*l+1])}))},u=2;u<l;u++)s(u)}},{key:"addMorphTargets",value:function(n,e,t,r){if(0!==t.length){n.morphTargetsRelative=!0,n.morphAttributes.position=[];var o=this;t.forEach((function(t){t.rawTargets.forEach((function(t){var a=e0.Objects.Geometry[t.geoID];void 0!==a&&o.genMorphGeometry(n,e,a,r,t.name)}))}))}}},{key:"genMorphGeometry",value:function(n,e,t,r,o){for(var a=void 0!==e.PolygonVertexIndex?e.PolygonVertexIndex.a:[],i=void 0!==t.Vertices?t.Vertices.a:[],v=void 0!==t.Indexes?t.Indexes.a:[],c=3*n.attributes.position.count,l=new Float32Array(c),s=0;s<v.length;s++){var u=3*v[s];l[u]=i[3*s],l[u+1]=i[3*s+1],l[u+2]=i[3*s+2]}var f={vertexIndices:a,vertexPositions:l},p=this.genBuffers(f),d=new ua(p.vertex,3);d.name=o||t.attrName,d.applyMatrix4(r),n.morphAttributes.position.push(d)}},{key:"parseNormals",value:function(n){var e=n.MappingInformationType,t=n.ReferenceInformationType,r=n.Normals.a,o=[];return"IndexToDirect"===t&&("NormalIndex"in n?o=n.NormalIndex.a:"NormalsIndex"in n&&(o=n.NormalsIndex.a)),{dataSize:3,buffer:r,indices:o,mappingType:e,referenceType:t}}},{key:"parseUVs",value:function(n){var e=n.MappingInformationType,t=n.ReferenceInformationType,r=n.UV.a,o=[];return"IndexToDirect"===t&&(o=n.UVIndex.a),{dataSize:2,buffer:r,indices:o,mappingType:e,referenceType:t}}},{key:"parseVertexColors",value:function(n){var e=n.MappingInformationType,t=n.ReferenceInformationType,r=n.Colors.a,o=[];return"IndexToDirect"===t&&(o=n.ColorIndex.a),{dataSize:4,buffer:r,indices:o,mappingType:e,referenceType:t}}},{key:"parseMaterialIndices",value:function(n){var e=n.MappingInformationType,t=n.ReferenceInformationType;if("NoMappingInformation"===e)return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:t};for(var r=n.Materials.a,o=[],a=0;a<r.length;++a)o.push(a);return{dataSize:1,buffer:r,indices:o,mappingType:e,referenceType:t}}},{key:"parseNurbsGeometry",value:function(n){if(void 0===o0)return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),new ba;var e=parseInt(n.Order);if(isNaN(e))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",n.Order,n.id),new ba;for(var t,r,o=e-1,a=n.KnotVector.a,i=[],v=n.Points.a,c=0,l=v.length;c<l;c+=4)i.push((new Tr).fromArray(v,c));if("Closed"===n.Form)i.push(i[0]);else if("Periodic"===n.Form){t=o,r=a.length-1-t;for(var s=0;s<o;++s)i.push(i[s])}var u=new o0(o,a,i,t,r).getPoints(12*i.length);return(new ba).setFromPoints(u)}}]),n}(),c0=function(){function n(){y(this,n)}return _(n,[{key:"parse",value:function(){var n=[],e=this.parseClips();if(void 0!==e)for(var t in e){var r=e[t],o=this.addClip(r);n.push(o)}return n}},{key:"parseClips",value:function(){if(void 0!==e0.Objects.AnimationCurve){var n=this.parseAnimationCurveNodes();this.parseAnimationCurves(n);var e=this.parseAnimationLayers(n);return this.parseAnimStacks(e)}}},{key:"parseAnimationCurveNodes",value:function(){var n=e0.Objects.AnimationCurveNode,e=new Map;for(var t in n){var r=n[t];if(null!==r.attrName.match(/S|R|T|DeformPercent/)){var o={id:r.id,attr:r.attrName,curves:{}};e.set(o.id,o)}}return e}},{key:"parseAnimationCurves",value:function(n){var e=e0.Objects.AnimationCurve;for(var t in e){var r={id:e[t].id,times:e[t].KeyTime.a.map(d0),values:e[t].KeyValueFloat.a},o=t0.get(r.id);if(void 0!==o){var a=o.parents[0].ID,i=o.parents[0].relationship;i.match(/X/)?n.get(a).curves.x=r:i.match(/Y/)?n.get(a).curves.y=r:i.match(/Z/)?n.get(a).curves.z=r:i.match(/d|DeformPercent/)&&n.has(a)&&(n.get(a).curves.morph=r)}}}},{key:"parseAnimationLayers",value:function(n){var e=e0.Objects.AnimationLayer,t=new Map,r=function(e){var r=[],o=t0.get(parseInt(e));void 0!==o&&(o.children.forEach((function(e,t){if(n.has(e.ID)){var o=n.get(e.ID);if(void 0!==o.curves.x||void 0!==o.curves.y||void 0!==o.curves.z){if(void 0===r[t]){var a=t0.get(e.ID).parents.filter((function(n){return void 0!==n.relationship}))[0].ID;if(void 0!==a){var i=e0.Objects.Model[a.toString()];if(void 0===i)return void console.warn("THREE.FBXLoader: Encountered a unused curve.",e);var v={modelName:i.attrName?mp.sanitizeNodeName(i.attrName):"",ID:i.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};r0.traverse((function(n){n.ID===i.id&&(v.transform=n.matrix,n.userData.transformData&&(v.eulerOrder=n.userData.transformData.eulerOrder))})),v.transform||(v.transform=new po),"PreRotation"in i&&(v.preRotation=i.PreRotation.value),"PostRotation"in i&&(v.postRotation=i.PostRotation.value),r[t]=v}}r[t]&&(r[t][o.attr]=o)}else if(void 0!==o.curves.morph){if(void 0===r[t]){var c=t0.get(e.ID).parents.filter((function(n){return void 0!==n.relationship}))[0].ID,l=t0.get(c).parents[0].ID,s=t0.get(l).parents[0].ID,u=t0.get(s).parents[0].ID,f=e0.Objects.Model[u],p={modelName:f.attrName?mp.sanitizeNodeName(f.attrName):"",morphName:e0.Objects.Deformer[c].attrName};r[t]=p}r[t][o.attr]=o}}})),t.set(parseInt(e),r))};for(var o in e)r(o);return t}},{key:"parseAnimStacks",value:function(n){var e=e0.Objects.AnimationStack,t={};for(var r in e){var o=t0.get(parseInt(r)).children;o.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");var a=n.get(o[0].ID);t[r]={name:e[r].attrName,layer:a}}return t}},{key:"addClip",value:function(n){var e=[],t=this;return n.layer.forEach((function(n){e=e.concat(t.generateTracks(n))})),new Yu(n.name,-1,e)}},{key:"generateTracks",value:function(n){var e=[],t=new Or,r=new Ir,o=new Or;if(n.transform&&n.transform.decompose(t,r,o),t=t.toArray(),r=(new So).setFromQuaternion(r,n.eulerOrder).toArray(),o=o.toArray(),void 0!==n.T&&Object.keys(n.T.curves).length>0){var a=this.generateVectorTrack(n.modelName,n.T.curves,t,"position");void 0!==a&&e.push(a)}if(void 0!==n.R&&Object.keys(n.R.curves).length>0){var i=this.generateRotationTrack(n.modelName,n.R.curves,r,n.preRotation,n.postRotation,n.eulerOrder);void 0!==i&&e.push(i)}if(void 0!==n.S&&Object.keys(n.S.curves).length>0){var v=this.generateVectorTrack(n.modelName,n.S.curves,o,"scale");void 0!==v&&e.push(v)}if(void 0!==n.DeformPercent){var c=this.generateMorphTrack(n);void 0!==c&&e.push(c)}return e}},{key:"generateVectorTrack",value:function(n,e,t,r){var o=this.getTimesForAllAxes(e),a=this.getKeyframeTrackValues(o,e,t);return new Xu(n+"."+r,o,a)}},{key:"generateRotationTrack",value:function(n,e,t,r,o,a){void 0!==e.x&&(this.interpolateRotations(e.x),e.x.values=e.x.values.map(ar.degToRad)),void 0!==e.y&&(this.interpolateRotations(e.y),e.y.values=e.y.values.map(ar.degToRad)),void 0!==e.z&&(this.interpolateRotations(e.z),e.z.values=e.z.values.map(ar.degToRad));var i=this.getTimesForAllAxes(e),v=this.getKeyframeTrackValues(i,e,t);void 0!==r&&((r=r.map(ar.degToRad)).push(a),r=(new So).fromArray(r),r=(new Ir).setFromEuler(r)),void 0!==o&&((o=o.map(ar.degToRad)).push(a),o=(new So).fromArray(o),o=(new Ir).setFromEuler(o).invert());for(var c=new Ir,l=new So,s=[],u=0;u<v.length;u+=3)l.set(v[u],v[u+1],v[u+2],a),c.setFromEuler(l),void 0!==r&&c.premultiply(r),void 0!==o&&c.multiply(o),c.toArray(s,u/3*4);return new Wu(n+".quaternion",i,s)}},{key:"generateMorphTrack",value:function(n){var e=n.DeformPercent.curves.morph,t=e.values.map((function(n){return n/100})),r=r0.getObjectByName(n.modelName).morphTargetDictionary[n.morphName];return new qu(n.modelName+".morphTargetInfluences["+r+"]",e.times,t)}},{key:"getTimesForAllAxes",value:function(n){var e=[];if(void 0!==n.x&&(e=e.concat(n.x.times)),void 0!==n.y&&(e=e.concat(n.y.times)),void 0!==n.z&&(e=e.concat(n.z.times)),e=e.sort((function(n,e){return n-e})),e.length>1){for(var t=1,r=e[0],o=1;o<e.length;o++){var a=e[o];a!==r&&(e[t]=a,r=a,t++)}e=e.slice(0,t)}return e}},{key:"getKeyframeTrackValues",value:function(n,e,t){var r=t,o=[],a=-1,i=-1,v=-1;return n.forEach((function(n){if(e.x&&(a=e.x.times.indexOf(n)),e.y&&(i=e.y.times.indexOf(n)),e.z&&(v=e.z.times.indexOf(n)),-1!==a){var t=e.x.values[a];o.push(t),r[0]=t}else o.push(r[0]);if(-1!==i){var c=e.y.values[i];o.push(c),r[1]=c}else o.push(r[1]);if(-1!==v){var l=e.z.values[v];o.push(l),r[2]=l}else o.push(r[2])})),o}},{key:"interpolateRotations",value:function(n){for(var e=1;e<n.values.length;e++){var t=n.values[e-1],r=n.values[e]-t,o=Math.abs(r);if(o>=180){for(var a=o/180,i=r/a,v=t+i,c=n.times[e-1],l=(n.times[e]-c)/a,s=c+l,u=[],f=[];s<n.times[e];)u.push(s),s+=l,f.push(v),v+=i;n.times=w0(n.times,e,u),n.values=w0(n.values,e,f)}}}}]),n}(),l0=function(){function n(){y(this,n)}return _(n,[{key:"getPrevNode",value:function(){return this.nodeStack[this.currentIndent-2]}},{key:"getCurrentNode",value:function(){return this.nodeStack[this.currentIndent-1]}},{key:"getCurrentProp",value:function(){return this.currentProp}},{key:"pushStack",value:function(n){this.nodeStack.push(n),this.currentIndent+=1}},{key:"popStack",value:function(){this.nodeStack.pop(),this.currentIndent-=1}},{key:"setCurrentProp",value:function(n,e){this.currentProp=n,this.currentPropName=e}},{key:"parse",value:function(n){this.currentIndent=0,this.allNodes=new f0,this.nodeStack=[],this.currentProp=[],this.currentPropName="";var e=this,t=n.split(/[\r\n]+/);return t.forEach((function(n,r){var o=n.match(/^[\s\t]*;/),a=n.match(/^[\s\t]*$/);if(!o&&!a){var i=n.match("^\\t{"+e.currentIndent+"}(\\w+):(.*){",""),v=n.match("^\\t{"+e.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),c=n.match("^\\t{"+(e.currentIndent-1)+"}}");i?e.parseNodeBegin(n,i):v?e.parseNodeProperty(n,v,t[++r]):c?e.popStack():n.match(/^[^\s\t}]/)&&e.parseNodePropertyContinued(n)}})),this.allNodes}},{key:"parseNodeBegin",value:function(n,e){var t=e[1].trim().replace(/^"/,"").replace(/"$/,""),r=e[2].split(",").map((function(n){return n.trim().replace(/^"/,"").replace(/"$/,"")})),o={name:t},a=this.parseNodeAttr(r),i=this.getCurrentNode();0===this.currentIndent?this.allNodes.add(t,o):t in i?("PoseNode"===t?i.PoseNode.push(o):void 0!==i[t].id&&(i[t]={},i[t][i[t].id]=i[t]),""!==a.id&&(i[t][a.id]=o)):"number"===typeof a.id?(i[t]={},i[t][a.id]=o):"Properties70"!==t&&(i[t]="PoseNode"===t?[o]:o),"number"===typeof a.id&&(o.id=a.id),""!==a.name&&(o.attrName=a.name),""!==a.type&&(o.attrType=a.type),this.pushStack(o)}},{key:"parseNodeAttr",value:function(n){var e=n[0];""!==n[0]&&(e=parseInt(n[0]),isNaN(e)&&(e=n[0]));var t="",r="";return n.length>1&&(t=n[1].replace(/^(\w+)::/,""),r=n[2]),{id:e,name:t,type:r}}},{key:"parseNodeProperty",value:function(n,e,t){var r=e[1].replace(/^"/,"").replace(/"$/,"").trim(),o=e[2].replace(/^"/,"").replace(/"$/,"").trim();"Content"===r&&","===o&&(o=t.replace(/"/g,"").replace(/,$/,"").trim());var a=this.getCurrentNode();if("Properties70"!==a.name){if("C"===r){var i=o.split(",").slice(1),v=parseInt(i[0]),c=parseInt(i[1]),l=o.split(",").slice(3);r="connections",function(n,e){for(var t=0,r=n.length,o=e.length;t<o;t++,r++)n[r]=e[t]}(o=[v,c],l=l.map((function(n){return n.trim().replace(/^"/,"")}))),void 0===a[r]&&(a[r]=[])}"Node"===r&&(a.id=o),r in a&&Array.isArray(a[r])?a[r].push(o):"a"!==r?a[r]=o:a.a=o,this.setCurrentProp(a,r),"a"===r&&","!==o.slice(-1)&&(a.a=_0(o))}else this.parseNodeSpecialProperty(n,r,o)}},{key:"parseNodePropertyContinued",value:function(n){var e=this.getCurrentNode();e.a+=n,","!==n.slice(-1)&&(e.a=_0(e.a))}},{key:"parseNodeSpecialProperty",value:function(n,e,t){var r=t.split('",').map((function(n){return n.trim().replace(/^\"/,"").replace(/\s/,"_")})),o=r[0],a=r[1],i=r[2],v=r[3],c=r[4];switch(a){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":c=parseFloat(c);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":c=_0(c)}this.getPrevNode()[o]={type:a,type2:i,flag:v,value:c},this.setCurrentProp(this.getPrevNode(),o)}}]),n}(),s0=function(){function n(){y(this,n)}return _(n,[{key:"parse",value:function(n){var e=new u0(n);e.skip(23);var t=e.getUint32();if(t<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+t);for(var r=new f0;!this.endOfContent(e);){var o=this.parseNode(e,t);null!==o&&r.add(o.name,o)}return r}},{key:"endOfContent",value:function(n){return n.size()%16===0?(n.getOffset()+160+16&-16)>=n.size():n.getOffset()+160+16>=n.size()}},{key:"parseNode",value:function(n,e){var t={},r=e>=7500?n.getUint64():n.getUint32(),o=e>=7500?n.getUint64():n.getUint32();e>=7500?n.getUint64():n.getUint32();var a=n.getUint8(),i=n.getString(a);if(0===r)return null;for(var v=[],c=0;c<o;c++)v.push(this.parseProperty(n));var l=v.length>0?v[0]:"",s=v.length>1?v[1]:"",u=v.length>2?v[2]:"";for(t.singleProperty=1===o&&n.getOffset()===r;r>n.getOffset();){var f=this.parseNode(n,e);null!==f&&this.parseSubNode(i,t,f)}return t.propertyList=v,"number"===typeof l&&(t.id=l),""!==s&&(t.attrName=s),""!==u&&(t.attrType=u),""!==i&&(t.name=i),t}},{key:"parseSubNode",value:function(n,e,t){if(!0===t.singleProperty){var r=t.propertyList[0];Array.isArray(r)?(e[t.name]=t,t.a=r):e[t.name]=r}else if("Connections"===n&&"C"===t.name){var o=[];t.propertyList.forEach((function(n,e){0!==e&&o.push(n)})),void 0===e.connections&&(e.connections=[]),e.connections.push(o)}else if("Properties70"===t.name){Object.keys(t).forEach((function(n){e[n]=t[n]}))}else if("Properties70"===n&&"P"===t.name){var a,i=t.propertyList[0],v=t.propertyList[1],c=t.propertyList[2],l=t.propertyList[3];0===i.indexOf("Lcl ")&&(i=i.replace("Lcl ","Lcl_")),0===v.indexOf("Lcl ")&&(v=v.replace("Lcl ","Lcl_")),a="Color"===v||"ColorRGB"===v||"Vector"===v||"Vector3D"===v||0===v.indexOf("Lcl_")?[t.propertyList[4],t.propertyList[5],t.propertyList[6]]:t.propertyList[4],e[i]={type:v,type2:c,flag:l,value:a}}else void 0===e[t.name]?"number"===typeof t.id?(e[t.name]={},e[t.name][t.id]=t):e[t.name]=t:"PoseNode"===t.name?(Array.isArray(e[t.name])||(e[t.name]=[e[t.name]]),e[t.name].push(t)):void 0===e[t.name][t.id]&&(e[t.name][t.id]=t)}},{key:"parseProperty",value:function(n){var e,t=n.getString(1);switch(t){case"C":return n.getBoolean();case"D":return n.getFloat64();case"F":return n.getFloat32();case"I":return n.getInt32();case"L":return n.getInt64();case"R":return e=n.getUint32(),n.getArrayBuffer(e);case"S":return e=n.getUint32(),n.getString(e);case"Y":return n.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":var r=n.getUint32(),o=n.getUint32(),a=n.getUint32();if(0===o)switch(t){case"b":case"c":return n.getBooleanArray(r);case"d":return n.getFloat64Array(r);case"f":return n.getFloat32Array(r);case"i":return n.getInt32Array(r);case"l":return n.getInt64Array(r)}var i=$Q(new Uint8Array(n.getArrayBuffer(a))),v=new u0(i.buffer);switch(t){case"b":case"c":return v.getBooleanArray(r);case"d":return v.getFloat64Array(r);case"f":return v.getFloat32Array(r);case"i":return v.getInt32Array(r);case"l":return v.getInt64Array(r)}default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}]),n}(),u0=function(){function n(e,t){y(this,n),this.dv=new DataView(e),this.offset=0,this.littleEndian=void 0===t||t}return _(n,[{key:"getOffset",value:function(){return this.offset}},{key:"size",value:function(){return this.dv.buffer.byteLength}},{key:"skip",value:function(n){this.offset+=n}},{key:"getBoolean",value:function(){return 1===(1&this.getUint8())}},{key:"getBooleanArray",value:function(n){for(var e=[],t=0;t<n;t++)e.push(this.getBoolean());return e}},{key:"getUint8",value:function(){var n=this.dv.getUint8(this.offset);return this.offset+=1,n}},{key:"getInt16",value:function(){var n=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,n}},{key:"getInt32",value:function(){var n=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,n}},{key:"getInt32Array",value:function(n){for(var e=[],t=0;t<n;t++)e.push(this.getInt32());return e}},{key:"getUint32",value:function(){var n=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,n}},{key:"getInt64",value:function(){var n,e;return this.littleEndian?(n=this.getUint32(),e=this.getUint32()):(e=this.getUint32(),n=this.getUint32()),2147483648&e?(e=4294967295&~e,4294967295===(n=4294967295&~n)&&(e=e+1&4294967295),-(4294967296*e+(n=n+1&4294967295))):4294967296*e+n}},{key:"getInt64Array",value:function(n){for(var e=[],t=0;t<n;t++)e.push(this.getInt64());return e}},{key:"getUint64",value:function(){var n,e;return this.littleEndian?(n=this.getUint32(),e=this.getUint32()):(e=this.getUint32(),n=this.getUint32()),4294967296*e+n}},{key:"getFloat32",value:function(){var n=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,n}},{key:"getFloat32Array",value:function(n){for(var e=[],t=0;t<n;t++)e.push(this.getFloat32());return e}},{key:"getFloat64",value:function(){var n=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,n}},{key:"getFloat64Array",value:function(n){for(var e=[],t=0;t<n;t++)e.push(this.getFloat64());return e}},{key:"getArrayBuffer",value:function(n){var e=this.dv.buffer.slice(this.offset,this.offset+n);return this.offset+=n,e}},{key:"getString",value:function(n){for(var e=[],t=0;t<n;t++)e[t]=this.getUint8();var r=e.indexOf(0);return r>=0&&(e=e.slice(0,r)),Df.decodeText(new Uint8Array(e))}}]),n}(),f0=function(){function n(){y(this,n)}return _(n,[{key:"add",value:function(n,e){this[n]=e}}]),n}();function p0(n){var e=n.match(/FBXVersion: (\d+)/);if(e)return parseInt(e[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function d0(n){return n/46186158e3}var m0=[];function h0(n,e,t,r){var o;switch(r.mappingType){case"ByPolygonVertex":o=n;break;case"ByPolygon":o=e;break;case"ByVertice":o=t;break;case"AllSame":o=r.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+r.mappingType)}"IndexToDirect"===r.referenceType&&(o=r.indices[o]);var a=o*r.dataSize,i=a+r.dataSize;return function(n,e,t,r){for(var o=t,a=0;o<r;o++,a++)n[a]=e[o];return n}(m0,r.buffer,a,i)}var x0=new So,g0=new Or;function y0(n){var e=new po,t=new po,r=new po,o=new po,a=new po,i=new po,v=new po,c=new po,l=new po,s=new po,u=new po,f=new po,p=n.inheritType?n.inheritType:0;if(n.translation&&e.setPosition(g0.fromArray(n.translation)),n.preRotation){var d=n.preRotation.map(ar.degToRad);d.push(n.eulerOrder),t.makeRotationFromEuler(x0.fromArray(d))}if(n.rotation){var m=n.rotation.map(ar.degToRad);m.push(n.eulerOrder),r.makeRotationFromEuler(x0.fromArray(m))}if(n.postRotation){var h=n.postRotation.map(ar.degToRad);h.push(n.eulerOrder),o.makeRotationFromEuler(x0.fromArray(h)),o.invert()}n.scale&&a.scale(g0.fromArray(n.scale)),n.scalingOffset&&v.setPosition(g0.fromArray(n.scalingOffset)),n.scalingPivot&&i.setPosition(g0.fromArray(n.scalingPivot)),n.rotationOffset&&c.setPosition(g0.fromArray(n.rotationOffset)),n.rotationPivot&&l.setPosition(g0.fromArray(n.rotationPivot)),n.parentMatrixWorld&&(u.copy(n.parentMatrix),s.copy(n.parentMatrixWorld));var x=t.clone().multiply(r).multiply(o),g=new po;g.extractRotation(s);var y=new po;y.copyPosition(s);var b=y.clone().invert().multiply(s),_=g.clone().invert().multiply(b),U=a,w=new po;if(0===p)w.copy(g).multiply(x).multiply(_).multiply(U);else if(1===p)w.copy(g).multiply(_).multiply(x).multiply(U);else{var S=(new po).scale((new Or).setFromMatrixScale(u)).clone().invert(),k=_.clone().multiply(S);w.copy(g).multiply(x).multiply(k).multiply(U)}var M=l.clone().invert(),z=i.clone().invert(),C=e.clone().multiply(c).multiply(l).multiply(t).multiply(r).multiply(o).multiply(M).multiply(v).multiply(i).multiply(a).multiply(z),T=(new po).copyPosition(C),R=s.clone().multiply(T);return f.copyPosition(R),(C=f.clone().multiply(w)).premultiply(s.invert()),C}function b0(n){var e=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return 6===(n=n||0)?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),e[0]):e[n]}function _0(n){return n.split(",").map((function(n){return parseFloat(n)}))}function U0(n,e,t){return void 0===e&&(e=0),void 0===t&&(t=n.byteLength),Df.decodeText(new Uint8Array(n,e,t))}function w0(n,e,t){return n.slice(0,e).concat(t).concat(n.slice(e))}function S0(n){return Hm(a0,n)}S0.preload=function(n){return Hm.preload(a0,n)},S0.clear=function(n){return Hm.clear(a0,n)};var k0=function(n){return n===Object(n)&&!Array.isArray(n)&&"function"!==typeof n};function M0(n,e){var t=qm((function(n){return n.gl})),r=Hm(sf,k0(n)?Object.values(n):n);if((0,Ad.useLayoutEffect)((function(){null==e||e(r)}),[e]),(0,Ad.useEffect)((function(){(Array.isArray(r)?r:[r]).forEach(t.initTexture)}),[t,r]),k0(n)){var o=Object.keys(n),a={};return o.forEach((function(n){return Object.assign(a,l({},n,r[o.indexOf(n)]))})),a}return r}function z0(n){var e=S0("./Models/warehouse2/source/WareHouse.fbx"),t=M0("./Models/warehouse2/textures/Bake.jpg"),r=M0("./Models/warehouse2/textures/Tx.jpg");t.flipY=!0,r.flipY=!1;new ku;var o=new _u({map:t,aoMap:r});return(0,Yh.jsxs)("group",u(u({},n),{},{dispose:null,children:[(0,Yh.jsxs)("group",{position:[0,-27,80],children:[(0,Yh.jsx)("mesh",{geometry:e.children[0].children[1].geometry,material:o}),(0,Yh.jsx)("mesh",{geometry:e.children[0].children[0].children[1].geometry,material:o}),(0,Yh.jsx)("mesh",{geometry:e.children[0].children[0].children[0].children[0].geometry,material:o}),(0,Yh.jsx)("mesh",{geometry:e.children[1].geometry,material:o}),(0,Yh.jsx)("mesh",{geometry:e.children[2].geometry,material:o})]}),(0,Yh.jsx)("ambientLight",{intensity:.2}),(0,Yh.jsx)("rectAreaLight",{position:[0,0,-80],intensity:30})]}))}function C0(){var n=Vh((function(n){return n.songPlaying})),e=Vh((function(n){return n.getSongTime}));console.log(n);var t=(0,Ad.useRef)(),r=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var o=Lm((function(){var o=0,a=e();!0===n&&(o=0),o=Date.now()-a,o/=1e3,t.current&&o>0&&o<=137&&(t.current.textContent=function(n){return Math.floor(n%3600/60).toString().padStart(2,"0")+":"+Math.floor(n%60).toString().padStart(2,"0")}(o),r.current.style.width=o/137*100+"%")}));return function(){o()}}),[]),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsxs)("div",{className:"interface",children:[(0,Yh.jsx)("div",{className:"song",children:"song: new adventure"}),(0,Yh.jsx)("div",{className:"artist",children:"artist: matrika "}),(0,Yh.jsx)("div",{id:"Progress_Status",children:(0,Yh.jsx)("div",{className:"progress",ref:r})}),(0,Yh.jsx)("div",{className:"time",ref:t,children:"00:00"})]})})}function T0(){var n=Vh((function(n){return n.songPlaying})),e=Vh((function(n){return n.getSongTime}));console.log(n);var t=(0,Ad.useRef)(),r=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var o=Lm((function(){var o=0,a=e();!0===n&&(o=0),o=Date.now()-a,o/=1e3,t.current&&o>0&&o<=204&&(t.current.textContent=function(n){return Math.floor(n%3600/60).toString().padStart(2,"0")+":"+Math.floor(n%60).toString().padStart(2,"0")}(o),r.current.style.width=o/204*100+"%")}));return function(){o()}}),[]),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsxs)("div",{className:"interface",children:[(0,Yh.jsx)("div",{className:"song",children:"song: polaroid"}),(0,Yh.jsx)("div",{className:"artist",children:"artist: arston "}),(0,Yh.jsx)("div",{id:"Progress_Status",children:(0,Yh.jsx)("div",{className:"progress",ref:r})}),(0,Yh.jsx)("div",{className:"time",ref:t,children:"00:00"})]})})}function R0(){var n=Vh((function(n){return n.songPlaying})),e=Vh((function(n){return n.getSongTime}));console.log(n);var t=(0,Ad.useRef)(),r=(0,Ad.useRef)();return(0,Ad.useEffect)((function(){var o=Lm((function(){var o=0,a=e();!0===n&&(o=0),o=Date.now()-a,o/=1e3,t.current&&o>0&&o<=137&&(t.current.textContent=function(n){return Math.floor(n%3600/60).toString().padStart(2,"0")+":"+Math.floor(n%60).toString().padStart(2,"0")}(o),r.current.style.width=o/137*100+"%")}));return function(){o()}}),[]),(0,Yh.jsx)(Yh.Fragment,{children:(0,Yh.jsxs)("div",{className:"interface",children:[(0,Yh.jsx)("div",{className:"song",children:"song: new adventure"}),(0,Yh.jsx)("div",{className:"artist",children:"artist: matrika "}),(0,Yh.jsx)("div",{id:"Progress_Status",children:(0,Yh.jsx)("div",{className:"progress",ref:r})}),(0,Yh.jsx)("div",{className:"time",ref:t,children:"00:00"})]})})}function D0(){var n=Vh((function(n){return n.currentShader})),e=Vh((function(n){return n.setCurrentShader})),t=Vh((function(n){return n.information})),r=Vh((function(n){return n.activateInformation})),o=Vh((function(n){return n.deactivateInformation}));document.addEventListener("wheel",(function(n){"number"===document.activeElement.type&&document.activeElement.blur()}));return(0,Yh.jsxs)(Yh.Fragment,{children:[(0,Yh.jsxs)("div",{className:"nav",children:[!t&&(0,Yh.jsx)("button",{className:"back",onClick:function(){n>1&&e(n-1)},children:"back"}),!t&&(0,Yh.jsx)("button",{className:"next",onClick:function(){n<675&&e(n+1)},children:"next"}),(0,Yh.jsx)("h1",{className:"current",children:n})]}),(0,Yh.jsxs)("form",{id:"myForm",className:"form",onSubmit:function(n){n.preventDefault();var t=n.target,r=new FormData(t),o=Object.fromEntries(r.entries()),a=parseInt(o.shader);!Number.isNaN(a)&&a>0&&a<=675&&e(a),document.getElementById("myForm").reset()},children:[!t&&(0,Yh.jsx)("input",{type:"number",name:"shader",placeholder:"Enter Shader Number",className:"input"}),!t&&(0,Yh.jsx)("input",{type:"submit",value:"Submit",className:"submit"})]}),(0,Yh.jsx)("div",{className:"icon",onClick:function(){!1===t&&(document.getElementsByClassName("webgl")[0].style.opacity="0.15",document.getElementsByClassName("nav")[0].style.opacity="0.025",document.getElementsByClassName("form")[0].style.opacity="0.025",document.getElementsByClassName("icon")[0].style.opacity="0.025",document.getElementsByClassName("random")[0].style.opacity="0.025",r())},children:(0,Yh.jsx)("i",{className:"fa-solid fa-info"})}),(0,Yh.jsx)("div",{className:"random",onClick:function(){e(Math.floor(675*Math.random())+1)},children:!t&&(0,Yh.jsx)("i",{className:"fa-solid fa-shuffle"})}),646===n&&(0,Yh.jsx)(C0,{}),647===n&&(0,Yh.jsx)(T0,{}),648===n&&(0,Yh.jsx)(R0,{}),t&&(0,Yh.jsxs)("div",{className:"container",children:[(0,Yh.jsx)("div",{className:"close",onClick:function(){document.getElementsByClassName("webgl")[0].style.opacity="1.0",document.getElementsByClassName("nav")[0].style.opacity="1.0",document.getElementsByClassName("form")[0].style.opacity="1.0",document.getElementsByClassName("icon")[0].style.opacity="1.0",document.getElementsByClassName("random")[0].style.opacity="1.0",o()},children:(0,Yh.jsx)("i",{className:"fa-solid fa-x"})}),(0,Yh.jsx)("h1",{className:"header",children:"Welcome to Shader Daily!"}),(0,Yh.jsxs)("p",{className:"text",children:["This website is a result of my personal journey towards learning the magic of Shaders. A shader is a computer program that uses a variety of specialized functions and algorithms to calculate the color value of each pixel in a rendered result using the graphics processing unit (GPU). Shaders are used in a variety of industries ranging from cinema to video games. The programming language used in shaders depends on the target environment. This target environment uses GLSL (Graphics Library Shader Language). This shader program requires a vertex shader and a fragment shader. The vertex shader is not manipulated in this website and kept standard for all results. The fragment shader is modified for each result. The rendering result and experience is achieved using Three.js and React-Three-Fiber. ",(0,Yh.jsx)("br",{})," ",(0,Yh.jsx)("br",{})," Thank you for visiting!",(0,Yh.jsx)("br",{})," ",(0,Yh.jsx)("br",{}),"Nate Argaw  ",(0,Yh.jsx)("p",{className:"copyright",children:"\xa9 Shader Daily. All Rights Reserved"})]}),(0,Yh.jsxs)("div",{className:"contact",children:[(0,Yh.jsxs)("div",{className:"mail",onClick:function(){var n="nateargaw@gmail.com";navigator.clipboard.writeText(n),alert("Copied email: "+n)},children:[(0,Yh.jsx)("a",{href:"mailto: nateargaw@gmail.com"}),(0,Yh.jsx)("i",{className:"fa-solid fa-envelope"})]}),(0,Yh.jsx)("div",{className:"twitter",children:(0,Yh.jsx)("a",{href:"https://twitter.com/nate_dev_",children:(0,Yh.jsx)("i",{className:"fa-brands fa-x-twitter"})})}),(0,Yh.jsx)("div",{className:"linkedin",children:(0,Yh.jsx)("a",{href:"https://www.linkedin.com/in/nateargaw/",children:(0,Yh.jsx)("i",{className:"fa-brands fa-linkedin-in"})})}),(0,Yh.jsx)("div",{className:"instagram",children:(0,Yh.jsx)("a",{href:"https://www.instagram.com/shaderdaily/",children:(0,Yh.jsx)("i",{className:"fa-brands fa-instagram"})})})]})]})]})}function P0(){var n=(0,Ad.useRef)();return qm((function(e){n.current=e.camera})),Vm((function(){})),(0,Yh.jsx)(Yh.Fragment,{})}M0.preload=function(n){return Hm.preload(sf,n)},M0.clear=function(n){return Hm.clear(sf,n)},(0,Oh.s)(document.querySelector("#root")).render((0,Yh.jsxs)(Ad.StrictMode,{children:[(0,Yh.jsx)("div",{style:{position:"absolute",top:"20vh",left:"50vw",transform:"translate(-50%, -50%)",zIndex:"1",width:"250px",height:"250px"},children:(0,Yh.jsx)(uQ,{fill:!0,flat:!1,titleBar:!0,collapsed:!0,drag:!0,hideCopyButton:!0})}),(0,Yh.jsxs)(Ih,{className:"webgl",camera:{fov:50,aspect:window.innerWidth/window.innerHeight,near:.01,far:1e3,position:[0,0,5]},children:[(0,Yh.jsx)(bQ,{}),(0,Yh.jsx)(z0,{}),(0,Yh.jsx)(P0,{})]}),(0,Yh.jsx)(D0,{})]}))}()}();
//# sourceMappingURL=main.22c5af3d.js.map