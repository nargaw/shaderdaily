/*! For license information please see main.d872fcd6.js.LICENSE.txt */
!function(){var n={345:function(n,e){"use strict";function t(n,e){var t=n.length;n.push(e);n:for(;0<t;){var o=t-1>>>1,r=n[o];if(!(0<a(r,e)))break n;n[o]=e,n[t]=r,t=o}}function o(n){return 0===n.length?null:n[0]}function r(n){if(0===n.length)return null;var e=n[0],t=n.pop();if(t!==e){n[0]=t;n:for(var o=0,r=n.length,i=r>>>1;o<i;){var v=2*(o+1)-1,c=n[v],s=v+1,l=n[s];if(0>a(c,t))s<r&&0>a(l,c)?(n[o]=l,n[s]=t,o=s):(n[o]=c,n[v]=t,o=v);else{if(!(s<r&&0>a(l,t)))break n;n[o]=l,n[s]=t,o=s}}}return e}function a(n,e){var t=n.sortIndex-e.sortIndex;return 0!==t?t:n.id-e.id}if("object"===typeof performance&&"function"===typeof performance.now){var i=performance;e.unstable_now=function(){return i.now()}}else{var v=Date,c=v.now();e.unstable_now=function(){return v.now()-c}}var s=[],l=[],u=1,f=null,p=3,m=!1,d=!1,h=!1,x="function"===typeof setTimeout?setTimeout:null,g="function"===typeof clearTimeout?clearTimeout:null,y="undefined"!==typeof setImmediate?setImmediate:null;function b(n){for(var e=o(l);null!==e;){if(null===e.callback)r(l);else{if(!(e.startTime<=n))break;r(l),e.sortIndex=e.expirationTime,t(s,e)}e=o(l)}}function U(n){if(h=!1,b(n),!d)if(null!==o(s))d=!0,F(_);else{var e=o(l);null!==e&&j(U,e.startTime-n)}}function _(n,t){d=!1,h&&(h=!1,g(k),k=-1),m=!0;var a=p;try{for(b(t),f=o(s);null!==f&&(!(f.expirationTime>t)||n&&!T());){var i=f.callback;if("function"===typeof i){f.callback=null,p=f.priorityLevel;var v=i(f.expirationTime<=t);t=e.unstable_now(),"function"===typeof v?f.callback=v:f===o(s)&&r(s),b(t)}else r(s);f=o(s)}if(null!==f)var c=!0;else{var u=o(l);null!==u&&j(U,u.startTime-t),c=!1}return c}finally{f=null,p=a,m=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var w,S=!1,M=null,k=-1,z=5,C=-1;function T(){return!(e.unstable_now()-C<z)}function R(){if(null!==M){var n=e.unstable_now();C=n;var t=!0;try{t=M(!0,n)}finally{t?w():(S=!1,M=null)}}else S=!1}if("function"===typeof y)w=function(){y(R)};else if("undefined"!==typeof MessageChannel){var D=new MessageChannel,P=D.port2;D.port1.onmessage=R,w=function(){P.postMessage(null)}}else w=function(){x(R,0)};function F(n){M=n,S||(S=!0,w())}function j(n,t){k=x((function(){n(e.unstable_now())}),t)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(n){n.callback=null},e.unstable_continueExecution=function(){d||m||(d=!0,F(_))},e.unstable_forceFrameRate=function(n){0>n||125<n?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):z=0<n?Math.floor(1e3/n):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return o(s)},e.unstable_next=function(n){switch(p){case 1:case 2:case 3:var e=3;break;default:e=p}var t=p;p=e;try{return n()}finally{p=t}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(n,e){switch(n){case 1:case 2:case 3:case 4:case 5:break;default:n=3}var t=p;p=n;try{return e()}finally{p=t}},e.unstable_scheduleCallback=function(n,r,a){var i=e.unstable_now();switch("object"===typeof a&&null!==a?a="number"===typeof(a=a.delay)&&0<a?i+a:i:a=i,n){case 1:var v=-1;break;case 2:v=250;break;case 5:v=1073741823;break;case 4:v=1e4;break;default:v=5e3}return n={id:u++,callback:r,priorityLevel:n,startTime:a,expirationTime:v=a+v,sortIndex:-1},a>i?(n.sortIndex=a,t(l,n),null===o(s)&&n===o(l)&&(h?(g(k),k=-1):h=!0,j(U,a-i))):(n.sortIndex=v,t(s,n),d||m||(d=!0,F(_))),n},e.unstable_shouldYield=T,e.unstable_wrapCallback=function(n){var e=p;return function(){var t=p;p=e;try{return n.apply(this,arguments)}finally{p=t}}}},545:function(n,e,t){"use strict";n.exports=t(345)},494:function(n){function e(n,e,t){var o,r,a,i,v;function c(){var s=Date.now()-i;s<e&&s>=0?o=setTimeout(c,e-s):(o=null,t||(v=n.apply(a,r),a=r=null))}null==e&&(e=100);var s=function(){a=this,r=arguments,i=Date.now();var s=t&&!o;return o||(o=setTimeout(c,e)),s&&(v=n.apply(a,r),a=r=null),v};return s.clear=function(){o&&(clearTimeout(o),o=null)},s.flush=function(){o&&(v=n.apply(a,r),a=r=null,clearTimeout(o),o=null)},s}e.debounce=e,n.exports=e},463:function(n,e,t){"use strict";var o=t(791),r=t(296);function a(n){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+n,t=1;t<arguments.length;t++)e+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+n+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var i=new Set,v={};function c(n,e){s(n,e),s(n+"Capture",e)}function s(n,e){for(v[n]=e,n=0;n<e.length;n++)i.add(e[n])}var l=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),u=Object.prototype.hasOwnProperty,f=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},m={};function d(n,e,t,o,r,a,i){this.acceptsBooleans=2===e||3===e||4===e,this.attributeName=o,this.attributeNamespace=r,this.mustUseProperty=t,this.propertyName=n,this.type=e,this.sanitizeURL=a,this.removeEmptyString=i}var h={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(n){h[n]=new d(n,0,!1,n,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(n){var e=n[0];h[e]=new d(e,1,!1,n[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(n){h[n]=new d(n,2,!1,n.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(n){h[n]=new d(n,2,!1,n,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(n){h[n]=new d(n,3,!1,n.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(n){h[n]=new d(n,3,!0,n,null,!1,!1)})),["capture","download"].forEach((function(n){h[n]=new d(n,4,!1,n,null,!1,!1)})),["cols","rows","size","span"].forEach((function(n){h[n]=new d(n,6,!1,n,null,!1,!1)})),["rowSpan","start"].forEach((function(n){h[n]=new d(n,5,!1,n.toLowerCase(),null,!1,!1)}));var x=/[\-:]([a-z])/g;function g(n){return n[1].toUpperCase()}function y(n,e,t,o){var r=h.hasOwnProperty(e)?h[e]:null;(null!==r?0!==r.type:o||!(2<e.length)||"o"!==e[0]&&"O"!==e[0]||"n"!==e[1]&&"N"!==e[1])&&(function(n,e,t,o){if(null===e||"undefined"===typeof e||function(n,e,t,o){if(null!==t&&0===t.type)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return!o&&(null!==t?!t.acceptsBooleans:"data-"!==(n=n.toLowerCase().slice(0,5))&&"aria-"!==n);default:return!1}}(n,e,t,o))return!0;if(o)return!1;if(null!==t)switch(t.type){case 3:return!e;case 4:return!1===e;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}(e,t,r,o)&&(t=null),o||null===r?function(n){return!!u.call(m,n)||!u.call(p,n)&&(f.test(n)?m[n]=!0:(p[n]=!0,!1))}(e)&&(null===t?n.removeAttribute(e):n.setAttribute(e,""+t)):r.mustUseProperty?n[r.propertyName]=null===t?3!==r.type&&"":t:(e=r.attributeName,o=r.attributeNamespace,null===t?n.removeAttribute(e):(t=3===(r=r.type)||4===r&&!0===t?"":""+t,o?n.setAttributeNS(o,e,t):n.setAttribute(e,t))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(n){var e=n.replace(x,g);h[e]=new d(e,1,!1,n,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(n){var e=n.replace(x,g);h[e]=new d(e,1,!1,n,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(n){var e=n.replace(x,g);h[e]=new d(e,1,!1,n,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(n){h[n]=new d(n,1,!1,n.toLowerCase(),null,!1,!1)})),h.xlinkHref=new d("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(n){h[n]=new d(n,1,!1,n.toLowerCase(),null,!0,!0)}));var b=o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,U=Symbol.for("react.element"),_=Symbol.for("react.portal"),w=Symbol.for("react.fragment"),S=Symbol.for("react.strict_mode"),M=Symbol.for("react.profiler"),k=Symbol.for("react.provider"),z=Symbol.for("react.context"),C=Symbol.for("react.forward_ref"),T=Symbol.for("react.suspense"),R=Symbol.for("react.suspense_list"),D=Symbol.for("react.memo"),P=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var F=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var j=Symbol.iterator;function I(n){return null===n||"object"!==typeof n?null:"function"===typeof(n=j&&n[j]||n["@@iterator"])?n:null}var E,O=Object.assign;function A(n){if(void 0===E)try{throw Error()}catch(t){var e=t.stack.trim().match(/\n( *(at )?)/);E=e&&e[1]||""}return"\n"+E+n}var L=!1;function G(n,e){if(!n||L)return"";L=!0;var t=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(e,[])}catch(s){var o=s}Reflect.construct(n,[],e)}else{try{e.call()}catch(s){o=s}n.call(e.prototype)}else{try{throw Error()}catch(s){o=s}n()}}catch(s){if(s&&o&&"string"===typeof s.stack){for(var r=s.stack.split("\n"),a=o.stack.split("\n"),i=r.length-1,v=a.length-1;1<=i&&0<=v&&r[i]!==a[v];)v--;for(;1<=i&&0<=v;i--,v--)if(r[i]!==a[v]){if(1!==i||1!==v)do{if(i--,0>--v||r[i]!==a[v]){var c="\n"+r[i].replace(" at new "," at ");return n.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",n.displayName)),c}}while(1<=i&&0<=v);break}}}finally{L=!1,Error.prepareStackTrace=t}return(n=n?n.displayName||n.name:"")?A(n):""}function N(n){switch(n.tag){case 5:return A(n.type);case 16:return A("Lazy");case 13:return A("Suspense");case 19:return A("SuspenseList");case 0:case 2:case 15:return n=G(n.type,!1);case 11:return n=G(n.type.render,!1);case 1:return n=G(n.type,!0);default:return""}}function B(n){if(null==n)return null;if("function"===typeof n)return n.displayName||n.name||null;if("string"===typeof n)return n;switch(n){case w:return"Fragment";case _:return"Portal";case M:return"Profiler";case S:return"StrictMode";case T:return"Suspense";case R:return"SuspenseList"}if("object"===typeof n)switch(n.$$typeof){case z:return(n.displayName||"Context")+".Consumer";case k:return(n._context.displayName||"Context")+".Provider";case C:var e=n.render;return(n=n.displayName)||(n=""!==(n=e.displayName||e.name||"")?"ForwardRef("+n+")":"ForwardRef"),n;case D:return null!==(e=n.displayName||null)?e:B(n.type)||"Memo";case P:e=n._payload,n=n._init;try{return B(n(e))}catch(t){}}return null}function q(n){var e=n.type;switch(n.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return n=(n=e.render).displayName||n.name||"",e.displayName||(""!==n?"ForwardRef("+n+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return B(e);case 8:return e===S?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e}return null}function V(n){switch(typeof n){case"boolean":case"number":case"string":case"undefined":case"object":return n;default:return""}}function W(n){var e=n.type;return(n=n.nodeName)&&"input"===n.toLowerCase()&&("checkbox"===e||"radio"===e)}function H(n){n._valueTracker||(n._valueTracker=function(n){var e=W(n)?"checked":"value",t=Object.getOwnPropertyDescriptor(n.constructor.prototype,e),o=""+n[e];if(!n.hasOwnProperty(e)&&"undefined"!==typeof t&&"function"===typeof t.get&&"function"===typeof t.set){var r=t.get,a=t.set;return Object.defineProperty(n,e,{configurable:!0,get:function(){return r.call(this)},set:function(n){o=""+n,a.call(this,n)}}),Object.defineProperty(n,e,{enumerable:t.enumerable}),{getValue:function(){return o},setValue:function(n){o=""+n},stopTracking:function(){n._valueTracker=null,delete n[e]}}}}(n))}function X(n){if(!n)return!1;var e=n._valueTracker;if(!e)return!0;var t=e.getValue(),o="";return n&&(o=W(n)?n.checked?"true":"false":n.value),(n=o)!==t&&(e.setValue(n),!0)}function Y(n){if("undefined"===typeof(n=n||("undefined"!==typeof document?document:void 0)))return null;try{return n.activeElement||n.body}catch(e){return n.body}}function Z(n,e){var t=e.checked;return O({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=t?t:n._wrapperState.initialChecked})}function Q(n,e){var t=null==e.defaultValue?"":e.defaultValue,o=null!=e.checked?e.checked:e.defaultChecked;t=V(null!=e.value?e.value:t),n._wrapperState={initialChecked:o,initialValue:t,controlled:"checkbox"===e.type||"radio"===e.type?null!=e.checked:null!=e.value}}function J(n,e){null!=(e=e.checked)&&y(n,"checked",e,!1)}function K(n,e){J(n,e);var t=V(e.value),o=e.type;if(null!=t)"number"===o?(0===t&&""===n.value||n.value!=t)&&(n.value=""+t):n.value!==""+t&&(n.value=""+t);else if("submit"===o||"reset"===o)return void n.removeAttribute("value");e.hasOwnProperty("value")?nn(n,e.type,t):e.hasOwnProperty("defaultValue")&&nn(n,e.type,V(e.defaultValue)),null==e.checked&&null!=e.defaultChecked&&(n.defaultChecked=!!e.defaultChecked)}function $(n,e,t){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var o=e.type;if(!("submit"!==o&&"reset"!==o||void 0!==e.value&&null!==e.value))return;e=""+n._wrapperState.initialValue,t||e===n.value||(n.value=e),n.defaultValue=e}""!==(t=n.name)&&(n.name=""),n.defaultChecked=!!n._wrapperState.initialChecked,""!==t&&(n.name=t)}function nn(n,e,t){"number"===e&&Y(n.ownerDocument)===n||(null==t?n.defaultValue=""+n._wrapperState.initialValue:n.defaultValue!==""+t&&(n.defaultValue=""+t))}var en=Array.isArray;function tn(n,e,t,o){if(n=n.options,e){e={};for(var r=0;r<t.length;r++)e["$"+t[r]]=!0;for(t=0;t<n.length;t++)r=e.hasOwnProperty("$"+n[t].value),n[t].selected!==r&&(n[t].selected=r),r&&o&&(n[t].defaultSelected=!0)}else{for(t=""+V(t),e=null,r=0;r<n.length;r++){if(n[r].value===t)return n[r].selected=!0,void(o&&(n[r].defaultSelected=!0));null!==e||n[r].disabled||(e=n[r])}null!==e&&(e.selected=!0)}}function on(n,e){if(null!=e.dangerouslySetInnerHTML)throw Error(a(91));return O({},e,{value:void 0,defaultValue:void 0,children:""+n._wrapperState.initialValue})}function rn(n,e){var t=e.value;if(null==t){if(t=e.children,e=e.defaultValue,null!=t){if(null!=e)throw Error(a(92));if(en(t)){if(1<t.length)throw Error(a(93));t=t[0]}e=t}null==e&&(e=""),t=e}n._wrapperState={initialValue:V(t)}}function an(n,e){var t=V(e.value),o=V(e.defaultValue);null!=t&&((t=""+t)!==n.value&&(n.value=t),null==e.defaultValue&&n.defaultValue!==t&&(n.defaultValue=t)),null!=o&&(n.defaultValue=""+o)}function vn(n){var e=n.textContent;e===n._wrapperState.initialValue&&""!==e&&null!==e&&(n.value=e)}function cn(n){switch(n){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function sn(n,e){return null==n||"http://www.w3.org/1999/xhtml"===n?cn(e):"http://www.w3.org/2000/svg"===n&&"foreignObject"===e?"http://www.w3.org/1999/xhtml":n}var ln,un,fn=(un=function(n,e){if("http://www.w3.org/2000/svg"!==n.namespaceURI||"innerHTML"in n)n.innerHTML=e;else{for((ln=ln||document.createElement("div")).innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=ln.firstChild;n.firstChild;)n.removeChild(n.firstChild);for(;e.firstChild;)n.appendChild(e.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(n,e,t,o){MSApp.execUnsafeLocalFunction((function(){return un(n,e)}))}:un);function pn(n,e){if(e){var t=n.firstChild;if(t&&t===n.lastChild&&3===t.nodeType)return void(t.nodeValue=e)}n.textContent=e}var mn={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},dn=["Webkit","ms","Moz","O"];function hn(n,e,t){return null==e||"boolean"===typeof e||""===e?"":t||"number"!==typeof e||0===e||mn.hasOwnProperty(n)&&mn[n]?(""+e).trim():e+"px"}function xn(n,e){for(var t in n=n.style,e)if(e.hasOwnProperty(t)){var o=0===t.indexOf("--"),r=hn(t,e[t],o);"float"===t&&(t="cssFloat"),o?n.setProperty(t,r):n[t]=r}}Object.keys(mn).forEach((function(n){dn.forEach((function(e){e=e+n.charAt(0).toUpperCase()+n.substring(1),mn[e]=mn[n]}))}));var gn=O({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function yn(n,e){if(e){if(gn[n]&&(null!=e.children||null!=e.dangerouslySetInnerHTML))throw Error(a(137,n));if(null!=e.dangerouslySetInnerHTML){if(null!=e.children)throw Error(a(60));if("object"!==typeof e.dangerouslySetInnerHTML||!("__html"in e.dangerouslySetInnerHTML))throw Error(a(61))}if(null!=e.style&&"object"!==typeof e.style)throw Error(a(62))}}function bn(n,e){if(-1===n.indexOf("-"))return"string"===typeof e.is;switch(n){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Un=null;function _n(n){return(n=n.target||n.srcElement||window).correspondingUseElement&&(n=n.correspondingUseElement),3===n.nodeType?n.parentNode:n}var wn=null,Sn=null,Mn=null;function kn(n){if(n=br(n)){if("function"!==typeof wn)throw Error(a(280));var e=n.stateNode;e&&(e=_r(e),wn(n.stateNode,n.type,e))}}function zn(n){Sn?Mn?Mn.push(n):Mn=[n]:Sn=n}function Cn(){if(Sn){var n=Sn,e=Mn;if(Mn=Sn=null,kn(n),e)for(n=0;n<e.length;n++)kn(e[n])}}function Tn(n,e){return n(e)}function Rn(){}var Dn=!1;function Pn(n,e,t){if(Dn)return n(e,t);Dn=!0;try{return Tn(n,e,t)}finally{Dn=!1,(null!==Sn||null!==Mn)&&(Rn(),Cn())}}function Fn(n,e){var t=n.stateNode;if(null===t)return null;var o=_r(t);if(null===o)return null;t=o[e];n:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(o=!o.disabled)||(o=!("button"===(n=n.type)||"input"===n||"select"===n||"textarea"===n)),n=!o;break n;default:n=!1}if(n)return null;if(t&&"function"!==typeof t)throw Error(a(231,e,typeof t));return t}var jn=!1;if(l)try{var In={};Object.defineProperty(In,"passive",{get:function(){jn=!0}}),window.addEventListener("test",In,In),window.removeEventListener("test",In,In)}catch(un){jn=!1}function En(n,e,t,o,r,a,i,v,c){var s=Array.prototype.slice.call(arguments,3);try{e.apply(t,s)}catch(l){this.onError(l)}}var On=!1,An=null,Ln=!1,Gn=null,Nn={onError:function(n){On=!0,An=n}};function Bn(n,e,t,o,r,a,i,v,c){On=!1,An=null,En.apply(Nn,arguments)}function qn(n){var e=n,t=n;if(n.alternate)for(;e.return;)e=e.return;else{n=e;do{0!==(4098&(e=n).flags)&&(t=e.return),n=e.return}while(n)}return 3===e.tag?t:null}function Vn(n){if(13===n.tag){var e=n.memoizedState;if(null===e&&(null!==(n=n.alternate)&&(e=n.memoizedState)),null!==e)return e.dehydrated}return null}function Wn(n){if(qn(n)!==n)throw Error(a(188))}function Hn(n){return null!==(n=function(n){var e=n.alternate;if(!e){if(null===(e=qn(n)))throw Error(a(188));return e!==n?null:n}for(var t=n,o=e;;){var r=t.return;if(null===r)break;var i=r.alternate;if(null===i){if(null!==(o=r.return)){t=o;continue}break}if(r.child===i.child){for(i=r.child;i;){if(i===t)return Wn(r),n;if(i===o)return Wn(r),e;i=i.sibling}throw Error(a(188))}if(t.return!==o.return)t=r,o=i;else{for(var v=!1,c=r.child;c;){if(c===t){v=!0,t=r,o=i;break}if(c===o){v=!0,o=r,t=i;break}c=c.sibling}if(!v){for(c=i.child;c;){if(c===t){v=!0,t=i,o=r;break}if(c===o){v=!0,o=i,t=r;break}c=c.sibling}if(!v)throw Error(a(189))}}if(t.alternate!==o)throw Error(a(190))}if(3!==t.tag)throw Error(a(188));return t.stateNode.current===t?n:e}(n))?Xn(n):null}function Xn(n){if(5===n.tag||6===n.tag)return n;for(n=n.child;null!==n;){var e=Xn(n);if(null!==e)return e;n=n.sibling}return null}var Yn=r.unstable_scheduleCallback,Zn=r.unstable_cancelCallback,Qn=r.unstable_shouldYield,Jn=r.unstable_requestPaint,Kn=r.unstable_now,$n=r.unstable_getCurrentPriorityLevel,ne=r.unstable_ImmediatePriority,ee=r.unstable_UserBlockingPriority,te=r.unstable_NormalPriority,oe=r.unstable_LowPriority,re=r.unstable_IdlePriority,ae=null,ie=null;var ve=Math.clz32?Math.clz32:function(n){return 0===(n>>>=0)?32:31-(ce(n)/se|0)|0},ce=Math.log,se=Math.LN2;var le=64,ue=4194304;function fe(n){switch(n&-n){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&n;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&n;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return n}}function pe(n,e){var t=n.pendingLanes;if(0===t)return 0;var o=0,r=n.suspendedLanes,a=n.pingedLanes,i=268435455&t;if(0!==i){var v=i&~r;0!==v?o=fe(v):0!==(a&=i)&&(o=fe(a))}else 0!==(i=t&~r)?o=fe(i):0!==a&&(o=fe(a));if(0===o)return 0;if(0!==e&&e!==o&&0===(e&r)&&((r=o&-o)>=(a=e&-e)||16===r&&0!==(4194240&a)))return e;if(0!==(4&o)&&(o|=16&t),0!==(e=n.entangledLanes))for(n=n.entanglements,e&=o;0<e;)r=1<<(t=31-ve(e)),o|=n[t],e&=~r;return o}function me(n,e){switch(n){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;default:return-1}}function de(n){return 0!==(n=-1073741825&n.pendingLanes)?n:1073741824&n?1073741824:0}function he(){var n=le;return 0===(4194240&(le<<=1))&&(le=64),n}function xe(n){for(var e=[],t=0;31>t;t++)e.push(n);return e}function ge(n,e,t){n.pendingLanes|=e,536870912!==e&&(n.suspendedLanes=0,n.pingedLanes=0),(n=n.eventTimes)[e=31-ve(e)]=t}function ye(n,e){var t=n.entangledLanes|=e;for(n=n.entanglements;t;){var o=31-ve(t),r=1<<o;r&e|n[o]&e&&(n[o]|=e),t&=~r}}var be=0;function Ue(n){return 1<(n&=-n)?4<n?0!==(268435455&n)?16:536870912:4:1}var _e,we,Se,Me,ke,ze=!1,Ce=[],Te=null,Re=null,De=null,Pe=new Map,Fe=new Map,je=[],Ie="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Ee(n,e){switch(n){case"focusin":case"focusout":Te=null;break;case"dragenter":case"dragleave":Re=null;break;case"mouseover":case"mouseout":De=null;break;case"pointerover":case"pointerout":Pe.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":Fe.delete(e.pointerId)}}function Oe(n,e,t,o,r,a){return null===n||n.nativeEvent!==a?(n={blockedOn:e,domEventName:t,eventSystemFlags:o,nativeEvent:a,targetContainers:[r]},null!==e&&(null!==(e=br(e))&&we(e)),n):(n.eventSystemFlags|=o,e=n.targetContainers,null!==r&&-1===e.indexOf(r)&&e.push(r),n)}function Ae(n){var e=yr(n.target);if(null!==e){var t=qn(e);if(null!==t)if(13===(e=t.tag)){if(null!==(e=Vn(t)))return n.blockedOn=e,void ke(n.priority,(function(){Se(t)}))}else if(3===e&&t.stateNode.current.memoizedState.isDehydrated)return void(n.blockedOn=3===t.tag?t.stateNode.containerInfo:null)}n.blockedOn=null}function Le(n){if(null!==n.blockedOn)return!1;for(var e=n.targetContainers;0<e.length;){var t=Qe(n.domEventName,n.eventSystemFlags,e[0],n.nativeEvent);if(null!==t)return null!==(e=br(t))&&we(e),n.blockedOn=t,!1;var o=new(t=n.nativeEvent).constructor(t.type,t);Un=o,t.target.dispatchEvent(o),Un=null,e.shift()}return!0}function Ge(n,e,t){Le(n)&&t.delete(e)}function Ne(){ze=!1,null!==Te&&Le(Te)&&(Te=null),null!==Re&&Le(Re)&&(Re=null),null!==De&&Le(De)&&(De=null),Pe.forEach(Ge),Fe.forEach(Ge)}function Be(n,e){n.blockedOn===e&&(n.blockedOn=null,ze||(ze=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Ne)))}function qe(n){function e(e){return Be(e,n)}if(0<Ce.length){Be(Ce[0],n);for(var t=1;t<Ce.length;t++){var o=Ce[t];o.blockedOn===n&&(o.blockedOn=null)}}for(null!==Te&&Be(Te,n),null!==Re&&Be(Re,n),null!==De&&Be(De,n),Pe.forEach(e),Fe.forEach(e),t=0;t<je.length;t++)(o=je[t]).blockedOn===n&&(o.blockedOn=null);for(;0<je.length&&null===(t=je[0]).blockedOn;)Ae(t),null===t.blockedOn&&je.shift()}var Ve=b.ReactCurrentBatchConfig,We=!0;function He(n,e,t,o){var r=be,a=Ve.transition;Ve.transition=null;try{be=1,Ye(n,e,t,o)}finally{be=r,Ve.transition=a}}function Xe(n,e,t,o){var r=be,a=Ve.transition;Ve.transition=null;try{be=4,Ye(n,e,t,o)}finally{be=r,Ve.transition=a}}function Ye(n,e,t,o){if(We){var r=Qe(n,e,t,o);if(null===r)Wo(n,e,o,Ze,t),Ee(n,o);else if(function(n,e,t,o,r){switch(e){case"focusin":return Te=Oe(Te,n,e,t,o,r),!0;case"dragenter":return Re=Oe(Re,n,e,t,o,r),!0;case"mouseover":return De=Oe(De,n,e,t,o,r),!0;case"pointerover":var a=r.pointerId;return Pe.set(a,Oe(Pe.get(a)||null,n,e,t,o,r)),!0;case"gotpointercapture":return a=r.pointerId,Fe.set(a,Oe(Fe.get(a)||null,n,e,t,o,r)),!0}return!1}(r,n,e,t,o))o.stopPropagation();else if(Ee(n,o),4&e&&-1<Ie.indexOf(n)){for(;null!==r;){var a=br(r);if(null!==a&&_e(a),null===(a=Qe(n,e,t,o))&&Wo(n,e,o,Ze,t),a===r)break;r=a}null!==r&&o.stopPropagation()}else Wo(n,e,o,null,t)}}var Ze=null;function Qe(n,e,t,o){if(Ze=null,null!==(n=yr(n=_n(o))))if(null===(e=qn(n)))n=null;else if(13===(t=e.tag)){if(null!==(n=Vn(e)))return n;n=null}else if(3===t){if(e.stateNode.current.memoizedState.isDehydrated)return 3===e.tag?e.stateNode.containerInfo:null;n=null}else e!==n&&(n=null);return Ze=n,null}function Je(n){switch(n){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch($n()){case ne:return 1;case ee:return 4;case te:case oe:return 16;case re:return 536870912;default:return 16}default:return 16}}var Ke=null,$e=null,nt=null;function et(){if(nt)return nt;var n,e,t=$e,o=t.length,r="value"in Ke?Ke.value:Ke.textContent,a=r.length;for(n=0;n<o&&t[n]===r[n];n++);var i=o-n;for(e=1;e<=i&&t[o-e]===r[a-e];e++);return nt=r.slice(n,1<e?1-e:void 0)}function tt(n){var e=n.keyCode;return"charCode"in n?0===(n=n.charCode)&&13===e&&(n=13):n=e,10===n&&(n=13),32<=n||13===n?n:0}function ot(){return!0}function rt(){return!1}function at(n){function e(e,t,o,r,a){for(var i in this._reactName=e,this._targetInst=o,this.type=t,this.nativeEvent=r,this.target=a,this.currentTarget=null,n)n.hasOwnProperty(i)&&(e=n[i],this[i]=e?e(r):r[i]);return this.isDefaultPrevented=(null!=r.defaultPrevented?r.defaultPrevented:!1===r.returnValue)?ot:rt,this.isPropagationStopped=rt,this}return O(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():"unknown"!==typeof n.returnValue&&(n.returnValue=!1),this.isDefaultPrevented=ot)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():"unknown"!==typeof n.cancelBubble&&(n.cancelBubble=!0),this.isPropagationStopped=ot)},persist:function(){},isPersistent:ot}),e}var it,vt,ct,st={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(n){return n.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},lt=at(st),ut=O({},st,{view:0,detail:0}),ft=at(ut),pt=O({},ut,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Mt,button:0,buttons:0,relatedTarget:function(n){return void 0===n.relatedTarget?n.fromElement===n.srcElement?n.toElement:n.fromElement:n.relatedTarget},movementX:function(n){return"movementX"in n?n.movementX:(n!==ct&&(ct&&"mousemove"===n.type?(it=n.screenX-ct.screenX,vt=n.screenY-ct.screenY):vt=it=0,ct=n),it)},movementY:function(n){return"movementY"in n?n.movementY:vt}}),mt=at(pt),dt=at(O({},pt,{dataTransfer:0})),ht=at(O({},ut,{relatedTarget:0})),xt=at(O({},st,{animationName:0,elapsedTime:0,pseudoElement:0})),gt=O({},st,{clipboardData:function(n){return"clipboardData"in n?n.clipboardData:window.clipboardData}}),yt=at(gt),bt=at(O({},st,{data:0})),Ut={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},_t={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},wt={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function St(n){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(n):!!(n=wt[n])&&!!e[n]}function Mt(){return St}var kt=O({},ut,{key:function(n){if(n.key){var e=Ut[n.key]||n.key;if("Unidentified"!==e)return e}return"keypress"===n.type?13===(n=tt(n))?"Enter":String.fromCharCode(n):"keydown"===n.type||"keyup"===n.type?_t[n.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Mt,charCode:function(n){return"keypress"===n.type?tt(n):0},keyCode:function(n){return"keydown"===n.type||"keyup"===n.type?n.keyCode:0},which:function(n){return"keypress"===n.type?tt(n):"keydown"===n.type||"keyup"===n.type?n.keyCode:0}}),zt=at(kt),Ct=at(O({},pt,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Tt=at(O({},ut,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Mt})),Rt=at(O({},st,{propertyName:0,elapsedTime:0,pseudoElement:0})),Dt=O({},pt,{deltaX:function(n){return"deltaX"in n?n.deltaX:"wheelDeltaX"in n?-n.wheelDeltaX:0},deltaY:function(n){return"deltaY"in n?n.deltaY:"wheelDeltaY"in n?-n.wheelDeltaY:"wheelDelta"in n?-n.wheelDelta:0},deltaZ:0,deltaMode:0}),Pt=at(Dt),Ft=[9,13,27,32],jt=l&&"CompositionEvent"in window,It=null;l&&"documentMode"in document&&(It=document.documentMode);var Et=l&&"TextEvent"in window&&!It,Ot=l&&(!jt||It&&8<It&&11>=It),At=String.fromCharCode(32),Lt=!1;function Gt(n,e){switch(n){case"keyup":return-1!==Ft.indexOf(e.keyCode);case"keydown":return 229!==e.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Nt(n){return"object"===typeof(n=n.detail)&&"data"in n?n.data:null}var Bt=!1;var qt={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Vt(n){var e=n&&n.nodeName&&n.nodeName.toLowerCase();return"input"===e?!!qt[n.type]:"textarea"===e}function Wt(n,e,t,o){zn(o),0<(e=Xo(e,"onChange")).length&&(t=new lt("onChange","change",null,t,o),n.push({event:t,listeners:e}))}var Ht=null,Xt=null;function Yt(n){Lo(n,0)}function Zt(n){if(X(Ur(n)))return n}function Qt(n,e){if("change"===n)return e}var Jt=!1;if(l){var Kt;if(l){var $t="oninput"in document;if(!$t){var no=document.createElement("div");no.setAttribute("oninput","return;"),$t="function"===typeof no.oninput}Kt=$t}else Kt=!1;Jt=Kt&&(!document.documentMode||9<document.documentMode)}function eo(){Ht&&(Ht.detachEvent("onpropertychange",to),Xt=Ht=null)}function to(n){if("value"===n.propertyName&&Zt(Xt)){var e=[];Wt(e,Xt,n,_n(n)),Pn(Yt,e)}}function oo(n,e,t){"focusin"===n?(eo(),Xt=t,(Ht=e).attachEvent("onpropertychange",to)):"focusout"===n&&eo()}function ro(n){if("selectionchange"===n||"keyup"===n||"keydown"===n)return Zt(Xt)}function ao(n,e){if("click"===n)return Zt(e)}function io(n,e){if("input"===n||"change"===n)return Zt(e)}var vo="function"===typeof Object.is?Object.is:function(n,e){return n===e&&(0!==n||1/n===1/e)||n!==n&&e!==e};function co(n,e){if(vo(n,e))return!0;if("object"!==typeof n||null===n||"object"!==typeof e||null===e)return!1;var t=Object.keys(n),o=Object.keys(e);if(t.length!==o.length)return!1;for(o=0;o<t.length;o++){var r=t[o];if(!u.call(e,r)||!vo(n[r],e[r]))return!1}return!0}function so(n){for(;n&&n.firstChild;)n=n.firstChild;return n}function lo(n,e){var t,o=so(n);for(n=0;o;){if(3===o.nodeType){if(t=n+o.textContent.length,n<=e&&t>=e)return{node:o,offset:e-n};n=t}n:{for(;o;){if(o.nextSibling){o=o.nextSibling;break n}o=o.parentNode}o=void 0}o=so(o)}}function uo(n,e){return!(!n||!e)&&(n===e||(!n||3!==n.nodeType)&&(e&&3===e.nodeType?uo(n,e.parentNode):"contains"in n?n.contains(e):!!n.compareDocumentPosition&&!!(16&n.compareDocumentPosition(e))))}function fo(){for(var n=window,e=Y();e instanceof n.HTMLIFrameElement;){try{var t="string"===typeof e.contentWindow.location.href}catch(o){t=!1}if(!t)break;e=Y((n=e.contentWindow).document)}return e}function po(n){var e=n&&n.nodeName&&n.nodeName.toLowerCase();return e&&("input"===e&&("text"===n.type||"search"===n.type||"tel"===n.type||"url"===n.type||"password"===n.type)||"textarea"===e||"true"===n.contentEditable)}function mo(n){var e=fo(),t=n.focusedElem,o=n.selectionRange;if(e!==t&&t&&t.ownerDocument&&uo(t.ownerDocument.documentElement,t)){if(null!==o&&po(t))if(e=o.start,void 0===(n=o.end)&&(n=e),"selectionStart"in t)t.selectionStart=e,t.selectionEnd=Math.min(n,t.value.length);else if((n=(e=t.ownerDocument||document)&&e.defaultView||window).getSelection){n=n.getSelection();var r=t.textContent.length,a=Math.min(o.start,r);o=void 0===o.end?a:Math.min(o.end,r),!n.extend&&a>o&&(r=o,o=a,a=r),r=lo(t,a);var i=lo(t,o);r&&i&&(1!==n.rangeCount||n.anchorNode!==r.node||n.anchorOffset!==r.offset||n.focusNode!==i.node||n.focusOffset!==i.offset)&&((e=e.createRange()).setStart(r.node,r.offset),n.removeAllRanges(),a>o?(n.addRange(e),n.extend(i.node,i.offset)):(e.setEnd(i.node,i.offset),n.addRange(e)))}for(e=[],n=t;n=n.parentNode;)1===n.nodeType&&e.push({element:n,left:n.scrollLeft,top:n.scrollTop});for("function"===typeof t.focus&&t.focus(),t=0;t<e.length;t++)(n=e[t]).element.scrollLeft=n.left,n.element.scrollTop=n.top}}var ho=l&&"documentMode"in document&&11>=document.documentMode,xo=null,go=null,yo=null,bo=!1;function Uo(n,e,t){var o=t.window===t?t.document:9===t.nodeType?t:t.ownerDocument;bo||null==xo||xo!==Y(o)||("selectionStart"in(o=xo)&&po(o)?o={start:o.selectionStart,end:o.selectionEnd}:o={anchorNode:(o=(o.ownerDocument&&o.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:o.anchorOffset,focusNode:o.focusNode,focusOffset:o.focusOffset},yo&&co(yo,o)||(yo=o,0<(o=Xo(go,"onSelect")).length&&(e=new lt("onSelect","select",null,e,t),n.push({event:e,listeners:o}),e.target=xo)))}function _o(n,e){var t={};return t[n.toLowerCase()]=e.toLowerCase(),t["Webkit"+n]="webkit"+e,t["Moz"+n]="moz"+e,t}var wo={animationend:_o("Animation","AnimationEnd"),animationiteration:_o("Animation","AnimationIteration"),animationstart:_o("Animation","AnimationStart"),transitionend:_o("Transition","TransitionEnd")},So={},Mo={};function ko(n){if(So[n])return So[n];if(!wo[n])return n;var e,t=wo[n];for(e in t)if(t.hasOwnProperty(e)&&e in Mo)return So[n]=t[e];return n}l&&(Mo=document.createElement("div").style,"AnimationEvent"in window||(delete wo.animationend.animation,delete wo.animationiteration.animation,delete wo.animationstart.animation),"TransitionEvent"in window||delete wo.transitionend.transition);var zo=ko("animationend"),Co=ko("animationiteration"),To=ko("animationstart"),Ro=ko("transitionend"),Do=new Map,Po="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Fo(n,e){Do.set(n,e),c(e,[n])}for(var jo=0;jo<Po.length;jo++){var Io=Po[jo];Fo(Io.toLowerCase(),"on"+(Io[0].toUpperCase()+Io.slice(1)))}Fo(zo,"onAnimationEnd"),Fo(Co,"onAnimationIteration"),Fo(To,"onAnimationStart"),Fo("dblclick","onDoubleClick"),Fo("focusin","onFocus"),Fo("focusout","onBlur"),Fo(Ro,"onTransitionEnd"),s("onMouseEnter",["mouseout","mouseover"]),s("onMouseLeave",["mouseout","mouseover"]),s("onPointerEnter",["pointerout","pointerover"]),s("onPointerLeave",["pointerout","pointerover"]),c("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),c("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),c("onBeforeInput",["compositionend","keypress","textInput","paste"]),c("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Eo="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Oo=new Set("cancel close invalid load scroll toggle".split(" ").concat(Eo));function Ao(n,e,t){var o=n.type||"unknown-event";n.currentTarget=t,function(n,e,t,o,r,i,v,c,s){if(Bn.apply(this,arguments),On){if(!On)throw Error(a(198));var l=An;On=!1,An=null,Ln||(Ln=!0,Gn=l)}}(o,e,void 0,n),n.currentTarget=null}function Lo(n,e){e=0!==(4&e);for(var t=0;t<n.length;t++){var o=n[t],r=o.event;o=o.listeners;n:{var a=void 0;if(e)for(var i=o.length-1;0<=i;i--){var v=o[i],c=v.instance,s=v.currentTarget;if(v=v.listener,c!==a&&r.isPropagationStopped())break n;Ao(r,v,s),a=c}else for(i=0;i<o.length;i++){if(c=(v=o[i]).instance,s=v.currentTarget,v=v.listener,c!==a&&r.isPropagationStopped())break n;Ao(r,v,s),a=c}}}if(Ln)throw n=Gn,Ln=!1,Gn=null,n}function Go(n,e){var t=e[hr];void 0===t&&(t=e[hr]=new Set);var o=n+"__bubble";t.has(o)||(Vo(e,n,2,!1),t.add(o))}function No(n,e,t){var o=0;e&&(o|=4),Vo(t,n,o,e)}var Bo="_reactListening"+Math.random().toString(36).slice(2);function qo(n){if(!n[Bo]){n[Bo]=!0,i.forEach((function(e){"selectionchange"!==e&&(Oo.has(e)||No(e,!1,n),No(e,!0,n))}));var e=9===n.nodeType?n:n.ownerDocument;null===e||e[Bo]||(e[Bo]=!0,No("selectionchange",!1,e))}}function Vo(n,e,t,o){switch(Je(e)){case 1:var r=He;break;case 4:r=Xe;break;default:r=Ye}t=r.bind(null,e,t,n),r=void 0,!jn||"touchstart"!==e&&"touchmove"!==e&&"wheel"!==e||(r=!0),o?void 0!==r?n.addEventListener(e,t,{capture:!0,passive:r}):n.addEventListener(e,t,!0):void 0!==r?n.addEventListener(e,t,{passive:r}):n.addEventListener(e,t,!1)}function Wo(n,e,t,o,r){var a=o;if(0===(1&e)&&0===(2&e)&&null!==o)n:for(;;){if(null===o)return;var i=o.tag;if(3===i||4===i){var v=o.stateNode.containerInfo;if(v===r||8===v.nodeType&&v.parentNode===r)break;if(4===i)for(i=o.return;null!==i;){var c=i.tag;if((3===c||4===c)&&((c=i.stateNode.containerInfo)===r||8===c.nodeType&&c.parentNode===r))return;i=i.return}for(;null!==v;){if(null===(i=yr(v)))return;if(5===(c=i.tag)||6===c){o=a=i;continue n}v=v.parentNode}}o=o.return}Pn((function(){var o=a,r=_n(t),i=[];n:{var v=Do.get(n);if(void 0!==v){var c=lt,s=n;switch(n){case"keypress":if(0===tt(t))break n;case"keydown":case"keyup":c=zt;break;case"focusin":s="focus",c=ht;break;case"focusout":s="blur",c=ht;break;case"beforeblur":case"afterblur":c=ht;break;case"click":if(2===t.button)break n;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":c=mt;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":c=dt;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":c=Tt;break;case zo:case Co:case To:c=xt;break;case Ro:c=Rt;break;case"scroll":c=ft;break;case"wheel":c=Pt;break;case"copy":case"cut":case"paste":c=yt;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":c=Ct}var l=0!==(4&e),u=!l&&"scroll"===n,f=l?null!==v?v+"Capture":null:v;l=[];for(var p,m=o;null!==m;){var d=(p=m).stateNode;if(5===p.tag&&null!==d&&(p=d,null!==f&&(null!=(d=Fn(m,f))&&l.push(Ho(m,d,p)))),u)break;m=m.return}0<l.length&&(v=new c(v,s,null,t,r),i.push({event:v,listeners:l}))}}if(0===(7&e)){if(c="mouseout"===n||"pointerout"===n,(!(v="mouseover"===n||"pointerover"===n)||t===Un||!(s=t.relatedTarget||t.fromElement)||!yr(s)&&!s[dr])&&(c||v)&&(v=r.window===r?r:(v=r.ownerDocument)?v.defaultView||v.parentWindow:window,c?(c=o,null!==(s=(s=t.relatedTarget||t.toElement)?yr(s):null)&&(s!==(u=qn(s))||5!==s.tag&&6!==s.tag)&&(s=null)):(c=null,s=o),c!==s)){if(l=mt,d="onMouseLeave",f="onMouseEnter",m="mouse","pointerout"!==n&&"pointerover"!==n||(l=Ct,d="onPointerLeave",f="onPointerEnter",m="pointer"),u=null==c?v:Ur(c),p=null==s?v:Ur(s),(v=new l(d,m+"leave",c,t,r)).target=u,v.relatedTarget=p,d=null,yr(r)===o&&((l=new l(f,m+"enter",s,t,r)).target=p,l.relatedTarget=u,d=l),u=d,c&&s)n:{for(f=s,m=0,p=l=c;p;p=Yo(p))m++;for(p=0,d=f;d;d=Yo(d))p++;for(;0<m-p;)l=Yo(l),m--;for(;0<p-m;)f=Yo(f),p--;for(;m--;){if(l===f||null!==f&&l===f.alternate)break n;l=Yo(l),f=Yo(f)}l=null}else l=null;null!==c&&Zo(i,v,c,l,!1),null!==s&&null!==u&&Zo(i,u,s,l,!0)}if("select"===(c=(v=o?Ur(o):window).nodeName&&v.nodeName.toLowerCase())||"input"===c&&"file"===v.type)var h=Qt;else if(Vt(v))if(Jt)h=io;else{h=ro;var x=oo}else(c=v.nodeName)&&"input"===c.toLowerCase()&&("checkbox"===v.type||"radio"===v.type)&&(h=ao);switch(h&&(h=h(n,o))?Wt(i,h,t,r):(x&&x(n,v,o),"focusout"===n&&(x=v._wrapperState)&&x.controlled&&"number"===v.type&&nn(v,"number",v.value)),x=o?Ur(o):window,n){case"focusin":(Vt(x)||"true"===x.contentEditable)&&(xo=x,go=o,yo=null);break;case"focusout":yo=go=xo=null;break;case"mousedown":bo=!0;break;case"contextmenu":case"mouseup":case"dragend":bo=!1,Uo(i,t,r);break;case"selectionchange":if(ho)break;case"keydown":case"keyup":Uo(i,t,r)}var g;if(jt)n:{switch(n){case"compositionstart":var y="onCompositionStart";break n;case"compositionend":y="onCompositionEnd";break n;case"compositionupdate":y="onCompositionUpdate";break n}y=void 0}else Bt?Gt(n,t)&&(y="onCompositionEnd"):"keydown"===n&&229===t.keyCode&&(y="onCompositionStart");y&&(Ot&&"ko"!==t.locale&&(Bt||"onCompositionStart"!==y?"onCompositionEnd"===y&&Bt&&(g=et()):($e="value"in(Ke=r)?Ke.value:Ke.textContent,Bt=!0)),0<(x=Xo(o,y)).length&&(y=new bt(y,n,null,t,r),i.push({event:y,listeners:x}),g?y.data=g:null!==(g=Nt(t))&&(y.data=g))),(g=Et?function(n,e){switch(n){case"compositionend":return Nt(e);case"keypress":return 32!==e.which?null:(Lt=!0,At);case"textInput":return(n=e.data)===At&&Lt?null:n;default:return null}}(n,t):function(n,e){if(Bt)return"compositionend"===n||!jt&&Gt(n,e)?(n=et(),nt=$e=Ke=null,Bt=!1,n):null;switch(n){case"paste":default:return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return Ot&&"ko"!==e.locale?null:e.data}}(n,t))&&(0<(o=Xo(o,"onBeforeInput")).length&&(r=new bt("onBeforeInput","beforeinput",null,t,r),i.push({event:r,listeners:o}),r.data=g))}Lo(i,e)}))}function Ho(n,e,t){return{instance:n,listener:e,currentTarget:t}}function Xo(n,e){for(var t=e+"Capture",o=[];null!==n;){var r=n,a=r.stateNode;5===r.tag&&null!==a&&(r=a,null!=(a=Fn(n,t))&&o.unshift(Ho(n,a,r)),null!=(a=Fn(n,e))&&o.push(Ho(n,a,r))),n=n.return}return o}function Yo(n){if(null===n)return null;do{n=n.return}while(n&&5!==n.tag);return n||null}function Zo(n,e,t,o,r){for(var a=e._reactName,i=[];null!==t&&t!==o;){var v=t,c=v.alternate,s=v.stateNode;if(null!==c&&c===o)break;5===v.tag&&null!==s&&(v=s,r?null!=(c=Fn(t,a))&&i.unshift(Ho(t,c,v)):r||null!=(c=Fn(t,a))&&i.push(Ho(t,c,v))),t=t.return}0!==i.length&&n.push({event:e,listeners:i})}var Qo=/\r\n?/g,Jo=/\u0000|\uFFFD/g;function Ko(n){return("string"===typeof n?n:""+n).replace(Qo,"\n").replace(Jo,"")}function $o(n,e,t){if(e=Ko(e),Ko(n)!==e&&t)throw Error(a(425))}function nr(){}var er=null,tr=null;function or(n,e){return"textarea"===n||"noscript"===n||"string"===typeof e.children||"number"===typeof e.children||"object"===typeof e.dangerouslySetInnerHTML&&null!==e.dangerouslySetInnerHTML&&null!=e.dangerouslySetInnerHTML.__html}var rr="function"===typeof setTimeout?setTimeout:void 0,ar="function"===typeof clearTimeout?clearTimeout:void 0,ir="function"===typeof Promise?Promise:void 0,vr="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof ir?function(n){return ir.resolve(null).then(n).catch(cr)}:rr;function cr(n){setTimeout((function(){throw n}))}function sr(n,e){var t=e,o=0;do{var r=t.nextSibling;if(n.removeChild(t),r&&8===r.nodeType)if("/$"===(t=r.data)){if(0===o)return n.removeChild(r),void qe(e);o--}else"$"!==t&&"$?"!==t&&"$!"!==t||o++;t=r}while(t);qe(e)}function lr(n){for(;null!=n;n=n.nextSibling){var e=n.nodeType;if(1===e||3===e)break;if(8===e){if("$"===(e=n.data)||"$!"===e||"$?"===e)break;if("/$"===e)return null}}return n}function ur(n){n=n.previousSibling;for(var e=0;n;){if(8===n.nodeType){var t=n.data;if("$"===t||"$!"===t||"$?"===t){if(0===e)return n;e--}else"/$"===t&&e++}n=n.previousSibling}return null}var fr=Math.random().toString(36).slice(2),pr="__reactFiber$"+fr,mr="__reactProps$"+fr,dr="__reactContainer$"+fr,hr="__reactEvents$"+fr,xr="__reactListeners$"+fr,gr="__reactHandles$"+fr;function yr(n){var e=n[pr];if(e)return e;for(var t=n.parentNode;t;){if(e=t[dr]||t[pr]){if(t=e.alternate,null!==e.child||null!==t&&null!==t.child)for(n=ur(n);null!==n;){if(t=n[pr])return t;n=ur(n)}return e}t=(n=t).parentNode}return null}function br(n){return!(n=n[pr]||n[dr])||5!==n.tag&&6!==n.tag&&13!==n.tag&&3!==n.tag?null:n}function Ur(n){if(5===n.tag||6===n.tag)return n.stateNode;throw Error(a(33))}function _r(n){return n[mr]||null}var wr=[],Sr=-1;function Mr(n){return{current:n}}function kr(n){0>Sr||(n.current=wr[Sr],wr[Sr]=null,Sr--)}function zr(n,e){Sr++,wr[Sr]=n.current,n.current=e}var Cr={},Tr=Mr(Cr),Rr=Mr(!1),Dr=Cr;function Pr(n,e){var t=n.type.contextTypes;if(!t)return Cr;var o=n.stateNode;if(o&&o.__reactInternalMemoizedUnmaskedChildContext===e)return o.__reactInternalMemoizedMaskedChildContext;var r,a={};for(r in t)a[r]=e[r];return o&&((n=n.stateNode).__reactInternalMemoizedUnmaskedChildContext=e,n.__reactInternalMemoizedMaskedChildContext=a),a}function Fr(n){return null!==(n=n.childContextTypes)&&void 0!==n}function jr(){kr(Rr),kr(Tr)}function Ir(n,e,t){if(Tr.current!==Cr)throw Error(a(168));zr(Tr,e),zr(Rr,t)}function Er(n,e,t){var o=n.stateNode;if(e=e.childContextTypes,"function"!==typeof o.getChildContext)return t;for(var r in o=o.getChildContext())if(!(r in e))throw Error(a(108,q(n)||"Unknown",r));return O({},t,o)}function Or(n){return n=(n=n.stateNode)&&n.__reactInternalMemoizedMergedChildContext||Cr,Dr=Tr.current,zr(Tr,n),zr(Rr,Rr.current),!0}function Ar(n,e,t){var o=n.stateNode;if(!o)throw Error(a(169));t?(n=Er(n,e,Dr),o.__reactInternalMemoizedMergedChildContext=n,kr(Rr),kr(Tr),zr(Tr,n)):kr(Rr),zr(Rr,t)}var Lr=null,Gr=!1,Nr=!1;function Br(n){null===Lr?Lr=[n]:Lr.push(n)}function qr(){if(!Nr&&null!==Lr){Nr=!0;var n=0,e=be;try{var t=Lr;for(be=1;n<t.length;n++){var o=t[n];do{o=o(!0)}while(null!==o)}Lr=null,Gr=!1}catch(r){throw null!==Lr&&(Lr=Lr.slice(n+1)),Yn(ne,qr),r}finally{be=e,Nr=!1}}return null}var Vr=[],Wr=0,Hr=null,Xr=0,Yr=[],Zr=0,Qr=null,Jr=1,Kr="";function $r(n,e){Vr[Wr++]=Xr,Vr[Wr++]=Hr,Hr=n,Xr=e}function na(n,e,t){Yr[Zr++]=Jr,Yr[Zr++]=Kr,Yr[Zr++]=Qr,Qr=n;var o=Jr;n=Kr;var r=32-ve(o)-1;o&=~(1<<r),t+=1;var a=32-ve(e)+r;if(30<a){var i=r-r%5;a=(o&(1<<i)-1).toString(32),o>>=i,r-=i,Jr=1<<32-ve(e)+r|t<<r|o,Kr=a+n}else Jr=1<<a|t<<r|o,Kr=n}function ea(n){null!==n.return&&($r(n,1),na(n,1,0))}function ta(n){for(;n===Hr;)Hr=Vr[--Wr],Vr[Wr]=null,Xr=Vr[--Wr],Vr[Wr]=null;for(;n===Qr;)Qr=Yr[--Zr],Yr[Zr]=null,Kr=Yr[--Zr],Yr[Zr]=null,Jr=Yr[--Zr],Yr[Zr]=null}var oa=null,ra=null,aa=!1,ia=null;function va(n,e){var t=Ds(5,null,null,0);t.elementType="DELETED",t.stateNode=e,t.return=n,null===(e=n.deletions)?(n.deletions=[t],n.flags|=16):e.push(t)}function ca(n,e){switch(n.tag){case 5:var t=n.type;return null!==(e=1!==e.nodeType||t.toLowerCase()!==e.nodeName.toLowerCase()?null:e)&&(n.stateNode=e,oa=n,ra=lr(e.firstChild),!0);case 6:return null!==(e=""===n.pendingProps||3!==e.nodeType?null:e)&&(n.stateNode=e,oa=n,ra=null,!0);case 13:return null!==(e=8!==e.nodeType?null:e)&&(t=null!==Qr?{id:Jr,overflow:Kr}:null,n.memoizedState={dehydrated:e,treeContext:t,retryLane:1073741824},(t=Ds(18,null,null,0)).stateNode=e,t.return=n,n.child=t,oa=n,ra=null,!0);default:return!1}}function sa(n){return 0!==(1&n.mode)&&0===(128&n.flags)}function la(n){if(aa){var e=ra;if(e){var t=e;if(!ca(n,e)){if(sa(n))throw Error(a(418));e=lr(t.nextSibling);var o=oa;e&&ca(n,e)?va(o,t):(n.flags=-4097&n.flags|2,aa=!1,oa=n)}}else{if(sa(n))throw Error(a(418));n.flags=-4097&n.flags|2,aa=!1,oa=n}}}function ua(n){for(n=n.return;null!==n&&5!==n.tag&&3!==n.tag&&13!==n.tag;)n=n.return;oa=n}function fa(n){if(n!==oa)return!1;if(!aa)return ua(n),aa=!0,!1;var e;if((e=3!==n.tag)&&!(e=5!==n.tag)&&(e="head"!==(e=n.type)&&"body"!==e&&!or(n.type,n.memoizedProps)),e&&(e=ra)){if(sa(n))throw pa(),Error(a(418));for(;e;)va(n,e),e=lr(e.nextSibling)}if(ua(n),13===n.tag){if(!(n=null!==(n=n.memoizedState)?n.dehydrated:null))throw Error(a(317));n:{for(n=n.nextSibling,e=0;n;){if(8===n.nodeType){var t=n.data;if("/$"===t){if(0===e){ra=lr(n.nextSibling);break n}e--}else"$"!==t&&"$!"!==t&&"$?"!==t||e++}n=n.nextSibling}ra=null}}else ra=oa?lr(n.stateNode.nextSibling):null;return!0}function pa(){for(var n=ra;n;)n=lr(n.nextSibling)}function ma(){ra=oa=null,aa=!1}function da(n){null===ia?ia=[n]:ia.push(n)}var ha=b.ReactCurrentBatchConfig;function xa(n,e){if(n&&n.defaultProps){for(var t in e=O({},e),n=n.defaultProps)void 0===e[t]&&(e[t]=n[t]);return e}return e}var ga=Mr(null),ya=null,ba=null,Ua=null;function _a(){Ua=ba=ya=null}function wa(n){var e=ga.current;kr(ga),n._currentValue=e}function Sa(n,e,t){for(;null!==n;){var o=n.alternate;if((n.childLanes&e)!==e?(n.childLanes|=e,null!==o&&(o.childLanes|=e)):null!==o&&(o.childLanes&e)!==e&&(o.childLanes|=e),n===t)break;n=n.return}}function Ma(n,e){ya=n,Ua=ba=null,null!==(n=n.dependencies)&&null!==n.firstContext&&(0!==(n.lanes&e)&&(bv=!0),n.firstContext=null)}function ka(n){var e=n._currentValue;if(Ua!==n)if(n={context:n,memoizedValue:e,next:null},null===ba){if(null===ya)throw Error(a(308));ba=n,ya.dependencies={lanes:0,firstContext:n}}else ba=ba.next=n;return e}var za=null;function Ca(n){null===za?za=[n]:za.push(n)}function Ta(n,e,t,o){var r=e.interleaved;return null===r?(t.next=t,Ca(e)):(t.next=r.next,r.next=t),e.interleaved=t,Ra(n,o)}function Ra(n,e){n.lanes|=e;var t=n.alternate;for(null!==t&&(t.lanes|=e),t=n,n=n.return;null!==n;)n.childLanes|=e,null!==(t=n.alternate)&&(t.childLanes|=e),t=n,n=n.return;return 3===t.tag?t.stateNode:null}var Da=!1;function Pa(n){n.updateQueue={baseState:n.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Fa(n,e){n=n.updateQueue,e.updateQueue===n&&(e.updateQueue={baseState:n.baseState,firstBaseUpdate:n.firstBaseUpdate,lastBaseUpdate:n.lastBaseUpdate,shared:n.shared,effects:n.effects})}function ja(n,e){return{eventTime:n,lane:e,tag:0,payload:null,callback:null,next:null}}function Ia(n,e,t){var o=n.updateQueue;if(null===o)return null;if(o=o.shared,0!==(2&Cc)){var r=o.pending;return null===r?e.next=e:(e.next=r.next,r.next=e),o.pending=e,Ra(n,t)}return null===(r=o.interleaved)?(e.next=e,Ca(o)):(e.next=r.next,r.next=e),o.interleaved=e,Ra(n,t)}function Ea(n,e,t){if(null!==(e=e.updateQueue)&&(e=e.shared,0!==(4194240&t))){var o=e.lanes;t|=o&=n.pendingLanes,e.lanes=t,ye(n,t)}}function Oa(n,e){var t=n.updateQueue,o=n.alternate;if(null!==o&&t===(o=o.updateQueue)){var r=null,a=null;if(null!==(t=t.firstBaseUpdate)){do{var i={eventTime:t.eventTime,lane:t.lane,tag:t.tag,payload:t.payload,callback:t.callback,next:null};null===a?r=a=i:a=a.next=i,t=t.next}while(null!==t);null===a?r=a=e:a=a.next=e}else r=a=e;return t={baseState:o.baseState,firstBaseUpdate:r,lastBaseUpdate:a,shared:o.shared,effects:o.effects},void(n.updateQueue=t)}null===(n=t.lastBaseUpdate)?t.firstBaseUpdate=e:n.next=e,t.lastBaseUpdate=e}function Aa(n,e,t,o){var r=n.updateQueue;Da=!1;var a=r.firstBaseUpdate,i=r.lastBaseUpdate,v=r.shared.pending;if(null!==v){r.shared.pending=null;var c=v,s=c.next;c.next=null,null===i?a=s:i.next=s,i=c;var l=n.alternate;null!==l&&((v=(l=l.updateQueue).lastBaseUpdate)!==i&&(null===v?l.firstBaseUpdate=s:v.next=s,l.lastBaseUpdate=c))}if(null!==a){var u=r.baseState;for(i=0,l=s=c=null,v=a;;){var f=v.lane,p=v.eventTime;if((o&f)===f){null!==l&&(l=l.next={eventTime:p,lane:0,tag:v.tag,payload:v.payload,callback:v.callback,next:null});n:{var m=n,d=v;switch(f=e,p=t,d.tag){case 1:if("function"===typeof(m=d.payload)){u=m.call(p,u,f);break n}u=m;break n;case 3:m.flags=-65537&m.flags|128;case 0:if(null===(f="function"===typeof(m=d.payload)?m.call(p,u,f):m)||void 0===f)break n;u=O({},u,f);break n;case 2:Da=!0}}null!==v.callback&&0!==v.lane&&(n.flags|=64,null===(f=r.effects)?r.effects=[v]:f.push(v))}else p={eventTime:p,lane:f,tag:v.tag,payload:v.payload,callback:v.callback,next:null},null===l?(s=l=p,c=u):l=l.next=p,i|=f;if(null===(v=v.next)){if(null===(v=r.shared.pending))break;v=(f=v).next,f.next=null,r.lastBaseUpdate=f,r.shared.pending=null}}if(null===l&&(c=u),r.baseState=c,r.firstBaseUpdate=s,r.lastBaseUpdate=l,null!==(e=r.shared.interleaved)){r=e;do{i|=r.lane,r=r.next}while(r!==e)}else null===a&&(r.shared.lanes=0);Ec|=i,n.lanes=i,n.memoizedState=u}}function La(n,e,t){if(n=e.effects,e.effects=null,null!==n)for(e=0;e<n.length;e++){var o=n[e],r=o.callback;if(null!==r){if(o.callback=null,o=t,"function"!==typeof r)throw Error(a(191,r));r.call(o)}}}var Ga=(new o.Component).refs;function Na(n,e,t,o){t=null===(t=t(o,e=n.memoizedState))||void 0===t?e:O({},e,t),n.memoizedState=t,0===n.lanes&&(n.updateQueue.baseState=t)}var Ba={isMounted:function(n){return!!(n=n._reactInternals)&&qn(n)===n},enqueueSetState:function(n,e,t){n=n._reactInternals;var o=ns(),r=es(n),a=ja(o,r);a.payload=e,void 0!==t&&null!==t&&(a.callback=t),null!==(e=Ia(n,a,r))&&(ts(e,n,r,o),Ea(e,n,r))},enqueueReplaceState:function(n,e,t){n=n._reactInternals;var o=ns(),r=es(n),a=ja(o,r);a.tag=1,a.payload=e,void 0!==t&&null!==t&&(a.callback=t),null!==(e=Ia(n,a,r))&&(ts(e,n,r,o),Ea(e,n,r))},enqueueForceUpdate:function(n,e){n=n._reactInternals;var t=ns(),o=es(n),r=ja(t,o);r.tag=2,void 0!==e&&null!==e&&(r.callback=e),null!==(e=Ia(n,r,o))&&(ts(e,n,o,t),Ea(e,n,o))}};function qa(n,e,t,o,r,a,i){return"function"===typeof(n=n.stateNode).shouldComponentUpdate?n.shouldComponentUpdate(o,a,i):!e.prototype||!e.prototype.isPureReactComponent||(!co(t,o)||!co(r,a))}function Va(n,e,t){var o=!1,r=Cr,a=e.contextType;return"object"===typeof a&&null!==a?a=ka(a):(r=Fr(e)?Dr:Tr.current,a=(o=null!==(o=e.contextTypes)&&void 0!==o)?Pr(n,r):Cr),e=new e(t,a),n.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,e.updater=Ba,n.stateNode=e,e._reactInternals=n,o&&((n=n.stateNode).__reactInternalMemoizedUnmaskedChildContext=r,n.__reactInternalMemoizedMaskedChildContext=a),e}function Wa(n,e,t,o){n=e.state,"function"===typeof e.componentWillReceiveProps&&e.componentWillReceiveProps(t,o),"function"===typeof e.UNSAFE_componentWillReceiveProps&&e.UNSAFE_componentWillReceiveProps(t,o),e.state!==n&&Ba.enqueueReplaceState(e,e.state,null)}function Ha(n,e,t,o){var r=n.stateNode;r.props=t,r.state=n.memoizedState,r.refs=Ga,Pa(n);var a=e.contextType;"object"===typeof a&&null!==a?r.context=ka(a):(a=Fr(e)?Dr:Tr.current,r.context=Pr(n,a)),r.state=n.memoizedState,"function"===typeof(a=e.getDerivedStateFromProps)&&(Na(n,e,a,t),r.state=n.memoizedState),"function"===typeof e.getDerivedStateFromProps||"function"===typeof r.getSnapshotBeforeUpdate||"function"!==typeof r.UNSAFE_componentWillMount&&"function"!==typeof r.componentWillMount||(e=r.state,"function"===typeof r.componentWillMount&&r.componentWillMount(),"function"===typeof r.UNSAFE_componentWillMount&&r.UNSAFE_componentWillMount(),e!==r.state&&Ba.enqueueReplaceState(r,r.state,null),Aa(n,t,r,o),r.state=n.memoizedState),"function"===typeof r.componentDidMount&&(n.flags|=4194308)}function Xa(n,e,t){if(null!==(n=t.ref)&&"function"!==typeof n&&"object"!==typeof n){if(t._owner){if(t=t._owner){if(1!==t.tag)throw Error(a(309));var o=t.stateNode}if(!o)throw Error(a(147,n));var r=o,i=""+n;return null!==e&&null!==e.ref&&"function"===typeof e.ref&&e.ref._stringRef===i?e.ref:(e=function(n){var e=r.refs;e===Ga&&(e=r.refs={}),null===n?delete e[i]:e[i]=n},e._stringRef=i,e)}if("string"!==typeof n)throw Error(a(284));if(!t._owner)throw Error(a(290,n))}return n}function Ya(n,e){throw n=Object.prototype.toString.call(e),Error(a(31,"[object Object]"===n?"object with keys {"+Object.keys(e).join(", ")+"}":n))}function Za(n){return(0,n._init)(n._payload)}function Qa(n){function e(e,t){if(n){var o=e.deletions;null===o?(e.deletions=[t],e.flags|=16):o.push(t)}}function t(t,o){if(!n)return null;for(;null!==o;)e(t,o),o=o.sibling;return null}function o(n,e){for(n=new Map;null!==e;)null!==e.key?n.set(e.key,e):n.set(e.index,e),e=e.sibling;return n}function r(n,e){return(n=Fs(n,e)).index=0,n.sibling=null,n}function i(e,t,o){return e.index=o,n?null!==(o=e.alternate)?(o=o.index)<t?(e.flags|=2,t):o:(e.flags|=2,t):(e.flags|=1048576,t)}function v(e){return n&&null===e.alternate&&(e.flags|=2),e}function c(n,e,t,o){return null===e||6!==e.tag?((e=Os(t,n.mode,o)).return=n,e):((e=r(e,t)).return=n,e)}function s(n,e,t,o){var a=t.type;return a===w?u(n,e,t.props.children,o,t.key):null!==e&&(e.elementType===a||"object"===typeof a&&null!==a&&a.$$typeof===P&&Za(a)===e.type)?((o=r(e,t.props)).ref=Xa(n,e,t),o.return=n,o):((o=js(t.type,t.key,t.props,null,n.mode,o)).ref=Xa(n,e,t),o.return=n,o)}function l(n,e,t,o){return null===e||4!==e.tag||e.stateNode.containerInfo!==t.containerInfo||e.stateNode.implementation!==t.implementation?((e=As(t,n.mode,o)).return=n,e):((e=r(e,t.children||[])).return=n,e)}function u(n,e,t,o,a){return null===e||7!==e.tag?((e=Is(t,n.mode,o,a)).return=n,e):((e=r(e,t)).return=n,e)}function f(n,e,t){if("string"===typeof e&&""!==e||"number"===typeof e)return(e=Os(""+e,n.mode,t)).return=n,e;if("object"===typeof e&&null!==e){switch(e.$$typeof){case U:return(t=js(e.type,e.key,e.props,null,n.mode,t)).ref=Xa(n,null,e),t.return=n,t;case _:return(e=As(e,n.mode,t)).return=n,e;case P:return f(n,(0,e._init)(e._payload),t)}if(en(e)||I(e))return(e=Is(e,n.mode,t,null)).return=n,e;Ya(n,e)}return null}function p(n,e,t,o){var r=null!==e?e.key:null;if("string"===typeof t&&""!==t||"number"===typeof t)return null!==r?null:c(n,e,""+t,o);if("object"===typeof t&&null!==t){switch(t.$$typeof){case U:return t.key===r?s(n,e,t,o):null;case _:return t.key===r?l(n,e,t,o):null;case P:return p(n,e,(r=t._init)(t._payload),o)}if(en(t)||I(t))return null!==r?null:u(n,e,t,o,null);Ya(n,t)}return null}function m(n,e,t,o,r){if("string"===typeof o&&""!==o||"number"===typeof o)return c(e,n=n.get(t)||null,""+o,r);if("object"===typeof o&&null!==o){switch(o.$$typeof){case U:return s(e,n=n.get(null===o.key?t:o.key)||null,o,r);case _:return l(e,n=n.get(null===o.key?t:o.key)||null,o,r);case P:return m(n,e,t,(0,o._init)(o._payload),r)}if(en(o)||I(o))return u(e,n=n.get(t)||null,o,r,null);Ya(e,o)}return null}function d(r,a,v,c){for(var s=null,l=null,u=a,d=a=0,h=null;null!==u&&d<v.length;d++){u.index>d?(h=u,u=null):h=u.sibling;var x=p(r,u,v[d],c);if(null===x){null===u&&(u=h);break}n&&u&&null===x.alternate&&e(r,u),a=i(x,a,d),null===l?s=x:l.sibling=x,l=x,u=h}if(d===v.length)return t(r,u),aa&&$r(r,d),s;if(null===u){for(;d<v.length;d++)null!==(u=f(r,v[d],c))&&(a=i(u,a,d),null===l?s=u:l.sibling=u,l=u);return aa&&$r(r,d),s}for(u=o(r,u);d<v.length;d++)null!==(h=m(u,r,d,v[d],c))&&(n&&null!==h.alternate&&u.delete(null===h.key?d:h.key),a=i(h,a,d),null===l?s=h:l.sibling=h,l=h);return n&&u.forEach((function(n){return e(r,n)})),aa&&$r(r,d),s}function h(r,v,c,s){var l=I(c);if("function"!==typeof l)throw Error(a(150));if(null==(c=l.call(c)))throw Error(a(151));for(var u=l=null,d=v,h=v=0,x=null,g=c.next();null!==d&&!g.done;h++,g=c.next()){d.index>h?(x=d,d=null):x=d.sibling;var y=p(r,d,g.value,s);if(null===y){null===d&&(d=x);break}n&&d&&null===y.alternate&&e(r,d),v=i(y,v,h),null===u?l=y:u.sibling=y,u=y,d=x}if(g.done)return t(r,d),aa&&$r(r,h),l;if(null===d){for(;!g.done;h++,g=c.next())null!==(g=f(r,g.value,s))&&(v=i(g,v,h),null===u?l=g:u.sibling=g,u=g);return aa&&$r(r,h),l}for(d=o(r,d);!g.done;h++,g=c.next())null!==(g=m(d,r,h,g.value,s))&&(n&&null!==g.alternate&&d.delete(null===g.key?h:g.key),v=i(g,v,h),null===u?l=g:u.sibling=g,u=g);return n&&d.forEach((function(n){return e(r,n)})),aa&&$r(r,h),l}return function n(o,a,i,c){if("object"===typeof i&&null!==i&&i.type===w&&null===i.key&&(i=i.props.children),"object"===typeof i&&null!==i){switch(i.$$typeof){case U:n:{for(var s=i.key,l=a;null!==l;){if(l.key===s){if((s=i.type)===w){if(7===l.tag){t(o,l.sibling),(a=r(l,i.props.children)).return=o,o=a;break n}}else if(l.elementType===s||"object"===typeof s&&null!==s&&s.$$typeof===P&&Za(s)===l.type){t(o,l.sibling),(a=r(l,i.props)).ref=Xa(o,l,i),a.return=o,o=a;break n}t(o,l);break}e(o,l),l=l.sibling}i.type===w?((a=Is(i.props.children,o.mode,c,i.key)).return=o,o=a):((c=js(i.type,i.key,i.props,null,o.mode,c)).ref=Xa(o,a,i),c.return=o,o=c)}return v(o);case _:n:{for(l=i.key;null!==a;){if(a.key===l){if(4===a.tag&&a.stateNode.containerInfo===i.containerInfo&&a.stateNode.implementation===i.implementation){t(o,a.sibling),(a=r(a,i.children||[])).return=o,o=a;break n}t(o,a);break}e(o,a),a=a.sibling}(a=As(i,o.mode,c)).return=o,o=a}return v(o);case P:return n(o,a,(l=i._init)(i._payload),c)}if(en(i))return d(o,a,i,c);if(I(i))return h(o,a,i,c);Ya(o,i)}return"string"===typeof i&&""!==i||"number"===typeof i?(i=""+i,null!==a&&6===a.tag?(t(o,a.sibling),(a=r(a,i)).return=o,o=a):(t(o,a),(a=Os(i,o.mode,c)).return=o,o=a),v(o)):t(o,a)}}var Ja=Qa(!0),Ka=Qa(!1),$a={},ni=Mr($a),ei=Mr($a),ti=Mr($a);function oi(n){if(n===$a)throw Error(a(174));return n}function ri(n,e){switch(zr(ti,e),zr(ei,n),zr(ni,$a),n=e.nodeType){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:sn(null,"");break;default:e=sn(e=(n=8===n?e.parentNode:e).namespaceURI||null,n=n.tagName)}kr(ni),zr(ni,e)}function ai(){kr(ni),kr(ei),kr(ti)}function ii(n){oi(ti.current);var e=oi(ni.current),t=sn(e,n.type);e!==t&&(zr(ei,n),zr(ni,t))}function vi(n){ei.current===n&&(kr(ni),kr(ei))}var ci=Mr(0);function si(n){for(var e=n;null!==e;){if(13===e.tag){var t=e.memoizedState;if(null!==t&&(null===(t=t.dehydrated)||"$?"===t.data||"$!"===t.data))return e}else if(19===e.tag&&void 0!==e.memoizedProps.revealOrder){if(0!==(128&e.flags))return e}else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===n)break;for(;null===e.sibling;){if(null===e.return||e.return===n)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var li=[];function ui(){for(var n=0;n<li.length;n++)li[n]._workInProgressVersionPrimary=null;li.length=0}var fi=b.ReactCurrentDispatcher,pi=b.ReactCurrentBatchConfig,mi=0,di=null,hi=null,xi=null,gi=!1,yi=!1,bi=0,Ui=0;function _i(){throw Error(a(321))}function wi(n,e){if(null===e)return!1;for(var t=0;t<e.length&&t<n.length;t++)if(!vo(n[t],e[t]))return!1;return!0}function Si(n,e,t,o,r,i){if(mi=i,di=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,fi.current=null===n||null===n.memoizedState?vv:cv,n=t(o,r),yi){i=0;do{if(yi=!1,bi=0,25<=i)throw Error(a(301));i+=1,xi=hi=null,e.updateQueue=null,fi.current=sv,n=t(o,r)}while(yi)}if(fi.current=iv,e=null!==hi&&null!==hi.next,mi=0,xi=hi=di=null,gi=!1,e)throw Error(a(300));return n}function Mi(){var n=0!==bi;return bi=0,n}function ki(){var n={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===xi?di.memoizedState=xi=n:xi=xi.next=n,xi}function zi(){if(null===hi){var n=di.alternate;n=null!==n?n.memoizedState:null}else n=hi.next;var e=null===xi?di.memoizedState:xi.next;if(null!==e)xi=e,hi=n;else{if(null===n)throw Error(a(310));n={memoizedState:(hi=n).memoizedState,baseState:hi.baseState,baseQueue:hi.baseQueue,queue:hi.queue,next:null},null===xi?di.memoizedState=xi=n:xi=xi.next=n}return xi}function Ci(n,e){return"function"===typeof e?e(n):e}function Ti(n){var e=zi(),t=e.queue;if(null===t)throw Error(a(311));t.lastRenderedReducer=n;var o=hi,r=o.baseQueue,i=t.pending;if(null!==i){if(null!==r){var v=r.next;r.next=i.next,i.next=v}o.baseQueue=r=i,t.pending=null}if(null!==r){i=r.next,o=o.baseState;var c=v=null,s=null,l=i;do{var u=l.lane;if((mi&u)===u)null!==s&&(s=s.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),o=l.hasEagerState?l.eagerState:n(o,l.action);else{var f={lane:u,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null};null===s?(c=s=f,v=o):s=s.next=f,di.lanes|=u,Ec|=u}l=l.next}while(null!==l&&l!==i);null===s?v=o:s.next=c,vo(o,e.memoizedState)||(bv=!0),e.memoizedState=o,e.baseState=v,e.baseQueue=s,t.lastRenderedState=o}if(null!==(n=t.interleaved)){r=n;do{i=r.lane,di.lanes|=i,Ec|=i,r=r.next}while(r!==n)}else null===r&&(t.lanes=0);return[e.memoizedState,t.dispatch]}function Ri(n){var e=zi(),t=e.queue;if(null===t)throw Error(a(311));t.lastRenderedReducer=n;var o=t.dispatch,r=t.pending,i=e.memoizedState;if(null!==r){t.pending=null;var v=r=r.next;do{i=n(i,v.action),v=v.next}while(v!==r);vo(i,e.memoizedState)||(bv=!0),e.memoizedState=i,null===e.baseQueue&&(e.baseState=i),t.lastRenderedState=i}return[i,o]}function Di(){}function Pi(n,e){var t=di,o=zi(),r=e(),i=!vo(o.memoizedState,r);if(i&&(o.memoizedState=r,bv=!0),o=o.queue,Vi(Ii.bind(null,t,o,n),[n]),o.getSnapshot!==e||i||null!==xi&&1&xi.memoizedState.tag){if(t.flags|=2048,Li(9,ji.bind(null,t,o,r,e),void 0,null),null===Tc)throw Error(a(349));0!==(30&mi)||Fi(t,e,r)}return r}function Fi(n,e,t){n.flags|=16384,n={getSnapshot:e,value:t},null===(e=di.updateQueue)?(e={lastEffect:null,stores:null},di.updateQueue=e,e.stores=[n]):null===(t=e.stores)?e.stores=[n]:t.push(n)}function ji(n,e,t,o){e.value=t,e.getSnapshot=o,Ei(e)&&Oi(n)}function Ii(n,e,t){return t((function(){Ei(e)&&Oi(n)}))}function Ei(n){var e=n.getSnapshot;n=n.value;try{var t=e();return!vo(n,t)}catch(o){return!0}}function Oi(n){var e=Ra(n,1);null!==e&&ts(e,n,1,-1)}function Ai(n){var e=ki();return"function"===typeof n&&(n=n()),e.memoizedState=e.baseState=n,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Ci,lastRenderedState:n},e.queue=n,n=n.dispatch=tv.bind(null,di,n),[e.memoizedState,n]}function Li(n,e,t,o){return n={tag:n,create:e,destroy:t,deps:o,next:null},null===(e=di.updateQueue)?(e={lastEffect:null,stores:null},di.updateQueue=e,e.lastEffect=n.next=n):null===(t=e.lastEffect)?e.lastEffect=n.next=n:(o=t.next,t.next=n,n.next=o,e.lastEffect=n),n}function Gi(){return zi().memoizedState}function Ni(n,e,t,o){var r=ki();di.flags|=n,r.memoizedState=Li(1|e,t,void 0,void 0===o?null:o)}function Bi(n,e,t,o){var r=zi();o=void 0===o?null:o;var a=void 0;if(null!==hi){var i=hi.memoizedState;if(a=i.destroy,null!==o&&wi(o,i.deps))return void(r.memoizedState=Li(e,t,a,o))}di.flags|=n,r.memoizedState=Li(1|e,t,a,o)}function qi(n,e){return Ni(8390656,8,n,e)}function Vi(n,e){return Bi(2048,8,n,e)}function Wi(n,e){return Bi(4,2,n,e)}function Hi(n,e){return Bi(4,4,n,e)}function Xi(n,e){return"function"===typeof e?(n=n(),e(n),function(){e(null)}):null!==e&&void 0!==e?(n=n(),e.current=n,function(){e.current=null}):void 0}function Yi(n,e,t){return t=null!==t&&void 0!==t?t.concat([n]):null,Bi(4,4,Xi.bind(null,e,n),t)}function Zi(){}function Qi(n,e){var t=zi();e=void 0===e?null:e;var o=t.memoizedState;return null!==o&&null!==e&&wi(e,o[1])?o[0]:(t.memoizedState=[n,e],n)}function Ji(n,e){var t=zi();e=void 0===e?null:e;var o=t.memoizedState;return null!==o&&null!==e&&wi(e,o[1])?o[0]:(n=n(),t.memoizedState=[n,e],n)}function Ki(n,e,t){return 0===(21&mi)?(n.baseState&&(n.baseState=!1,bv=!0),n.memoizedState=t):(vo(t,e)||(t=he(),di.lanes|=t,Ec|=t,n.baseState=!0),e)}function $i(n,e){var t=be;be=0!==t&&4>t?t:4,n(!0);var o=pi.transition;pi.transition={};try{n(!1),e()}finally{be=t,pi.transition=o}}function nv(){return zi().memoizedState}function ev(n,e,t){var o=es(n);if(t={lane:o,action:t,hasEagerState:!1,eagerState:null,next:null},ov(n))rv(e,t);else if(null!==(t=Ta(n,e,t,o))){ts(t,n,o,ns()),av(t,e,o)}}function tv(n,e,t){var o=es(n),r={lane:o,action:t,hasEagerState:!1,eagerState:null,next:null};if(ov(n))rv(e,r);else{var a=n.alternate;if(0===n.lanes&&(null===a||0===a.lanes)&&null!==(a=e.lastRenderedReducer))try{var i=e.lastRenderedState,v=a(i,t);if(r.hasEagerState=!0,r.eagerState=v,vo(v,i)){var c=e.interleaved;return null===c?(r.next=r,Ca(e)):(r.next=c.next,c.next=r),void(e.interleaved=r)}}catch(s){}null!==(t=Ta(n,e,r,o))&&(ts(t,n,o,r=ns()),av(t,e,o))}}function ov(n){var e=n.alternate;return n===di||null!==e&&e===di}function rv(n,e){yi=gi=!0;var t=n.pending;null===t?e.next=e:(e.next=t.next,t.next=e),n.pending=e}function av(n,e,t){if(0!==(4194240&t)){var o=e.lanes;t|=o&=n.pendingLanes,e.lanes=t,ye(n,t)}}var iv={readContext:ka,useCallback:_i,useContext:_i,useEffect:_i,useImperativeHandle:_i,useInsertionEffect:_i,useLayoutEffect:_i,useMemo:_i,useReducer:_i,useRef:_i,useState:_i,useDebugValue:_i,useDeferredValue:_i,useTransition:_i,useMutableSource:_i,useSyncExternalStore:_i,useId:_i,unstable_isNewReconciler:!1},vv={readContext:ka,useCallback:function(n,e){return ki().memoizedState=[n,void 0===e?null:e],n},useContext:ka,useEffect:qi,useImperativeHandle:function(n,e,t){return t=null!==t&&void 0!==t?t.concat([n]):null,Ni(4194308,4,Xi.bind(null,e,n),t)},useLayoutEffect:function(n,e){return Ni(4194308,4,n,e)},useInsertionEffect:function(n,e){return Ni(4,2,n,e)},useMemo:function(n,e){var t=ki();return e=void 0===e?null:e,n=n(),t.memoizedState=[n,e],n},useReducer:function(n,e,t){var o=ki();return e=void 0!==t?t(e):e,o.memoizedState=o.baseState=e,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:n,lastRenderedState:e},o.queue=n,n=n.dispatch=ev.bind(null,di,n),[o.memoizedState,n]},useRef:function(n){return n={current:n},ki().memoizedState=n},useState:Ai,useDebugValue:Zi,useDeferredValue:function(n){return ki().memoizedState=n},useTransition:function(){var n=Ai(!1),e=n[0];return n=$i.bind(null,n[1]),ki().memoizedState=n,[e,n]},useMutableSource:function(){},useSyncExternalStore:function(n,e,t){var o=di,r=ki();if(aa){if(void 0===t)throw Error(a(407));t=t()}else{if(t=e(),null===Tc)throw Error(a(349));0!==(30&mi)||Fi(o,e,t)}r.memoizedState=t;var i={value:t,getSnapshot:e};return r.queue=i,qi(Ii.bind(null,o,i,n),[n]),o.flags|=2048,Li(9,ji.bind(null,o,i,t,e),void 0,null),t},useId:function(){var n=ki(),e=Tc.identifierPrefix;if(aa){var t=Kr;e=":"+e+"R"+(t=(Jr&~(1<<32-ve(Jr)-1)).toString(32)+t),0<(t=bi++)&&(e+="H"+t.toString(32)),e+=":"}else e=":"+e+"r"+(t=Ui++).toString(32)+":";return n.memoizedState=e},unstable_isNewReconciler:!1},cv={readContext:ka,useCallback:Qi,useContext:ka,useEffect:Vi,useImperativeHandle:Yi,useInsertionEffect:Wi,useLayoutEffect:Hi,useMemo:Ji,useReducer:Ti,useRef:Gi,useState:function(){return Ti(Ci)},useDebugValue:Zi,useDeferredValue:function(n){return Ki(zi(),hi.memoizedState,n)},useTransition:function(){return[Ti(Ci)[0],zi().memoizedState]},useMutableSource:Di,useSyncExternalStore:Pi,useId:nv,unstable_isNewReconciler:!1},sv={readContext:ka,useCallback:Qi,useContext:ka,useEffect:Vi,useImperativeHandle:Yi,useInsertionEffect:Wi,useLayoutEffect:Hi,useMemo:Ji,useReducer:Ri,useRef:Gi,useState:function(){return Ri(Ci)},useDebugValue:Zi,useDeferredValue:function(n){var e=zi();return null===hi?e.memoizedState=n:Ki(e,hi.memoizedState,n)},useTransition:function(){return[Ri(Ci)[0],zi().memoizedState]},useMutableSource:Di,useSyncExternalStore:Pi,useId:nv,unstable_isNewReconciler:!1};function lv(n,e){try{var t="",o=e;do{t+=N(o),o=o.return}while(o);var r=t}catch(a){r="\nError generating stack: "+a.message+"\n"+a.stack}return{value:n,source:e,stack:r,digest:null}}function uv(n,e,t){return{value:n,source:null,stack:null!=t?t:null,digest:null!=e?e:null}}function fv(n,e){try{console.error(e.value)}catch(t){setTimeout((function(){throw t}))}}var pv="function"===typeof WeakMap?WeakMap:Map;function mv(n,e,t){(t=ja(-1,t)).tag=3,t.payload={element:null};var o=e.value;return t.callback=function(){Vc||(Vc=!0,Wc=o),fv(0,e)},t}function dv(n,e,t){(t=ja(-1,t)).tag=3;var o=n.type.getDerivedStateFromError;if("function"===typeof o){var r=e.value;t.payload=function(){return o(r)},t.callback=function(){fv(0,e)}}var a=n.stateNode;return null!==a&&"function"===typeof a.componentDidCatch&&(t.callback=function(){fv(0,e),"function"!==typeof o&&(null===Hc?Hc=new Set([this]):Hc.add(this));var n=e.stack;this.componentDidCatch(e.value,{componentStack:null!==n?n:""})}),t}function hv(n,e,t){var o=n.pingCache;if(null===o){o=n.pingCache=new pv;var r=new Set;o.set(e,r)}else void 0===(r=o.get(e))&&(r=new Set,o.set(e,r));r.has(t)||(r.add(t),n=Ms.bind(null,n,e,t),e.then(n,n))}function xv(n){do{var e;if((e=13===n.tag)&&(e=null===(e=n.memoizedState)||null!==e.dehydrated),e)return n;n=n.return}while(null!==n);return null}function gv(n,e,t,o,r){return 0===(1&n.mode)?(n===e?n.flags|=65536:(n.flags|=128,t.flags|=131072,t.flags&=-52805,1===t.tag&&(null===t.alternate?t.tag=17:((e=ja(-1,1)).tag=2,Ia(t,e,1))),t.lanes|=1),n):(n.flags|=65536,n.lanes=r,n)}var yv=b.ReactCurrentOwner,bv=!1;function Uv(n,e,t,o){e.child=null===n?Ka(e,null,t,o):Ja(e,n.child,t,o)}function _v(n,e,t,o,r){t=t.render;var a=e.ref;return Ma(e,r),o=Si(n,e,t,o,a,r),t=Mi(),null===n||bv?(aa&&t&&ea(e),e.flags|=1,Uv(n,e,o,r),e.child):(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~r,Vv(n,e,r))}function wv(n,e,t,o,r){if(null===n){var a=t.type;return"function"!==typeof a||Ps(a)||void 0!==a.defaultProps||null!==t.compare||void 0!==t.defaultProps?((n=js(t.type,null,o,e,e.mode,r)).ref=e.ref,n.return=e,e.child=n):(e.tag=15,e.type=a,Sv(n,e,a,o,r))}if(a=n.child,0===(n.lanes&r)){var i=a.memoizedProps;if((t=null!==(t=t.compare)?t:co)(i,o)&&n.ref===e.ref)return Vv(n,e,r)}return e.flags|=1,(n=Fs(a,o)).ref=e.ref,n.return=e,e.child=n}function Sv(n,e,t,o,r){if(null!==n){var a=n.memoizedProps;if(co(a,o)&&n.ref===e.ref){if(bv=!1,e.pendingProps=o=a,0===(n.lanes&r))return e.lanes=n.lanes,Vv(n,e,r);0!==(131072&n.flags)&&(bv=!0)}}return zv(n,e,t,o,r)}function Mv(n,e,t){var o=e.pendingProps,r=o.children,a=null!==n?n.memoizedState:null;if("hidden"===o.mode)if(0===(1&e.mode))e.memoizedState={baseLanes:0,cachePool:null,transitions:null},zr(Fc,Pc),Pc|=t;else{if(0===(1073741824&t))return n=null!==a?a.baseLanes|t:t,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:n,cachePool:null,transitions:null},e.updateQueue=null,zr(Fc,Pc),Pc|=n,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},o=null!==a?a.baseLanes:t,zr(Fc,Pc),Pc|=o}else null!==a?(o=a.baseLanes|t,e.memoizedState=null):o=t,zr(Fc,Pc),Pc|=o;return Uv(n,e,r,t),e.child}function kv(n,e){var t=e.ref;(null===n&&null!==t||null!==n&&n.ref!==t)&&(e.flags|=512,e.flags|=2097152)}function zv(n,e,t,o,r){var a=Fr(t)?Dr:Tr.current;return a=Pr(e,a),Ma(e,r),t=Si(n,e,t,o,a,r),o=Mi(),null===n||bv?(aa&&o&&ea(e),e.flags|=1,Uv(n,e,t,r),e.child):(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~r,Vv(n,e,r))}function Cv(n,e,t,o,r){if(Fr(t)){var a=!0;Or(e)}else a=!1;if(Ma(e,r),null===e.stateNode)qv(n,e),Va(e,t,o),Ha(e,t,o,r),o=!0;else if(null===n){var i=e.stateNode,v=e.memoizedProps;i.props=v;var c=i.context,s=t.contextType;"object"===typeof s&&null!==s?s=ka(s):s=Pr(e,s=Fr(t)?Dr:Tr.current);var l=t.getDerivedStateFromProps,u="function"===typeof l||"function"===typeof i.getSnapshotBeforeUpdate;u||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(v!==o||c!==s)&&Wa(e,i,o,s),Da=!1;var f=e.memoizedState;i.state=f,Aa(e,o,i,r),c=e.memoizedState,v!==o||f!==c||Rr.current||Da?("function"===typeof l&&(Na(e,t,l,o),c=e.memoizedState),(v=Da||qa(e,t,v,o,f,c,s))?(u||"function"!==typeof i.UNSAFE_componentWillMount&&"function"!==typeof i.componentWillMount||("function"===typeof i.componentWillMount&&i.componentWillMount(),"function"===typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount()),"function"===typeof i.componentDidMount&&(e.flags|=4194308)):("function"===typeof i.componentDidMount&&(e.flags|=4194308),e.memoizedProps=o,e.memoizedState=c),i.props=o,i.state=c,i.context=s,o=v):("function"===typeof i.componentDidMount&&(e.flags|=4194308),o=!1)}else{i=e.stateNode,Fa(n,e),v=e.memoizedProps,s=e.type===e.elementType?v:xa(e.type,v),i.props=s,u=e.pendingProps,f=i.context,"object"===typeof(c=t.contextType)&&null!==c?c=ka(c):c=Pr(e,c=Fr(t)?Dr:Tr.current);var p=t.getDerivedStateFromProps;(l="function"===typeof p||"function"===typeof i.getSnapshotBeforeUpdate)||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(v!==u||f!==c)&&Wa(e,i,o,c),Da=!1,f=e.memoizedState,i.state=f,Aa(e,o,i,r);var m=e.memoizedState;v!==u||f!==m||Rr.current||Da?("function"===typeof p&&(Na(e,t,p,o),m=e.memoizedState),(s=Da||qa(e,t,s,o,f,m,c)||!1)?(l||"function"!==typeof i.UNSAFE_componentWillUpdate&&"function"!==typeof i.componentWillUpdate||("function"===typeof i.componentWillUpdate&&i.componentWillUpdate(o,m,c),"function"===typeof i.UNSAFE_componentWillUpdate&&i.UNSAFE_componentWillUpdate(o,m,c)),"function"===typeof i.componentDidUpdate&&(e.flags|=4),"function"===typeof i.getSnapshotBeforeUpdate&&(e.flags|=1024)):("function"!==typeof i.componentDidUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=1024),e.memoizedProps=o,e.memoizedState=m),i.props=o,i.state=m,i.context=c,o=s):("function"!==typeof i.componentDidUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=1024),o=!1)}return Tv(n,e,t,o,a,r)}function Tv(n,e,t,o,r,a){kv(n,e);var i=0!==(128&e.flags);if(!o&&!i)return r&&Ar(e,t,!1),Vv(n,e,a);o=e.stateNode,yv.current=e;var v=i&&"function"!==typeof t.getDerivedStateFromError?null:o.render();return e.flags|=1,null!==n&&i?(e.child=Ja(e,n.child,null,a),e.child=Ja(e,null,v,a)):Uv(n,e,v,a),e.memoizedState=o.state,r&&Ar(e,t,!0),e.child}function Rv(n){var e=n.stateNode;e.pendingContext?Ir(0,e.pendingContext,e.pendingContext!==e.context):e.context&&Ir(0,e.context,!1),ri(n,e.containerInfo)}function Dv(n,e,t,o,r){return ma(),da(r),e.flags|=256,Uv(n,e,t,o),e.child}var Pv,Fv,jv,Iv={dehydrated:null,treeContext:null,retryLane:0};function Ev(n){return{baseLanes:n,cachePool:null,transitions:null}}function Ov(n,e,t){var o,r=e.pendingProps,i=ci.current,v=!1,c=0!==(128&e.flags);if((o=c)||(o=(null===n||null!==n.memoizedState)&&0!==(2&i)),o?(v=!0,e.flags&=-129):null!==n&&null===n.memoizedState||(i|=1),zr(ci,1&i),null===n)return la(e),null!==(n=e.memoizedState)&&null!==(n=n.dehydrated)?(0===(1&e.mode)?e.lanes=1:"$!"===n.data?e.lanes=8:e.lanes=1073741824,null):(c=r.children,n=r.fallback,v?(r=e.mode,v=e.child,c={mode:"hidden",children:c},0===(1&r)&&null!==v?(v.childLanes=0,v.pendingProps=c):v=Es(c,r,0,null),n=Is(n,r,t,null),v.return=e,n.return=e,v.sibling=n,e.child=v,e.child.memoizedState=Ev(t),e.memoizedState=Iv,n):Av(e,c));if(null!==(i=n.memoizedState)&&null!==(o=i.dehydrated))return function(n,e,t,o,r,i,v){if(t)return 256&e.flags?(e.flags&=-257,Lv(n,e,v,o=uv(Error(a(422))))):null!==e.memoizedState?(e.child=n.child,e.flags|=128,null):(i=o.fallback,r=e.mode,o=Es({mode:"visible",children:o.children},r,0,null),(i=Is(i,r,v,null)).flags|=2,o.return=e,i.return=e,o.sibling=i,e.child=o,0!==(1&e.mode)&&Ja(e,n.child,null,v),e.child.memoizedState=Ev(v),e.memoizedState=Iv,i);if(0===(1&e.mode))return Lv(n,e,v,null);if("$!"===r.data){if(o=r.nextSibling&&r.nextSibling.dataset)var c=o.dgst;return o=c,Lv(n,e,v,o=uv(i=Error(a(419)),o,void 0))}if(c=0!==(v&n.childLanes),bv||c){if(null!==(o=Tc)){switch(v&-v){case 4:r=2;break;case 16:r=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:r=32;break;case 536870912:r=268435456;break;default:r=0}0!==(r=0!==(r&(o.suspendedLanes|v))?0:r)&&r!==i.retryLane&&(i.retryLane=r,Ra(n,r),ts(o,n,r,-1))}return ds(),Lv(n,e,v,o=uv(Error(a(421))))}return"$?"===r.data?(e.flags|=128,e.child=n.child,e=zs.bind(null,n),r._reactRetry=e,null):(n=i.treeContext,ra=lr(r.nextSibling),oa=e,aa=!0,ia=null,null!==n&&(Yr[Zr++]=Jr,Yr[Zr++]=Kr,Yr[Zr++]=Qr,Jr=n.id,Kr=n.overflow,Qr=e),(e=Av(e,o.children)).flags|=4096,e)}(n,e,c,r,o,i,t);if(v){v=r.fallback,c=e.mode,o=(i=n.child).sibling;var s={mode:"hidden",children:r.children};return 0===(1&c)&&e.child!==i?((r=e.child).childLanes=0,r.pendingProps=s,e.deletions=null):(r=Fs(i,s)).subtreeFlags=14680064&i.subtreeFlags,null!==o?v=Fs(o,v):(v=Is(v,c,t,null)).flags|=2,v.return=e,r.return=e,r.sibling=v,e.child=r,r=v,v=e.child,c=null===(c=n.child.memoizedState)?Ev(t):{baseLanes:c.baseLanes|t,cachePool:null,transitions:c.transitions},v.memoizedState=c,v.childLanes=n.childLanes&~t,e.memoizedState=Iv,r}return n=(v=n.child).sibling,r=Fs(v,{mode:"visible",children:r.children}),0===(1&e.mode)&&(r.lanes=t),r.return=e,r.sibling=null,null!==n&&(null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)),e.child=r,e.memoizedState=null,r}function Av(n,e){return(e=Es({mode:"visible",children:e},n.mode,0,null)).return=n,n.child=e}function Lv(n,e,t,o){return null!==o&&da(o),Ja(e,n.child,null,t),(n=Av(e,e.pendingProps.children)).flags|=2,e.memoizedState=null,n}function Gv(n,e,t){n.lanes|=e;var o=n.alternate;null!==o&&(o.lanes|=e),Sa(n.return,e,t)}function Nv(n,e,t,o,r){var a=n.memoizedState;null===a?n.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:o,tail:t,tailMode:r}:(a.isBackwards=e,a.rendering=null,a.renderingStartTime=0,a.last=o,a.tail=t,a.tailMode=r)}function Bv(n,e,t){var o=e.pendingProps,r=o.revealOrder,a=o.tail;if(Uv(n,e,o.children,t),0!==(2&(o=ci.current)))o=1&o|2,e.flags|=128;else{if(null!==n&&0!==(128&n.flags))n:for(n=e.child;null!==n;){if(13===n.tag)null!==n.memoizedState&&Gv(n,t,e);else if(19===n.tag)Gv(n,t,e);else if(null!==n.child){n.child.return=n,n=n.child;continue}if(n===e)break n;for(;null===n.sibling;){if(null===n.return||n.return===e)break n;n=n.return}n.sibling.return=n.return,n=n.sibling}o&=1}if(zr(ci,o),0===(1&e.mode))e.memoizedState=null;else switch(r){case"forwards":for(t=e.child,r=null;null!==t;)null!==(n=t.alternate)&&null===si(n)&&(r=t),t=t.sibling;null===(t=r)?(r=e.child,e.child=null):(r=t.sibling,t.sibling=null),Nv(e,!1,r,t,a);break;case"backwards":for(t=null,r=e.child,e.child=null;null!==r;){if(null!==(n=r.alternate)&&null===si(n)){e.child=r;break}n=r.sibling,r.sibling=t,t=r,r=n}Nv(e,!0,t,null,a);break;case"together":Nv(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function qv(n,e){0===(1&e.mode)&&null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2)}function Vv(n,e,t){if(null!==n&&(e.dependencies=n.dependencies),Ec|=e.lanes,0===(t&e.childLanes))return null;if(null!==n&&e.child!==n.child)throw Error(a(153));if(null!==e.child){for(t=Fs(n=e.child,n.pendingProps),e.child=t,t.return=e;null!==n.sibling;)n=n.sibling,(t=t.sibling=Fs(n,n.pendingProps)).return=e;t.sibling=null}return e.child}function Wv(n,e){if(!aa)switch(n.tailMode){case"hidden":e=n.tail;for(var t=null;null!==e;)null!==e.alternate&&(t=e),e=e.sibling;null===t?n.tail=null:t.sibling=null;break;case"collapsed":t=n.tail;for(var o=null;null!==t;)null!==t.alternate&&(o=t),t=t.sibling;null===o?e||null===n.tail?n.tail=null:n.tail.sibling=null:o.sibling=null}}function Hv(n){var e=null!==n.alternate&&n.alternate.child===n.child,t=0,o=0;if(e)for(var r=n.child;null!==r;)t|=r.lanes|r.childLanes,o|=14680064&r.subtreeFlags,o|=14680064&r.flags,r.return=n,r=r.sibling;else for(r=n.child;null!==r;)t|=r.lanes|r.childLanes,o|=r.subtreeFlags,o|=r.flags,r.return=n,r=r.sibling;return n.subtreeFlags|=o,n.childLanes=t,e}function Xv(n,e,t){var o=e.pendingProps;switch(ta(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Hv(e),null;case 1:case 17:return Fr(e.type)&&jr(),Hv(e),null;case 3:return o=e.stateNode,ai(),kr(Rr),kr(Tr),ui(),o.pendingContext&&(o.context=o.pendingContext,o.pendingContext=null),null!==n&&null!==n.child||(fa(e)?e.flags|=4:null===n||n.memoizedState.isDehydrated&&0===(256&e.flags)||(e.flags|=1024,null!==ia&&(is(ia),ia=null))),Hv(e),null;case 5:vi(e);var r=oi(ti.current);if(t=e.type,null!==n&&null!=e.stateNode)Fv(n,e,t,o),n.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!o){if(null===e.stateNode)throw Error(a(166));return Hv(e),null}if(n=oi(ni.current),fa(e)){o=e.stateNode,t=e.type;var i=e.memoizedProps;switch(o[pr]=e,o[mr]=i,n=0!==(1&e.mode),t){case"dialog":Go("cancel",o),Go("close",o);break;case"iframe":case"object":case"embed":Go("load",o);break;case"video":case"audio":for(r=0;r<Eo.length;r++)Go(Eo[r],o);break;case"source":Go("error",o);break;case"img":case"image":case"link":Go("error",o),Go("load",o);break;case"details":Go("toggle",o);break;case"input":Q(o,i),Go("invalid",o);break;case"select":o._wrapperState={wasMultiple:!!i.multiple},Go("invalid",o);break;case"textarea":rn(o,i),Go("invalid",o)}for(var c in yn(t,i),r=null,i)if(i.hasOwnProperty(c)){var s=i[c];"children"===c?"string"===typeof s?o.textContent!==s&&(!0!==i.suppressHydrationWarning&&$o(o.textContent,s,n),r=["children",s]):"number"===typeof s&&o.textContent!==""+s&&(!0!==i.suppressHydrationWarning&&$o(o.textContent,s,n),r=["children",""+s]):v.hasOwnProperty(c)&&null!=s&&"onScroll"===c&&Go("scroll",o)}switch(t){case"input":H(o),$(o,i,!0);break;case"textarea":H(o),vn(o);break;case"select":case"option":break;default:"function"===typeof i.onClick&&(o.onclick=nr)}o=r,e.updateQueue=o,null!==o&&(e.flags|=4)}else{c=9===r.nodeType?r:r.ownerDocument,"http://www.w3.org/1999/xhtml"===n&&(n=cn(t)),"http://www.w3.org/1999/xhtml"===n?"script"===t?((n=c.createElement("div")).innerHTML="<script><\/script>",n=n.removeChild(n.firstChild)):"string"===typeof o.is?n=c.createElement(t,{is:o.is}):(n=c.createElement(t),"select"===t&&(c=n,o.multiple?c.multiple=!0:o.size&&(c.size=o.size))):n=c.createElementNS(n,t),n[pr]=e,n[mr]=o,Pv(n,e),e.stateNode=n;n:{switch(c=bn(t,o),t){case"dialog":Go("cancel",n),Go("close",n),r=o;break;case"iframe":case"object":case"embed":Go("load",n),r=o;break;case"video":case"audio":for(r=0;r<Eo.length;r++)Go(Eo[r],n);r=o;break;case"source":Go("error",n),r=o;break;case"img":case"image":case"link":Go("error",n),Go("load",n),r=o;break;case"details":Go("toggle",n),r=o;break;case"input":Q(n,o),r=Z(n,o),Go("invalid",n);break;case"option":default:r=o;break;case"select":n._wrapperState={wasMultiple:!!o.multiple},r=O({},o,{value:void 0}),Go("invalid",n);break;case"textarea":rn(n,o),r=on(n,o),Go("invalid",n)}for(i in yn(t,r),s=r)if(s.hasOwnProperty(i)){var l=s[i];"style"===i?xn(n,l):"dangerouslySetInnerHTML"===i?null!=(l=l?l.__html:void 0)&&fn(n,l):"children"===i?"string"===typeof l?("textarea"!==t||""!==l)&&pn(n,l):"number"===typeof l&&pn(n,""+l):"suppressContentEditableWarning"!==i&&"suppressHydrationWarning"!==i&&"autoFocus"!==i&&(v.hasOwnProperty(i)?null!=l&&"onScroll"===i&&Go("scroll",n):null!=l&&y(n,i,l,c))}switch(t){case"input":H(n),$(n,o,!1);break;case"textarea":H(n),vn(n);break;case"option":null!=o.value&&n.setAttribute("value",""+V(o.value));break;case"select":n.multiple=!!o.multiple,null!=(i=o.value)?tn(n,!!o.multiple,i,!1):null!=o.defaultValue&&tn(n,!!o.multiple,o.defaultValue,!0);break;default:"function"===typeof r.onClick&&(n.onclick=nr)}switch(t){case"button":case"input":case"select":case"textarea":o=!!o.autoFocus;break n;case"img":o=!0;break n;default:o=!1}}o&&(e.flags|=4)}null!==e.ref&&(e.flags|=512,e.flags|=2097152)}return Hv(e),null;case 6:if(n&&null!=e.stateNode)jv(0,e,n.memoizedProps,o);else{if("string"!==typeof o&&null===e.stateNode)throw Error(a(166));if(t=oi(ti.current),oi(ni.current),fa(e)){if(o=e.stateNode,t=e.memoizedProps,o[pr]=e,(i=o.nodeValue!==t)&&null!==(n=oa))switch(n.tag){case 3:$o(o.nodeValue,t,0!==(1&n.mode));break;case 5:!0!==n.memoizedProps.suppressHydrationWarning&&$o(o.nodeValue,t,0!==(1&n.mode))}i&&(e.flags|=4)}else(o=(9===t.nodeType?t:t.ownerDocument).createTextNode(o))[pr]=e,e.stateNode=o}return Hv(e),null;case 13:if(kr(ci),o=e.memoizedState,null===n||null!==n.memoizedState&&null!==n.memoizedState.dehydrated){if(aa&&null!==ra&&0!==(1&e.mode)&&0===(128&e.flags))pa(),ma(),e.flags|=98560,i=!1;else if(i=fa(e),null!==o&&null!==o.dehydrated){if(null===n){if(!i)throw Error(a(318));if(!(i=null!==(i=e.memoizedState)?i.dehydrated:null))throw Error(a(317));i[pr]=e}else ma(),0===(128&e.flags)&&(e.memoizedState=null),e.flags|=4;Hv(e),i=!1}else null!==ia&&(is(ia),ia=null),i=!0;if(!i)return 65536&e.flags?e:null}return 0!==(128&e.flags)?(e.lanes=t,e):((o=null!==o)!==(null!==n&&null!==n.memoizedState)&&o&&(e.child.flags|=8192,0!==(1&e.mode)&&(null===n||0!==(1&ci.current)?0===jc&&(jc=3):ds())),null!==e.updateQueue&&(e.flags|=4),Hv(e),null);case 4:return ai(),null===n&&qo(e.stateNode.containerInfo),Hv(e),null;case 10:return wa(e.type._context),Hv(e),null;case 19:if(kr(ci),null===(i=e.memoizedState))return Hv(e),null;if(o=0!==(128&e.flags),null===(c=i.rendering))if(o)Wv(i,!1);else{if(0!==jc||null!==n&&0!==(128&n.flags))for(n=e.child;null!==n;){if(null!==(c=si(n))){for(e.flags|=128,Wv(i,!1),null!==(o=c.updateQueue)&&(e.updateQueue=o,e.flags|=4),e.subtreeFlags=0,o=t,t=e.child;null!==t;)n=o,(i=t).flags&=14680066,null===(c=i.alternate)?(i.childLanes=0,i.lanes=n,i.child=null,i.subtreeFlags=0,i.memoizedProps=null,i.memoizedState=null,i.updateQueue=null,i.dependencies=null,i.stateNode=null):(i.childLanes=c.childLanes,i.lanes=c.lanes,i.child=c.child,i.subtreeFlags=0,i.deletions=null,i.memoizedProps=c.memoizedProps,i.memoizedState=c.memoizedState,i.updateQueue=c.updateQueue,i.type=c.type,n=c.dependencies,i.dependencies=null===n?null:{lanes:n.lanes,firstContext:n.firstContext}),t=t.sibling;return zr(ci,1&ci.current|2),e.child}n=n.sibling}null!==i.tail&&Kn()>Bc&&(e.flags|=128,o=!0,Wv(i,!1),e.lanes=4194304)}else{if(!o)if(null!==(n=si(c))){if(e.flags|=128,o=!0,null!==(t=n.updateQueue)&&(e.updateQueue=t,e.flags|=4),Wv(i,!0),null===i.tail&&"hidden"===i.tailMode&&!c.alternate&&!aa)return Hv(e),null}else 2*Kn()-i.renderingStartTime>Bc&&1073741824!==t&&(e.flags|=128,o=!0,Wv(i,!1),e.lanes=4194304);i.isBackwards?(c.sibling=e.child,e.child=c):(null!==(t=i.last)?t.sibling=c:e.child=c,i.last=c)}return null!==i.tail?(e=i.tail,i.rendering=e,i.tail=e.sibling,i.renderingStartTime=Kn(),e.sibling=null,t=ci.current,zr(ci,o?1&t|2:1&t),e):(Hv(e),null);case 22:case 23:return us(),o=null!==e.memoizedState,null!==n&&null!==n.memoizedState!==o&&(e.flags|=8192),o&&0!==(1&e.mode)?0!==(1073741824&Pc)&&(Hv(e),6&e.subtreeFlags&&(e.flags|=8192)):Hv(e),null;case 24:case 25:return null}throw Error(a(156,e.tag))}function Yv(n,e){switch(ta(e),e.tag){case 1:return Fr(e.type)&&jr(),65536&(n=e.flags)?(e.flags=-65537&n|128,e):null;case 3:return ai(),kr(Rr),kr(Tr),ui(),0!==(65536&(n=e.flags))&&0===(128&n)?(e.flags=-65537&n|128,e):null;case 5:return vi(e),null;case 13:if(kr(ci),null!==(n=e.memoizedState)&&null!==n.dehydrated){if(null===e.alternate)throw Error(a(340));ma()}return 65536&(n=e.flags)?(e.flags=-65537&n|128,e):null;case 19:return kr(ci),null;case 4:return ai(),null;case 10:return wa(e.type._context),null;case 22:case 23:return us(),null;default:return null}}Pv=function(n,e){for(var t=e.child;null!==t;){if(5===t.tag||6===t.tag)n.appendChild(t.stateNode);else if(4!==t.tag&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return;t=t.return}t.sibling.return=t.return,t=t.sibling}},Fv=function(n,e,t,o){var r=n.memoizedProps;if(r!==o){n=e.stateNode,oi(ni.current);var a,i=null;switch(t){case"input":r=Z(n,r),o=Z(n,o),i=[];break;case"select":r=O({},r,{value:void 0}),o=O({},o,{value:void 0}),i=[];break;case"textarea":r=on(n,r),o=on(n,o),i=[];break;default:"function"!==typeof r.onClick&&"function"===typeof o.onClick&&(n.onclick=nr)}for(l in yn(t,o),t=null,r)if(!o.hasOwnProperty(l)&&r.hasOwnProperty(l)&&null!=r[l])if("style"===l){var c=r[l];for(a in c)c.hasOwnProperty(a)&&(t||(t={}),t[a]="")}else"dangerouslySetInnerHTML"!==l&&"children"!==l&&"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(v.hasOwnProperty(l)?i||(i=[]):(i=i||[]).push(l,null));for(l in o){var s=o[l];if(c=null!=r?r[l]:void 0,o.hasOwnProperty(l)&&s!==c&&(null!=s||null!=c))if("style"===l)if(c){for(a in c)!c.hasOwnProperty(a)||s&&s.hasOwnProperty(a)||(t||(t={}),t[a]="");for(a in s)s.hasOwnProperty(a)&&c[a]!==s[a]&&(t||(t={}),t[a]=s[a])}else t||(i||(i=[]),i.push(l,t)),t=s;else"dangerouslySetInnerHTML"===l?(s=s?s.__html:void 0,c=c?c.__html:void 0,null!=s&&c!==s&&(i=i||[]).push(l,s)):"children"===l?"string"!==typeof s&&"number"!==typeof s||(i=i||[]).push(l,""+s):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&(v.hasOwnProperty(l)?(null!=s&&"onScroll"===l&&Go("scroll",n),i||c===s||(i=[])):(i=i||[]).push(l,s))}t&&(i=i||[]).push("style",t);var l=i;(e.updateQueue=l)&&(e.flags|=4)}},jv=function(n,e,t,o){t!==o&&(e.flags|=4)};var Zv=!1,Qv=!1,Jv="function"===typeof WeakSet?WeakSet:Set,Kv=null;function $v(n,e){var t=n.ref;if(null!==t)if("function"===typeof t)try{t(null)}catch(o){Ss(n,e,o)}else t.current=null}function nc(n,e,t){try{t()}catch(o){Ss(n,e,o)}}var ec=!1;function tc(n,e,t){var o=e.updateQueue;if(null!==(o=null!==o?o.lastEffect:null)){var r=o=o.next;do{if((r.tag&n)===n){var a=r.destroy;r.destroy=void 0,void 0!==a&&nc(e,t,a)}r=r.next}while(r!==o)}}function oc(n,e){if(null!==(e=null!==(e=e.updateQueue)?e.lastEffect:null)){var t=e=e.next;do{if((t.tag&n)===n){var o=t.create;t.destroy=o()}t=t.next}while(t!==e)}}function rc(n){var e=n.ref;if(null!==e){var t=n.stateNode;n.tag,n=t,"function"===typeof e?e(n):e.current=n}}function ac(n){var e=n.alternate;null!==e&&(n.alternate=null,ac(e)),n.child=null,n.deletions=null,n.sibling=null,5===n.tag&&(null!==(e=n.stateNode)&&(delete e[pr],delete e[mr],delete e[hr],delete e[xr],delete e[gr])),n.stateNode=null,n.return=null,n.dependencies=null,n.memoizedProps=null,n.memoizedState=null,n.pendingProps=null,n.stateNode=null,n.updateQueue=null}function ic(n){return 5===n.tag||3===n.tag||4===n.tag}function vc(n){n:for(;;){for(;null===n.sibling;){if(null===n.return||ic(n.return))return null;n=n.return}for(n.sibling.return=n.return,n=n.sibling;5!==n.tag&&6!==n.tag&&18!==n.tag;){if(2&n.flags)continue n;if(null===n.child||4===n.tag)continue n;n.child.return=n,n=n.child}if(!(2&n.flags))return n.stateNode}}function cc(n,e,t){var o=n.tag;if(5===o||6===o)n=n.stateNode,e?8===t.nodeType?t.parentNode.insertBefore(n,e):t.insertBefore(n,e):(8===t.nodeType?(e=t.parentNode).insertBefore(n,t):(e=t).appendChild(n),null!==(t=t._reactRootContainer)&&void 0!==t||null!==e.onclick||(e.onclick=nr));else if(4!==o&&null!==(n=n.child))for(cc(n,e,t),n=n.sibling;null!==n;)cc(n,e,t),n=n.sibling}function sc(n,e,t){var o=n.tag;if(5===o||6===o)n=n.stateNode,e?t.insertBefore(n,e):t.appendChild(n);else if(4!==o&&null!==(n=n.child))for(sc(n,e,t),n=n.sibling;null!==n;)sc(n,e,t),n=n.sibling}var lc=null,uc=!1;function fc(n,e,t){for(t=t.child;null!==t;)pc(n,e,t),t=t.sibling}function pc(n,e,t){if(ie&&"function"===typeof ie.onCommitFiberUnmount)try{ie.onCommitFiberUnmount(ae,t)}catch(v){}switch(t.tag){case 5:Qv||$v(t,e);case 6:var o=lc,r=uc;lc=null,fc(n,e,t),uc=r,null!==(lc=o)&&(uc?(n=lc,t=t.stateNode,8===n.nodeType?n.parentNode.removeChild(t):n.removeChild(t)):lc.removeChild(t.stateNode));break;case 18:null!==lc&&(uc?(n=lc,t=t.stateNode,8===n.nodeType?sr(n.parentNode,t):1===n.nodeType&&sr(n,t),qe(n)):sr(lc,t.stateNode));break;case 4:o=lc,r=uc,lc=t.stateNode.containerInfo,uc=!0,fc(n,e,t),lc=o,uc=r;break;case 0:case 11:case 14:case 15:if(!Qv&&(null!==(o=t.updateQueue)&&null!==(o=o.lastEffect))){r=o=o.next;do{var a=r,i=a.destroy;a=a.tag,void 0!==i&&(0!==(2&a)||0!==(4&a))&&nc(t,e,i),r=r.next}while(r!==o)}fc(n,e,t);break;case 1:if(!Qv&&($v(t,e),"function"===typeof(o=t.stateNode).componentWillUnmount))try{o.props=t.memoizedProps,o.state=t.memoizedState,o.componentWillUnmount()}catch(v){Ss(t,e,v)}fc(n,e,t);break;case 21:fc(n,e,t);break;case 22:1&t.mode?(Qv=(o=Qv)||null!==t.memoizedState,fc(n,e,t),Qv=o):fc(n,e,t);break;default:fc(n,e,t)}}function mc(n){var e=n.updateQueue;if(null!==e){n.updateQueue=null;var t=n.stateNode;null===t&&(t=n.stateNode=new Jv),e.forEach((function(e){var o=Cs.bind(null,n,e);t.has(e)||(t.add(e),e.then(o,o))}))}}function dc(n,e){var t=e.deletions;if(null!==t)for(var o=0;o<t.length;o++){var r=t[o];try{var i=n,v=e,c=v;n:for(;null!==c;){switch(c.tag){case 5:lc=c.stateNode,uc=!1;break n;case 3:case 4:lc=c.stateNode.containerInfo,uc=!0;break n}c=c.return}if(null===lc)throw Error(a(160));pc(i,v,r),lc=null,uc=!1;var s=r.alternate;null!==s&&(s.return=null),r.return=null}catch(l){Ss(r,e,l)}}if(12854&e.subtreeFlags)for(e=e.child;null!==e;)hc(e,n),e=e.sibling}function hc(n,e){var t=n.alternate,o=n.flags;switch(n.tag){case 0:case 11:case 14:case 15:if(dc(e,n),xc(n),4&o){try{tc(3,n,n.return),oc(3,n)}catch(h){Ss(n,n.return,h)}try{tc(5,n,n.return)}catch(h){Ss(n,n.return,h)}}break;case 1:dc(e,n),xc(n),512&o&&null!==t&&$v(t,t.return);break;case 5:if(dc(e,n),xc(n),512&o&&null!==t&&$v(t,t.return),32&n.flags){var r=n.stateNode;try{pn(r,"")}catch(h){Ss(n,n.return,h)}}if(4&o&&null!=(r=n.stateNode)){var i=n.memoizedProps,v=null!==t?t.memoizedProps:i,c=n.type,s=n.updateQueue;if(n.updateQueue=null,null!==s)try{"input"===c&&"radio"===i.type&&null!=i.name&&J(r,i),bn(c,v);var l=bn(c,i);for(v=0;v<s.length;v+=2){var u=s[v],f=s[v+1];"style"===u?xn(r,f):"dangerouslySetInnerHTML"===u?fn(r,f):"children"===u?pn(r,f):y(r,u,f,l)}switch(c){case"input":K(r,i);break;case"textarea":an(r,i);break;case"select":var p=r._wrapperState.wasMultiple;r._wrapperState.wasMultiple=!!i.multiple;var m=i.value;null!=m?tn(r,!!i.multiple,m,!1):p!==!!i.multiple&&(null!=i.defaultValue?tn(r,!!i.multiple,i.defaultValue,!0):tn(r,!!i.multiple,i.multiple?[]:"",!1))}r[mr]=i}catch(h){Ss(n,n.return,h)}}break;case 6:if(dc(e,n),xc(n),4&o){if(null===n.stateNode)throw Error(a(162));r=n.stateNode,i=n.memoizedProps;try{r.nodeValue=i}catch(h){Ss(n,n.return,h)}}break;case 3:if(dc(e,n),xc(n),4&o&&null!==t&&t.memoizedState.isDehydrated)try{qe(e.containerInfo)}catch(h){Ss(n,n.return,h)}break;case 4:default:dc(e,n),xc(n);break;case 13:dc(e,n),xc(n),8192&(r=n.child).flags&&(i=null!==r.memoizedState,r.stateNode.isHidden=i,!i||null!==r.alternate&&null!==r.alternate.memoizedState||(Nc=Kn())),4&o&&mc(n);break;case 22:if(u=null!==t&&null!==t.memoizedState,1&n.mode?(Qv=(l=Qv)||u,dc(e,n),Qv=l):dc(e,n),xc(n),8192&o){if(l=null!==n.memoizedState,(n.stateNode.isHidden=l)&&!u&&0!==(1&n.mode))for(Kv=n,u=n.child;null!==u;){for(f=Kv=u;null!==Kv;){switch(m=(p=Kv).child,p.tag){case 0:case 11:case 14:case 15:tc(4,p,p.return);break;case 1:$v(p,p.return);var d=p.stateNode;if("function"===typeof d.componentWillUnmount){o=p,t=p.return;try{e=o,d.props=e.memoizedProps,d.state=e.memoizedState,d.componentWillUnmount()}catch(h){Ss(o,t,h)}}break;case 5:$v(p,p.return);break;case 22:if(null!==p.memoizedState){Uc(f);continue}}null!==m?(m.return=p,Kv=m):Uc(f)}u=u.sibling}n:for(u=null,f=n;;){if(5===f.tag){if(null===u){u=f;try{r=f.stateNode,l?"function"===typeof(i=r.style).setProperty?i.setProperty("display","none","important"):i.display="none":(c=f.stateNode,v=void 0!==(s=f.memoizedProps.style)&&null!==s&&s.hasOwnProperty("display")?s.display:null,c.style.display=hn("display",v))}catch(h){Ss(n,n.return,h)}}}else if(6===f.tag){if(null===u)try{f.stateNode.nodeValue=l?"":f.memoizedProps}catch(h){Ss(n,n.return,h)}}else if((22!==f.tag&&23!==f.tag||null===f.memoizedState||f===n)&&null!==f.child){f.child.return=f,f=f.child;continue}if(f===n)break n;for(;null===f.sibling;){if(null===f.return||f.return===n)break n;u===f&&(u=null),f=f.return}u===f&&(u=null),f.sibling.return=f.return,f=f.sibling}}break;case 19:dc(e,n),xc(n),4&o&&mc(n);case 21:}}function xc(n){var e=n.flags;if(2&e){try{n:{for(var t=n.return;null!==t;){if(ic(t)){var o=t;break n}t=t.return}throw Error(a(160))}switch(o.tag){case 5:var r=o.stateNode;32&o.flags&&(pn(r,""),o.flags&=-33),sc(n,vc(n),r);break;case 3:case 4:var i=o.stateNode.containerInfo;cc(n,vc(n),i);break;default:throw Error(a(161))}}catch(v){Ss(n,n.return,v)}n.flags&=-3}4096&e&&(n.flags&=-4097)}function gc(n,e,t){Kv=n,yc(n,e,t)}function yc(n,e,t){for(var o=0!==(1&n.mode);null!==Kv;){var r=Kv,a=r.child;if(22===r.tag&&o){var i=null!==r.memoizedState||Zv;if(!i){var v=r.alternate,c=null!==v&&null!==v.memoizedState||Qv;v=Zv;var s=Qv;if(Zv=i,(Qv=c)&&!s)for(Kv=r;null!==Kv;)c=(i=Kv).child,22===i.tag&&null!==i.memoizedState?_c(r):null!==c?(c.return=i,Kv=c):_c(r);for(;null!==a;)Kv=a,yc(a,e,t),a=a.sibling;Kv=r,Zv=v,Qv=s}bc(n)}else 0!==(8772&r.subtreeFlags)&&null!==a?(a.return=r,Kv=a):bc(n)}}function bc(n){for(;null!==Kv;){var e=Kv;if(0!==(8772&e.flags)){var t=e.alternate;try{if(0!==(8772&e.flags))switch(e.tag){case 0:case 11:case 15:Qv||oc(5,e);break;case 1:var o=e.stateNode;if(4&e.flags&&!Qv)if(null===t)o.componentDidMount();else{var r=e.elementType===e.type?t.memoizedProps:xa(e.type,t.memoizedProps);o.componentDidUpdate(r,t.memoizedState,o.__reactInternalSnapshotBeforeUpdate)}var i=e.updateQueue;null!==i&&La(e,i,o);break;case 3:var v=e.updateQueue;if(null!==v){if(t=null,null!==e.child)switch(e.child.tag){case 5:case 1:t=e.child.stateNode}La(e,v,t)}break;case 5:var c=e.stateNode;if(null===t&&4&e.flags){t=c;var s=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":s.autoFocus&&t.focus();break;case"img":s.src&&(t.src=s.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===e.memoizedState){var l=e.alternate;if(null!==l){var u=l.memoizedState;if(null!==u){var f=u.dehydrated;null!==f&&qe(f)}}}break;default:throw Error(a(163))}Qv||512&e.flags&&rc(e)}catch(p){Ss(e,e.return,p)}}if(e===n){Kv=null;break}if(null!==(t=e.sibling)){t.return=e.return,Kv=t;break}Kv=e.return}}function Uc(n){for(;null!==Kv;){var e=Kv;if(e===n){Kv=null;break}var t=e.sibling;if(null!==t){t.return=e.return,Kv=t;break}Kv=e.return}}function _c(n){for(;null!==Kv;){var e=Kv;try{switch(e.tag){case 0:case 11:case 15:var t=e.return;try{oc(4,e)}catch(c){Ss(e,t,c)}break;case 1:var o=e.stateNode;if("function"===typeof o.componentDidMount){var r=e.return;try{o.componentDidMount()}catch(c){Ss(e,r,c)}}var a=e.return;try{rc(e)}catch(c){Ss(e,a,c)}break;case 5:var i=e.return;try{rc(e)}catch(c){Ss(e,i,c)}}}catch(c){Ss(e,e.return,c)}if(e===n){Kv=null;break}var v=e.sibling;if(null!==v){v.return=e.return,Kv=v;break}Kv=e.return}}var wc,Sc=Math.ceil,Mc=b.ReactCurrentDispatcher,kc=b.ReactCurrentOwner,zc=b.ReactCurrentBatchConfig,Cc=0,Tc=null,Rc=null,Dc=0,Pc=0,Fc=Mr(0),jc=0,Ic=null,Ec=0,Oc=0,Ac=0,Lc=null,Gc=null,Nc=0,Bc=1/0,qc=null,Vc=!1,Wc=null,Hc=null,Xc=!1,Yc=null,Zc=0,Qc=0,Jc=null,Kc=-1,$c=0;function ns(){return 0!==(6&Cc)?Kn():-1!==Kc?Kc:Kc=Kn()}function es(n){return 0===(1&n.mode)?1:0!==(2&Cc)&&0!==Dc?Dc&-Dc:null!==ha.transition?(0===$c&&($c=he()),$c):0!==(n=be)?n:n=void 0===(n=window.event)?16:Je(n.type)}function ts(n,e,t,o){if(50<Qc)throw Qc=0,Jc=null,Error(a(185));ge(n,t,o),0!==(2&Cc)&&n===Tc||(n===Tc&&(0===(2&Cc)&&(Oc|=t),4===jc&&vs(n,Dc)),os(n,o),1===t&&0===Cc&&0===(1&e.mode)&&(Bc=Kn()+500,Gr&&qr()))}function os(n,e){var t=n.callbackNode;!function(n,e){for(var t=n.suspendedLanes,o=n.pingedLanes,r=n.expirationTimes,a=n.pendingLanes;0<a;){var i=31-ve(a),v=1<<i,c=r[i];-1===c?0!==(v&t)&&0===(v&o)||(r[i]=me(v,e)):c<=e&&(n.expiredLanes|=v),a&=~v}}(n,e);var o=pe(n,n===Tc?Dc:0);if(0===o)null!==t&&Zn(t),n.callbackNode=null,n.callbackPriority=0;else if(e=o&-o,n.callbackPriority!==e){if(null!=t&&Zn(t),1===e)0===n.tag?function(n){Gr=!0,Br(n)}(cs.bind(null,n)):Br(cs.bind(null,n)),vr((function(){0===(6&Cc)&&qr()})),t=null;else{switch(Ue(o)){case 1:t=ne;break;case 4:t=ee;break;case 16:default:t=te;break;case 536870912:t=re}t=Ts(t,rs.bind(null,n))}n.callbackPriority=e,n.callbackNode=t}}function rs(n,e){if(Kc=-1,$c=0,0!==(6&Cc))throw Error(a(327));var t=n.callbackNode;if(_s()&&n.callbackNode!==t)return null;var o=pe(n,n===Tc?Dc:0);if(0===o)return null;if(0!==(30&o)||0!==(o&n.expiredLanes)||e)e=hs(n,o);else{e=o;var r=Cc;Cc|=2;var i=ms();for(Tc===n&&Dc===e||(qc=null,Bc=Kn()+500,fs(n,e));;)try{gs();break}catch(c){ps(n,c)}_a(),Mc.current=i,Cc=r,null!==Rc?e=0:(Tc=null,Dc=0,e=jc)}if(0!==e){if(2===e&&(0!==(r=de(n))&&(o=r,e=as(n,r))),1===e)throw t=Ic,fs(n,0),vs(n,o),os(n,Kn()),t;if(6===e)vs(n,o);else{if(r=n.current.alternate,0===(30&o)&&!function(n){for(var e=n;;){if(16384&e.flags){var t=e.updateQueue;if(null!==t&&null!==(t=t.stores))for(var o=0;o<t.length;o++){var r=t[o],a=r.getSnapshot;r=r.value;try{if(!vo(a(),r))return!1}catch(v){return!1}}}if(t=e.child,16384&e.subtreeFlags&&null!==t)t.return=e,e=t;else{if(e===n)break;for(;null===e.sibling;){if(null===e.return||e.return===n)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}(r)&&(2===(e=hs(n,o))&&(0!==(i=de(n))&&(o=i,e=as(n,i))),1===e))throw t=Ic,fs(n,0),vs(n,o),os(n,Kn()),t;switch(n.finishedWork=r,n.finishedLanes=o,e){case 0:case 1:throw Error(a(345));case 2:case 5:Us(n,Gc,qc);break;case 3:if(vs(n,o),(130023424&o)===o&&10<(e=Nc+500-Kn())){if(0!==pe(n,0))break;if(((r=n.suspendedLanes)&o)!==o){ns(),n.pingedLanes|=n.suspendedLanes&r;break}n.timeoutHandle=rr(Us.bind(null,n,Gc,qc),e);break}Us(n,Gc,qc);break;case 4:if(vs(n,o),(4194240&o)===o)break;for(e=n.eventTimes,r=-1;0<o;){var v=31-ve(o);i=1<<v,(v=e[v])>r&&(r=v),o&=~i}if(o=r,10<(o=(120>(o=Kn()-o)?120:480>o?480:1080>o?1080:1920>o?1920:3e3>o?3e3:4320>o?4320:1960*Sc(o/1960))-o)){n.timeoutHandle=rr(Us.bind(null,n,Gc,qc),o);break}Us(n,Gc,qc);break;default:throw Error(a(329))}}}return os(n,Kn()),n.callbackNode===t?rs.bind(null,n):null}function as(n,e){var t=Lc;return n.current.memoizedState.isDehydrated&&(fs(n,e).flags|=256),2!==(n=hs(n,e))&&(e=Gc,Gc=t,null!==e&&is(e)),n}function is(n){null===Gc?Gc=n:Gc.push.apply(Gc,n)}function vs(n,e){for(e&=~Ac,e&=~Oc,n.suspendedLanes|=e,n.pingedLanes&=~e,n=n.expirationTimes;0<e;){var t=31-ve(e),o=1<<t;n[t]=-1,e&=~o}}function cs(n){if(0!==(6&Cc))throw Error(a(327));_s();var e=pe(n,0);if(0===(1&e))return os(n,Kn()),null;var t=hs(n,e);if(0!==n.tag&&2===t){var o=de(n);0!==o&&(e=o,t=as(n,o))}if(1===t)throw t=Ic,fs(n,0),vs(n,e),os(n,Kn()),t;if(6===t)throw Error(a(345));return n.finishedWork=n.current.alternate,n.finishedLanes=e,Us(n,Gc,qc),os(n,Kn()),null}function ss(n,e){var t=Cc;Cc|=1;try{return n(e)}finally{0===(Cc=t)&&(Bc=Kn()+500,Gr&&qr())}}function ls(n){null!==Yc&&0===Yc.tag&&0===(6&Cc)&&_s();var e=Cc;Cc|=1;var t=zc.transition,o=be;try{if(zc.transition=null,be=1,n)return n()}finally{be=o,zc.transition=t,0===(6&(Cc=e))&&qr()}}function us(){Pc=Fc.current,kr(Fc)}function fs(n,e){n.finishedWork=null,n.finishedLanes=0;var t=n.timeoutHandle;if(-1!==t&&(n.timeoutHandle=-1,ar(t)),null!==Rc)for(t=Rc.return;null!==t;){var o=t;switch(ta(o),o.tag){case 1:null!==(o=o.type.childContextTypes)&&void 0!==o&&jr();break;case 3:ai(),kr(Rr),kr(Tr),ui();break;case 5:vi(o);break;case 4:ai();break;case 13:case 19:kr(ci);break;case 10:wa(o.type._context);break;case 22:case 23:us()}t=t.return}if(Tc=n,Rc=n=Fs(n.current,null),Dc=Pc=e,jc=0,Ic=null,Ac=Oc=Ec=0,Gc=Lc=null,null!==za){for(e=0;e<za.length;e++)if(null!==(o=(t=za[e]).interleaved)){t.interleaved=null;var r=o.next,a=t.pending;if(null!==a){var i=a.next;a.next=r,o.next=i}t.pending=o}za=null}return n}function ps(n,e){for(;;){var t=Rc;try{if(_a(),fi.current=iv,gi){for(var o=di.memoizedState;null!==o;){var r=o.queue;null!==r&&(r.pending=null),o=o.next}gi=!1}if(mi=0,xi=hi=di=null,yi=!1,bi=0,kc.current=null,null===t||null===t.return){jc=1,Ic=e,Rc=null;break}n:{var i=n,v=t.return,c=t,s=e;if(e=Dc,c.flags|=32768,null!==s&&"object"===typeof s&&"function"===typeof s.then){var l=s,u=c,f=u.tag;if(0===(1&u.mode)&&(0===f||11===f||15===f)){var p=u.alternate;p?(u.updateQueue=p.updateQueue,u.memoizedState=p.memoizedState,u.lanes=p.lanes):(u.updateQueue=null,u.memoizedState=null)}var m=xv(v);if(null!==m){m.flags&=-257,gv(m,v,c,0,e),1&m.mode&&hv(i,l,e),s=l;var d=(e=m).updateQueue;if(null===d){var h=new Set;h.add(s),e.updateQueue=h}else d.add(s);break n}if(0===(1&e)){hv(i,l,e),ds();break n}s=Error(a(426))}else if(aa&&1&c.mode){var x=xv(v);if(null!==x){0===(65536&x.flags)&&(x.flags|=256),gv(x,v,c,0,e),da(lv(s,c));break n}}i=s=lv(s,c),4!==jc&&(jc=2),null===Lc?Lc=[i]:Lc.push(i),i=v;do{switch(i.tag){case 3:i.flags|=65536,e&=-e,i.lanes|=e,Oa(i,mv(0,s,e));break n;case 1:c=s;var g=i.type,y=i.stateNode;if(0===(128&i.flags)&&("function"===typeof g.getDerivedStateFromError||null!==y&&"function"===typeof y.componentDidCatch&&(null===Hc||!Hc.has(y)))){i.flags|=65536,e&=-e,i.lanes|=e,Oa(i,dv(i,c,e));break n}}i=i.return}while(null!==i)}bs(t)}catch(b){e=b,Rc===t&&null!==t&&(Rc=t=t.return);continue}break}}function ms(){var n=Mc.current;return Mc.current=iv,null===n?iv:n}function ds(){0!==jc&&3!==jc&&2!==jc||(jc=4),null===Tc||0===(268435455&Ec)&&0===(268435455&Oc)||vs(Tc,Dc)}function hs(n,e){var t=Cc;Cc|=2;var o=ms();for(Tc===n&&Dc===e||(qc=null,fs(n,e));;)try{xs();break}catch(r){ps(n,r)}if(_a(),Cc=t,Mc.current=o,null!==Rc)throw Error(a(261));return Tc=null,Dc=0,jc}function xs(){for(;null!==Rc;)ys(Rc)}function gs(){for(;null!==Rc&&!Qn();)ys(Rc)}function ys(n){var e=wc(n.alternate,n,Pc);n.memoizedProps=n.pendingProps,null===e?bs(n):Rc=e,kc.current=null}function bs(n){var e=n;do{var t=e.alternate;if(n=e.return,0===(32768&e.flags)){if(null!==(t=Xv(t,e,Pc)))return void(Rc=t)}else{if(null!==(t=Yv(t,e)))return t.flags&=32767,void(Rc=t);if(null===n)return jc=6,void(Rc=null);n.flags|=32768,n.subtreeFlags=0,n.deletions=null}if(null!==(e=e.sibling))return void(Rc=e);Rc=e=n}while(null!==e);0===jc&&(jc=5)}function Us(n,e,t){var o=be,r=zc.transition;try{zc.transition=null,be=1,function(n,e,t,o){do{_s()}while(null!==Yc);if(0!==(6&Cc))throw Error(a(327));t=n.finishedWork;var r=n.finishedLanes;if(null===t)return null;if(n.finishedWork=null,n.finishedLanes=0,t===n.current)throw Error(a(177));n.callbackNode=null,n.callbackPriority=0;var i=t.lanes|t.childLanes;if(function(n,e){var t=n.pendingLanes&~e;n.pendingLanes=e,n.suspendedLanes=0,n.pingedLanes=0,n.expiredLanes&=e,n.mutableReadLanes&=e,n.entangledLanes&=e,e=n.entanglements;var o=n.eventTimes;for(n=n.expirationTimes;0<t;){var r=31-ve(t),a=1<<r;e[r]=0,o[r]=-1,n[r]=-1,t&=~a}}(n,i),n===Tc&&(Rc=Tc=null,Dc=0),0===(2064&t.subtreeFlags)&&0===(2064&t.flags)||Xc||(Xc=!0,Ts(te,(function(){return _s(),null}))),i=0!==(15990&t.flags),0!==(15990&t.subtreeFlags)||i){i=zc.transition,zc.transition=null;var v=be;be=1;var c=Cc;Cc|=4,kc.current=null,function(n,e){if(er=We,po(n=fo())){if("selectionStart"in n)var t={start:n.selectionStart,end:n.selectionEnd};else n:{var o=(t=(t=n.ownerDocument)&&t.defaultView||window).getSelection&&t.getSelection();if(o&&0!==o.rangeCount){t=o.anchorNode;var r=o.anchorOffset,i=o.focusNode;o=o.focusOffset;try{t.nodeType,i.nodeType}catch(U){t=null;break n}var v=0,c=-1,s=-1,l=0,u=0,f=n,p=null;e:for(;;){for(var m;f!==t||0!==r&&3!==f.nodeType||(c=v+r),f!==i||0!==o&&3!==f.nodeType||(s=v+o),3===f.nodeType&&(v+=f.nodeValue.length),null!==(m=f.firstChild);)p=f,f=m;for(;;){if(f===n)break e;if(p===t&&++l===r&&(c=v),p===i&&++u===o&&(s=v),null!==(m=f.nextSibling))break;p=(f=p).parentNode}f=m}t=-1===c||-1===s?null:{start:c,end:s}}else t=null}t=t||{start:0,end:0}}else t=null;for(tr={focusedElem:n,selectionRange:t},We=!1,Kv=e;null!==Kv;)if(n=(e=Kv).child,0!==(1028&e.subtreeFlags)&&null!==n)n.return=e,Kv=n;else for(;null!==Kv;){e=Kv;try{var d=e.alternate;if(0!==(1024&e.flags))switch(e.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==d){var h=d.memoizedProps,x=d.memoizedState,g=e.stateNode,y=g.getSnapshotBeforeUpdate(e.elementType===e.type?h:xa(e.type,h),x);g.__reactInternalSnapshotBeforeUpdate=y}break;case 3:var b=e.stateNode.containerInfo;1===b.nodeType?b.textContent="":9===b.nodeType&&b.documentElement&&b.removeChild(b.documentElement);break;default:throw Error(a(163))}}catch(U){Ss(e,e.return,U)}if(null!==(n=e.sibling)){n.return=e.return,Kv=n;break}Kv=e.return}d=ec,ec=!1}(n,t),hc(t,n),mo(tr),We=!!er,tr=er=null,n.current=t,gc(t,n,r),Jn(),Cc=c,be=v,zc.transition=i}else n.current=t;if(Xc&&(Xc=!1,Yc=n,Zc=r),0===(i=n.pendingLanes)&&(Hc=null),function(n){if(ie&&"function"===typeof ie.onCommitFiberRoot)try{ie.onCommitFiberRoot(ae,n,void 0,128===(128&n.current.flags))}catch(e){}}(t.stateNode),os(n,Kn()),null!==e)for(o=n.onRecoverableError,t=0;t<e.length;t++)o((r=e[t]).value,{componentStack:r.stack,digest:r.digest});if(Vc)throw Vc=!1,n=Wc,Wc=null,n;0!==(1&Zc)&&0!==n.tag&&_s(),0!==(1&(i=n.pendingLanes))?n===Jc?Qc++:(Qc=0,Jc=n):Qc=0,qr()}(n,e,t,o)}finally{zc.transition=r,be=o}return null}function _s(){if(null!==Yc){var n=Ue(Zc),e=zc.transition,t=be;try{if(zc.transition=null,be=16>n?16:n,null===Yc)var o=!1;else{if(n=Yc,Yc=null,Zc=0,0!==(6&Cc))throw Error(a(331));var r=Cc;for(Cc|=4,Kv=n.current;null!==Kv;){var i=Kv,v=i.child;if(0!==(16&Kv.flags)){var c=i.deletions;if(null!==c){for(var s=0;s<c.length;s++){var l=c[s];for(Kv=l;null!==Kv;){var u=Kv;switch(u.tag){case 0:case 11:case 15:tc(8,u,i)}var f=u.child;if(null!==f)f.return=u,Kv=f;else for(;null!==Kv;){var p=(u=Kv).sibling,m=u.return;if(ac(u),u===l){Kv=null;break}if(null!==p){p.return=m,Kv=p;break}Kv=m}}}var d=i.alternate;if(null!==d){var h=d.child;if(null!==h){d.child=null;do{var x=h.sibling;h.sibling=null,h=x}while(null!==h)}}Kv=i}}if(0!==(2064&i.subtreeFlags)&&null!==v)v.return=i,Kv=v;else n:for(;null!==Kv;){if(0!==(2048&(i=Kv).flags))switch(i.tag){case 0:case 11:case 15:tc(9,i,i.return)}var g=i.sibling;if(null!==g){g.return=i.return,Kv=g;break n}Kv=i.return}}var y=n.current;for(Kv=y;null!==Kv;){var b=(v=Kv).child;if(0!==(2064&v.subtreeFlags)&&null!==b)b.return=v,Kv=b;else n:for(v=y;null!==Kv;){if(0!==(2048&(c=Kv).flags))try{switch(c.tag){case 0:case 11:case 15:oc(9,c)}}catch(_){Ss(c,c.return,_)}if(c===v){Kv=null;break n}var U=c.sibling;if(null!==U){U.return=c.return,Kv=U;break n}Kv=c.return}}if(Cc=r,qr(),ie&&"function"===typeof ie.onPostCommitFiberRoot)try{ie.onPostCommitFiberRoot(ae,n)}catch(_){}o=!0}return o}finally{be=t,zc.transition=e}}return!1}function ws(n,e,t){n=Ia(n,e=mv(0,e=lv(t,e),1),1),e=ns(),null!==n&&(ge(n,1,e),os(n,e))}function Ss(n,e,t){if(3===n.tag)ws(n,n,t);else for(;null!==e;){if(3===e.tag){ws(e,n,t);break}if(1===e.tag){var o=e.stateNode;if("function"===typeof e.type.getDerivedStateFromError||"function"===typeof o.componentDidCatch&&(null===Hc||!Hc.has(o))){e=Ia(e,n=dv(e,n=lv(t,n),1),1),n=ns(),null!==e&&(ge(e,1,n),os(e,n));break}}e=e.return}}function Ms(n,e,t){var o=n.pingCache;null!==o&&o.delete(e),e=ns(),n.pingedLanes|=n.suspendedLanes&t,Tc===n&&(Dc&t)===t&&(4===jc||3===jc&&(130023424&Dc)===Dc&&500>Kn()-Nc?fs(n,0):Ac|=t),os(n,e)}function ks(n,e){0===e&&(0===(1&n.mode)?e=1:(e=ue,0===(130023424&(ue<<=1))&&(ue=4194304)));var t=ns();null!==(n=Ra(n,e))&&(ge(n,e,t),os(n,t))}function zs(n){var e=n.memoizedState,t=0;null!==e&&(t=e.retryLane),ks(n,t)}function Cs(n,e){var t=0;switch(n.tag){case 13:var o=n.stateNode,r=n.memoizedState;null!==r&&(t=r.retryLane);break;case 19:o=n.stateNode;break;default:throw Error(a(314))}null!==o&&o.delete(e),ks(n,t)}function Ts(n,e){return Yn(n,e)}function Rs(n,e,t,o){this.tag=n,this.key=t,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=o,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ds(n,e,t,o){return new Rs(n,e,t,o)}function Ps(n){return!(!(n=n.prototype)||!n.isReactComponent)}function Fs(n,e){var t=n.alternate;return null===t?((t=Ds(n.tag,e,n.key,n.mode)).elementType=n.elementType,t.type=n.type,t.stateNode=n.stateNode,t.alternate=n,n.alternate=t):(t.pendingProps=e,t.type=n.type,t.flags=0,t.subtreeFlags=0,t.deletions=null),t.flags=14680064&n.flags,t.childLanes=n.childLanes,t.lanes=n.lanes,t.child=n.child,t.memoizedProps=n.memoizedProps,t.memoizedState=n.memoizedState,t.updateQueue=n.updateQueue,e=n.dependencies,t.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext},t.sibling=n.sibling,t.index=n.index,t.ref=n.ref,t}function js(n,e,t,o,r,i){var v=2;if(o=n,"function"===typeof n)Ps(n)&&(v=1);else if("string"===typeof n)v=5;else n:switch(n){case w:return Is(t.children,r,i,e);case S:v=8,r|=8;break;case M:return(n=Ds(12,t,e,2|r)).elementType=M,n.lanes=i,n;case T:return(n=Ds(13,t,e,r)).elementType=T,n.lanes=i,n;case R:return(n=Ds(19,t,e,r)).elementType=R,n.lanes=i,n;case F:return Es(t,r,i,e);default:if("object"===typeof n&&null!==n)switch(n.$$typeof){case k:v=10;break n;case z:v=9;break n;case C:v=11;break n;case D:v=14;break n;case P:v=16,o=null;break n}throw Error(a(130,null==n?n:typeof n,""))}return(e=Ds(v,t,e,r)).elementType=n,e.type=o,e.lanes=i,e}function Is(n,e,t,o){return(n=Ds(7,n,o,e)).lanes=t,n}function Es(n,e,t,o){return(n=Ds(22,n,o,e)).elementType=F,n.lanes=t,n.stateNode={isHidden:!1},n}function Os(n,e,t){return(n=Ds(6,n,null,e)).lanes=t,n}function As(n,e,t){return(e=Ds(4,null!==n.children?n.children:[],n.key,e)).lanes=t,e.stateNode={containerInfo:n.containerInfo,pendingChildren:null,implementation:n.implementation},e}function Ls(n,e,t,o,r){this.tag=e,this.containerInfo=n,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=xe(0),this.expirationTimes=xe(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=xe(0),this.identifierPrefix=o,this.onRecoverableError=r,this.mutableSourceEagerHydrationData=null}function Gs(n,e,t,o,r,a,i,v,c){return n=new Ls(n,e,t,v,c),1===e?(e=1,!0===a&&(e|=8)):e=0,a=Ds(3,null,null,e),n.current=a,a.stateNode=n,a.memoizedState={element:o,isDehydrated:t,cache:null,transitions:null,pendingSuspenseBoundaries:null},Pa(a),n}function Ns(n,e,t){var o=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:_,key:null==o?null:""+o,children:n,containerInfo:e,implementation:t}}function Bs(n){if(!n)return Cr;n:{if(qn(n=n._reactInternals)!==n||1!==n.tag)throw Error(a(170));var e=n;do{switch(e.tag){case 3:e=e.stateNode.context;break n;case 1:if(Fr(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break n}}e=e.return}while(null!==e);throw Error(a(171))}if(1===n.tag){var t=n.type;if(Fr(t))return Er(n,t,e)}return e}function qs(n,e,t,o,r,a,i,v,c){return(n=Gs(t,o,!0,n,0,a,0,v,c)).context=Bs(null),t=n.current,(a=ja(o=ns(),r=es(t))).callback=void 0!==e&&null!==e?e:null,Ia(t,a,r),n.current.lanes=r,ge(n,r,o),os(n,o),n}function Vs(n,e,t,o){var r=e.current,a=ns(),i=es(r);return t=Bs(t),null===e.context?e.context=t:e.pendingContext=t,(e=ja(a,i)).payload={element:n},null!==(o=void 0===o?null:o)&&(e.callback=o),null!==(n=Ia(r,e,i))&&(ts(n,r,i,a),Ea(n,r,i)),i}function Ws(n){return(n=n.current).child?(n.child.tag,n.child.stateNode):null}function Hs(n,e){if(null!==(n=n.memoizedState)&&null!==n.dehydrated){var t=n.retryLane;n.retryLane=0!==t&&t<e?t:e}}function Xs(n,e){Hs(n,e),(n=n.alternate)&&Hs(n,e)}wc=function(n,e,t){if(null!==n)if(n.memoizedProps!==e.pendingProps||Rr.current)bv=!0;else{if(0===(n.lanes&t)&&0===(128&e.flags))return bv=!1,function(n,e,t){switch(e.tag){case 3:Rv(e),ma();break;case 5:ii(e);break;case 1:Fr(e.type)&&Or(e);break;case 4:ri(e,e.stateNode.containerInfo);break;case 10:var o=e.type._context,r=e.memoizedProps.value;zr(ga,o._currentValue),o._currentValue=r;break;case 13:if(null!==(o=e.memoizedState))return null!==o.dehydrated?(zr(ci,1&ci.current),e.flags|=128,null):0!==(t&e.child.childLanes)?Ov(n,e,t):(zr(ci,1&ci.current),null!==(n=Vv(n,e,t))?n.sibling:null);zr(ci,1&ci.current);break;case 19:if(o=0!==(t&e.childLanes),0!==(128&n.flags)){if(o)return Bv(n,e,t);e.flags|=128}if(null!==(r=e.memoizedState)&&(r.rendering=null,r.tail=null,r.lastEffect=null),zr(ci,ci.current),o)break;return null;case 22:case 23:return e.lanes=0,Mv(n,e,t)}return Vv(n,e,t)}(n,e,t);bv=0!==(131072&n.flags)}else bv=!1,aa&&0!==(1048576&e.flags)&&na(e,Xr,e.index);switch(e.lanes=0,e.tag){case 2:var o=e.type;qv(n,e),n=e.pendingProps;var r=Pr(e,Tr.current);Ma(e,t),r=Si(null,e,o,n,r,t);var i=Mi();return e.flags|=1,"object"===typeof r&&null!==r&&"function"===typeof r.render&&void 0===r.$$typeof?(e.tag=1,e.memoizedState=null,e.updateQueue=null,Fr(o)?(i=!0,Or(e)):i=!1,e.memoizedState=null!==r.state&&void 0!==r.state?r.state:null,Pa(e),r.updater=Ba,e.stateNode=r,r._reactInternals=e,Ha(e,o,n,t),e=Tv(null,e,o,!0,i,t)):(e.tag=0,aa&&i&&ea(e),Uv(null,e,r,t),e=e.child),e;case 16:o=e.elementType;n:{switch(qv(n,e),n=e.pendingProps,o=(r=o._init)(o._payload),e.type=o,r=e.tag=function(n){if("function"===typeof n)return Ps(n)?1:0;if(void 0!==n&&null!==n){if((n=n.$$typeof)===C)return 11;if(n===D)return 14}return 2}(o),n=xa(o,n),r){case 0:e=zv(null,e,o,n,t);break n;case 1:e=Cv(null,e,o,n,t);break n;case 11:e=_v(null,e,o,n,t);break n;case 14:e=wv(null,e,o,xa(o.type,n),t);break n}throw Error(a(306,o,""))}return e;case 0:return o=e.type,r=e.pendingProps,zv(n,e,o,r=e.elementType===o?r:xa(o,r),t);case 1:return o=e.type,r=e.pendingProps,Cv(n,e,o,r=e.elementType===o?r:xa(o,r),t);case 3:n:{if(Rv(e),null===n)throw Error(a(387));o=e.pendingProps,r=(i=e.memoizedState).element,Fa(n,e),Aa(e,o,null,t);var v=e.memoizedState;if(o=v.element,i.isDehydrated){if(i={element:o,isDehydrated:!1,cache:v.cache,pendingSuspenseBoundaries:v.pendingSuspenseBoundaries,transitions:v.transitions},e.updateQueue.baseState=i,e.memoizedState=i,256&e.flags){e=Dv(n,e,o,t,r=lv(Error(a(423)),e));break n}if(o!==r){e=Dv(n,e,o,t,r=lv(Error(a(424)),e));break n}for(ra=lr(e.stateNode.containerInfo.firstChild),oa=e,aa=!0,ia=null,t=Ka(e,null,o,t),e.child=t;t;)t.flags=-3&t.flags|4096,t=t.sibling}else{if(ma(),o===r){e=Vv(n,e,t);break n}Uv(n,e,o,t)}e=e.child}return e;case 5:return ii(e),null===n&&la(e),o=e.type,r=e.pendingProps,i=null!==n?n.memoizedProps:null,v=r.children,or(o,r)?v=null:null!==i&&or(o,i)&&(e.flags|=32),kv(n,e),Uv(n,e,v,t),e.child;case 6:return null===n&&la(e),null;case 13:return Ov(n,e,t);case 4:return ri(e,e.stateNode.containerInfo),o=e.pendingProps,null===n?e.child=Ja(e,null,o,t):Uv(n,e,o,t),e.child;case 11:return o=e.type,r=e.pendingProps,_v(n,e,o,r=e.elementType===o?r:xa(o,r),t);case 7:return Uv(n,e,e.pendingProps,t),e.child;case 8:case 12:return Uv(n,e,e.pendingProps.children,t),e.child;case 10:n:{if(o=e.type._context,r=e.pendingProps,i=e.memoizedProps,v=r.value,zr(ga,o._currentValue),o._currentValue=v,null!==i)if(vo(i.value,v)){if(i.children===r.children&&!Rr.current){e=Vv(n,e,t);break n}}else for(null!==(i=e.child)&&(i.return=e);null!==i;){var c=i.dependencies;if(null!==c){v=i.child;for(var s=c.firstContext;null!==s;){if(s.context===o){if(1===i.tag){(s=ja(-1,t&-t)).tag=2;var l=i.updateQueue;if(null!==l){var u=(l=l.shared).pending;null===u?s.next=s:(s.next=u.next,u.next=s),l.pending=s}}i.lanes|=t,null!==(s=i.alternate)&&(s.lanes|=t),Sa(i.return,t,e),c.lanes|=t;break}s=s.next}}else if(10===i.tag)v=i.type===e.type?null:i.child;else if(18===i.tag){if(null===(v=i.return))throw Error(a(341));v.lanes|=t,null!==(c=v.alternate)&&(c.lanes|=t),Sa(v,t,e),v=i.sibling}else v=i.child;if(null!==v)v.return=i;else for(v=i;null!==v;){if(v===e){v=null;break}if(null!==(i=v.sibling)){i.return=v.return,v=i;break}v=v.return}i=v}Uv(n,e,r.children,t),e=e.child}return e;case 9:return r=e.type,o=e.pendingProps.children,Ma(e,t),o=o(r=ka(r)),e.flags|=1,Uv(n,e,o,t),e.child;case 14:return r=xa(o=e.type,e.pendingProps),wv(n,e,o,r=xa(o.type,r),t);case 15:return Sv(n,e,e.type,e.pendingProps,t);case 17:return o=e.type,r=e.pendingProps,r=e.elementType===o?r:xa(o,r),qv(n,e),e.tag=1,Fr(o)?(n=!0,Or(e)):n=!1,Ma(e,t),Va(e,o,r),Ha(e,o,r,t),Tv(null,e,o,!0,n,t);case 19:return Bv(n,e,t);case 22:return Mv(n,e,t)}throw Error(a(156,e.tag))};var Ys="function"===typeof reportError?reportError:function(n){console.error(n)};function Zs(n){this._internalRoot=n}function Qs(n){this._internalRoot=n}function Js(n){return!(!n||1!==n.nodeType&&9!==n.nodeType&&11!==n.nodeType)}function Ks(n){return!(!n||1!==n.nodeType&&9!==n.nodeType&&11!==n.nodeType&&(8!==n.nodeType||" react-mount-point-unstable "!==n.nodeValue))}function $s(){}function nl(n,e,t,o,r){var a=t._reactRootContainer;if(a){var i=a;if("function"===typeof r){var v=r;r=function(){var n=Ws(i);v.call(n)}}Vs(e,i,n,r)}else i=function(n,e,t,o,r){if(r){if("function"===typeof o){var a=o;o=function(){var n=Ws(i);a.call(n)}}var i=qs(e,o,n,0,null,!1,0,"",$s);return n._reactRootContainer=i,n[dr]=i.current,qo(8===n.nodeType?n.parentNode:n),ls(),i}for(;r=n.lastChild;)n.removeChild(r);if("function"===typeof o){var v=o;o=function(){var n=Ws(c);v.call(n)}}var c=Gs(n,0,!1,null,0,!1,0,"",$s);return n._reactRootContainer=c,n[dr]=c.current,qo(8===n.nodeType?n.parentNode:n),ls((function(){Vs(e,c,t,o)})),c}(t,e,n,r,o);return Ws(i)}Qs.prototype.render=Zs.prototype.render=function(n){var e=this._internalRoot;if(null===e)throw Error(a(409));Vs(n,e,null,null)},Qs.prototype.unmount=Zs.prototype.unmount=function(){var n=this._internalRoot;if(null!==n){this._internalRoot=null;var e=n.containerInfo;ls((function(){Vs(null,n,null,null)})),e[dr]=null}},Qs.prototype.unstable_scheduleHydration=function(n){if(n){var e=Me();n={blockedOn:null,target:n,priority:e};for(var t=0;t<je.length&&0!==e&&e<je[t].priority;t++);je.splice(t,0,n),0===t&&Ae(n)}},_e=function(n){switch(n.tag){case 3:var e=n.stateNode;if(e.current.memoizedState.isDehydrated){var t=fe(e.pendingLanes);0!==t&&(ye(e,1|t),os(e,Kn()),0===(6&Cc)&&(Bc=Kn()+500,qr()))}break;case 13:ls((function(){var e=Ra(n,1);if(null!==e){var t=ns();ts(e,n,1,t)}})),Xs(n,1)}},we=function(n){if(13===n.tag){var e=Ra(n,134217728);if(null!==e)ts(e,n,134217728,ns());Xs(n,134217728)}},Se=function(n){if(13===n.tag){var e=es(n),t=Ra(n,e);if(null!==t)ts(t,n,e,ns());Xs(n,e)}},Me=function(){return be},ke=function(n,e){var t=be;try{return be=n,e()}finally{be=t}},wn=function(n,e,t){switch(e){case"input":if(K(n,t),e=t.name,"radio"===t.type&&null!=e){for(t=n;t.parentNode;)t=t.parentNode;for(t=t.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<t.length;e++){var o=t[e];if(o!==n&&o.form===n.form){var r=_r(o);if(!r)throw Error(a(90));X(o),K(o,r)}}}break;case"textarea":an(n,t);break;case"select":null!=(e=t.value)&&tn(n,!!t.multiple,e,!1)}},Tn=ss,Rn=ls;var el={usingClientEntryPoint:!1,Events:[br,Ur,_r,zn,Cn,ss]},tl={findFiberByHostInstance:yr,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},ol={bundleType:tl.bundleType,version:tl.version,rendererPackageName:tl.rendererPackageName,rendererConfig:tl.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:b.ReactCurrentDispatcher,findHostInstanceByFiber:function(n){return null===(n=Hn(n))?null:n.stateNode},findFiberByHostInstance:tl.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var rl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!rl.isDisabled&&rl.supportsFiber)try{ae=rl.inject(ol),ie=rl}catch(un){}}e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=el,e.createPortal=function(n,e){var t=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Js(e))throw Error(a(200));return Ns(n,e,null,t)},e.createRoot=function(n,e){if(!Js(n))throw Error(a(299));var t=!1,o="",r=Ys;return null!==e&&void 0!==e&&(!0===e.unstable_strictMode&&(t=!0),void 0!==e.identifierPrefix&&(o=e.identifierPrefix),void 0!==e.onRecoverableError&&(r=e.onRecoverableError)),e=Gs(n,1,!1,null,0,t,0,o,r),n[dr]=e.current,qo(8===n.nodeType?n.parentNode:n),new Zs(e)},e.findDOMNode=function(n){if(null==n)return null;if(1===n.nodeType)return n;var e=n._reactInternals;if(void 0===e){if("function"===typeof n.render)throw Error(a(188));throw n=Object.keys(n).join(","),Error(a(268,n))}return n=null===(n=Hn(e))?null:n.stateNode},e.flushSync=function(n){return ls(n)},e.hydrate=function(n,e,t){if(!Ks(e))throw Error(a(200));return nl(null,n,e,!0,t)},e.hydrateRoot=function(n,e,t){if(!Js(n))throw Error(a(405));var o=null!=t&&t.hydratedSources||null,r=!1,i="",v=Ys;if(null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(r=!0),void 0!==t.identifierPrefix&&(i=t.identifierPrefix),void 0!==t.onRecoverableError&&(v=t.onRecoverableError)),e=qs(e,null,n,1,null!=t?t:null,r,0,i,v),n[dr]=e.current,qo(n),o)for(n=0;n<o.length;n++)r=(r=(t=o[n])._getVersion)(t._source),null==e.mutableSourceEagerHydrationData?e.mutableSourceEagerHydrationData=[t,r]:e.mutableSourceEagerHydrationData.push(t,r);return new Qs(e)},e.render=function(n,e,t){if(!Ks(e))throw Error(a(200));return nl(null,n,e,!1,t)},e.unmountComponentAtNode=function(n){if(!Ks(n))throw Error(a(40));return!!n._reactRootContainer&&(ls((function(){nl(null,null,n,!1,(function(){n._reactRootContainer=null,n[dr]=null}))})),!0)},e.unstable_batchedUpdates=ss,e.unstable_renderSubtreeIntoContainer=function(n,e,t,o){if(!Ks(t))throw Error(a(200));if(null==n||void 0===n._reactInternals)throw Error(a(38));return nl(n,e,t,!1,o)},e.version="18.2.0-next-9e3b772b8-20220608"},250:function(n,e,t){"use strict";var o=t(164);e.s=o.createRoot,o.hydrateRoot},164:function(n,e,t){"use strict";!function n(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}(),n.exports=t(463)},976:function(n,e){"use strict";e.ConcurrentRoot=1,e.ContinuousEventPriority=4,e.DefaultEventPriority=16,e.DiscreteEventPriority=1},721:function(n,e,t){n.exports=function(n){var e={},o=t(791),r=t(100),a=Object.assign;function i(n){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+n,t=1;t<arguments.length;t++)e+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+n+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var v=o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,c=Symbol.for("react.element"),s=Symbol.for("react.portal"),l=Symbol.for("react.fragment"),u=Symbol.for("react.strict_mode"),f=Symbol.for("react.profiler"),p=Symbol.for("react.provider"),m=Symbol.for("react.context"),d=Symbol.for("react.forward_ref"),h=Symbol.for("react.suspense"),x=Symbol.for("react.suspense_list"),g=Symbol.for("react.memo"),y=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var b=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var U=Symbol.iterator;function _(n){return null===n||"object"!==typeof n?null:"function"===typeof(n=U&&n[U]||n["@@iterator"])?n:null}function w(n){if(null==n)return null;if("function"===typeof n)return n.displayName||n.name||null;if("string"===typeof n)return n;switch(n){case l:return"Fragment";case s:return"Portal";case f:return"Profiler";case u:return"StrictMode";case h:return"Suspense";case x:return"SuspenseList"}if("object"===typeof n)switch(n.$$typeof){case m:return(n.displayName||"Context")+".Consumer";case p:return(n._context.displayName||"Context")+".Provider";case d:var e=n.render;return(n=n.displayName)||(n=""!==(n=e.displayName||e.name||"")?"ForwardRef("+n+")":"ForwardRef"),n;case g:return null!==(e=n.displayName||null)?e:w(n.type)||"Memo";case y:e=n._payload,n=n._init;try{return w(n(e))}catch(t){}}return null}function S(n){var e=n.type;switch(n.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return n=(n=e.render).displayName||n.name||"",e.displayName||(""!==n?"ForwardRef("+n+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return w(e);case 8:return e===u?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e}return null}function M(n){var e=n,t=n;if(n.alternate)for(;e.return;)e=e.return;else{n=e;do{0!==(4098&(e=n).flags)&&(t=e.return),n=e.return}while(n)}return 3===e.tag?t:null}function k(n){if(M(n)!==n)throw Error(i(188))}function z(n){var e=n.alternate;if(!e){if(null===(e=M(n)))throw Error(i(188));return e!==n?null:n}for(var t=n,o=e;;){var r=t.return;if(null===r)break;var a=r.alternate;if(null===a){if(null!==(o=r.return)){t=o;continue}break}if(r.child===a.child){for(a=r.child;a;){if(a===t)return k(r),n;if(a===o)return k(r),e;a=a.sibling}throw Error(i(188))}if(t.return!==o.return)t=r,o=a;else{for(var v=!1,c=r.child;c;){if(c===t){v=!0,t=r,o=a;break}if(c===o){v=!0,o=r,t=a;break}c=c.sibling}if(!v){for(c=a.child;c;){if(c===t){v=!0,t=a,o=r;break}if(c===o){v=!0,o=a,t=r;break}c=c.sibling}if(!v)throw Error(i(189))}}if(t.alternate!==o)throw Error(i(190))}if(3!==t.tag)throw Error(i(188));return t.stateNode.current===t?n:e}function C(n){return null!==(n=z(n))?T(n):null}function T(n){if(5===n.tag||6===n.tag)return n;for(n=n.child;null!==n;){var e=T(n);if(null!==e)return e;n=n.sibling}return null}function R(n){if(5===n.tag||6===n.tag)return n;for(n=n.child;null!==n;){if(4!==n.tag){var e=R(n);if(null!==e)return e}n=n.sibling}return null}var D,P=Array.isArray,F=n.getPublicInstance,j=n.getRootHostContext,I=n.getChildHostContext,E=n.prepareForCommit,O=n.resetAfterCommit,A=n.createInstance,L=n.appendInitialChild,G=n.finalizeInitialChildren,N=n.prepareUpdate,B=n.shouldSetTextContent,q=n.createTextInstance,V=n.scheduleTimeout,W=n.cancelTimeout,H=n.noTimeout,X=n.isPrimaryRenderer,Y=n.supportsMutation,Z=n.supportsPersistence,Q=n.supportsHydration,J=n.getInstanceFromNode,K=n.preparePortalMount,$=n.getCurrentEventPriority,nn=n.detachDeletedInstance,en=n.supportsMicrotasks,tn=n.scheduleMicrotask,on=n.supportsTestSelectors,rn=n.findFiberRoot,an=n.getBoundingRect,vn=n.getTextContent,cn=n.isHiddenSubtree,sn=n.matchAccessibilityRole,ln=n.setFocusIfFocusable,un=n.setupIntersectionObserver,fn=n.appendChild,pn=n.appendChildToContainer,mn=n.commitTextUpdate,dn=n.commitMount,hn=n.commitUpdate,xn=n.insertBefore,gn=n.insertInContainerBefore,yn=n.removeChild,bn=n.removeChildFromContainer,Un=n.resetTextContent,_n=n.hideInstance,wn=n.hideTextInstance,Sn=n.unhideInstance,Mn=n.unhideTextInstance,kn=n.clearContainer,zn=n.cloneInstance,Cn=n.createContainerChildSet,Tn=n.appendChildToContainerChildSet,Rn=n.finalizeContainerChildren,Dn=n.replaceContainerChildren,Pn=n.cloneHiddenInstance,Fn=n.cloneHiddenTextInstance,jn=n.canHydrateInstance,In=n.canHydrateTextInstance,En=n.canHydrateSuspenseInstance,On=n.isSuspenseInstancePending,An=n.isSuspenseInstanceFallback,Ln=n.registerSuspenseInstanceRetry,Gn=n.getNextHydratableSibling,Nn=n.getFirstHydratableChild,Bn=n.getFirstHydratableChildWithinContainer,qn=n.getFirstHydratableChildWithinSuspenseInstance,Vn=n.hydrateInstance,Wn=n.hydrateTextInstance,Hn=n.hydrateSuspenseInstance,Xn=n.getNextHydratableInstanceAfterSuspenseInstance,Yn=n.commitHydratedContainer,Zn=n.commitHydratedSuspenseInstance,Qn=n.clearSuspenseBoundary,Jn=n.clearSuspenseBoundaryFromContainer,Kn=n.shouldDeleteUnhydratedTailInstances,$n=n.didNotMatchHydratedContainerTextInstance,ne=n.didNotMatchHydratedTextInstance;function ee(n){if(void 0===D)try{throw Error()}catch(t){var e=t.stack.trim().match(/\n( *(at )?)/);D=e&&e[1]||""}return"\n"+D+n}var te=!1;function oe(n,e){if(!n||te)return"";te=!0;var t=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(e,[])}catch(s){var o=s}Reflect.construct(n,[],e)}else{try{e.call()}catch(s){o=s}n.call(e.prototype)}else{try{throw Error()}catch(s){o=s}n()}}catch(s){if(s&&o&&"string"===typeof s.stack){for(var r=s.stack.split("\n"),a=o.stack.split("\n"),i=r.length-1,v=a.length-1;1<=i&&0<=v&&r[i]!==a[v];)v--;for(;1<=i&&0<=v;i--,v--)if(r[i]!==a[v]){if(1!==i||1!==v)do{if(i--,0>--v||r[i]!==a[v]){var c="\n"+r[i].replace(" at new "," at ");return n.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",n.displayName)),c}}while(1<=i&&0<=v);break}}}finally{te=!1,Error.prepareStackTrace=t}return(n=n?n.displayName||n.name:"")?ee(n):""}var re=Object.prototype.hasOwnProperty,ae=[],ie=-1;function ve(n){return{current:n}}function ce(n){0>ie||(n.current=ae[ie],ae[ie]=null,ie--)}function se(n,e){ie++,ae[ie]=n.current,n.current=e}var le={},ue=ve(le),fe=ve(!1),pe=le;function me(n,e){var t=n.type.contextTypes;if(!t)return le;var o=n.stateNode;if(o&&o.__reactInternalMemoizedUnmaskedChildContext===e)return o.__reactInternalMemoizedMaskedChildContext;var r,a={};for(r in t)a[r]=e[r];return o&&((n=n.stateNode).__reactInternalMemoizedUnmaskedChildContext=e,n.__reactInternalMemoizedMaskedChildContext=a),a}function de(n){return null!==(n=n.childContextTypes)&&void 0!==n}function he(){ce(fe),ce(ue)}function xe(n,e,t){if(ue.current!==le)throw Error(i(168));se(ue,e),se(fe,t)}function ge(n,e,t){var o=n.stateNode;if(e=e.childContextTypes,"function"!==typeof o.getChildContext)return t;for(var r in o=o.getChildContext())if(!(r in e))throw Error(i(108,S(n)||"Unknown",r));return a({},t,o)}function ye(n){return n=(n=n.stateNode)&&n.__reactInternalMemoizedMergedChildContext||le,pe=ue.current,se(ue,n),se(fe,fe.current),!0}function be(n,e,t){var o=n.stateNode;if(!o)throw Error(i(169));t?(n=ge(n,e,pe),o.__reactInternalMemoizedMergedChildContext=n,ce(fe),ce(ue),se(ue,n)):ce(fe),se(fe,t)}var Ue=Math.clz32?Math.clz32:function(n){return 0===(n>>>=0)?32:31-(_e(n)/we|0)|0},_e=Math.log,we=Math.LN2;var Se=64,Me=4194304;function ke(n){switch(n&-n){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&n;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&n;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return n}}function ze(n,e){var t=n.pendingLanes;if(0===t)return 0;var o=0,r=n.suspendedLanes,a=n.pingedLanes,i=268435455&t;if(0!==i){var v=i&~r;0!==v?o=ke(v):0!==(a&=i)&&(o=ke(a))}else 0!==(i=t&~r)?o=ke(i):0!==a&&(o=ke(a));if(0===o)return 0;if(0!==e&&e!==o&&0===(e&r)&&((r=o&-o)>=(a=e&-e)||16===r&&0!==(4194240&a)))return e;if(0!==(4&o)&&(o|=16&t),0!==(e=n.entangledLanes))for(n=n.entanglements,e&=o;0<e;)r=1<<(t=31-Ue(e)),o|=n[t],e&=~r;return o}function Ce(n,e){switch(n){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;default:return-1}}function Te(n){return 0!==(n=-1073741825&n.pendingLanes)?n:1073741824&n?1073741824:0}function Re(n){for(var e=[],t=0;31>t;t++)e.push(n);return e}function De(n,e,t){n.pendingLanes|=e,536870912!==e&&(n.suspendedLanes=0,n.pingedLanes=0),(n=n.eventTimes)[e=31-Ue(e)]=t}function Pe(n,e){var t=n.entangledLanes|=e;for(n=n.entanglements;t;){var o=31-Ue(t),r=1<<o;r&e|n[o]&e&&(n[o]|=e),t&=~r}}var Fe=0;function je(n){return 1<(n&=-n)?4<n?0!==(268435455&n)?16:536870912:4:1}var Ie=r.unstable_scheduleCallback,Ee=r.unstable_cancelCallback,Oe=r.unstable_shouldYield,Ae=r.unstable_requestPaint,Le=r.unstable_now,Ge=r.unstable_ImmediatePriority,Ne=r.unstable_UserBlockingPriority,Be=r.unstable_NormalPriority,qe=r.unstable_IdlePriority,Ve=null,We=null;var He="function"===typeof Object.is?Object.is:function(n,e){return n===e&&(0!==n||1/n===1/e)||n!==n&&e!==e},Xe=null,Ye=!1,Ze=!1;function Qe(n){null===Xe?Xe=[n]:Xe.push(n)}function Je(){if(!Ze&&null!==Xe){Ze=!0;var n=0,e=Fe;try{var t=Xe;for(Fe=1;n<t.length;n++){var o=t[n];do{o=o(!0)}while(null!==o)}Xe=null,Ye=!1}catch(r){throw null!==Xe&&(Xe=Xe.slice(n+1)),Ie(Ge,Je),r}finally{Fe=e,Ze=!1}}return null}var Ke=v.ReactCurrentBatchConfig;function $e(n,e){if(He(n,e))return!0;if("object"!==typeof n||null===n||"object"!==typeof e||null===e)return!1;var t=Object.keys(n),o=Object.keys(e);if(t.length!==o.length)return!1;for(o=0;o<t.length;o++){var r=t[o];if(!re.call(e,r)||!He(n[r],e[r]))return!1}return!0}function nt(n){switch(n.tag){case 5:return ee(n.type);case 16:return ee("Lazy");case 13:return ee("Suspense");case 19:return ee("SuspenseList");case 0:case 2:case 15:return n=oe(n.type,!1);case 11:return n=oe(n.type.render,!1);case 1:return n=oe(n.type,!0);default:return""}}function et(n,e){if(n&&n.defaultProps){for(var t in e=a({},e),n=n.defaultProps)void 0===e[t]&&(e[t]=n[t]);return e}return e}var tt=ve(null),ot=null,rt=null,at=null;function it(){at=rt=ot=null}function vt(n,e,t){X?(se(tt,e._currentValue),e._currentValue=t):(se(tt,e._currentValue2),e._currentValue2=t)}function ct(n){var e=tt.current;ce(tt),X?n._currentValue=e:n._currentValue2=e}function st(n,e,t){for(;null!==n;){var o=n.alternate;if((n.childLanes&e)!==e?(n.childLanes|=e,null!==o&&(o.childLanes|=e)):null!==o&&(o.childLanes&e)!==e&&(o.childLanes|=e),n===t)break;n=n.return}}function lt(n,e){ot=n,at=rt=null,null!==(n=n.dependencies)&&null!==n.firstContext&&(0!==(n.lanes&e)&&(Or=!0),n.firstContext=null)}function ut(n){var e=X?n._currentValue:n._currentValue2;if(at!==n)if(n={context:n,memoizedValue:e,next:null},null===rt){if(null===ot)throw Error(i(308));rt=n,ot.dependencies={lanes:0,firstContext:n}}else rt=rt.next=n;return e}var ft=null,pt=!1;function mt(n){n.updateQueue={baseState:n.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function dt(n,e){n=n.updateQueue,e.updateQueue===n&&(e.updateQueue={baseState:n.baseState,firstBaseUpdate:n.firstBaseUpdate,lastBaseUpdate:n.lastBaseUpdate,shared:n.shared,effects:n.effects})}function ht(n,e){return{eventTime:n,lane:e,tag:0,payload:null,callback:null,next:null}}function xt(n,e){var t=n.updateQueue;null!==t&&(t=t.shared,null!==Za&&0!==(1&n.mode)&&0===(2&Ya)?(null===(n=t.interleaved)?(e.next=e,null===ft?ft=[t]:ft.push(t)):(e.next=n.next,n.next=e),t.interleaved=e):(null===(n=t.pending)?e.next=e:(e.next=n.next,n.next=e),t.pending=e))}function gt(n,e,t){if(null!==(e=e.updateQueue)&&(e=e.shared,0!==(4194240&t))){var o=e.lanes;t|=o&=n.pendingLanes,e.lanes=t,Pe(n,t)}}function yt(n,e){var t=n.updateQueue,o=n.alternate;if(null!==o&&t===(o=o.updateQueue)){var r=null,a=null;if(null!==(t=t.firstBaseUpdate)){do{var i={eventTime:t.eventTime,lane:t.lane,tag:t.tag,payload:t.payload,callback:t.callback,next:null};null===a?r=a=i:a=a.next=i,t=t.next}while(null!==t);null===a?r=a=e:a=a.next=e}else r=a=e;return t={baseState:o.baseState,firstBaseUpdate:r,lastBaseUpdate:a,shared:o.shared,effects:o.effects},void(n.updateQueue=t)}null===(n=t.lastBaseUpdate)?t.firstBaseUpdate=e:n.next=e,t.lastBaseUpdate=e}function bt(n,e,t,o){var r=n.updateQueue;pt=!1;var i=r.firstBaseUpdate,v=r.lastBaseUpdate,c=r.shared.pending;if(null!==c){r.shared.pending=null;var s=c,l=s.next;s.next=null,null===v?i=l:v.next=l,v=s;var u=n.alternate;null!==u&&((c=(u=u.updateQueue).lastBaseUpdate)!==v&&(null===c?u.firstBaseUpdate=l:c.next=l,u.lastBaseUpdate=s))}if(null!==i){var f=r.baseState;for(v=0,u=l=s=null,c=i;;){var p=c.lane,m=c.eventTime;if((o&p)===p){null!==u&&(u=u.next={eventTime:m,lane:0,tag:c.tag,payload:c.payload,callback:c.callback,next:null});n:{var d=n,h=c;switch(p=e,m=t,h.tag){case 1:if("function"===typeof(d=h.payload)){f=d.call(m,f,p);break n}f=d;break n;case 3:d.flags=-65537&d.flags|128;case 0:if(null===(p="function"===typeof(d=h.payload)?d.call(m,f,p):d)||void 0===p)break n;f=a({},f,p);break n;case 2:pt=!0}}null!==c.callback&&0!==c.lane&&(n.flags|=64,null===(p=r.effects)?r.effects=[c]:p.push(c))}else m={eventTime:m,lane:p,tag:c.tag,payload:c.payload,callback:c.callback,next:null},null===u?(l=u=m,s=f):u=u.next=m,v|=p;if(null===(c=c.next)){if(null===(c=r.shared.pending))break;c=(p=c).next,p.next=null,r.lastBaseUpdate=p,r.shared.pending=null}}if(null===u&&(s=f),r.baseState=s,r.firstBaseUpdate=l,r.lastBaseUpdate=u,null!==(e=r.shared.interleaved)){r=e;do{v|=r.lane,r=r.next}while(r!==e)}else null===i&&(r.shared.lanes=0);ti|=v,n.lanes=v,n.memoizedState=f}}function Ut(n,e,t){if(n=e.effects,e.effects=null,null!==n)for(e=0;e<n.length;e++){var o=n[e],r=o.callback;if(null!==r){if(o.callback=null,o=t,"function"!==typeof r)throw Error(i(191,r));r.call(o)}}}var _t=(new o.Component).refs;function wt(n,e,t,o){t=null===(t=t(o,e=n.memoizedState))||void 0===t?e:a({},e,t),n.memoizedState=t,0===n.lanes&&(n.updateQueue.baseState=t)}var St={isMounted:function(n){return!!(n=n._reactInternals)&&M(n)===n},enqueueSetState:function(n,e,t){n=n._reactInternals;var o=Ui(),r=_i(n),a=ht(o,r);a.payload=e,void 0!==t&&null!==t&&(a.callback=t),xt(n,a),null!==(e=wi(n,r,o))&&gt(e,n,r)},enqueueReplaceState:function(n,e,t){n=n._reactInternals;var o=Ui(),r=_i(n),a=ht(o,r);a.tag=1,a.payload=e,void 0!==t&&null!==t&&(a.callback=t),xt(n,a),null!==(e=wi(n,r,o))&&gt(e,n,r)},enqueueForceUpdate:function(n,e){n=n._reactInternals;var t=Ui(),o=_i(n),r=ht(t,o);r.tag=2,void 0!==e&&null!==e&&(r.callback=e),xt(n,r),null!==(e=wi(n,o,t))&&gt(e,n,o)}};function Mt(n,e,t,o,r,a,i){return"function"===typeof(n=n.stateNode).shouldComponentUpdate?n.shouldComponentUpdate(o,a,i):!e.prototype||!e.prototype.isPureReactComponent||(!$e(t,o)||!$e(r,a))}function kt(n,e,t){var o=!1,r=le,a=e.contextType;return"object"===typeof a&&null!==a?a=ut(a):(r=de(e)?pe:ue.current,a=(o=null!==(o=e.contextTypes)&&void 0!==o)?me(n,r):le),e=new e(t,a),n.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,e.updater=St,n.stateNode=e,e._reactInternals=n,o&&((n=n.stateNode).__reactInternalMemoizedUnmaskedChildContext=r,n.__reactInternalMemoizedMaskedChildContext=a),e}function zt(n,e,t,o){n=e.state,"function"===typeof e.componentWillReceiveProps&&e.componentWillReceiveProps(t,o),"function"===typeof e.UNSAFE_componentWillReceiveProps&&e.UNSAFE_componentWillReceiveProps(t,o),e.state!==n&&St.enqueueReplaceState(e,e.state,null)}function Ct(n,e,t,o){var r=n.stateNode;r.props=t,r.state=n.memoizedState,r.refs=_t,mt(n);var a=e.contextType;"object"===typeof a&&null!==a?r.context=ut(a):(a=de(e)?pe:ue.current,r.context=me(n,a)),r.state=n.memoizedState,"function"===typeof(a=e.getDerivedStateFromProps)&&(wt(n,e,a,t),r.state=n.memoizedState),"function"===typeof e.getDerivedStateFromProps||"function"===typeof r.getSnapshotBeforeUpdate||"function"!==typeof r.UNSAFE_componentWillMount&&"function"!==typeof r.componentWillMount||(e=r.state,"function"===typeof r.componentWillMount&&r.componentWillMount(),"function"===typeof r.UNSAFE_componentWillMount&&r.UNSAFE_componentWillMount(),e!==r.state&&St.enqueueReplaceState(r,r.state,null),bt(n,t,r,o),r.state=n.memoizedState),"function"===typeof r.componentDidMount&&(n.flags|=4194308)}var Tt=[],Rt=0,Dt=null,Pt=0,Ft=[],jt=0,It=null,Et=1,Ot="";function At(n,e){Tt[Rt++]=Pt,Tt[Rt++]=Dt,Dt=n,Pt=e}function Lt(n,e,t){Ft[jt++]=Et,Ft[jt++]=Ot,Ft[jt++]=It,It=n;var o=Et;n=Ot;var r=32-Ue(o)-1;o&=~(1<<r),t+=1;var a=32-Ue(e)+r;if(30<a){var i=r-r%5;a=(o&(1<<i)-1).toString(32),o>>=i,r-=i,Et=1<<32-Ue(e)+r|t<<r|o,Ot=a+n}else Et=1<<a|t<<r|o,Ot=n}function Gt(n){null!==n.return&&(At(n,1),Lt(n,1,0))}function Nt(n){for(;n===Dt;)Dt=Tt[--Rt],Tt[Rt]=null,Pt=Tt[--Rt],Tt[Rt]=null;for(;n===It;)It=Ft[--jt],Ft[jt]=null,Ot=Ft[--jt],Ft[jt]=null,Et=Ft[--jt],Ft[jt]=null}var Bt=null,qt=null,Vt=!1,Wt=!1,Ht=null;function Xt(n,e){var t=Ki(5,null,null,0);t.elementType="DELETED",t.stateNode=e,t.return=n,null===(e=n.deletions)?(n.deletions=[t],n.flags|=16):e.push(t)}function Yt(n,e){switch(n.tag){case 5:return null!==(e=jn(e,n.type,n.pendingProps))&&(n.stateNode=e,Bt=n,qt=Nn(e),!0);case 6:return null!==(e=In(e,n.pendingProps))&&(n.stateNode=e,Bt=n,qt=null,!0);case 13:if(null!==(e=En(e))){var t=null!==It?{id:Et,overflow:Ot}:null;return n.memoizedState={dehydrated:e,treeContext:t,retryLane:1073741824},(t=Ki(18,null,null,0)).stateNode=e,t.return=n,n.child=t,Bt=n,qt=null,!0}return!1;default:return!1}}function Zt(n){return 0!==(1&n.mode)&&0===(128&n.flags)}function Qt(n){if(Vt){var e=qt;if(e){var t=e;if(!Yt(n,e)){if(Zt(n))throw Error(i(418));e=Gn(t);var o=Bt;e&&Yt(n,e)?Xt(o,t):(n.flags=-4097&n.flags|2,Vt=!1,Bt=n)}}else{if(Zt(n))throw Error(i(418));n.flags=-4097&n.flags|2,Vt=!1,Bt=n}}}function Jt(n){for(n=n.return;null!==n&&5!==n.tag&&3!==n.tag&&13!==n.tag;)n=n.return;Bt=n}function Kt(n){if(!Q||n!==Bt)return!1;if(!Vt)return Jt(n),Vt=!0,!1;if(3!==n.tag&&(5!==n.tag||Kn(n.type)&&!B(n.type,n.memoizedProps))){var e=qt;if(e){if(Zt(n)){for(n=qt;n;)n=Gn(n);throw Error(i(418))}for(;e;)Xt(n,e),e=Gn(e)}}if(Jt(n),13===n.tag){if(!Q)throw Error(i(316));if(!(n=null!==(n=n.memoizedState)?n.dehydrated:null))throw Error(i(317));qt=Xn(n)}else qt=Bt?Gn(n.stateNode):null;return!0}function $t(){Q&&(qt=Bt=null,Wt=Vt=!1)}function no(n){null===Ht?Ht=[n]:Ht.push(n)}function eo(n,e,t){if(null!==(n=t.ref)&&"function"!==typeof n&&"object"!==typeof n){if(t._owner){if(t=t._owner){if(1!==t.tag)throw Error(i(309));var o=t.stateNode}if(!o)throw Error(i(147,n));var r=o,a=""+n;return null!==e&&null!==e.ref&&"function"===typeof e.ref&&e.ref._stringRef===a?e.ref:(e=function(n){var e=r.refs;e===_t&&(e=r.refs={}),null===n?delete e[a]:e[a]=n},e._stringRef=a,e)}if("string"!==typeof n)throw Error(i(284));if(!t._owner)throw Error(i(290,n))}return n}function to(n,e){throw n=Object.prototype.toString.call(e),Error(i(31,"[object Object]"===n?"object with keys {"+Object.keys(e).join(", ")+"}":n))}function oo(n){return(0,n._init)(n._payload)}function ro(n){function e(e,t){if(n){var o=e.deletions;null===o?(e.deletions=[t],e.flags|=16):o.push(t)}}function t(t,o){if(!n)return null;for(;null!==o;)e(t,o),o=o.sibling;return null}function o(n,e){for(n=new Map;null!==e;)null!==e.key?n.set(e.key,e):n.set(e.index,e),e=e.sibling;return n}function r(n,e){return(n=nv(n,e)).index=0,n.sibling=null,n}function a(e,t,o){return e.index=o,n?null!==(o=e.alternate)?(o=o.index)<t?(e.flags|=2,t):o:(e.flags|=2,t):(e.flags|=1048576,t)}function v(e){return n&&null===e.alternate&&(e.flags|=2),e}function u(n,e,t,o){return null===e||6!==e.tag?((e=rv(t,n.mode,o)).return=n,e):((e=r(e,t)).return=n,e)}function f(n,e,t,o){var a=t.type;return a===l?m(n,e,t.props.children,o,t.key):null!==e&&(e.elementType===a||"object"===typeof a&&null!==a&&a.$$typeof===y&&oo(a)===e.type)?((o=r(e,t.props)).ref=eo(n,e,t),o.return=n,o):((o=ev(t.type,t.key,t.props,null,n.mode,o)).ref=eo(n,e,t),o.return=n,o)}function p(n,e,t,o){return null===e||4!==e.tag||e.stateNode.containerInfo!==t.containerInfo||e.stateNode.implementation!==t.implementation?((e=av(t,n.mode,o)).return=n,e):((e=r(e,t.children||[])).return=n,e)}function m(n,e,t,o,a){return null===e||7!==e.tag?((e=tv(t,n.mode,o,a)).return=n,e):((e=r(e,t)).return=n,e)}function d(n,e,t){if("string"===typeof e&&""!==e||"number"===typeof e)return(e=rv(""+e,n.mode,t)).return=n,e;if("object"===typeof e&&null!==e){switch(e.$$typeof){case c:return(t=ev(e.type,e.key,e.props,null,n.mode,t)).ref=eo(n,null,e),t.return=n,t;case s:return(e=av(e,n.mode,t)).return=n,e;case y:return d(n,(0,e._init)(e._payload),t)}if(P(e)||_(e))return(e=tv(e,n.mode,t,null)).return=n,e;to(n,e)}return null}function h(n,e,t,o){var r=null!==e?e.key:null;if("string"===typeof t&&""!==t||"number"===typeof t)return null!==r?null:u(n,e,""+t,o);if("object"===typeof t&&null!==t){switch(t.$$typeof){case c:return t.key===r?f(n,e,t,o):null;case s:return t.key===r?p(n,e,t,o):null;case y:return h(n,e,(r=t._init)(t._payload),o)}if(P(t)||_(t))return null!==r?null:m(n,e,t,o,null);to(n,t)}return null}function x(n,e,t,o,r){if("string"===typeof o&&""!==o||"number"===typeof o)return u(e,n=n.get(t)||null,""+o,r);if("object"===typeof o&&null!==o){switch(o.$$typeof){case c:return f(e,n=n.get(null===o.key?t:o.key)||null,o,r);case s:return p(e,n=n.get(null===o.key?t:o.key)||null,o,r);case y:return x(n,e,t,(0,o._init)(o._payload),r)}if(P(o)||_(o))return m(e,n=n.get(t)||null,o,r,null);to(e,o)}return null}function g(r,i,v,c){for(var s=null,l=null,u=i,f=i=0,p=null;null!==u&&f<v.length;f++){u.index>f?(p=u,u=null):p=u.sibling;var m=h(r,u,v[f],c);if(null===m){null===u&&(u=p);break}n&&u&&null===m.alternate&&e(r,u),i=a(m,i,f),null===l?s=m:l.sibling=m,l=m,u=p}if(f===v.length)return t(r,u),Vt&&At(r,f),s;if(null===u){for(;f<v.length;f++)null!==(u=d(r,v[f],c))&&(i=a(u,i,f),null===l?s=u:l.sibling=u,l=u);return Vt&&At(r,f),s}for(u=o(r,u);f<v.length;f++)null!==(p=x(u,r,f,v[f],c))&&(n&&null!==p.alternate&&u.delete(null===p.key?f:p.key),i=a(p,i,f),null===l?s=p:l.sibling=p,l=p);return n&&u.forEach((function(n){return e(r,n)})),Vt&&At(r,f),s}function b(r,v,c,s){var l=_(c);if("function"!==typeof l)throw Error(i(150));if(null==(c=l.call(c)))throw Error(i(151));for(var u=l=null,f=v,p=v=0,m=null,g=c.next();null!==f&&!g.done;p++,g=c.next()){f.index>p?(m=f,f=null):m=f.sibling;var y=h(r,f,g.value,s);if(null===y){null===f&&(f=m);break}n&&f&&null===y.alternate&&e(r,f),v=a(y,v,p),null===u?l=y:u.sibling=y,u=y,f=m}if(g.done)return t(r,f),Vt&&At(r,p),l;if(null===f){for(;!g.done;p++,g=c.next())null!==(g=d(r,g.value,s))&&(v=a(g,v,p),null===u?l=g:u.sibling=g,u=g);return Vt&&At(r,p),l}for(f=o(r,f);!g.done;p++,g=c.next())null!==(g=x(f,r,p,g.value,s))&&(n&&null!==g.alternate&&f.delete(null===g.key?p:g.key),v=a(g,v,p),null===u?l=g:u.sibling=g,u=g);return n&&f.forEach((function(n){return e(r,n)})),Vt&&At(r,p),l}return function n(o,a,i,u){if("object"===typeof i&&null!==i&&i.type===l&&null===i.key&&(i=i.props.children),"object"===typeof i&&null!==i){switch(i.$$typeof){case c:n:{for(var f=i.key,p=a;null!==p;){if(p.key===f){if((f=i.type)===l){if(7===p.tag){t(o,p.sibling),(a=r(p,i.props.children)).return=o,o=a;break n}}else if(p.elementType===f||"object"===typeof f&&null!==f&&f.$$typeof===y&&oo(f)===p.type){t(o,p.sibling),(a=r(p,i.props)).ref=eo(o,p,i),a.return=o,o=a;break n}t(o,p);break}e(o,p),p=p.sibling}i.type===l?((a=tv(i.props.children,o.mode,u,i.key)).return=o,o=a):((u=ev(i.type,i.key,i.props,null,o.mode,u)).ref=eo(o,a,i),u.return=o,o=u)}return v(o);case s:n:{for(p=i.key;null!==a;){if(a.key===p){if(4===a.tag&&a.stateNode.containerInfo===i.containerInfo&&a.stateNode.implementation===i.implementation){t(o,a.sibling),(a=r(a,i.children||[])).return=o,o=a;break n}t(o,a);break}e(o,a),a=a.sibling}(a=av(i,o.mode,u)).return=o,o=a}return v(o);case y:return n(o,a,(p=i._init)(i._payload),u)}if(P(i))return g(o,a,i,u);if(_(i))return b(o,a,i,u);to(o,i)}return"string"===typeof i&&""!==i||"number"===typeof i?(i=""+i,null!==a&&6===a.tag?(t(o,a.sibling),(a=r(a,i)).return=o,o=a):(t(o,a),(a=rv(i,o.mode,u)).return=o,o=a),v(o)):t(o,a)}}var ao=ro(!0),io=ro(!1),vo={},co=ve(vo),so=ve(vo),lo=ve(vo);function uo(n){if(n===vo)throw Error(i(174));return n}function fo(n,e){se(lo,e),se(so,n),se(co,vo),n=j(e),ce(co),se(co,n)}function po(){ce(co),ce(so),ce(lo)}function mo(n){var e=uo(lo.current),t=uo(co.current);t!==(e=I(t,n.type,e))&&(se(so,n),se(co,e))}function ho(n){so.current===n&&(ce(co),ce(so))}var xo=ve(0);function go(n){for(var e=n;null!==e;){if(13===e.tag){var t=e.memoizedState;if(null!==t&&(null===(t=t.dehydrated)||On(t)||An(t)))return e}else if(19===e.tag&&void 0!==e.memoizedProps.revealOrder){if(0!==(128&e.flags))return e}else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===n)break;for(;null===e.sibling;){if(null===e.return||e.return===n)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var yo=[];function bo(){for(var n=0;n<yo.length;n++){var e=yo[n];X?e._workInProgressVersionPrimary=null:e._workInProgressVersionSecondary=null}yo.length=0}var Uo=v.ReactCurrentDispatcher,_o=v.ReactCurrentBatchConfig,wo=0,So=null,Mo=null,ko=null,zo=!1,Co=!1,To=0,Ro=0;function Do(){throw Error(i(321))}function Po(n,e){if(null===e)return!1;for(var t=0;t<e.length&&t<n.length;t++)if(!He(n[t],e[t]))return!1;return!0}function Fo(n,e,t,o,r,a){if(wo=a,So=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,Uo.current=null===n||null===n.memoizedState?dr:hr,n=t(o,r),Co){a=0;do{if(Co=!1,To=0,25<=a)throw Error(i(301));a+=1,ko=Mo=null,e.updateQueue=null,Uo.current=xr,n=t(o,r)}while(Co)}if(Uo.current=mr,e=null!==Mo&&null!==Mo.next,wo=0,ko=Mo=So=null,zo=!1,e)throw Error(i(300));return n}function jo(){var n=0!==To;return To=0,n}function Io(){var n={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===ko?So.memoizedState=ko=n:ko=ko.next=n,ko}function Eo(){if(null===Mo){var n=So.alternate;n=null!==n?n.memoizedState:null}else n=Mo.next;var e=null===ko?So.memoizedState:ko.next;if(null!==e)ko=e,Mo=n;else{if(null===n)throw Error(i(310));n={memoizedState:(Mo=n).memoizedState,baseState:Mo.baseState,baseQueue:Mo.baseQueue,queue:Mo.queue,next:null},null===ko?So.memoizedState=ko=n:ko=ko.next=n}return ko}function Oo(n,e){return"function"===typeof e?e(n):e}function Ao(n){var e=Eo(),t=e.queue;if(null===t)throw Error(i(311));t.lastRenderedReducer=n;var o=Mo,r=o.baseQueue,a=t.pending;if(null!==a){if(null!==r){var v=r.next;r.next=a.next,a.next=v}o.baseQueue=r=a,t.pending=null}if(null!==r){a=r.next,o=o.baseState;var c=v=null,s=null,l=a;do{var u=l.lane;if((wo&u)===u)null!==s&&(s=s.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),o=l.hasEagerState?l.eagerState:n(o,l.action);else{var f={lane:u,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null};null===s?(c=s=f,v=o):s=s.next=f,So.lanes|=u,ti|=u}l=l.next}while(null!==l&&l!==a);null===s?v=o:s.next=c,He(o,e.memoizedState)||(Or=!0),e.memoizedState=o,e.baseState=v,e.baseQueue=s,t.lastRenderedState=o}if(null!==(n=t.interleaved)){r=n;do{a=r.lane,So.lanes|=a,ti|=a,r=r.next}while(r!==n)}else null===r&&(t.lanes=0);return[e.memoizedState,t.dispatch]}function Lo(n){var e=Eo(),t=e.queue;if(null===t)throw Error(i(311));t.lastRenderedReducer=n;var o=t.dispatch,r=t.pending,a=e.memoizedState;if(null!==r){t.pending=null;var v=r=r.next;do{a=n(a,v.action),v=v.next}while(v!==r);He(a,e.memoizedState)||(Or=!0),e.memoizedState=a,null===e.baseQueue&&(e.baseState=a),t.lastRenderedState=a}return[a,o]}function Go(){}function No(n,e){var t=So,o=Eo(),r=e(),a=!He(o.memoizedState,r);if(a&&(o.memoizedState=r,Or=!0),o=o.queue,Ko(Vo.bind(null,t,o,n),[n]),o.getSnapshot!==e||a||null!==ko&&1&ko.memoizedState.tag){if(t.flags|=2048,Xo(9,qo.bind(null,t,o,r,e),void 0,null),null===Za)throw Error(i(349));0!==(30&wo)||Bo(t,e,r)}return r}function Bo(n,e,t){n.flags|=16384,n={getSnapshot:e,value:t},null===(e=So.updateQueue)?(e={lastEffect:null,stores:null},So.updateQueue=e,e.stores=[n]):null===(t=e.stores)?e.stores=[n]:t.push(n)}function qo(n,e,t,o){e.value=t,e.getSnapshot=o,Wo(e)&&wi(n,1,-1)}function Vo(n,e,t){return t((function(){Wo(e)&&wi(n,1,-1)}))}function Wo(n){var e=n.getSnapshot;n=n.value;try{var t=e();return!He(n,t)}catch(o){return!0}}function Ho(n){var e=Io();return"function"===typeof n&&(n=n()),e.memoizedState=e.baseState=n,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Oo,lastRenderedState:n},e.queue=n,n=n.dispatch=sr.bind(null,So,n),[e.memoizedState,n]}function Xo(n,e,t,o){return n={tag:n,create:e,destroy:t,deps:o,next:null},null===(e=So.updateQueue)?(e={lastEffect:null,stores:null},So.updateQueue=e,e.lastEffect=n.next=n):null===(t=e.lastEffect)?e.lastEffect=n.next=n:(o=t.next,t.next=n,n.next=o,e.lastEffect=n),n}function Yo(){return Eo().memoizedState}function Zo(n,e,t,o){var r=Io();So.flags|=n,r.memoizedState=Xo(1|e,t,void 0,void 0===o?null:o)}function Qo(n,e,t,o){var r=Eo();o=void 0===o?null:o;var a=void 0;if(null!==Mo){var i=Mo.memoizedState;if(a=i.destroy,null!==o&&Po(o,i.deps))return void(r.memoizedState=Xo(e,t,a,o))}So.flags|=n,r.memoizedState=Xo(1|e,t,a,o)}function Jo(n,e){return Zo(8390656,8,n,e)}function Ko(n,e){return Qo(2048,8,n,e)}function $o(n,e){return Qo(4,2,n,e)}function nr(n,e){return Qo(4,4,n,e)}function er(n,e){return"function"===typeof e?(n=n(),e(n),function(){e(null)}):null!==e&&void 0!==e?(n=n(),e.current=n,function(){e.current=null}):void 0}function tr(n,e,t){return t=null!==t&&void 0!==t?t.concat([n]):null,Qo(4,4,er.bind(null,e,n),t)}function or(){}function rr(n,e){var t=Eo();e=void 0===e?null:e;var o=t.memoizedState;return null!==o&&null!==e&&Po(e,o[1])?o[0]:(t.memoizedState=[n,e],n)}function ar(n,e){var t=Eo();e=void 0===e?null:e;var o=t.memoizedState;return null!==o&&null!==e&&Po(e,o[1])?o[0]:(n=n(),t.memoizedState=[n,e],n)}function ir(n,e){var t=Fe;Fe=0!==t&&4>t?t:4,n(!0);var o=_o.transition;_o.transition={};try{n(!1),e()}finally{Fe=t,_o.transition=o}}function vr(){return Eo().memoizedState}function cr(n,e,t){var o=_i(n);t={lane:o,action:t,hasEagerState:!1,eagerState:null,next:null},lr(n)?ur(e,t):(fr(n,e,t),null!==(n=wi(n,o,t=Ui()))&&pr(n,e,o))}function sr(n,e,t){var o=_i(n),r={lane:o,action:t,hasEagerState:!1,eagerState:null,next:null};if(lr(n))ur(e,r);else{fr(n,e,r);var a=n.alternate;if(0===n.lanes&&(null===a||0===a.lanes)&&null!==(a=e.lastRenderedReducer))try{var i=e.lastRenderedState,v=a(i,t);if(r.hasEagerState=!0,r.eagerState=v,He(v,i))return}catch(c){}null!==(n=wi(n,o,t=Ui()))&&pr(n,e,o)}}function lr(n){var e=n.alternate;return n===So||null!==e&&e===So}function ur(n,e){Co=zo=!0;var t=n.pending;null===t?e.next=e:(e.next=t.next,t.next=e),n.pending=e}function fr(n,e,t){null!==Za&&0!==(1&n.mode)&&0===(2&Ya)?(null===(n=e.interleaved)?(t.next=t,null===ft?ft=[e]:ft.push(e)):(t.next=n.next,n.next=t),e.interleaved=t):(null===(n=e.pending)?t.next=t:(t.next=n.next,n.next=t),e.pending=t)}function pr(n,e,t){if(0!==(4194240&t)){var o=e.lanes;t|=o&=n.pendingLanes,e.lanes=t,Pe(n,t)}}var mr={readContext:ut,useCallback:Do,useContext:Do,useEffect:Do,useImperativeHandle:Do,useInsertionEffect:Do,useLayoutEffect:Do,useMemo:Do,useReducer:Do,useRef:Do,useState:Do,useDebugValue:Do,useDeferredValue:Do,useTransition:Do,useMutableSource:Do,useSyncExternalStore:Do,useId:Do,unstable_isNewReconciler:!1},dr={readContext:ut,useCallback:function(n,e){return Io().memoizedState=[n,void 0===e?null:e],n},useContext:ut,useEffect:Jo,useImperativeHandle:function(n,e,t){return t=null!==t&&void 0!==t?t.concat([n]):null,Zo(4194308,4,er.bind(null,e,n),t)},useLayoutEffect:function(n,e){return Zo(4194308,4,n,e)},useInsertionEffect:function(n,e){return Zo(4,2,n,e)},useMemo:function(n,e){var t=Io();return e=void 0===e?null:e,n=n(),t.memoizedState=[n,e],n},useReducer:function(n,e,t){var o=Io();return e=void 0!==t?t(e):e,o.memoizedState=o.baseState=e,n={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:n,lastRenderedState:e},o.queue=n,n=n.dispatch=cr.bind(null,So,n),[o.memoizedState,n]},useRef:function(n){return n={current:n},Io().memoizedState=n},useState:Ho,useDebugValue:or,useDeferredValue:function(n){var e=Ho(n),t=e[0],o=e[1];return Jo((function(){var e=_o.transition;_o.transition={};try{o(n)}finally{_o.transition=e}}),[n]),t},useTransition:function(){var n=Ho(!1),e=n[0];return n=ir.bind(null,n[1]),Io().memoizedState=n,[e,n]},useMutableSource:function(){},useSyncExternalStore:function(n,e,t){var o=So,r=Io();if(Vt){if(void 0===t)throw Error(i(407));t=t()}else{if(t=e(),null===Za)throw Error(i(349));0!==(30&wo)||Bo(o,e,t)}r.memoizedState=t;var a={value:t,getSnapshot:e};return r.queue=a,Jo(Vo.bind(null,o,a,n),[n]),o.flags|=2048,Xo(9,qo.bind(null,o,a,t,e),void 0,null),t},useId:function(){var n=Io(),e=Za.identifierPrefix;if(Vt){var t=Ot;e=":"+e+"R"+(t=(Et&~(1<<32-Ue(Et)-1)).toString(32)+t),0<(t=To++)&&(e+="H"+t.toString(32)),e+=":"}else e=":"+e+"r"+(t=Ro++).toString(32)+":";return n.memoizedState=e},unstable_isNewReconciler:!1},hr={readContext:ut,useCallback:rr,useContext:ut,useEffect:Ko,useImperativeHandle:tr,useInsertionEffect:$o,useLayoutEffect:nr,useMemo:ar,useReducer:Ao,useRef:Yo,useState:function(){return Ao(Oo)},useDebugValue:or,useDeferredValue:function(n){var e=Ao(Oo),t=e[0],o=e[1];return Ko((function(){var e=_o.transition;_o.transition={};try{o(n)}finally{_o.transition=e}}),[n]),t},useTransition:function(){return[Ao(Oo)[0],Eo().memoizedState]},useMutableSource:Go,useSyncExternalStore:No,useId:vr,unstable_isNewReconciler:!1},xr={readContext:ut,useCallback:rr,useContext:ut,useEffect:Ko,useImperativeHandle:tr,useInsertionEffect:$o,useLayoutEffect:nr,useMemo:ar,useReducer:Lo,useRef:Yo,useState:function(){return Lo(Oo)},useDebugValue:or,useDeferredValue:function(n){var e=Lo(Oo),t=e[0],o=e[1];return Ko((function(){var e=_o.transition;_o.transition={};try{o(n)}finally{_o.transition=e}}),[n]),t},useTransition:function(){return[Lo(Oo)[0],Eo().memoizedState]},useMutableSource:Go,useSyncExternalStore:No,useId:vr,unstable_isNewReconciler:!1};function gr(n,e){try{var t="",o=e;do{t+=nt(o),o=o.return}while(o);var r=t}catch(a){r="\nError generating stack: "+a.message+"\n"+a.stack}return{value:n,source:e,stack:r}}function yr(n,e){try{console.error(e.value)}catch(t){setTimeout((function(){throw t}))}}var br,Ur,_r,wr,Sr="function"===typeof WeakMap?WeakMap:Map;function Mr(n,e,t){(t=ht(-1,t)).tag=3,t.payload={element:null};var o=e.value;return t.callback=function(){ui||(ui=!0,fi=o),yr(0,e)},t}function kr(n,e,t){(t=ht(-1,t)).tag=3;var o=n.type.getDerivedStateFromError;if("function"===typeof o){var r=e.value;t.payload=function(){return o(r)},t.callback=function(){yr(0,e)}}var a=n.stateNode;return null!==a&&"function"===typeof a.componentDidCatch&&(t.callback=function(){yr(0,e),"function"!==typeof o&&(null===pi?pi=new Set([this]):pi.add(this));var n=e.stack;this.componentDidCatch(e.value,{componentStack:null!==n?n:""})}),t}function zr(n,e,t){var o=n.pingCache;if(null===o){o=n.pingCache=new Sr;var r=new Set;o.set(e,r)}else void 0===(r=o.get(e))&&(r=new Set,o.set(e,r));r.has(t)||(r.add(t),n=Hi.bind(null,n,e,t),e.then(n,n))}function Cr(n){do{var e;if((e=13===n.tag)&&(e=null===(e=n.memoizedState)||null!==e.dehydrated),e)return n;n=n.return}while(null!==n);return null}function Tr(n,e,t,o,r){return 0===(1&n.mode)?(n===e?n.flags|=65536:(n.flags|=128,t.flags|=131072,t.flags&=-52805,1===t.tag&&(null===t.alternate?t.tag=17:((e=ht(-1,1)).tag=2,xt(t,e))),t.lanes|=1),n):(n.flags|=65536,n.lanes=r,n)}function Rr(n){n.flags|=4}function Dr(n,e){if(null!==n&&n.child===e.child)return!0;if(0!==(16&e.flags))return!1;for(n=e.child;null!==n;){if(0!==(12854&n.flags)||0!==(12854&n.subtreeFlags))return!1;n=n.sibling}return!0}if(Y)br=function(n,e){for(var t=e.child;null!==t;){if(5===t.tag||6===t.tag)L(n,t.stateNode);else if(4!==t.tag&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return;t=t.return}t.sibling.return=t.return,t=t.sibling}},Ur=function(){},_r=function(n,e,t,o,r){if((n=n.memoizedProps)!==o){var a=e.stateNode,i=uo(co.current);t=N(a,t,n,o,r,i),(e.updateQueue=t)&&Rr(e)}},wr=function(n,e,t,o){t!==o&&Rr(e)};else if(Z){br=function(n,e,t,o){for(var r=e.child;null!==r;){if(5===r.tag){var a=r.stateNode;t&&o&&(a=Pn(a,r.type,r.memoizedProps,r)),L(n,a)}else if(6===r.tag)a=r.stateNode,t&&o&&(a=Fn(a,r.memoizedProps,r)),L(n,a);else if(4!==r.tag)if(22===r.tag&&null!==r.memoizedState)null!==(a=r.child)&&(a.return=r),br(n,r,!0,!0);else if(null!==r.child){r.child.return=r,r=r.child;continue}if(r===e)break;for(;null===r.sibling;){if(null===r.return||r.return===e)return;r=r.return}r.sibling.return=r.return,r=r.sibling}};var Pr=function n(e,t,o,r){for(var a=t.child;null!==a;){if(5===a.tag){var i=a.stateNode;o&&r&&(i=Pn(i,a.type,a.memoizedProps,a)),Tn(e,i)}else if(6===a.tag)i=a.stateNode,o&&r&&(i=Fn(i,a.memoizedProps,a)),Tn(e,i);else if(4!==a.tag)if(22===a.tag&&null!==a.memoizedState)null!==(i=a.child)&&(i.return=a),n(e,a,!0,!0);else if(null!==a.child){a.child.return=a,a=a.child;continue}if(a===t)break;for(;null===a.sibling;){if(null===a.return||a.return===t)return;a=a.return}a.sibling.return=a.return,a=a.sibling}};Ur=function(n,e){var t=e.stateNode;if(!Dr(n,e)){n=t.containerInfo;var o=Cn(n);Pr(o,e,!1,!1),t.pendingChildren=o,Rr(e),Rn(n,o)}},_r=function(n,e,t,o,r){var a=n.stateNode,i=n.memoizedProps;if((n=Dr(n,e))&&i===o)e.stateNode=a;else{var v=e.stateNode,c=uo(co.current),s=null;i!==o&&(s=N(v,t,i,o,r,c)),n&&null===s?e.stateNode=a:(a=zn(a,s,t,i,o,e,n,v),G(a,t,o,r,c)&&Rr(e),e.stateNode=a,n?Rr(e):br(a,e,!1,!1))}},wr=function(n,e,t,o){t!==o?(n=uo(lo.current),t=uo(co.current),e.stateNode=q(o,n,t,e),Rr(e)):e.stateNode=n.stateNode}}else Ur=function(){},_r=function(){},wr=function(){};function Fr(n,e){if(!Vt)switch(n.tailMode){case"hidden":e=n.tail;for(var t=null;null!==e;)null!==e.alternate&&(t=e),e=e.sibling;null===t?n.tail=null:t.sibling=null;break;case"collapsed":t=n.tail;for(var o=null;null!==t;)null!==t.alternate&&(o=t),t=t.sibling;null===o?e||null===n.tail?n.tail=null:n.tail.sibling=null:o.sibling=null}}function jr(n){var e=null!==n.alternate&&n.alternate.child===n.child,t=0,o=0;if(e)for(var r=n.child;null!==r;)t|=r.lanes|r.childLanes,o|=14680064&r.subtreeFlags,o|=14680064&r.flags,r.return=n,r=r.sibling;else for(r=n.child;null!==r;)t|=r.lanes|r.childLanes,o|=r.subtreeFlags,o|=r.flags,r.return=n,r=r.sibling;return n.subtreeFlags|=o,n.childLanes=t,e}function Ir(n,e,t){var o=e.pendingProps;switch(Nt(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return jr(e),null;case 1:case 17:return de(e.type)&&he(),jr(e),null;case 3:return o=e.stateNode,po(),ce(fe),ce(ue),bo(),o.pendingContext&&(o.context=o.pendingContext,o.pendingContext=null),null!==n&&null!==n.child||(Kt(e)?Rr(e):null===n||n.memoizedState.isDehydrated&&0===(256&e.flags)||(e.flags|=1024,null!==Ht&&(Ci(Ht),Ht=null))),Ur(n,e),jr(e),null;case 5:ho(e),t=uo(lo.current);var r=e.type;if(null!==n&&null!=e.stateNode)_r(n,e,r,o,t),n.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!o){if(null===e.stateNode)throw Error(i(166));return jr(e),null}if(n=uo(co.current),Kt(e)){if(!Q)throw Error(i(175));n=Vn(e.stateNode,e.type,e.memoizedProps,t,n,e,!Wt),e.updateQueue=n,null!==n&&Rr(e)}else{var a=A(r,o,t,n,e);br(a,e,!1,!1),e.stateNode=a,G(a,r,o,t,n)&&Rr(e)}null!==e.ref&&(e.flags|=512,e.flags|=2097152)}return jr(e),null;case 6:if(n&&null!=e.stateNode)wr(n,e,n.memoizedProps,o);else{if("string"!==typeof o&&null===e.stateNode)throw Error(i(166));if(n=uo(lo.current),t=uo(co.current),Kt(e)){if(!Q)throw Error(i(176));if(n=e.stateNode,o=e.memoizedProps,(t=Wn(n,o,e,!Wt))&&null!==(r=Bt))switch(a=0!==(1&r.mode),r.tag){case 3:$n(r.stateNode.containerInfo,n,o,a);break;case 5:ne(r.type,r.memoizedProps,r.stateNode,n,o,a)}t&&Rr(e)}else e.stateNode=q(o,n,t,e)}return jr(e),null;case 13:if(ce(xo),o=e.memoizedState,Vt&&null!==qt&&0!==(1&e.mode)&&0===(128&e.flags)){for(n=qt;n;)n=Gn(n);return $t(),e.flags|=98560,e}if(null!==o&&null!==o.dehydrated){if(o=Kt(e),null===n){if(!o)throw Error(i(318));if(!Q)throw Error(i(344));if(!(n=null!==(n=e.memoizedState)?n.dehydrated:null))throw Error(i(317));Hn(n,e)}else $t(),0===(128&e.flags)&&(e.memoizedState=null),e.flags|=4;return jr(e),null}return null!==Ht&&(Ci(Ht),Ht=null),0!==(128&e.flags)?(e.lanes=t,e):(o=null!==o,t=!1,null===n?Kt(e):t=null!==n.memoizedState,o&&!t&&(e.child.flags|=8192,0!==(1&e.mode)&&(null===n||0!==(1&xo.current)?0===ni&&(ni=3):Ei())),null!==e.updateQueue&&(e.flags|=4),jr(e),null);case 4:return po(),Ur(n,e),null===n&&K(e.stateNode.containerInfo),jr(e),null;case 10:return ct(e.type._context),jr(e),null;case 19:if(ce(xo),null===(r=e.memoizedState))return jr(e),null;if(o=0!==(128&e.flags),null===(a=r.rendering))if(o)Fr(r,!1);else{if(0!==ni||null!==n&&0!==(128&n.flags))for(n=e.child;null!==n;){if(null!==(a=go(n))){for(e.flags|=128,Fr(r,!1),null!==(n=a.updateQueue)&&(e.updateQueue=n,e.flags|=4),e.subtreeFlags=0,n=t,o=e.child;null!==o;)r=n,(t=o).flags&=14680066,null===(a=t.alternate)?(t.childLanes=0,t.lanes=r,t.child=null,t.subtreeFlags=0,t.memoizedProps=null,t.memoizedState=null,t.updateQueue=null,t.dependencies=null,t.stateNode=null):(t.childLanes=a.childLanes,t.lanes=a.lanes,t.child=a.child,t.subtreeFlags=0,t.deletions=null,t.memoizedProps=a.memoizedProps,t.memoizedState=a.memoizedState,t.updateQueue=a.updateQueue,t.type=a.type,r=a.dependencies,t.dependencies=null===r?null:{lanes:r.lanes,firstContext:r.firstContext}),o=o.sibling;return se(xo,1&xo.current|2),e.child}n=n.sibling}null!==r.tail&&Le()>ci&&(e.flags|=128,o=!0,Fr(r,!1),e.lanes=4194304)}else{if(!o)if(null!==(n=go(a))){if(e.flags|=128,o=!0,null!==(n=n.updateQueue)&&(e.updateQueue=n,e.flags|=4),Fr(r,!0),null===r.tail&&"hidden"===r.tailMode&&!a.alternate&&!Vt)return jr(e),null}else 2*Le()-r.renderingStartTime>ci&&1073741824!==t&&(e.flags|=128,o=!0,Fr(r,!1),e.lanes=4194304);r.isBackwards?(a.sibling=e.child,e.child=a):(null!==(n=r.last)?n.sibling=a:e.child=a,r.last=a)}return null!==r.tail?(e=r.tail,r.rendering=e,r.tail=e.sibling,r.renderingStartTime=Le(),e.sibling=null,n=xo.current,se(xo,o?1&n|2:1&n),e):(jr(e),null);case 22:case 23:return Pi(),o=null!==e.memoizedState,null!==n&&null!==n.memoizedState!==o&&(e.flags|=8192),o&&0!==(1&e.mode)?0!==(1073741824&Ka)&&(jr(e),Y&&6&e.subtreeFlags&&(e.flags|=8192)):jr(e),null;case 24:case 25:return null}throw Error(i(156,e.tag))}var Er=v.ReactCurrentOwner,Or=!1;function Ar(n,e,t,o){e.child=null===n?io(e,null,t,o):ao(e,n.child,t,o)}function Lr(n,e,t,o,r){t=t.render;var a=e.ref;return lt(e,r),o=Fo(n,e,t,o,a,r),t=jo(),null===n||Or?(Vt&&t&&Gt(e),e.flags|=1,Ar(n,e,o,r),e.child):(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~r,aa(n,e,r))}function Gr(n,e,t,o,r){if(null===n){var a=t.type;return"function"!==typeof a||$i(a)||void 0!==a.defaultProps||null!==t.compare||void 0!==t.defaultProps?((n=ev(t.type,null,o,e,e.mode,r)).ref=e.ref,n.return=e,e.child=n):(e.tag=15,e.type=a,Nr(n,e,a,o,r))}if(a=n.child,0===(n.lanes&r)){var i=a.memoizedProps;if((t=null!==(t=t.compare)?t:$e)(i,o)&&n.ref===e.ref)return aa(n,e,r)}return e.flags|=1,(n=nv(a,o)).ref=e.ref,n.return=e,e.child=n}function Nr(n,e,t,o,r){if(null!==n&&$e(n.memoizedProps,o)&&n.ref===e.ref){if(Or=!1,0===(n.lanes&r))return e.lanes=n.lanes,aa(n,e,r);0!==(131072&n.flags)&&(Or=!0)}return Vr(n,e,t,o,r)}function Br(n,e,t){var o=e.pendingProps,r=o.children,a=null!==n?n.memoizedState:null;if("hidden"===o.mode)if(0===(1&e.mode))e.memoizedState={baseLanes:0,cachePool:null},se($a,Ka),Ka|=t;else{if(0===(1073741824&t))return n=null!==a?a.baseLanes|t:t,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:n,cachePool:null},e.updateQueue=null,se($a,Ka),Ka|=n,null;e.memoizedState={baseLanes:0,cachePool:null},o=null!==a?a.baseLanes:t,se($a,Ka),Ka|=o}else null!==a?(o=a.baseLanes|t,e.memoizedState=null):o=t,se($a,Ka),Ka|=o;return Ar(n,e,r,t),e.child}function qr(n,e){var t=e.ref;(null===n&&null!==t||null!==n&&n.ref!==t)&&(e.flags|=512,e.flags|=2097152)}function Vr(n,e,t,o,r){var a=de(t)?pe:ue.current;return a=me(e,a),lt(e,r),t=Fo(n,e,t,o,a,r),o=jo(),null===n||Or?(Vt&&o&&Gt(e),e.flags|=1,Ar(n,e,t,r),e.child):(e.updateQueue=n.updateQueue,e.flags&=-2053,n.lanes&=~r,aa(n,e,r))}function Wr(n,e,t,o,r){if(de(t)){var a=!0;ye(e)}else a=!1;if(lt(e,r),null===e.stateNode)null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2),kt(e,t,o),Ct(e,t,o,r),o=!0;else if(null===n){var i=e.stateNode,v=e.memoizedProps;i.props=v;var c=i.context,s=t.contextType;"object"===typeof s&&null!==s?s=ut(s):s=me(e,s=de(t)?pe:ue.current);var l=t.getDerivedStateFromProps,u="function"===typeof l||"function"===typeof i.getSnapshotBeforeUpdate;u||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(v!==o||c!==s)&&zt(e,i,o,s),pt=!1;var f=e.memoizedState;i.state=f,bt(e,o,i,r),c=e.memoizedState,v!==o||f!==c||fe.current||pt?("function"===typeof l&&(wt(e,t,l,o),c=e.memoizedState),(v=pt||Mt(e,t,v,o,f,c,s))?(u||"function"!==typeof i.UNSAFE_componentWillMount&&"function"!==typeof i.componentWillMount||("function"===typeof i.componentWillMount&&i.componentWillMount(),"function"===typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount()),"function"===typeof i.componentDidMount&&(e.flags|=4194308)):("function"===typeof i.componentDidMount&&(e.flags|=4194308),e.memoizedProps=o,e.memoizedState=c),i.props=o,i.state=c,i.context=s,o=v):("function"===typeof i.componentDidMount&&(e.flags|=4194308),o=!1)}else{i=e.stateNode,dt(n,e),v=e.memoizedProps,s=e.type===e.elementType?v:et(e.type,v),i.props=s,u=e.pendingProps,f=i.context,"object"===typeof(c=t.contextType)&&null!==c?c=ut(c):c=me(e,c=de(t)?pe:ue.current);var p=t.getDerivedStateFromProps;(l="function"===typeof p||"function"===typeof i.getSnapshotBeforeUpdate)||"function"!==typeof i.UNSAFE_componentWillReceiveProps&&"function"!==typeof i.componentWillReceiveProps||(v!==u||f!==c)&&zt(e,i,o,c),pt=!1,f=e.memoizedState,i.state=f,bt(e,o,i,r);var m=e.memoizedState;v!==u||f!==m||fe.current||pt?("function"===typeof p&&(wt(e,t,p,o),m=e.memoizedState),(s=pt||Mt(e,t,s,o,f,m,c)||!1)?(l||"function"!==typeof i.UNSAFE_componentWillUpdate&&"function"!==typeof i.componentWillUpdate||("function"===typeof i.componentWillUpdate&&i.componentWillUpdate(o,m,c),"function"===typeof i.UNSAFE_componentWillUpdate&&i.UNSAFE_componentWillUpdate(o,m,c)),"function"===typeof i.componentDidUpdate&&(e.flags|=4),"function"===typeof i.getSnapshotBeforeUpdate&&(e.flags|=1024)):("function"!==typeof i.componentDidUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=1024),e.memoizedProps=o,e.memoizedState=m),i.props=o,i.state=m,i.context=c,o=s):("function"!==typeof i.componentDidUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=4),"function"!==typeof i.getSnapshotBeforeUpdate||v===n.memoizedProps&&f===n.memoizedState||(e.flags|=1024),o=!1)}return Hr(n,e,t,o,a,r)}function Hr(n,e,t,o,r,a){qr(n,e);var i=0!==(128&e.flags);if(!o&&!i)return r&&be(e,t,!1),aa(n,e,a);o=e.stateNode,Er.current=e;var v=i&&"function"!==typeof t.getDerivedStateFromError?null:o.render();return e.flags|=1,null!==n&&i?(e.child=ao(e,n.child,null,a),e.child=ao(e,null,v,a)):Ar(n,e,v,a),e.memoizedState=o.state,r&&be(e,t,!0),e.child}function Xr(n){var e=n.stateNode;e.pendingContext?xe(0,e.pendingContext,e.pendingContext!==e.context):e.context&&xe(0,e.context,!1),fo(n,e.containerInfo)}function Yr(n,e,t,o,r){return $t(),no(r),e.flags|=256,Ar(n,e,t,o),e.child}var Zr={dehydrated:null,treeContext:null,retryLane:0};function Qr(n){return{baseLanes:n,cachePool:null}}function Jr(n,e,t){var o,r=e.pendingProps,a=xo.current,v=!1,c=0!==(128&e.flags);if((o=c)||(o=(null===n||null!==n.memoizedState)&&0!==(2&a)),o?(v=!0,e.flags&=-129):null!==n&&null===n.memoizedState||(a|=1),se(xo,1&a),null===n)return Qt(e),null!==(n=e.memoizedState)&&null!==(n=n.dehydrated)?(0===(1&e.mode)?e.lanes=1:An(n)?e.lanes=8:e.lanes=1073741824,null):(a=r.children,n=r.fallback,v?(r=e.mode,v=e.child,a={mode:"hidden",children:a},0===(1&r)&&null!==v?(v.childLanes=0,v.pendingProps=a):v=ov(a,r,0,null),n=tv(n,r,t,null),v.return=e,n.return=e,v.sibling=n,e.child=v,e.child.memoizedState=Qr(t),e.memoizedState=Zr,n):Kr(e,a));if(null!==(a=n.memoizedState)){if(null!==(o=a.dehydrated)){if(c)return 256&e.flags?(e.flags&=-257,ea(n,e,t,Error(i(422)))):null!==e.memoizedState?(e.child=n.child,e.flags|=128,null):(v=r.fallback,a=e.mode,r=ov({mode:"visible",children:r.children},a,0,null),(v=tv(v,a,t,null)).flags|=2,r.return=e,v.return=e,r.sibling=v,e.child=r,0!==(1&e.mode)&&ao(e,n.child,null,t),e.child.memoizedState=Qr(t),e.memoizedState=Zr,v);if(0===(1&e.mode))e=ea(n,e,t,null);else if(An(o))e=ea(n,e,t,Error(i(419)));else if(r=0!==(t&n.childLanes),Or||r){if(null!==(r=Za)){switch(t&-t){case 4:v=2;break;case 16:v=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:v=32;break;case 536870912:v=268435456;break;default:v=0}0!==(r=0!==(v&(r.suspendedLanes|t))?0:v)&&r!==a.retryLane&&(a.retryLane=r,wi(n,r,-1))}Ei(),e=ea(n,e,t,Error(i(421)))}else On(o)?(e.flags|=128,e.child=n.child,e=Yi.bind(null,n),Ln(o,e),e=null):(t=a.treeContext,Q&&(qt=qn(o),Bt=e,Vt=!0,Ht=null,Wt=!1,null!==t&&(Ft[jt++]=Et,Ft[jt++]=Ot,Ft[jt++]=It,Et=t.id,Ot=t.overflow,It=e)),(e=Kr(e,e.pendingProps.children)).flags|=4096);return e}return v?(r=na(n,e,r.children,r.fallback,t),v=e.child,a=n.child.memoizedState,v.memoizedState=null===a?Qr(t):{baseLanes:a.baseLanes|t,cachePool:null},v.childLanes=n.childLanes&~t,e.memoizedState=Zr,r):(t=$r(n,e,r.children,t),e.memoizedState=null,t)}return v?(r=na(n,e,r.children,r.fallback,t),v=e.child,a=n.child.memoizedState,v.memoizedState=null===a?Qr(t):{baseLanes:a.baseLanes|t,cachePool:null},v.childLanes=n.childLanes&~t,e.memoizedState=Zr,r):(t=$r(n,e,r.children,t),e.memoizedState=null,t)}function Kr(n,e){return(e=ov({mode:"visible",children:e},n.mode,0,null)).return=n,n.child=e}function $r(n,e,t,o){var r=n.child;return n=r.sibling,t=nv(r,{mode:"visible",children:t}),0===(1&e.mode)&&(t.lanes=o),t.return=e,t.sibling=null,null!==n&&(null===(o=e.deletions)?(e.deletions=[n],e.flags|=16):o.push(n)),e.child=t}function na(n,e,t,o,r){var a=e.mode,i=(n=n.child).sibling,v={mode:"hidden",children:t};return 0===(1&a)&&e.child!==n?((t=e.child).childLanes=0,t.pendingProps=v,e.deletions=null):(t=nv(n,v)).subtreeFlags=14680064&n.subtreeFlags,null!==i?o=nv(i,o):(o=tv(o,a,r,null)).flags|=2,o.return=e,t.return=e,t.sibling=o,e.child=t,o}function ea(n,e,t,o){return null!==o&&no(o),ao(e,n.child,null,t),(n=Kr(e,e.pendingProps.children)).flags|=2,e.memoizedState=null,n}function ta(n,e,t){n.lanes|=e;var o=n.alternate;null!==o&&(o.lanes|=e),st(n.return,e,t)}function oa(n,e,t,o,r){var a=n.memoizedState;null===a?n.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:o,tail:t,tailMode:r}:(a.isBackwards=e,a.rendering=null,a.renderingStartTime=0,a.last=o,a.tail=t,a.tailMode=r)}function ra(n,e,t){var o=e.pendingProps,r=o.revealOrder,a=o.tail;if(Ar(n,e,o.children,t),0!==(2&(o=xo.current)))o=1&o|2,e.flags|=128;else{if(null!==n&&0!==(128&n.flags))n:for(n=e.child;null!==n;){if(13===n.tag)null!==n.memoizedState&&ta(n,t,e);else if(19===n.tag)ta(n,t,e);else if(null!==n.child){n.child.return=n,n=n.child;continue}if(n===e)break n;for(;null===n.sibling;){if(null===n.return||n.return===e)break n;n=n.return}n.sibling.return=n.return,n=n.sibling}o&=1}if(se(xo,o),0===(1&e.mode))e.memoizedState=null;else switch(r){case"forwards":for(t=e.child,r=null;null!==t;)null!==(n=t.alternate)&&null===go(n)&&(r=t),t=t.sibling;null===(t=r)?(r=e.child,e.child=null):(r=t.sibling,t.sibling=null),oa(e,!1,r,t,a);break;case"backwards":for(t=null,r=e.child,e.child=null;null!==r;){if(null!==(n=r.alternate)&&null===go(n)){e.child=r;break}n=r.sibling,r.sibling=t,t=r,r=n}oa(e,!0,t,null,a);break;case"together":oa(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function aa(n,e,t){if(null!==n&&(e.dependencies=n.dependencies),ti|=e.lanes,0===(t&e.childLanes))return null;if(null!==n&&e.child!==n.child)throw Error(i(153));if(null!==e.child){for(t=nv(n=e.child,n.pendingProps),e.child=t,t.return=e;null!==n.sibling;)n=n.sibling,(t=t.sibling=nv(n,n.pendingProps)).return=e;t.sibling=null}return e.child}function ia(n,e){switch(Nt(e),e.tag){case 1:return de(e.type)&&he(),65536&(n=e.flags)?(e.flags=-65537&n|128,e):null;case 3:return po(),ce(fe),ce(ue),bo(),0!==(65536&(n=e.flags))&&0===(128&n)?(e.flags=-65537&n|128,e):null;case 5:return ho(e),null;case 13:if(ce(xo),null!==(n=e.memoizedState)&&null!==n.dehydrated){if(null===e.alternate)throw Error(i(340));$t()}return 65536&(n=e.flags)?(e.flags=-65537&n|128,e):null;case 19:return ce(xo),null;case 4:return po(),null;case 10:return ct(e.type._context),null;case 22:case 23:return Pi(),null;default:return null}}var va=!1,ca=!1,sa="function"===typeof WeakSet?WeakSet:Set,la=null;function ua(n,e){var t=n.ref;if(null!==t)if("function"===typeof t)try{t(null)}catch(o){Wi(n,e,o)}else t.current=null}function fa(n,e,t){try{t()}catch(o){Wi(n,e,o)}}var pa=!1;function ma(n,e,t){var o=e.updateQueue;if(null!==(o=null!==o?o.lastEffect:null)){var r=o=o.next;do{if((r.tag&n)===n){var a=r.destroy;r.destroy=void 0,void 0!==a&&fa(e,t,a)}r=r.next}while(r!==o)}}function da(n,e){if(null!==(e=null!==(e=e.updateQueue)?e.lastEffect:null)){var t=e=e.next;do{if((t.tag&n)===n){var o=t.create;t.destroy=o()}t=t.next}while(t!==e)}}function ha(n){var e=n.ref;if(null!==e){var t=n.stateNode;if(5===n.tag)n=F(t);else n=t;"function"===typeof e?e(n):e.current=n}}function xa(n,e,t){if(We&&"function"===typeof We.onCommitFiberUnmount)try{We.onCommitFiberUnmount(Ve,e)}catch(i){}switch(e.tag){case 0:case 11:case 14:case 15:if(null!==(n=e.updateQueue)&&null!==(n=n.lastEffect)){var o=n=n.next;do{var r=o,a=r.destroy;r=r.tag,void 0!==a&&(0!==(2&r)||0!==(4&r))&&fa(e,t,a),o=o.next}while(o!==n)}break;case 1:if(ua(e,t),"function"===typeof(n=e.stateNode).componentWillUnmount)try{n.props=e.memoizedProps,n.state=e.memoizedState,n.componentWillUnmount()}catch(i){Wi(e,t,i)}break;case 5:ua(e,t);break;case 4:Y?Ma(n,e,t):Z&&Z&&(e=e.stateNode.containerInfo,t=Cn(e),Dn(e,t))}}function ga(n,e,t){for(var o=e;;)if(xa(n,o,t),null===o.child||Y&&4===o.tag){if(o===e)break;for(;null===o.sibling;){if(null===o.return||o.return===e)return;o=o.return}o.sibling.return=o.return,o=o.sibling}else o.child.return=o,o=o.child}function ya(n){var e=n.alternate;null!==e&&(n.alternate=null,ya(e)),n.child=null,n.deletions=null,n.sibling=null,5===n.tag&&(null!==(e=n.stateNode)&&nn(e)),n.stateNode=null,n.return=null,n.dependencies=null,n.memoizedProps=null,n.memoizedState=null,n.pendingProps=null,n.stateNode=null,n.updateQueue=null}function ba(n){return 5===n.tag||3===n.tag||4===n.tag}function Ua(n){n:for(;;){for(;null===n.sibling;){if(null===n.return||ba(n.return))return null;n=n.return}for(n.sibling.return=n.return,n=n.sibling;5!==n.tag&&6!==n.tag&&18!==n.tag;){if(2&n.flags)continue n;if(null===n.child||4===n.tag)continue n;n.child.return=n,n=n.child}if(!(2&n.flags))return n.stateNode}}function _a(n){if(Y){n:{for(var e=n.return;null!==e;){if(ba(e))break n;e=e.return}throw Error(i(160))}var t=e;switch(t.tag){case 5:e=t.stateNode,32&t.flags&&(Un(e),t.flags&=-33),Sa(n,t=Ua(n),e);break;case 3:case 4:e=t.stateNode.containerInfo,wa(n,t=Ua(n),e);break;default:throw Error(i(161))}}}function wa(n,e,t){var o=n.tag;if(5===o||6===o)n=n.stateNode,e?gn(t,n,e):pn(t,n);else if(4!==o&&null!==(n=n.child))for(wa(n,e,t),n=n.sibling;null!==n;)wa(n,e,t),n=n.sibling}function Sa(n,e,t){var o=n.tag;if(5===o||6===o)n=n.stateNode,e?xn(t,n,e):fn(t,n);else if(4!==o&&null!==(n=n.child))for(Sa(n,e,t),n=n.sibling;null!==n;)Sa(n,e,t),n=n.sibling}function Ma(n,e,t){for(var o,r,a=e,v=!1;;){if(!v){v=a.return;n:for(;;){if(null===v)throw Error(i(160));switch(o=v.stateNode,v.tag){case 5:r=!1;break n;case 3:case 4:o=o.containerInfo,r=!0;break n}v=v.return}v=!0}if(5===a.tag||6===a.tag)ga(n,a,t),r?bn(o,a.stateNode):yn(o,a.stateNode);else if(18===a.tag)r?Jn(o,a.stateNode):Qn(o,a.stateNode);else if(4===a.tag){if(null!==a.child){o=a.stateNode.containerInfo,r=!0,a.child.return=a,a=a.child;continue}}else if(xa(n,a,t),null!==a.child){a.child.return=a,a=a.child;continue}if(a===e)break;for(;null===a.sibling;){if(null===a.return||a.return===e)return;4===(a=a.return).tag&&(v=!1)}a.sibling.return=a.return,a=a.sibling}}function ka(n,e){if(Y){switch(e.tag){case 0:case 11:case 14:case 15:return ma(3,e,e.return),da(3,e),void ma(5,e,e.return);case 1:case 12:case 17:return;case 5:var t=e.stateNode;if(null!=t){var o=e.memoizedProps;n=null!==n?n.memoizedProps:o;var r=e.type,a=e.updateQueue;e.updateQueue=null,null!==a&&hn(t,a,r,n,o,e)}return;case 6:if(null===e.stateNode)throw Error(i(162));return t=e.memoizedProps,void mn(e.stateNode,null!==n?n.memoizedProps:t,t);case 3:return void(Q&&null!==n&&n.memoizedState.isDehydrated&&Yn(e.stateNode.containerInfo));case 13:case 19:return void za(e)}throw Error(i(163))}switch(e.tag){case 0:case 11:case 14:case 15:return ma(3,e,e.return),da(3,e),void ma(5,e,e.return);case 12:case 22:case 23:return;case 13:case 19:return void za(e);case 3:Q&&null!==n&&n.memoizedState.isDehydrated&&Yn(e.stateNode.containerInfo)}n:if(Z){switch(e.tag){case 1:case 5:case 6:break n;case 3:case 4:e=e.stateNode,Dn(e.containerInfo,e.pendingChildren);break n}throw Error(i(163))}}function za(n){var e=n.updateQueue;if(null!==e){n.updateQueue=null;var t=n.stateNode;null===t&&(t=n.stateNode=new sa),e.forEach((function(e){var o=Zi.bind(null,n,e);t.has(e)||(t.add(e),e.then(o,o))}))}}function Ca(n,e,t){la=n,Ta(n,e,t)}function Ta(n,e,t){for(var o=0!==(1&n.mode);null!==la;){var r=la,a=r.child;if(22===r.tag&&o){var i=null!==r.memoizedState||va;if(!i){var v=r.alternate,c=null!==v&&null!==v.memoizedState||ca;v=va;var s=ca;if(va=i,(ca=c)&&!s)for(la=r;null!==la;)c=(i=la).child,22===i.tag&&null!==i.memoizedState?Pa(r):null!==c?(c.return=i,la=c):Pa(r);for(;null!==a;)la=a,Ta(a,e,t),a=a.sibling;la=r,va=v,ca=s}Ra(n)}else 0!==(8772&r.subtreeFlags)&&null!==a?(a.return=r,la=a):Ra(n)}}function Ra(n){for(;null!==la;){var e=la;if(0!==(8772&e.flags)){var t=e.alternate;try{if(0!==(8772&e.flags))switch(e.tag){case 0:case 11:case 15:ca||da(5,e);break;case 1:var o=e.stateNode;if(4&e.flags&&!ca)if(null===t)o.componentDidMount();else{var r=e.elementType===e.type?t.memoizedProps:et(e.type,t.memoizedProps);o.componentDidUpdate(r,t.memoizedState,o.__reactInternalSnapshotBeforeUpdate)}var a=e.updateQueue;null!==a&&Ut(e,a,o);break;case 3:var v=e.updateQueue;if(null!==v){if(t=null,null!==e.child)switch(e.child.tag){case 5:t=F(e.child.stateNode);break;case 1:t=e.child.stateNode}Ut(e,v,t)}break;case 5:var c=e.stateNode;null===t&&4&e.flags&&dn(c,e.type,e.memoizedProps,e);break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:break;case 13:if(Q&&null===e.memoizedState){var s=e.alternate;if(null!==s){var l=s.memoizedState;if(null!==l){var u=l.dehydrated;null!==u&&Zn(u)}}}break;default:throw Error(i(163))}ca||512&e.flags&&ha(e)}catch(f){Wi(e,e.return,f)}}if(e===n){la=null;break}if(null!==(t=e.sibling)){t.return=e.return,la=t;break}la=e.return}}function Da(n){for(;null!==la;){var e=la;if(e===n){la=null;break}var t=e.sibling;if(null!==t){t.return=e.return,la=t;break}la=e.return}}function Pa(n){for(;null!==la;){var e=la;try{switch(e.tag){case 0:case 11:case 15:var t=e.return;try{da(4,e)}catch(c){Wi(e,t,c)}break;case 1:var o=e.stateNode;if("function"===typeof o.componentDidMount){var r=e.return;try{o.componentDidMount()}catch(c){Wi(e,r,c)}}var a=e.return;try{ha(e)}catch(c){Wi(e,a,c)}break;case 5:var i=e.return;try{ha(e)}catch(c){Wi(e,i,c)}}}catch(c){Wi(e,e.return,c)}if(e===n){la=null;break}var v=e.sibling;if(null!==v){v.return=e.return,la=v;break}la=e.return}}var Fa=0,ja=1,Ia=2,Ea=3,Oa=4;if("function"===typeof Symbol&&Symbol.for){var Aa=Symbol.for;Fa=Aa("selector.component"),ja=Aa("selector.has_pseudo_class"),Ia=Aa("selector.role"),Ea=Aa("selector.test_id"),Oa=Aa("selector.text")}function La(n){var e=J(n);if(null!=e){if("string"!==typeof e.memoizedProps["data-testname"])throw Error(i(364));return e}if(null===(n=rn(n)))throw Error(i(362));return n.stateNode.current}function Ga(n,e){switch(e.$$typeof){case Fa:if(n.type===e.value)return!0;break;case ja:n:{e=e.value,n=[n,0];for(var t=0;t<n.length;){var o=n[t++],r=n[t++],a=e[r];if(5!==o.tag||!cn(o)){for(;null!=a&&Ga(o,a);)a=e[++r];if(r===e.length){e=!0;break n}for(o=o.child;null!==o;)n.push(o,r),o=o.sibling}}e=!1}return e;case Ia:if(5===n.tag&&sn(n.stateNode,e.value))return!0;break;case Oa:if((5===n.tag||6===n.tag)&&(null!==(n=vn(n))&&0<=n.indexOf(e.value)))return!0;break;case Ea:if(5===n.tag&&("string"===typeof(n=n.memoizedProps["data-testname"])&&n.toLowerCase()===e.value.toLowerCase()))return!0;break;default:throw Error(i(365))}return!1}function Na(n){switch(n.$$typeof){case Fa:return"<"+(w(n.value)||"Unknown")+">";case ja:return":has("+(Na(n)||"")+")";case Ia:return'[role="'+n.value+'"]';case Oa:return'"'+n.value+'"';case Ea:return'[data-testname="'+n.value+'"]';default:throw Error(i(365))}}function Ba(n,e){var t=[];n=[n,0];for(var o=0;o<n.length;){var r=n[o++],a=n[o++],i=e[a];if(5!==r.tag||!cn(r)){for(;null!=i&&Ga(r,i);)i=e[++a];if(a===e.length)t.push(r);else for(r=r.child;null!==r;)n.push(r,a),r=r.sibling}}return t}function qa(n,e){if(!on)throw Error(i(363));n=Ba(n=La(n),e),e=[],n=Array.from(n);for(var t=0;t<n.length;){var o=n[t++];if(5===o.tag)cn(o)||e.push(o.stateNode);else for(o=o.child;null!==o;)n.push(o),o=o.sibling}return e}var Va=Math.ceil,Wa=v.ReactCurrentDispatcher,Ha=v.ReactCurrentOwner,Xa=v.ReactCurrentBatchConfig,Ya=0,Za=null,Qa=null,Ja=0,Ka=0,$a=ve(0),ni=0,ei=null,ti=0,oi=0,ri=0,ai=null,ii=null,vi=0,ci=1/0;function si(){ci=Le()+500}var li,ui=!1,fi=null,pi=null,mi=!1,di=null,hi=0,xi=0,gi=null,yi=-1,bi=0;function Ui(){return 0!==(6&Ya)?Le():-1!==yi?yi:yi=Le()}function _i(n){return 0===(1&n.mode)?1:0!==(2&Ya)&&0!==Ja?Ja&-Ja:null!==Ke.transition?(0===bi&&(n=Se,0===(4194240&(Se<<=1))&&(Se=64),bi=n),bi):0!==(n=Fe)?n:$()}function wi(n,e,t){if(50<xi)throw xi=0,gi=null,Error(i(185));var o=Si(n,e);return null===o?null:(De(o,e,t),0!==(2&Ya)&&o===Za||(o===Za&&(0===(2&Ya)&&(oi|=e),4===ni&&Ti(o,Ja)),Mi(o,t),1===e&&0===Ya&&0===(1&n.mode)&&(si(),Ye&&Je())),o)}function Si(n,e){n.lanes|=e;var t=n.alternate;for(null!==t&&(t.lanes|=e),t=n,n=n.return;null!==n;)n.childLanes|=e,null!==(t=n.alternate)&&(t.childLanes|=e),t=n,n=n.return;return 3===t.tag?t.stateNode:null}function Mi(n,e){var t=n.callbackNode;!function(n,e){for(var t=n.suspendedLanes,o=n.pingedLanes,r=n.expirationTimes,a=n.pendingLanes;0<a;){var i=31-Ue(a),v=1<<i,c=r[i];-1===c?0!==(v&t)&&0===(v&o)||(r[i]=Ce(v,e)):c<=e&&(n.expiredLanes|=v),a&=~v}}(n,e);var o=ze(n,n===Za?Ja:0);if(0===o)null!==t&&Ee(t),n.callbackNode=null,n.callbackPriority=0;else if(e=o&-o,n.callbackPriority!==e){if(null!=t&&Ee(t),1===e)0===n.tag?function(n){Ye=!0,Qe(n)}(Ri.bind(null,n)):Qe(Ri.bind(null,n)),en?tn((function(){0===Ya&&Je()})):Ie(Ge,Je),t=null;else{switch(je(o)){case 1:t=Ge;break;case 4:t=Ne;break;case 16:default:t=Be;break;case 536870912:t=qe}t=Qi(t,ki.bind(null,n))}n.callbackPriority=e,n.callbackNode=t}}function ki(n,e){if(yi=-1,bi=0,0!==(6&Ya))throw Error(i(327));var t=n.callbackNode;if(qi()&&n.callbackNode!==t)return null;var o=ze(n,n===Za?Ja:0);if(0===o)return null;if(0!==(30&o)||0!==(o&n.expiredLanes)||e)e=Oi(n,o);else{e=o;var r=Ya;Ya|=2;var a=Ii();for(Za===n&&Ja===e||(si(),Fi(n,e));;)try{Li();break}catch(c){ji(n,c)}it(),Wa.current=a,Ya=r,null!==Qa?e=0:(Za=null,Ja=0,e=ni)}if(0!==e){if(2===e&&(0!==(r=Te(n))&&(o=r,e=zi(n,r))),1===e)throw t=ei,Fi(n,0),Ti(n,o),Mi(n,Le()),t;if(6===e)Ti(n,o);else{if(r=n.current.alternate,0===(30&o)&&!function(n){for(var e=n;;){if(16384&e.flags){var t=e.updateQueue;if(null!==t&&null!==(t=t.stores))for(var o=0;o<t.length;o++){var r=t[o],a=r.getSnapshot;r=r.value;try{if(!He(a(),r))return!1}catch(v){return!1}}}if(t=e.child,16384&e.subtreeFlags&&null!==t)t.return=e,e=t;else{if(e===n)break;for(;null===e.sibling;){if(null===e.return||e.return===n)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}(r)&&(2===(e=Oi(n,o))&&(0!==(a=Te(n))&&(o=a,e=zi(n,a))),1===e))throw t=ei,Fi(n,0),Ti(n,o),Mi(n,Le()),t;switch(n.finishedWork=r,n.finishedLanes=o,e){case 0:case 1:throw Error(i(345));case 2:case 5:Bi(n,ii);break;case 3:if(Ti(n,o),(130023424&o)===o&&10<(e=vi+500-Le())){if(0!==ze(n,0))break;if(((r=n.suspendedLanes)&o)!==o){Ui(),n.pingedLanes|=n.suspendedLanes&r;break}n.timeoutHandle=V(Bi.bind(null,n,ii),e);break}Bi(n,ii);break;case 4:if(Ti(n,o),(4194240&o)===o)break;for(e=n.eventTimes,r=-1;0<o;){var v=31-Ue(o);a=1<<v,(v=e[v])>r&&(r=v),o&=~a}if(o=r,10<(o=(120>(o=Le()-o)?120:480>o?480:1080>o?1080:1920>o?1920:3e3>o?3e3:4320>o?4320:1960*Va(o/1960))-o)){n.timeoutHandle=V(Bi.bind(null,n,ii),o);break}Bi(n,ii);break;default:throw Error(i(329))}}}return Mi(n,Le()),n.callbackNode===t?ki.bind(null,n):null}function zi(n,e){var t=ai;return n.current.memoizedState.isDehydrated&&(Fi(n,e).flags|=256),2!==(n=Oi(n,e))&&(e=ii,ii=t,null!==e&&Ci(e)),n}function Ci(n){null===ii?ii=n:ii.push.apply(ii,n)}function Ti(n,e){for(e&=~ri,e&=~oi,n.suspendedLanes|=e,n.pingedLanes&=~e,n=n.expirationTimes;0<e;){var t=31-Ue(e),o=1<<t;n[t]=-1,e&=~o}}function Ri(n){if(0!==(6&Ya))throw Error(i(327));qi();var e=ze(n,0);if(0===(1&e))return Mi(n,Le()),null;var t=Oi(n,e);if(0!==n.tag&&2===t){var o=Te(n);0!==o&&(e=o,t=zi(n,o))}if(1===t)throw t=ei,Fi(n,0),Ti(n,e),Mi(n,Le()),t;if(6===t)throw Error(i(345));return n.finishedWork=n.current.alternate,n.finishedLanes=e,Bi(n,ii),Mi(n,Le()),null}function Di(n){null!==di&&0===di.tag&&0===(6&Ya)&&qi();var e=Ya;Ya|=1;var t=Xa.transition,o=Fe;try{if(Xa.transition=null,Fe=1,n)return n()}finally{Fe=o,Xa.transition=t,0===(6&(Ya=e))&&Je()}}function Pi(){Ka=$a.current,ce($a)}function Fi(n,e){n.finishedWork=null,n.finishedLanes=0;var t=n.timeoutHandle;if(t!==H&&(n.timeoutHandle=H,W(t)),null!==Qa)for(t=Qa.return;null!==t;){var o=t;switch(Nt(o),o.tag){case 1:null!==(o=o.type.childContextTypes)&&void 0!==o&&he();break;case 3:po(),ce(fe),ce(ue),bo();break;case 5:ho(o);break;case 4:po();break;case 13:case 19:ce(xo);break;case 10:ct(o.type._context);break;case 22:case 23:Pi()}t=t.return}if(Za=n,Qa=n=nv(n.current,null),Ja=Ka=e,ni=0,ei=null,ri=oi=ti=0,ii=ai=null,null!==ft){for(e=0;e<ft.length;e++)if(null!==(o=(t=ft[e]).interleaved)){t.interleaved=null;var r=o.next,a=t.pending;if(null!==a){var i=a.next;a.next=r,o.next=i}t.pending=o}ft=null}return n}function ji(n,e){for(;;){var t=Qa;try{if(it(),Uo.current=mr,zo){for(var o=So.memoizedState;null!==o;){var r=o.queue;null!==r&&(r.pending=null),o=o.next}zo=!1}if(wo=0,ko=Mo=So=null,Co=!1,To=0,Ha.current=null,null===t||null===t.return){ni=1,ei=e,Qa=null;break}n:{var a=n,v=t.return,c=t,s=e;if(e=Ja,c.flags|=32768,null!==s&&"object"===typeof s&&"function"===typeof s.then){var l=s,u=c,f=u.tag;if(0===(1&u.mode)&&(0===f||11===f||15===f)){var p=u.alternate;p?(u.updateQueue=p.updateQueue,u.memoizedState=p.memoizedState,u.lanes=p.lanes):(u.updateQueue=null,u.memoizedState=null)}var m=Cr(v);if(null!==m){m.flags&=-257,Tr(m,v,c,0,e),1&m.mode&&zr(a,l,e),s=l;var d=(e=m).updateQueue;if(null===d){var h=new Set;h.add(s),e.updateQueue=h}else d.add(s);break n}if(0===(1&e)){zr(a,l,e),Ei();break n}s=Error(i(426))}else if(Vt&&1&c.mode){var x=Cr(v);if(null!==x){0===(65536&x.flags)&&(x.flags|=256),Tr(x,v,c,0,e),no(s);break n}}a=s,4!==ni&&(ni=2),null===ai?ai=[a]:ai.push(a),s=gr(s,c),c=v;do{switch(c.tag){case 3:c.flags|=65536,e&=-e,c.lanes|=e,yt(c,Mr(0,s,e));break n;case 1:a=s;var g=c.type,y=c.stateNode;if(0===(128&c.flags)&&("function"===typeof g.getDerivedStateFromError||null!==y&&"function"===typeof y.componentDidCatch&&(null===pi||!pi.has(y)))){c.flags|=65536,e&=-e,c.lanes|=e,yt(c,kr(c,a,e));break n}}c=c.return}while(null!==c)}Ni(t)}catch(b){e=b,Qa===t&&null!==t&&(Qa=t=t.return);continue}break}}function Ii(){var n=Wa.current;return Wa.current=mr,null===n?mr:n}function Ei(){0!==ni&&3!==ni&&2!==ni||(ni=4),null===Za||0===(268435455&ti)&&0===(268435455&oi)||Ti(Za,Ja)}function Oi(n,e){var t=Ya;Ya|=2;var o=Ii();for(Za===n&&Ja===e||Fi(n,e);;)try{Ai();break}catch(r){ji(n,r)}if(it(),Ya=t,Wa.current=o,null!==Qa)throw Error(i(261));return Za=null,Ja=0,ni}function Ai(){for(;null!==Qa;)Gi(Qa)}function Li(){for(;null!==Qa&&!Oe();)Gi(Qa)}function Gi(n){var e=li(n.alternate,n,Ka);n.memoizedProps=n.pendingProps,null===e?Ni(n):Qa=e,Ha.current=null}function Ni(n){var e=n;do{var t=e.alternate;if(n=e.return,0===(32768&e.flags)){if(null!==(t=Ir(t,e,Ka)))return void(Qa=t)}else{if(null!==(t=ia(t,e)))return t.flags&=32767,void(Qa=t);if(null===n)return ni=6,void(Qa=null);n.flags|=32768,n.subtreeFlags=0,n.deletions=null}if(null!==(e=e.sibling))return void(Qa=e);Qa=e=n}while(null!==e);0===ni&&(ni=5)}function Bi(n,e){var t=Fe,o=Xa.transition;try{Xa.transition=null,Fe=1,function(n,e,t){do{qi()}while(null!==di);if(0!==(6&Ya))throw Error(i(327));var o=n.finishedWork,r=n.finishedLanes;if(null===o)return null;if(n.finishedWork=null,n.finishedLanes=0,o===n.current)throw Error(i(177));n.callbackNode=null,n.callbackPriority=0;var a=o.lanes|o.childLanes;if(function(n,e){var t=n.pendingLanes&~e;n.pendingLanes=e,n.suspendedLanes=0,n.pingedLanes=0,n.expiredLanes&=e,n.mutableReadLanes&=e,n.entangledLanes&=e,e=n.entanglements;var o=n.eventTimes;for(n=n.expirationTimes;0<t;){var r=31-Ue(t),a=1<<r;e[r]=0,o[r]=-1,n[r]=-1,t&=~a}}(n,a),n===Za&&(Qa=Za=null,Ja=0),0===(2064&o.subtreeFlags)&&0===(2064&o.flags)||mi||(mi=!0,Qi(Be,(function(){return qi(),null}))),a=0!==(15990&o.flags),0!==(15990&o.subtreeFlags)||a){a=Xa.transition,Xa.transition=null;var v=Fe;Fe=1;var c=Ya;Ya|=4,Ha.current=null,function(n,e){for(E(n.containerInfo),la=e;null!==la;)if(e=(n=la).child,0!==(1028&n.subtreeFlags)&&null!==e)e.return=n,la=e;else for(;null!==la;){n=la;try{var t=n.alternate;if(0!==(1024&n.flags))switch(n.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==t){var o=t.memoizedProps,r=t.memoizedState,a=n.stateNode,v=a.getSnapshotBeforeUpdate(n.elementType===n.type?o:et(n.type,o),r);a.__reactInternalSnapshotBeforeUpdate=v}break;case 3:Y&&kn(n.stateNode.containerInfo);break;default:throw Error(i(163))}}catch(c){Wi(n,n.return,c)}if(null!==(e=n.sibling)){e.return=n.return,la=e;break}la=n.return}t=pa,pa=!1}(n,o),function(n,e){for(la=e;null!==la;){var t=(e=la).deletions;if(null!==t)for(var o=0;o<t.length;o++){var r=t[o];try{var a=n;Y?Ma(a,r,e):ga(a,r,e);var i=r.alternate;null!==i&&(i.return=null),r.return=null}catch(U){Wi(r,e,U)}}if(t=e.child,0!==(12854&e.subtreeFlags)&&null!==t)t.return=e,la=t;else for(;null!==la;){e=la;try{var v=e.flags;if(32&v&&Y&&Un(e.stateNode),512&v){var c=e.alternate;if(null!==c){var s=c.ref;null!==s&&("function"===typeof s?s(null):s.current=null)}}if(8192&v)switch(e.tag){case 13:if(null!==e.memoizedState){var l=e.alternate;null!==l&&null!==l.memoizedState||(vi=Le())}break;case 22:var u=null!==e.memoizedState,f=e.alternate,p=null!==f&&null!==f.memoizedState;if(t=e,Y)n:if(o=t,r=u,a=null,Y)for(var m=o;;){if(5===m.tag){if(null===a){a=m;var d=m.stateNode;r?_n(d):Sn(m.stateNode,m.memoizedProps)}}else if(6===m.tag){if(null===a){var h=m.stateNode;r?wn(h):Mn(h,m.memoizedProps)}}else if((22!==m.tag&&23!==m.tag||null===m.memoizedState||m===o)&&null!==m.child){m.child.return=m,m=m.child;continue}if(m===o)break;for(;null===m.sibling;){if(null===m.return||m.return===o)break n;a===m&&(a=null),m=m.return}a===m&&(a=null),m.sibling.return=m.return,m=m.sibling}if(u&&!p&&0!==(1&t.mode)){la=t;for(var x=t.child;null!==x;){for(t=la=x;null!==la;){var g=(o=la).child;switch(o.tag){case 0:case 11:case 14:case 15:ma(4,o,o.return);break;case 1:ua(o,o.return);var y=o.stateNode;if("function"===typeof y.componentWillUnmount){var b=o.return;try{y.props=o.memoizedProps,y.state=o.memoizedState,y.componentWillUnmount()}catch(U){Wi(o,b,U)}}break;case 5:ua(o,o.return);break;case 22:if(null!==o.memoizedState){Da(t);continue}}null!==g?(g.return=o,la=g):Da(t)}x=x.sibling}}}switch(4102&v){case 2:_a(e),e.flags&=-3;break;case 6:_a(e),e.flags&=-3,ka(e.alternate,e);break;case 4096:e.flags&=-4097;break;case 4100:e.flags&=-4097,ka(e.alternate,e);break;case 4:ka(e.alternate,e)}}catch(U){Wi(e,e.return,U)}if(null!==(t=e.sibling)){t.return=e.return,la=t;break}la=e.return}}}(n,o),O(n.containerInfo),n.current=o,Ca(o,n,r),Ae(),Ya=c,Fe=v,Xa.transition=a}else n.current=o;if(mi&&(mi=!1,di=n,hi=r),0===(a=n.pendingLanes)&&(pi=null),function(n){if(We&&"function"===typeof We.onCommitFiberRoot)try{We.onCommitFiberRoot(Ve,n,void 0,128===(128&n.current.flags))}catch(e){}}(o.stateNode),Mi(n,Le()),null!==e)for(t=n.onRecoverableError,o=0;o<e.length;o++)t(e[o]);if(ui)throw ui=!1,n=fi,fi=null,n;0!==(1&hi)&&0!==n.tag&&qi(),0!==(1&(a=n.pendingLanes))?n===gi?xi++:(xi=0,gi=n):xi=0,Je()}(n,e,t)}finally{Xa.transition=o,Fe=t}return null}function qi(){if(null!==di){var n=je(hi),e=Xa.transition,t=Fe;try{if(Xa.transition=null,Fe=16>n?16:n,null===di)var o=!1;else{if(n=di,di=null,hi=0,0!==(6&Ya))throw Error(i(331));var r=Ya;for(Ya|=4,la=n.current;null!==la;){var a=la,v=a.child;if(0!==(16&la.flags)){var c=a.deletions;if(null!==c){for(var s=0;s<c.length;s++){var l=c[s];for(la=l;null!==la;){var u=la;switch(u.tag){case 0:case 11:case 15:ma(8,u,a)}var f=u.child;if(null!==f)f.return=u,la=f;else for(;null!==la;){var p=(u=la).sibling,m=u.return;if(ya(u),u===l){la=null;break}if(null!==p){p.return=m,la=p;break}la=m}}}var d=a.alternate;if(null!==d){var h=d.child;if(null!==h){d.child=null;do{var x=h.sibling;h.sibling=null,h=x}while(null!==h)}}la=a}}if(0!==(2064&a.subtreeFlags)&&null!==v)v.return=a,la=v;else n:for(;null!==la;){if(0!==(2048&(a=la).flags))switch(a.tag){case 0:case 11:case 15:ma(9,a,a.return)}var g=a.sibling;if(null!==g){g.return=a.return,la=g;break n}la=a.return}}var y=n.current;for(la=y;null!==la;){var b=(v=la).child;if(0!==(2064&v.subtreeFlags)&&null!==b)b.return=v,la=b;else n:for(v=y;null!==la;){if(0!==(2048&(c=la).flags))try{switch(c.tag){case 0:case 11:case 15:da(9,c)}}catch(_){Wi(c,c.return,_)}if(c===v){la=null;break n}var U=c.sibling;if(null!==U){U.return=c.return,la=U;break n}la=c.return}}if(Ya=r,Je(),We&&"function"===typeof We.onPostCommitFiberRoot)try{We.onPostCommitFiberRoot(Ve,n)}catch(_){}o=!0}return o}finally{Fe=t,Xa.transition=e}}return!1}function Vi(n,e,t){xt(n,e=Mr(0,e=gr(t,e),1)),e=Ui(),null!==(n=Si(n,1))&&(De(n,1,e),Mi(n,e))}function Wi(n,e,t){if(3===n.tag)Vi(n,n,t);else for(;null!==e;){if(3===e.tag){Vi(e,n,t);break}if(1===e.tag){var o=e.stateNode;if("function"===typeof e.type.getDerivedStateFromError||"function"===typeof o.componentDidCatch&&(null===pi||!pi.has(o))){xt(e,n=kr(e,n=gr(t,n),1)),n=Ui(),null!==(e=Si(e,1))&&(De(e,1,n),Mi(e,n));break}}e=e.return}}function Hi(n,e,t){var o=n.pingCache;null!==o&&o.delete(e),e=Ui(),n.pingedLanes|=n.suspendedLanes&t,Za===n&&(Ja&t)===t&&(4===ni||3===ni&&(130023424&Ja)===Ja&&500>Le()-vi?Fi(n,0):ri|=t),Mi(n,e)}function Xi(n,e){0===e&&(0===(1&n.mode)?e=1:(e=Me,0===(130023424&(Me<<=1))&&(Me=4194304)));var t=Ui();null!==(n=Si(n,e))&&(De(n,e,t),Mi(n,t))}function Yi(n){var e=n.memoizedState,t=0;null!==e&&(t=e.retryLane),Xi(n,t)}function Zi(n,e){var t=0;switch(n.tag){case 13:var o=n.stateNode,r=n.memoizedState;null!==r&&(t=r.retryLane);break;case 19:o=n.stateNode;break;default:throw Error(i(314))}null!==o&&o.delete(e),Xi(n,t)}function Qi(n,e){return Ie(n,e)}function Ji(n,e,t,o){this.tag=n,this.key=t,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=o,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ki(n,e,t,o){return new Ji(n,e,t,o)}function $i(n){return!(!(n=n.prototype)||!n.isReactComponent)}function nv(n,e){var t=n.alternate;return null===t?((t=Ki(n.tag,e,n.key,n.mode)).elementType=n.elementType,t.type=n.type,t.stateNode=n.stateNode,t.alternate=n,n.alternate=t):(t.pendingProps=e,t.type=n.type,t.flags=0,t.subtreeFlags=0,t.deletions=null),t.flags=14680064&n.flags,t.childLanes=n.childLanes,t.lanes=n.lanes,t.child=n.child,t.memoizedProps=n.memoizedProps,t.memoizedState=n.memoizedState,t.updateQueue=n.updateQueue,e=n.dependencies,t.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext},t.sibling=n.sibling,t.index=n.index,t.ref=n.ref,t}function ev(n,e,t,o,r,a){var v=2;if(o=n,"function"===typeof n)$i(n)&&(v=1);else if("string"===typeof n)v=5;else n:switch(n){case l:return tv(t.children,r,a,e);case u:v=8,r|=8;break;case f:return(n=Ki(12,t,e,2|r)).elementType=f,n.lanes=a,n;case h:return(n=Ki(13,t,e,r)).elementType=h,n.lanes=a,n;case x:return(n=Ki(19,t,e,r)).elementType=x,n.lanes=a,n;case b:return ov(t,r,a,e);default:if("object"===typeof n&&null!==n)switch(n.$$typeof){case p:v=10;break n;case m:v=9;break n;case d:v=11;break n;case g:v=14;break n;case y:v=16,o=null;break n}throw Error(i(130,null==n?n:typeof n,""))}return(e=Ki(v,t,e,r)).elementType=n,e.type=o,e.lanes=a,e}function tv(n,e,t,o){return(n=Ki(7,n,o,e)).lanes=t,n}function ov(n,e,t,o){return(n=Ki(22,n,o,e)).elementType=b,n.lanes=t,n.stateNode={},n}function rv(n,e,t){return(n=Ki(6,n,null,e)).lanes=t,n}function av(n,e,t){return(e=Ki(4,null!==n.children?n.children:[],n.key,e)).lanes=t,e.stateNode={containerInfo:n.containerInfo,pendingChildren:null,implementation:n.implementation},e}function iv(n,e,t,o,r){this.tag=e,this.containerInfo=n,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=H,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Re(0),this.expirationTimes=Re(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Re(0),this.identifierPrefix=o,this.onRecoverableError=r,Q&&(this.mutableSourceEagerHydrationData=null)}function vv(n,e,t,o,r,a,i,v,c){return n=new iv(n,e,t,v,c),1===e?(e=1,!0===a&&(e|=8)):e=0,a=Ki(3,null,null,e),n.current=a,a.stateNode=n,a.memoizedState={element:o,isDehydrated:t,cache:null,transitions:null},mt(a),n}function cv(n){if(!n)return le;n:{if(M(n=n._reactInternals)!==n||1!==n.tag)throw Error(i(170));var e=n;do{switch(e.tag){case 3:e=e.stateNode.context;break n;case 1:if(de(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break n}}e=e.return}while(null!==e);throw Error(i(171))}if(1===n.tag){var t=n.type;if(de(t))return ge(n,t,e)}return e}function sv(n){var e=n._reactInternals;if(void 0===e){if("function"===typeof n.render)throw Error(i(188));throw n=Object.keys(n).join(","),Error(i(268,n))}return null===(n=C(e))?null:n.stateNode}function lv(n,e){if(null!==(n=n.memoizedState)&&null!==n.dehydrated){var t=n.retryLane;n.retryLane=0!==t&&t<e?t:e}}function uv(n,e){lv(n,e),(n=n.alternate)&&lv(n,e)}function fv(n){return null===(n=C(n))?null:n.stateNode}function pv(){return null}return li=function(n,e,t){if(null!==n)if(n.memoizedProps!==e.pendingProps||fe.current)Or=!0;else{if(0===(n.lanes&t)&&0===(128&e.flags))return Or=!1,function(n,e,t){switch(e.tag){case 3:Xr(e),$t();break;case 5:mo(e);break;case 1:de(e.type)&&ye(e);break;case 4:fo(e,e.stateNode.containerInfo);break;case 10:vt(0,e.type._context,e.memoizedProps.value);break;case 13:var o=e.memoizedState;if(null!==o)return null!==o.dehydrated?(se(xo,1&xo.current),e.flags|=128,null):0!==(t&e.child.childLanes)?Jr(n,e,t):(se(xo,1&xo.current),null!==(n=aa(n,e,t))?n.sibling:null);se(xo,1&xo.current);break;case 19:if(o=0!==(t&e.childLanes),0!==(128&n.flags)){if(o)return ra(n,e,t);e.flags|=128}var r=e.memoizedState;if(null!==r&&(r.rendering=null,r.tail=null,r.lastEffect=null),se(xo,xo.current),o)break;return null;case 22:case 23:return e.lanes=0,Br(n,e,t)}return aa(n,e,t)}(n,e,t);Or=0!==(131072&n.flags)}else Or=!1,Vt&&0!==(1048576&e.flags)&&Lt(e,Pt,e.index);switch(e.lanes=0,e.tag){case 2:var o=e.type;null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2),n=e.pendingProps;var r=me(e,ue.current);lt(e,t),r=Fo(null,e,o,n,r,t);var a=jo();return e.flags|=1,"object"===typeof r&&null!==r&&"function"===typeof r.render&&void 0===r.$$typeof?(e.tag=1,e.memoizedState=null,e.updateQueue=null,de(o)?(a=!0,ye(e)):a=!1,e.memoizedState=null!==r.state&&void 0!==r.state?r.state:null,mt(e),r.updater=St,e.stateNode=r,r._reactInternals=e,Ct(e,o,n,t),e=Hr(null,e,o,!0,a,t)):(e.tag=0,Vt&&a&&Gt(e),Ar(null,e,r,t),e=e.child),e;case 16:o=e.elementType;n:{switch(null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2),n=e.pendingProps,o=(r=o._init)(o._payload),e.type=o,r=e.tag=function(n){if("function"===typeof n)return $i(n)?1:0;if(void 0!==n&&null!==n){if((n=n.$$typeof)===d)return 11;if(n===g)return 14}return 2}(o),n=et(o,n),r){case 0:e=Vr(null,e,o,n,t);break n;case 1:e=Wr(null,e,o,n,t);break n;case 11:e=Lr(null,e,o,n,t);break n;case 14:e=Gr(null,e,o,et(o.type,n),t);break n}throw Error(i(306,o,""))}return e;case 0:return o=e.type,r=e.pendingProps,Vr(n,e,o,r=e.elementType===o?r:et(o,r),t);case 1:return o=e.type,r=e.pendingProps,Wr(n,e,o,r=e.elementType===o?r:et(o,r),t);case 3:n:{if(Xr(e),null===n)throw Error(i(387));o=e.pendingProps,r=(a=e.memoizedState).element,dt(n,e),bt(e,o,null,t);var v=e.memoizedState;if(o=v.element,Q&&a.isDehydrated){if(a={element:o,isDehydrated:!1,cache:v.cache,transitions:v.transitions},e.updateQueue.baseState=a,e.memoizedState=a,256&e.flags){e=Yr(n,e,o,t,r=Error(i(423)));break n}if(o!==r){e=Yr(n,e,o,t,r=Error(i(424)));break n}for(Q&&(qt=Bn(e.stateNode.containerInfo),Bt=e,Vt=!0,Ht=null,Wt=!1),t=io(e,null,o,t),e.child=t;t;)t.flags=-3&t.flags|4096,t=t.sibling}else{if($t(),o===r){e=aa(n,e,t);break n}Ar(n,e,o,t)}e=e.child}return e;case 5:return mo(e),null===n&&Qt(e),o=e.type,r=e.pendingProps,a=null!==n?n.memoizedProps:null,v=r.children,B(o,r)?v=null:null!==a&&B(o,a)&&(e.flags|=32),qr(n,e),Ar(n,e,v,t),e.child;case 6:return null===n&&Qt(e),null;case 13:return Jr(n,e,t);case 4:return fo(e,e.stateNode.containerInfo),o=e.pendingProps,null===n?e.child=ao(e,null,o,t):Ar(n,e,o,t),e.child;case 11:return o=e.type,r=e.pendingProps,Lr(n,e,o,r=e.elementType===o?r:et(o,r),t);case 7:return Ar(n,e,e.pendingProps,t),e.child;case 8:case 12:return Ar(n,e,e.pendingProps.children,t),e.child;case 10:n:{if(o=e.type._context,r=e.pendingProps,a=e.memoizedProps,vt(0,o,v=r.value),null!==a)if(He(a.value,v)){if(a.children===r.children&&!fe.current){e=aa(n,e,t);break n}}else for(null!==(a=e.child)&&(a.return=e);null!==a;){var c=a.dependencies;if(null!==c){v=a.child;for(var s=c.firstContext;null!==s;){if(s.context===o){if(1===a.tag){(s=ht(-1,t&-t)).tag=2;var l=a.updateQueue;if(null!==l){var u=(l=l.shared).pending;null===u?s.next=s:(s.next=u.next,u.next=s),l.pending=s}}a.lanes|=t,null!==(s=a.alternate)&&(s.lanes|=t),st(a.return,t,e),c.lanes|=t;break}s=s.next}}else if(10===a.tag)v=a.type===e.type?null:a.child;else if(18===a.tag){if(null===(v=a.return))throw Error(i(341));v.lanes|=t,null!==(c=v.alternate)&&(c.lanes|=t),st(v,t,e),v=a.sibling}else v=a.child;if(null!==v)v.return=a;else for(v=a;null!==v;){if(v===e){v=null;break}if(null!==(a=v.sibling)){a.return=v.return,v=a;break}v=v.return}a=v}Ar(n,e,r.children,t),e=e.child}return e;case 9:return r=e.type,o=e.pendingProps.children,lt(e,t),o=o(r=ut(r)),e.flags|=1,Ar(n,e,o,t),e.child;case 14:return r=et(o=e.type,e.pendingProps),Gr(n,e,o,r=et(o.type,r),t);case 15:return Nr(n,e,e.type,e.pendingProps,t);case 17:return o=e.type,r=e.pendingProps,r=e.elementType===o?r:et(o,r),null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2),e.tag=1,de(o)?(n=!0,ye(e)):n=!1,lt(e,t),kt(e,o,r),Ct(e,o,r,t),Hr(null,e,o,!0,n,t);case 19:return ra(n,e,t);case 22:return Br(n,e,t)}throw Error(i(156,e.tag))},e.attemptContinuousHydration=function(n){13===n.tag&&(wi(n,134217728,Ui()),uv(n,134217728))},e.attemptHydrationAtCurrentPriority=function(n){if(13===n.tag){var e=Ui(),t=_i(n);wi(n,t,e),uv(n,t)}},e.attemptSynchronousHydration=function(n){switch(n.tag){case 3:var e=n.stateNode;if(e.current.memoizedState.isDehydrated){var t=ke(e.pendingLanes);0!==t&&(Pe(e,1|t),Mi(e,Le()),0===(6&Ya)&&(si(),Je()))}break;case 13:var o=Ui();Di((function(){return wi(n,1,o)})),uv(n,1)}},e.batchedUpdates=function(n,e){var t=Ya;Ya|=1;try{return n(e)}finally{0===(Ya=t)&&(si(),Ye&&Je())}},e.createComponentSelector=function(n){return{$$typeof:Fa,value:n}},e.createContainer=function(n,e,t,o,r,a,i){return vv(n,e,!1,null,0,o,0,a,i)},e.createHasPseudoClassSelector=function(n){return{$$typeof:ja,value:n}},e.createHydrationContainer=function(n,e,t,o,r,a,i,v,c){return(n=vv(t,o,!0,n,0,a,0,v,c)).context=cv(null),t=n.current,(a=ht(o=Ui(),r=_i(t))).callback=void 0!==e&&null!==e?e:null,xt(t,a),n.current.lanes=r,De(n,r,o),Mi(n,o),n},e.createPortal=function(n,e,t){var o=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:s,key:null==o?null:""+o,children:n,containerInfo:e,implementation:t}},e.createRoleSelector=function(n){return{$$typeof:Ia,value:n}},e.createTestNameSelector=function(n){return{$$typeof:Ea,value:n}},e.createTextSelector=function(n){return{$$typeof:Oa,value:n}},e.deferredUpdates=function(n){var e=Fe,t=Xa.transition;try{return Xa.transition=null,Fe=16,n()}finally{Fe=e,Xa.transition=t}},e.discreteUpdates=function(n,e,t,o,r){var a=Fe,i=Xa.transition;try{return Xa.transition=null,Fe=1,n(e,t,o,r)}finally{Fe=a,Xa.transition=i,0===Ya&&si()}},e.findAllNodes=qa,e.findBoundingRects=function(n,e){if(!on)throw Error(i(363));e=qa(n,e),n=[];for(var t=0;t<e.length;t++)n.push(an(e[t]));for(e=n.length-1;0<e;e--)for(var o=(t=n[e]).x,r=o+t.width,a=t.y,v=a+t.height,c=e-1;0<=c;c--)if(e!==c){var s=n[c],l=s.x,u=l+s.width,f=s.y,p=f+s.height;if(o>=l&&a>=f&&r<=u&&v<=p){n.splice(e,1);break}if(!(o!==l||t.width!==s.width||p<a||f>v)){f>a&&(s.height+=f-a,s.y=a),p<v&&(s.height=v-f),n.splice(e,1);break}if(!(a!==f||t.height!==s.height||u<o||l>r)){l>o&&(s.width+=l-o,s.x=o),u<r&&(s.width=r-l),n.splice(e,1);break}}return n},e.findHostInstance=sv,e.findHostInstanceWithNoPortals=function(n){return null===(n=null!==(n=z(n))?R(n):null)?null:n.stateNode},e.findHostInstanceWithWarning=function(n){return sv(n)},e.flushControlled=function(n){var e=Ya;Ya|=1;var t=Xa.transition,o=Fe;try{Xa.transition=null,Fe=1,n()}finally{Fe=o,Xa.transition=t,0===(Ya=e)&&(si(),Je())}},e.flushPassiveEffects=qi,e.flushSync=Di,e.focusWithin=function(n,e){if(!on)throw Error(i(363));for(e=Ba(n=La(n),e),e=Array.from(e),n=0;n<e.length;){var t=e[n++];if(!cn(t)){if(5===t.tag&&ln(t.stateNode))return!0;for(t=t.child;null!==t;)e.push(t),t=t.sibling}}return!1},e.getCurrentUpdatePriority=function(){return Fe},e.getFindAllNodesFailureDescription=function(n,e){if(!on)throw Error(i(363));var t=0,o=[];n=[La(n),0];for(var r=0;r<n.length;){var a=n[r++],v=n[r++],c=e[v];if((5!==a.tag||!cn(a))&&(Ga(a,c)&&(o.push(Na(c)),++v>t&&(t=v)),v<e.length))for(a=a.child;null!==a;)n.push(a,v),a=a.sibling}if(t<e.length){for(n=[];t<e.length;t++)n.push(Na(e[t]));return"findAllNodes was able to match part of the selector:\n  "+o.join(" > ")+"\n\nNo matching component was found for:\n  "+n.join(" > ")}return null},e.getPublicRootInstance=function(n){return(n=n.current).child?5===n.child.tag?F(n.child.stateNode):n.child.stateNode:null},e.injectIntoDevTools=function(n){if(n={bundleType:n.bundleType,version:n.version,rendererPackageName:n.rendererPackageName,rendererConfig:n.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:v.ReactCurrentDispatcher,findHostInstanceByFiber:fv,findFiberByHostInstance:n.findFiberByHostInstance||pv,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.0.0-fc46dba67-20220329"},"undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)n=!1;else{var e=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(e.isDisabled||!e.supportsFiber)n=!0;else{try{Ve=e.inject(n),We=e}catch(t){}n=!!e.checkDCE}}return n},e.isAlreadyRendering=function(){return!1},e.observeVisibleRects=function(n,e,t,o){if(!on)throw Error(i(363));n=qa(n,e);var r=un(n,t,o).disconnect;return{disconnect:function(){r()}}},e.registerMutableSourceForHydration=function(n,e){var t=e._getVersion;t=t(e._source),null==n.mutableSourceEagerHydrationData?n.mutableSourceEagerHydrationData=[e,t]:n.mutableSourceEagerHydrationData.push(e,t)},e.runWithPriority=function(n,e){var t=Fe;try{return Fe=n,e()}finally{Fe=t}},e.shouldError=function(){return null},e.shouldSuspend=function(){return!1},e.updateContainer=function(n,e,t,o){var r=e.current,a=Ui(),i=_i(r);return t=cv(t),null===e.context?e.context=t:e.pendingContext=t,(e=ht(a,i)).payload={element:n},null!==(o=void 0===o?null:o)&&(e.callback=o),xt(r,e),null!==(n=wi(r,i,a))&&gt(n,r,i),i},e}},585:function(n,e,t){"use strict";n.exports=t(976)},258:function(n,e,t){"use strict";n.exports=t(721)},783:function(n,e){"use strict";function t(n,e){var t=n.length;n.push(e);n:for(;0<t;){var o=t-1>>>1,r=n[o];if(!(0<a(r,e)))break n;n[o]=e,n[t]=r,t=o}}function o(n){return 0===n.length?null:n[0]}function r(n){if(0===n.length)return null;var e=n[0],t=n.pop();if(t!==e){n[0]=t;n:for(var o=0,r=n.length,i=r>>>1;o<i;){var v=2*(o+1)-1,c=n[v],s=v+1,l=n[s];if(0>a(c,t))s<r&&0>a(l,c)?(n[o]=l,n[s]=t,o=s):(n[o]=c,n[v]=t,o=v);else{if(!(s<r&&0>a(l,t)))break n;n[o]=l,n[s]=t,o=s}}}return e}function a(n,e){var t=n.sortIndex-e.sortIndex;return 0!==t?t:n.id-e.id}if("object"===typeof performance&&"function"===typeof performance.now){var i=performance;e.unstable_now=function(){return i.now()}}else{var v=Date,c=v.now();e.unstable_now=function(){return v.now()-c}}var s=[],l=[],u=1,f=null,p=3,m=!1,d=!1,h=!1,x="function"===typeof setTimeout?setTimeout:null,g="function"===typeof clearTimeout?clearTimeout:null,y="undefined"!==typeof setImmediate?setImmediate:null;function b(n){for(var e=o(l);null!==e;){if(null===e.callback)r(l);else{if(!(e.startTime<=n))break;r(l),e.sortIndex=e.expirationTime,t(s,e)}e=o(l)}}function U(n){if(h=!1,b(n),!d)if(null!==o(s))d=!0,F(_);else{var e=o(l);null!==e&&j(U,e.startTime-n)}}function _(n,t){d=!1,h&&(h=!1,g(k),k=-1),m=!0;var a=p;try{for(b(t),f=o(s);null!==f&&(!(f.expirationTime>t)||n&&!T());){var i=f.callback;if("function"===typeof i){f.callback=null,p=f.priorityLevel;var v=i(f.expirationTime<=t);t=e.unstable_now(),"function"===typeof v?f.callback=v:f===o(s)&&r(s),b(t)}else r(s);f=o(s)}if(null!==f)var c=!0;else{var u=o(l);null!==u&&j(U,u.startTime-t),c=!1}return c}finally{f=null,p=a,m=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var w,S=!1,M=null,k=-1,z=5,C=-1;function T(){return!(e.unstable_now()-C<z)}function R(){if(null!==M){var n=e.unstable_now();C=n;var t=!0;try{t=M(!0,n)}finally{t?w():(S=!1,M=null)}}else S=!1}if("function"===typeof y)w=function(){y(R)};else if("undefined"!==typeof MessageChannel){var D=new MessageChannel,P=D.port2;D.port1.onmessage=R,w=function(){P.postMessage(null)}}else w=function(){x(R,0)};function F(n){M=n,S||(S=!0,w())}function j(n,t){k=x((function(){n(e.unstable_now())}),t)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(n){n.callback=null},e.unstable_continueExecution=function(){d||m||(d=!0,F(_))},e.unstable_forceFrameRate=function(n){0>n||125<n?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):z=0<n?Math.floor(1e3/n):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return o(s)},e.unstable_next=function(n){switch(p){case 1:case 2:case 3:var e=3;break;default:e=p}var t=p;p=e;try{return n()}finally{p=t}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(n,e){switch(n){case 1:case 2:case 3:case 4:case 5:break;default:n=3}var t=p;p=n;try{return e()}finally{p=t}},e.unstable_scheduleCallback=function(n,r,a){var i=e.unstable_now();switch("object"===typeof a&&null!==a?a="number"===typeof(a=a.delay)&&0<a?i+a:i:a=i,n){case 1:var v=-1;break;case 2:v=250;break;case 5:v=1073741823;break;case 4:v=1e4;break;default:v=5e3}return n={id:u++,callback:r,priorityLevel:n,startTime:a,expirationTime:v=a+v,sortIndex:-1},a>i?(n.sortIndex=a,t(l,n),null===o(s)&&n===o(l)&&(h?(g(k),k=-1):h=!0,j(U,a-i))):(n.sortIndex=v,t(s,n),d||m||(d=!0,F(_))),n},e.unstable_shouldYield=T,e.unstable_wrapCallback=function(n){var e=p;return function(){var t=p;p=e;try{return n.apply(this,arguments)}finally{p=t}}}},100:function(n,e,t){"use strict";n.exports=t(783)},374:function(n,e,t){"use strict";var o=t(791),r=Symbol.for("react.element"),a=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,v=o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function s(n,e,t){var o,a={},s=null,l=null;for(o in void 0!==t&&(s=""+t),void 0!==e.key&&(s=""+e.key),void 0!==e.ref&&(l=e.ref),e)i.call(e,o)&&!c.hasOwnProperty(o)&&(a[o]=e[o]);if(n&&n.defaultProps)for(o in e=n.defaultProps)void 0===a[o]&&(a[o]=e[o]);return{$$typeof:r,type:n,key:s,ref:l,props:a,_owner:v.current}}e.Fragment=a,e.jsx=s,e.jsxs=s},117:function(n,e){"use strict";var t=Symbol.for("react.element"),o=Symbol.for("react.portal"),r=Symbol.for("react.fragment"),a=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),v=Symbol.for("react.provider"),c=Symbol.for("react.context"),s=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),u=Symbol.for("react.memo"),f=Symbol.for("react.lazy"),p=Symbol.iterator;var m={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},d=Object.assign,h={};function x(n,e,t){this.props=n,this.context=e,this.refs=h,this.updater=t||m}function g(){}function y(n,e,t){this.props=n,this.context=e,this.refs=h,this.updater=t||m}x.prototype.isReactComponent={},x.prototype.setState=function(n,e){if("object"!==typeof n&&"function"!==typeof n&&null!=n)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,n,e,"setState")},x.prototype.forceUpdate=function(n){this.updater.enqueueForceUpdate(this,n,"forceUpdate")},g.prototype=x.prototype;var b=y.prototype=new g;b.constructor=y,d(b,x.prototype),b.isPureReactComponent=!0;var U=Array.isArray,_=Object.prototype.hasOwnProperty,w={current:null},S={key:!0,ref:!0,__self:!0,__source:!0};function M(n,e,o){var r,a={},i=null,v=null;if(null!=e)for(r in void 0!==e.ref&&(v=e.ref),void 0!==e.key&&(i=""+e.key),e)_.call(e,r)&&!S.hasOwnProperty(r)&&(a[r]=e[r]);var c=arguments.length-2;if(1===c)a.children=o;else if(1<c){for(var s=Array(c),l=0;l<c;l++)s[l]=arguments[l+2];a.children=s}if(n&&n.defaultProps)for(r in c=n.defaultProps)void 0===a[r]&&(a[r]=c[r]);return{$$typeof:t,type:n,key:i,ref:v,props:a,_owner:w.current}}function k(n){return"object"===typeof n&&null!==n&&n.$$typeof===t}var z=/\/+/g;function C(n,e){return"object"===typeof n&&null!==n&&null!=n.key?function(n){var e={"=":"=0",":":"=2"};return"$"+n.replace(/[=:]/g,(function(n){return e[n]}))}(""+n.key):e.toString(36)}function T(n,e,r,a,i){var v=typeof n;"undefined"!==v&&"boolean"!==v||(n=null);var c=!1;if(null===n)c=!0;else switch(v){case"string":case"number":c=!0;break;case"object":switch(n.$$typeof){case t:case o:c=!0}}if(c)return i=i(c=n),n=""===a?"."+C(c,0):a,U(i)?(r="",null!=n&&(r=n.replace(z,"$&/")+"/"),T(i,e,r,"",(function(n){return n}))):null!=i&&(k(i)&&(i=function(n,e){return{$$typeof:t,type:n.type,key:e,ref:n.ref,props:n.props,_owner:n._owner}}(i,r+(!i.key||c&&c.key===i.key?"":(""+i.key).replace(z,"$&/")+"/")+n)),e.push(i)),1;if(c=0,a=""===a?".":a+":",U(n))for(var s=0;s<n.length;s++){var l=a+C(v=n[s],s);c+=T(v,e,r,l,i)}else if(l=function(n){return null===n||"object"!==typeof n?null:"function"===typeof(n=p&&n[p]||n["@@iterator"])?n:null}(n),"function"===typeof l)for(n=l.call(n),s=0;!(v=n.next()).done;)c+=T(v=v.value,e,r,l=a+C(v,s++),i);else if("object"===v)throw e=String(n),Error("Objects are not valid as a React child (found: "+("[object Object]"===e?"object with keys {"+Object.keys(n).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return c}function R(n,e,t){if(null==n)return n;var o=[],r=0;return T(n,o,"","",(function(n){return e.call(t,n,r++)})),o}function D(n){if(-1===n._status){var e=n._result;(e=e()).then((function(e){0!==n._status&&-1!==n._status||(n._status=1,n._result=e)}),(function(e){0!==n._status&&-1!==n._status||(n._status=2,n._result=e)})),-1===n._status&&(n._status=0,n._result=e)}if(1===n._status)return n._result.default;throw n._result}var P={current:null},F={transition:null},j={ReactCurrentDispatcher:P,ReactCurrentBatchConfig:F,ReactCurrentOwner:w};e.Children={map:R,forEach:function(n,e,t){R(n,(function(){e.apply(this,arguments)}),t)},count:function(n){var e=0;return R(n,(function(){e++})),e},toArray:function(n){return R(n,(function(n){return n}))||[]},only:function(n){if(!k(n))throw Error("React.Children.only expected to receive a single React element child.");return n}},e.Component=x,e.Fragment=r,e.Profiler=i,e.PureComponent=y,e.StrictMode=a,e.Suspense=l,e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=j,e.cloneElement=function(n,e,o){if(null===n||void 0===n)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+n+".");var r=d({},n.props),a=n.key,i=n.ref,v=n._owner;if(null!=e){if(void 0!==e.ref&&(i=e.ref,v=w.current),void 0!==e.key&&(a=""+e.key),n.type&&n.type.defaultProps)var c=n.type.defaultProps;for(s in e)_.call(e,s)&&!S.hasOwnProperty(s)&&(r[s]=void 0===e[s]&&void 0!==c?c[s]:e[s])}var s=arguments.length-2;if(1===s)r.children=o;else if(1<s){c=Array(s);for(var l=0;l<s;l++)c[l]=arguments[l+2];r.children=c}return{$$typeof:t,type:n.type,key:a,ref:i,props:r,_owner:v}},e.createContext=function(n){return(n={$$typeof:c,_currentValue:n,_currentValue2:n,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:v,_context:n},n.Consumer=n},e.createElement=M,e.createFactory=function(n){var e=M.bind(null,n);return e.type=n,e},e.createRef=function(){return{current:null}},e.forwardRef=function(n){return{$$typeof:s,render:n}},e.isValidElement=k,e.lazy=function(n){return{$$typeof:f,_payload:{_status:-1,_result:n},_init:D}},e.memo=function(n,e){return{$$typeof:u,type:n,compare:void 0===e?null:e}},e.startTransition=function(n){var e=F.transition;F.transition={};try{n()}finally{F.transition=e}},e.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")},e.useCallback=function(n,e){return P.current.useCallback(n,e)},e.useContext=function(n){return P.current.useContext(n)},e.useDebugValue=function(){},e.useDeferredValue=function(n){return P.current.useDeferredValue(n)},e.useEffect=function(n,e){return P.current.useEffect(n,e)},e.useId=function(){return P.current.useId()},e.useImperativeHandle=function(n,e,t){return P.current.useImperativeHandle(n,e,t)},e.useInsertionEffect=function(n,e){return P.current.useInsertionEffect(n,e)},e.useLayoutEffect=function(n,e){return P.current.useLayoutEffect(n,e)},e.useMemo=function(n,e){return P.current.useMemo(n,e)},e.useReducer=function(n,e,t){return P.current.useReducer(n,e,t)},e.useRef=function(n){return P.current.useRef(n)},e.useState=function(n){return P.current.useState(n)},e.useSyncExternalStore=function(n,e,t){return P.current.useSyncExternalStore(n,e,t)},e.useTransition=function(){return P.current.useTransition()},e.version="18.2.0"},791:function(n,e,t){"use strict";n.exports=t(117)},184:function(n,e,t){"use strict";n.exports=t(374)},813:function(n,e){"use strict";function t(n,e){var t=n.length;n.push(e);n:for(;0<t;){var o=t-1>>>1,r=n[o];if(!(0<a(r,e)))break n;n[o]=e,n[t]=r,t=o}}function o(n){return 0===n.length?null:n[0]}function r(n){if(0===n.length)return null;var e=n[0],t=n.pop();if(t!==e){n[0]=t;n:for(var o=0,r=n.length,i=r>>>1;o<i;){var v=2*(o+1)-1,c=n[v],s=v+1,l=n[s];if(0>a(c,t))s<r&&0>a(l,c)?(n[o]=l,n[s]=t,o=s):(n[o]=c,n[v]=t,o=v);else{if(!(s<r&&0>a(l,t)))break n;n[o]=l,n[s]=t,o=s}}}return e}function a(n,e){var t=n.sortIndex-e.sortIndex;return 0!==t?t:n.id-e.id}if("object"===typeof performance&&"function"===typeof performance.now){var i=performance;e.unstable_now=function(){return i.now()}}else{var v=Date,c=v.now();e.unstable_now=function(){return v.now()-c}}var s=[],l=[],u=1,f=null,p=3,m=!1,d=!1,h=!1,x="function"===typeof setTimeout?setTimeout:null,g="function"===typeof clearTimeout?clearTimeout:null,y="undefined"!==typeof setImmediate?setImmediate:null;function b(n){for(var e=o(l);null!==e;){if(null===e.callback)r(l);else{if(!(e.startTime<=n))break;r(l),e.sortIndex=e.expirationTime,t(s,e)}e=o(l)}}function U(n){if(h=!1,b(n),!d)if(null!==o(s))d=!0,F(_);else{var e=o(l);null!==e&&j(U,e.startTime-n)}}function _(n,t){d=!1,h&&(h=!1,g(k),k=-1),m=!0;var a=p;try{for(b(t),f=o(s);null!==f&&(!(f.expirationTime>t)||n&&!T());){var i=f.callback;if("function"===typeof i){f.callback=null,p=f.priorityLevel;var v=i(f.expirationTime<=t);t=e.unstable_now(),"function"===typeof v?f.callback=v:f===o(s)&&r(s),b(t)}else r(s);f=o(s)}if(null!==f)var c=!0;else{var u=o(l);null!==u&&j(U,u.startTime-t),c=!1}return c}finally{f=null,p=a,m=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var w,S=!1,M=null,k=-1,z=5,C=-1;function T(){return!(e.unstable_now()-C<z)}function R(){if(null!==M){var n=e.unstable_now();C=n;var t=!0;try{t=M(!0,n)}finally{t?w():(S=!1,M=null)}}else S=!1}if("function"===typeof y)w=function(){y(R)};else if("undefined"!==typeof MessageChannel){var D=new MessageChannel,P=D.port2;D.port1.onmessage=R,w=function(){P.postMessage(null)}}else w=function(){x(R,0)};function F(n){M=n,S||(S=!0,w())}function j(n,t){k=x((function(){n(e.unstable_now())}),t)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(n){n.callback=null},e.unstable_continueExecution=function(){d||m||(d=!0,F(_))},e.unstable_forceFrameRate=function(n){0>n||125<n?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):z=0<n?Math.floor(1e3/n):5},e.unstable_getCurrentPriorityLevel=function(){return p},e.unstable_getFirstCallbackNode=function(){return o(s)},e.unstable_next=function(n){switch(p){case 1:case 2:case 3:var e=3;break;default:e=p}var t=p;p=e;try{return n()}finally{p=t}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(n,e){switch(n){case 1:case 2:case 3:case 4:case 5:break;default:n=3}var t=p;p=n;try{return e()}finally{p=t}},e.unstable_scheduleCallback=function(n,r,a){var i=e.unstable_now();switch("object"===typeof a&&null!==a?a="number"===typeof(a=a.delay)&&0<a?i+a:i:a=i,n){case 1:var v=-1;break;case 2:v=250;break;case 5:v=1073741823;break;case 4:v=1e4;break;default:v=5e3}return n={id:u++,callback:r,priorityLevel:n,startTime:a,expirationTime:v=a+v,sortIndex:-1},a>i?(n.sortIndex=a,t(l,n),null===o(s)&&n===o(l)&&(h?(g(k),k=-1):h=!0,j(U,a-i))):(n.sortIndex=v,t(s,n),d||m||(d=!0,F(_))),n},e.unstable_shouldYield=T,e.unstable_wrapCallback=function(n){var e=p;return function(){var t=p;p=e;try{return n.apply(this,arguments)}finally{p=t}}}},296:function(n,e,t){"use strict";n.exports=t(813)},561:function(n,e,t){"use strict";var o=t(791);var r="function"===typeof Object.is?Object.is:function(n,e){return n===e&&(0!==n||1/n===1/e)||n!==n&&e!==e},a=o.useState,i=o.useEffect,v=o.useLayoutEffect,c=o.useDebugValue;function s(n){var e=n.getSnapshot;n=n.value;try{var t=e();return!r(n,t)}catch(o){return!0}}var l="undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement?function(n,e){return e()}:function(n,e){var t=e(),o=a({inst:{value:t,getSnapshot:e}}),r=o[0].inst,l=o[1];return v((function(){r.value=t,r.getSnapshot=e,s(r)&&l({inst:r})}),[n,t,e]),i((function(){return s(r)&&l({inst:r}),n((function(){s(r)&&l({inst:r})}))}),[n]),c(t),t};e.useSyncExternalStore=void 0!==o.useSyncExternalStore?o.useSyncExternalStore:l},595:function(n,e,t){"use strict";var o=t(791),r=t(248);var a="function"===typeof Object.is?Object.is:function(n,e){return n===e&&(0!==n||1/n===1/e)||n!==n&&e!==e},i=r.useSyncExternalStore,v=o.useRef,c=o.useEffect,s=o.useMemo,l=o.useDebugValue;e.useSyncExternalStoreWithSelector=function(n,e,t,o,r){var u=v(null);if(null===u.current){var f={hasValue:!1,value:null};u.current=f}else f=u.current;u=s((function(){function n(n){if(!c){if(c=!0,i=n,n=o(n),void 0!==r&&f.hasValue){var e=f.value;if(r(e,n))return v=e}return v=n}if(e=v,a(i,n))return e;var t=o(n);return void 0!==r&&r(e,t)?e:(i=n,v=t)}var i,v,c=!1,s=void 0===t?null:t;return[function(){return n(e())},null===s?void 0:function(){return n(s())}]}),[e,t,o,r]);var p=i(n,u[0],u[1]);return c((function(){f.hasValue=!0,f.value=p}),[p]),l(p),p}},248:function(n,e,t){"use strict";n.exports=t(561)},327:function(n,e,t){"use strict";n.exports=t(595)}},e={};function t(o){var r=e[o];if(void 0!==r)return r.exports;var a=e[o]={exports:{}};return n[o](a,a.exports,t),a.exports}t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,{a:e}),e},t.d=function(n,e){for(var o in e)t.o(e,o)&&!t.o(n,o)&&Object.defineProperty(n,o,{enumerable:!0,get:e[o]})},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.r=function(n){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},function(){"use strict";var n,e={};function o(n,e){if(null==n)return{};var t,o,r=function(n,e){if(null==n)return{};var t,o,r={},a=Object.keys(n);for(o=0;o<a.length;o++)t=a[o],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(o=0;o<a.length;o++)t=a[o],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}function r(n){if(Array.isArray(n))return n}function a(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}function i(n,e){if(n){if("string"===typeof n)return a(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?a(n,e):void 0}}function v(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function c(n,e){return r(n)||function(n,e){var t=null==n?null:"undefined"!==typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var o,r,a=[],i=!0,v=!1;try{for(t=t.call(n);!(i=(o=t.next()).done)&&(a.push(o.value),!e||a.length!==e);i=!0);}catch(c){v=!0,r=c}finally{try{i||null==t.return||t.return()}finally{if(v)throw r}}return a}}(n,e)||i(n,e)||v()}function s(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function l(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,o)}return t}function u(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?l(Object(t),!0).forEach((function(e){s(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function f(n,e){var t="undefined"!==typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(!t){if(Array.isArray(n)||(t=i(n))||e&&n&&"number"===typeof n.length){t&&(n=t);var o=0,r=function(){};return{s:r,n:function(){return o>=n.length?{done:!0}:{done:!1,value:n[o++]}},e:function(n){throw n},f:r}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,v=!0,c=!1;return{s:function(){t=t.call(n)},n:function(){var n=t.next();return v=n.done,n},e:function(n){c=!0,a=n},f:function(){try{v||null==t.return||t.return()}finally{if(c)throw a}}}}function p(n,e){return p=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(n,e){return n.__proto__=e,n},p(n,e)}function m(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}function d(n,e,t){return d=m()?Reflect.construct.bind():function(n,e,t){var o=[null];o.push.apply(o,e);var r=new(Function.bind.apply(n,o));return t&&p(r,t.prototype),r},d.apply(null,arguments)}function h(n){if("undefined"!==typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}function x(n){return function(n){if(Array.isArray(n))return a(n)}(n)||h(n)||i(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function g(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function y(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}function b(n,e,t){return e&&y(n.prototype,e),t&&y(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}function U(n,e){if("function"!==typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),e&&p(n,e)}function _(n){return _=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(n){return n.__proto__||Object.getPrototypeOf(n)},_(n)}function w(n){return w="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},w(n)}function S(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}function M(n,e){if(e&&("object"===w(e)||"function"===typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return S(n)}function k(n){var e=m();return function(){var t,o=_(n);if(e){var r=_(this).constructor;t=Reflect.construct(o,arguments,r)}else t=o.apply(this,arguments);return M(this,t)}}function z(n){var e="function"===typeof Map?new Map:void 0;return z=function(n){if(null===n||(t=n,-1===Function.toString.call(t).indexOf("[native code]")))return n;var t;if("function"!==typeof n)throw new TypeError("Super expression must either be null or a function");if("undefined"!==typeof e){if(e.has(n))return e.get(n);e.set(n,o)}function o(){return d(n,arguments,_(this).constructor)}return o.prototype=Object.create(n.prototype,{constructor:{value:o,enumerable:!1,writable:!0,configurable:!0}}),p(o,n)},z(n)}function C(n,e,t,o,r,a,i){try{var v=n[a](i),c=v.value}catch(s){return void t(s)}v.done?e(c):Promise.resolve(c).then(o,r)}function T(n){return function(){var e=this,t=arguments;return new Promise((function(o,r){var a=n.apply(e,t);function i(n){C(a,o,r,i,v,"next",n)}function v(n){C(a,o,r,i,v,"throw",n)}i(void 0)}))}}function R(n,e){for(;!Object.prototype.hasOwnProperty.call(n,e)&&null!==(n=_(n)););return n}function D(){return D="undefined"!==typeof Reflect&&Reflect.get?Reflect.get.bind():function(n,e,t){var o=R(n,e);if(o){var r=Object.getOwnPropertyDescriptor(o,e);return r.get?r.get.call(arguments.length<3?n:t):r.value}},D.apply(this,arguments)}function P(){P=function(){return n};var n={},e=Object.prototype,t=e.hasOwnProperty,o=Object.defineProperty||function(n,e,t){n[e]=t.value},r="function"==typeof Symbol?Symbol:{},a=r.iterator||"@@iterator",i=r.asyncIterator||"@@asyncIterator",v=r.toStringTag||"@@toStringTag";function c(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{c({},"")}catch(T){c=function(n,e,t){return n[e]=t}}function s(n,e,t,r){var a=e&&e.prototype instanceof f?e:f,i=Object.create(a.prototype),v=new k(r||[]);return o(i,"_invoke",{value:U(n,t,v)}),i}function l(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(T){return{type:"throw",arg:T}}}n.wrap=s;var u={};function f(){}function p(){}function m(){}var d={};c(d,a,(function(){return this}));var h=Object.getPrototypeOf,x=h&&h(h(z([])));x&&x!==e&&t.call(x,a)&&(d=x);var g=m.prototype=f.prototype=Object.create(d);function y(n){["next","throw","return"].forEach((function(e){c(n,e,(function(n){return this._invoke(e,n)}))}))}function b(n,e){function r(o,a,i,v){var c=l(n[o],n,a);if("throw"!==c.type){var s=c.arg,u=s.value;return u&&"object"==w(u)&&t.call(u,"__await")?e.resolve(u.__await).then((function(n){r("next",n,i,v)}),(function(n){r("throw",n,i,v)})):e.resolve(u).then((function(n){s.value=n,i(s)}),(function(n){return r("throw",n,i,v)}))}v(c.arg)}var a;o(this,"_invoke",{value:function(n,t){function o(){return new e((function(e,o){r(n,t,e,o)}))}return a=a?a.then(o,o):o()}})}function U(n,e,t){var o="suspendedStart";return function(r,a){if("executing"===o)throw new Error("Generator is already running");if("completed"===o){if("throw"===r)throw a;return C()}for(t.method=r,t.arg=a;;){var i=t.delegate;if(i){var v=_(i,t);if(v){if(v===u)continue;return v}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===o)throw o="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);o="executing";var c=l(n,e,t);if("normal"===c.type){if(o=t.done?"completed":"suspendedYield",c.arg===u)continue;return{value:c.arg,done:t.done}}"throw"===c.type&&(o="completed",t.method="throw",t.arg=c.arg)}}}function _(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,_(n,e),"throw"===e.method))return u;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return u}var o=l(t,n.iterator,e.arg);if("throw"===o.type)return e.method="throw",e.arg=o.arg,e.delegate=null,u;var r=o.arg;return r?r.done?(e[n.resultName]=r.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,u):r:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,u)}function S(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function M(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function k(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(S,this),this.reset(!0)}function z(n){if(n){var e=n[a];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var o=-1,r=function e(){for(;++o<n.length;)if(t.call(n,o))return e.value=n[o],e.done=!1,e;return e.value=void 0,e.done=!0,e};return r.next=r}}return{next:C}}function C(){return{value:void 0,done:!0}}return p.prototype=m,o(g,"constructor",{value:m,configurable:!0}),o(m,"constructor",{value:p,configurable:!0}),p.displayName=c(m,v,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===p||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,m):(n.__proto__=m,c(n,v,"GeneratorFunction")),n.prototype=Object.create(g),n},n.awrap=function(n){return{__await:n}},y(b.prototype),c(b.prototype,i,(function(){return this})),n.AsyncIterator=b,n.async=function(e,t,o,r,a){void 0===a&&(a=Promise);var i=new b(s(e,t,o,r),a);return n.isGeneratorFunction(t)?i:i.next().then((function(n){return n.done?n.value:i.next()}))},y(g),c(g,v,"Generator"),c(g,a,(function(){return this})),c(g,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var e=Object(n),t=[];for(var o in e)t.push(o);return t.reverse(),function n(){for(;t.length;){var o=t.pop();if(o in e)return n.value=o,n.done=!1,n}return n.done=!0,n}},n.values=z,k.prototype={constructor:k,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(M),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function o(t,o){return i.type="throw",i.arg=n,e.next=t,o&&(e.method="next",e.arg=void 0),!!o}for(var r=this.tryEntries.length-1;r>=0;--r){var a=this.tryEntries[r],i=a.completion;if("root"===a.tryLoc)return o("end");if(a.tryLoc<=this.prev){var v=t.call(a,"catchLoc"),c=t.call(a,"finallyLoc");if(v&&c){if(this.prev<a.catchLoc)return o(a.catchLoc,!0);if(this.prev<a.finallyLoc)return o(a.finallyLoc)}else if(v){if(this.prev<a.catchLoc)return o(a.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return o(a.finallyLoc)}}}},abrupt:function(n,e){for(var o=this.tryEntries.length-1;o>=0;--o){var r=this.tryEntries[o];if(r.tryLoc<=this.prev&&t.call(r,"finallyLoc")&&this.prev<r.finallyLoc){var a=r;break}}a&&("break"===n||"continue"===n)&&a.tryLoc<=e&&e<=a.finallyLoc&&(a=null);var i=a?a.completion:{};return i.type=n,i.arg=e,a?(this.method="next",this.next=a.finallyLoc,u):this.complete(i)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),u},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),M(t),u}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var o=t.completion;if("throw"===o.type){var r=o.arg;M(t)}return r}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:z(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),u}},n}t.r(e),t.d(e,{ACESFilmicToneMapping:function(){return Dn},AddEquation:function(){return $},AddOperation:function(){return kn},AdditiveAnimationBlendMode:function(){return ot},AdditiveBlending:function(){return Z},AlphaFormat:function(){return se},AlwaysDepth:function(){return xn},AlwaysStencilFunc:function(){return Dt},AmbientLight:function(){return Mf},AmbientLightProbe:function(){return Nf},AnimationClip:function(){return Xu},AnimationLoader:function(){return of},AnimationMixer:function(){return gp},AnimationObjectGroup:function(){return dp},AnimationUtils:function(){return ju},ArcCurve:function(){return Qs},ArrayCamera:function(){return Mc},ArrowHelper:function(){return sm},Audio:function(){return $f},AudioAnalyser:function(){return ap},AudioContext:function(){return Af},AudioListener:function(){return Kf},AudioLoader:function(){return Lf},AxesHelper:function(){return lm},BackSide:function(){return W},BasicDepthPacking:function(){return st},BasicShadowMap:function(){return G},Bone:function(){return ps},BooleanKeyframeTrack:function(){return Gu},Box2:function(){return Rp},Box3:function(){return Go},Box3Helper:function(){return im},BoxBufferGeometry:function(){return ym},BoxGeometry:function(){return La},BoxHelper:function(){return am},BufferAttribute:function(){return ea},BufferGeometry:function(){return ya},BufferGeometryLoader:function(){return Pf},ByteType:function(){return $n},Cache:function(){return Qu},Camera:function(){return Va},CameraHelper:function(){return nm},CanvasTexture:function(){return Xs},CapsuleBufferGeometry:function(){return bm},CapsuleGeometry:function(){return xl},CatmullRomCurve3:function(){return tl},CineonToneMapping:function(){return Rn},CircleBufferGeometry:function(){return Um},CircleGeometry:function(){return gl},ClampToEdgeWrapping:function(){return Gn},Clock:function(){return Hf},Color:function(){return wo},ColorKeyframeTrack:function(){return Nu},ColorManagement:function(){return mo},CompressedArrayTexture:function(){return Hs},CompressedTexture:function(){return Ws},CompressedTextureLoader:function(){return rf},ConeBufferGeometry:function(){return _m},ConeGeometry:function(){return bl},CubeCamera:function(){return Xa},CubeReflectionMapping:function(){return jn},CubeRefractionMapping:function(){return In},CubeTexture:function(){return Ya},CubeTextureLoader:function(){return vf},CubeUVReflectionMapping:function(){return An},CubicBezierCurve:function(){return il},CubicBezierCurve3:function(){return vl},CubicInterpolant:function(){return Eu},CullFaceBack:function(){return O},CullFaceFront:function(){return A},CullFaceFrontBack:function(){return L},CullFaceNone:function(){return E},Curve:function(){return Ys},CurvePath:function(){return ml},CustomBlending:function(){return K},CustomToneMapping:function(){return Pn},CylinderBufferGeometry:function(){return wm},CylinderGeometry:function(){return yl},Cylindrical:function(){return Cp},Data3DTexture:function(){return Fo},DataArrayTexture:function(){return Do},DataTexture:function(){return ms},DataTexture2DArray:function(){return xm},DataTexture3D:function(){return gm},DataTextureLoader:function(){return cf},DataUtils:function(){return mm},DecrementStencilOp:function(){return bt},DecrementWrapStencilOp:function(){return _t},DefaultLoadingManager:function(){return Ku},DepthFormat:function(){return me},DepthStencilFormat:function(){return de},DepthTexture:function(){return Tc},DirectionalLight:function(){return Sf},DirectionalLightHelper:function(){return Jp},DiscreteInterpolant:function(){return Au},DodecahedronBufferGeometry:function(){return Sm},DodecahedronGeometry:function(){return _l},DoubleSide:function(){return H},DstAlphaFactor:function(){return un},DstColorFactor:function(){return pn},DynamicCopyUsage:function(){return Lt},DynamicDrawUsage:function(){return Ft},DynamicReadUsage:function(){return Et},EdgesGeometry:function(){return zl},EllipseCurve:function(){return Zs},EqualDepth:function(){return bn},EqualStencilFunc:function(){return kt},EquirectangularReflectionMapping:function(){return En},EquirectangularRefractionMapping:function(){return On},Euler:function(){return wr},EventDispatcher:function(){return Vt},ExtrudeBufferGeometry:function(){return Mm},ExtrudeGeometry:function(){return ru},FileLoader:function(){return tf},Float16BufferAttribute:function(){return sa},Float32BufferAttribute:function(){return la},Float64BufferAttribute:function(){return ua},FloatType:function(){return re},Fog:function(){return Ac},FogExp2:function(){return Oc},FramebufferTexture:function(){return Vs},FrontSide:function(){return V},Frustum:function(){return ti},GLBufferAttribute:function(){return wp},GLSL1:function(){return Nt},GLSL3:function(){return Bt},GreaterDepth:function(){return _n},GreaterEqualDepth:function(){return Un},GreaterEqualStencilFunc:function(){return Rt},GreaterStencilFunc:function(){return Ct},GridHelper:function(){return Hp},Group:function(){return kc},HalfFloatType:function(){return ae},HemisphereLight:function(){return uf},HemisphereLightHelper:function(){return Wp},HemisphereLightProbe:function(){return Gf},IcosahedronBufferGeometry:function(){return km},IcosahedronGeometry:function(){return iu},ImageBitmapLoader:function(){return Of},ImageLoader:function(){return af},ImageUtils:function(){return So},ImmediateRenderObject:function(){return dm},IncrementStencilOp:function(){return yt},IncrementWrapStencilOp:function(){return Ut},InstancedBufferAttribute:function(){return gs},InstancedBufferGeometry:function(){return Df},InstancedInterleavedBuffer:function(){return _p},InstancedMesh:function(){return Ss},Int16BufferAttribute:function(){return aa},Int32BufferAttribute:function(){return va},Int8BufferAttribute:function(){return ta},IntType:function(){return te},InterleavedBuffer:function(){return Gc},InterleavedBufferAttribute:function(){return Bc},Interpolant:function(){return Iu},InterpolateDiscrete:function(){return Qe},InterpolateLinear:function(){return Je},InterpolateSmooth:function(){return Ke},InvertStencilOp:function(){return wt},KeepStencilOp:function(){return xt},KeyframeTrack:function(){return Lu},LOD:function(){return is},LatheBufferGeometry:function(){return zm},LatheGeometry:function(){return hl},Layers:function(){return Sr},LessDepth:function(){return gn},LessEqualDepth:function(){return yn},LessEqualStencilFunc:function(){return zt},LessStencilFunc:function(){return Mt},Light:function(){return lf},LightProbe:function(){return Cf},Line:function(){return Ds},Line3:function(){return Fp},LineBasicMaterial:function(){return Ms},LineCurve:function(){return cl},LineCurve3:function(){return sl},LineDashedMaterial:function(){return zu},LineLoop:function(){return Is},LineSegments:function(){return js},LinearEncoding:function(){return vt},LinearFilter:function(){return Xn},LinearInterpolant:function(){return Ou},LinearMipMapLinearFilter:function(){return Jn},LinearMipMapNearestFilter:function(){return Zn},LinearMipmapLinearFilter:function(){return Qn},LinearMipmapNearestFilter:function(){return Yn},LinearSRGBColorSpace:function(){return dt},LinearToneMapping:function(){return Cn},Loader:function(){return $u},LoaderUtils:function(){return Rf},LoadingManager:function(){return Ju},LoopOnce:function(){return Xe},LoopPingPong:function(){return Ze},LoopRepeat:function(){return Ye},LuminanceAlphaFormat:function(){return pe},LuminanceFormat:function(){return fe},MOUSE:function(){return j},Material:function(){return Jr},MaterialLoader:function(){return Tf},MathUtils:function(){return ro},Matrix3:function(){return io},Matrix4:function(){return pr},MaxEquation:function(){return on},Mesh:function(){return Oa},MeshBasicMaterial:function(){return Kr},MeshDepthMaterial:function(){return yc},MeshDistanceMaterial:function(){return bc},MeshLambertMaterial:function(){return Mu},MeshMatcapMaterial:function(){return ku},MeshNormalMaterial:function(){return Su},MeshPhongMaterial:function(){return _u},MeshPhysicalMaterial:function(){return Uu},MeshStandardMaterial:function(){return bu},MeshToonMaterial:function(){return wu},MinEquation:function(){return tn},MirroredRepeatWrapping:function(){return Nn},MixOperation:function(){return Mn},MultiplyBlending:function(){return J},MultiplyOperation:function(){return Sn},NearestFilter:function(){return Bn},NearestMipMapLinearFilter:function(){return Hn},NearestMipMapNearestFilter:function(){return Vn},NearestMipmapLinearFilter:function(){return Wn},NearestMipmapNearestFilter:function(){return qn},NeverDepth:function(){return hn},NeverStencilFunc:function(){return St},NoBlending:function(){return X},NoColorSpace:function(){return pt},NoToneMapping:function(){return zn},NormalAnimationBlendMode:function(){return tt},NormalBlending:function(){return Y},NotEqualDepth:function(){return wn},NotEqualStencilFunc:function(){return Tt},NumberKeyframeTrack:function(){return Bu},Object3D:function(){return Ar},ObjectLoader:function(){return Ff},ObjectSpaceNormalMap:function(){return ft},OctahedronBufferGeometry:function(){return Cm},OctahedronGeometry:function(){return vu},OneFactor:function(){return an},OneMinusDstAlphaFactor:function(){return fn},OneMinusDstColorFactor:function(){return mn},OneMinusSrcAlphaFactor:function(){return ln},OneMinusSrcColorFactor:function(){return cn},OrthographicCamera:function(){return di},PCFShadowMap:function(){return N},PCFSoftShadowMap:function(){return B},PMREMGenerator:function(){return Si},Path:function(){return dl},PerspectiveCamera:function(){return Wa},Plane:function(){return $a},PlaneBufferGeometry:function(){return Tm},PlaneGeometry:function(){return ai},PlaneHelper:function(){return vm},PointLight:function(){return _f},PointLightHelper:function(){return Np},Points:function(){return Ns},PointsMaterial:function(){return Es},PolarGridHelper:function(){return Xp},PolyhedronBufferGeometry:function(){return Rm},PolyhedronGeometry:function(){return Ul},PositionalAudio:function(){return rp},PropertyBinding:function(){return mp},PropertyMixer:function(){return ip},QuadraticBezierCurve:function(){return ll},QuadraticBezierCurve3:function(){return ul},Quaternion:function(){return Eo},QuaternionKeyframeTrack:function(){return Vu},QuaternionLinearInterpolant:function(){return qu},REVISION:function(){return F},RGBADepthPacking:function(){return lt},RGBAFormat:function(){return ue},RGBAIntegerFormat:function(){return be},RGBA_ASTC_10x10_Format:function(){return qe},RGBA_ASTC_10x5_Format:function(){return Ge},RGBA_ASTC_10x6_Format:function(){return Ne},RGBA_ASTC_10x8_Format:function(){return Be},RGBA_ASTC_12x10_Format:function(){return Ve},RGBA_ASTC_12x12_Format:function(){return We},RGBA_ASTC_4x4_Format:function(){return Pe},RGBA_ASTC_5x4_Format:function(){return Fe},RGBA_ASTC_5x5_Format:function(){return je},RGBA_ASTC_6x5_Format:function(){return Ie},RGBA_ASTC_6x6_Format:function(){return Ee},RGBA_ASTC_8x5_Format:function(){return Oe},RGBA_ASTC_8x6_Format:function(){return Ae},RGBA_ASTC_8x8_Format:function(){return Le},RGBA_BPTC_Format:function(){return He},RGBA_ETC2_EAC_Format:function(){return De},RGBA_PVRTC_2BPPV1_Format:function(){return Ce},RGBA_PVRTC_4BPPV1_Format:function(){return ze},RGBA_S3TC_DXT1_Format:function(){return _e},RGBA_S3TC_DXT3_Format:function(){return we},RGBA_S3TC_DXT5_Format:function(){return Se},RGBFormat:function(){return le},RGB_ETC1_Format:function(){return Te},RGB_ETC2_Format:function(){return Re},RGB_PVRTC_2BPPV1_Format:function(){return ke},RGB_PVRTC_4BPPV1_Format:function(){return Me},RGB_S3TC_DXT1_Format:function(){return Ue},RGFormat:function(){return ge},RGIntegerFormat:function(){return ye},RawShaderMaterial:function(){return yu},Ray:function(){return fr},Raycaster:function(){return Sp},RectAreaLight:function(){return kf},RedFormat:function(){return he},RedIntegerFormat:function(){return xe},ReinhardToneMapping:function(){return Tn},RepeatWrapping:function(){return Ln},ReplaceStencilOp:function(){return gt},ReverseSubtractEquation:function(){return en},RingBufferGeometry:function(){return Dm},RingGeometry:function(){return cu},SRGBColorSpace:function(){return mt},Scene:function(){return Lc},ShaderChunk:function(){return ii},ShaderLib:function(){return ci},ShaderMaterial:function(){return qa},ShadowMaterial:function(){return gu},Shape:function(){return Cl},ShapeBufferGeometry:function(){return Pm},ShapeGeometry:function(){return su},ShapePath:function(){return um},ShapeUtils:function(){return eu},ShortType:function(){return ne},Skeleton:function(){return xs},SkeletonHelper:function(){return Lp},SkinnedMesh:function(){return fs},Source:function(){return Mo},Sphere:function(){return rr},SphereBufferGeometry:function(){return Fm},SphereGeometry:function(){return lu},Spherical:function(){return zp},SphericalHarmonics3:function(){return zf},SplineCurve:function(){return fl},SpotLight:function(){return xf},SpotLightHelper:function(){return Ip},Sprite:function(){return ts},SpriteMaterial:function(){return qc},SrcAlphaFactor:function(){return sn},SrcAlphaSaturateFactor:function(){return dn},SrcColorFactor:function(){return vn},StaticCopyUsage:function(){return At},StaticDrawUsage:function(){return Pt},StaticReadUsage:function(){return It},StereoCamera:function(){return Wf},StreamCopyUsage:function(){return Gt},StreamDrawUsage:function(){return jt},StreamReadUsage:function(){return Ot},StringKeyframeTrack:function(){return Wu},SubtractEquation:function(){return nn},SubtractiveBlending:function(){return Q},TOUCH:function(){return I},TangentSpaceNormalMap:function(){return ut},TetrahedronBufferGeometry:function(){return jm},TetrahedronGeometry:function(){return uu},Texture:function(){return Co},TextureLoader:function(){return sf},TorusBufferGeometry:function(){return Im},TorusGeometry:function(){return fu},TorusKnotBufferGeometry:function(){return Em},TorusKnotGeometry:function(){return pu},Triangle:function(){return Zr},TriangleFanDrawMode:function(){return it},TriangleStripDrawMode:function(){return at},TrianglesDrawMode:function(){return rt},TubeBufferGeometry:function(){return Om},TubeGeometry:function(){return mu},UVMapping:function(){return Fn},Uint16BufferAttribute:function(){return ia},Uint32BufferAttribute:function(){return ca},Uint8BufferAttribute:function(){return oa},Uint8ClampedBufferAttribute:function(){return ra},Uniform:function(){return yp},UniformsGroup:function(){return Up},UniformsLib:function(){return vi},UniformsUtils:function(){return Ba},UnsignedByteType:function(){return Kn},UnsignedInt248Type:function(){return ce},UnsignedIntType:function(){return oe},UnsignedShort4444Type:function(){return ie},UnsignedShort5551Type:function(){return ve},UnsignedShortType:function(){return ee},VSMShadowMap:function(){return q},Vector2:function(){return ao},Vector3:function(){return Oo},Vector4:function(){return To},VectorKeyframeTrack:function(){return Hu},VideoTexture:function(){return qs},WebGL1Renderer:function(){return Ic},WebGL3DRenderTarget:function(){return jo},WebGLArrayRenderTarget:function(){return Po},WebGLCubeRenderTarget:function(){return Za},WebGLMultipleRenderTargets:function(){return Io},WebGLMultisampleRenderTarget:function(){return hm},WebGLRenderTarget:function(){return Ro},WebGLRenderer:function(){return jc},WebGLUtils:function(){return Sc},WireframeGeometry:function(){return du},WrapAroundEnding:function(){return et},ZeroCurvatureEnding:function(){return $e},ZeroFactor:function(){return rn},ZeroSlopeEnding:function(){return nt},ZeroStencilOp:function(){return ht},_SRGBAFormat:function(){return qt},sRGBEncoding:function(){return ct}});var F="146",j={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},I={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},E=0,O=1,A=2,L=3,G=0,N=1,B=2,q=3,V=0,W=1,H=2,X=0,Y=1,Z=2,Q=3,J=4,K=5,$=100,nn=101,en=102,tn=103,on=104,rn=200,an=201,vn=202,cn=203,sn=204,ln=205,un=206,fn=207,pn=208,mn=209,dn=210,hn=0,xn=1,gn=2,yn=3,bn=4,Un=5,_n=6,wn=7,Sn=0,Mn=1,kn=2,zn=0,Cn=1,Tn=2,Rn=3,Dn=4,Pn=5,Fn=300,jn=301,In=302,En=303,On=304,An=306,Ln=1e3,Gn=1001,Nn=1002,Bn=1003,qn=1004,Vn=1004,Wn=1005,Hn=1005,Xn=1006,Yn=1007,Zn=1007,Qn=1008,Jn=1008,Kn=1009,$n=1010,ne=1011,ee=1012,te=1013,oe=1014,re=1015,ae=1016,ie=1017,ve=1018,ce=1020,se=1021,le=1022,ue=1023,fe=1024,pe=1025,me=1026,de=1027,he=1028,xe=1029,ge=1030,ye=1031,be=1033,Ue=33776,_e=33777,we=33778,Se=33779,Me=35840,ke=35841,ze=35842,Ce=35843,Te=36196,Re=37492,De=37496,Pe=37808,Fe=37809,je=37810,Ie=37811,Ee=37812,Oe=37813,Ae=37814,Le=37815,Ge=37816,Ne=37817,Be=37818,qe=37819,Ve=37820,We=37821,He=36492,Xe=2200,Ye=2201,Ze=2202,Qe=2300,Je=2301,Ke=2302,$e=2400,nt=2401,et=2402,tt=2500,ot=2501,rt=0,at=1,it=2,vt=3e3,ct=3001,st=3200,lt=3201,ut=0,ft=1,pt="",mt="srgb",dt="srgb-linear",ht=0,xt=7680,gt=7681,yt=7682,bt=7683,Ut=34055,_t=34056,wt=5386,St=512,Mt=513,kt=514,zt=515,Ct=516,Tt=517,Rt=518,Dt=519,Pt=35044,Ft=35048,jt=35040,It=35045,Et=35049,Ot=35041,At=35046,Lt=35050,Gt=35042,Nt="100",Bt="300 es",qt=1035,Vt=function(){function n(){g(this,n)}return b(n,[{key:"addEventListener",value:function(n,e){void 0===this._listeners&&(this._listeners={});var t=this._listeners;void 0===t[n]&&(t[n]=[]),-1===t[n].indexOf(e)&&t[n].push(e)}},{key:"hasEventListener",value:function(n,e){if(void 0===this._listeners)return!1;var t=this._listeners;return void 0!==t[n]&&-1!==t[n].indexOf(e)}},{key:"removeEventListener",value:function(n,e){if(void 0!==this._listeners){var t=this._listeners[n];if(void 0!==t){var o=t.indexOf(e);-1!==o&&t.splice(o,1)}}}},{key:"dispatchEvent",value:function(n){if(void 0!==this._listeners){var e=this._listeners[n.type];if(void 0!==e){n.target=this;for(var t=e.slice(0),o=0,r=t.length;o<r;o++)t[o].call(this,n);n.target=null}}}}]),n}(),Wt=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"],Ht=1234567,Xt=Math.PI/180,Yt=180/Math.PI;function Zt(){var n=4294967295*Math.random()|0,e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,o=4294967295*Math.random()|0;return(Wt[255&n]+Wt[n>>8&255]+Wt[n>>16&255]+Wt[n>>24&255]+"-"+Wt[255&e]+Wt[e>>8&255]+"-"+Wt[e>>16&15|64]+Wt[e>>24&255]+"-"+Wt[63&t|128]+Wt[t>>8&255]+"-"+Wt[t>>16&255]+Wt[t>>24&255]+Wt[255&o]+Wt[o>>8&255]+Wt[o>>16&255]+Wt[o>>24&255]).toLowerCase()}function Qt(n,e,t){return Math.max(e,Math.min(t,n))}function Jt(n,e){return(n%e+e)%e}function Kt(n,e,t){return(1-t)*n+t*e}function $t(n){return 0===(n&n-1)&&0!==n}function no(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function eo(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function to(n,e){switch(e.constructor){case Float32Array:return n;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function oo(n,e){switch(e.constructor){case Float32Array:return n;case Uint16Array:return Math.round(65535*n);case Uint8Array:return Math.round(255*n);case Int16Array:return Math.round(32767*n);case Int8Array:return Math.round(127*n);default:throw new Error("Invalid component type.")}}var ro=Object.freeze({__proto__:null,DEG2RAD:Xt,RAD2DEG:Yt,generateUUID:Zt,clamp:Qt,euclideanModulo:Jt,mapLinear:function(n,e,t,o,r){return o+(n-e)*(r-o)/(t-e)},inverseLerp:function(n,e,t){return n!==e?(t-n)/(e-n):0},lerp:Kt,damp:function(n,e,t,o){return Kt(n,e,1-Math.exp(-t*o))},pingpong:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return e-Math.abs(Jt(n,2*e)-e)},smoothstep:function(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e))*n*(3-2*n)},smootherstep:function(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e))*n*n*(n*(6*n-15)+10)},randInt:function(n,e){return n+Math.floor(Math.random()*(e-n+1))},randFloat:function(n,e){return n+Math.random()*(e-n)},randFloatSpread:function(n){return n*(.5-Math.random())},seededRandom:function(n){void 0!==n&&(Ht=n);var e=Ht+=1831565813;return e=Math.imul(e^e>>>15,1|e),(((e^=e+Math.imul(e^e>>>7,61|e))^e>>>14)>>>0)/4294967296},degToRad:function(n){return n*Xt},radToDeg:function(n){return n*Yt},isPowerOfTwo:$t,ceilPowerOfTwo:no,floorPowerOfTwo:eo,setQuaternionFromProperEuler:function(n,e,t,o,r){var a=Math.cos,i=Math.sin,v=a(t/2),c=i(t/2),s=a((e+o)/2),l=i((e+o)/2),u=a((e-o)/2),f=i((e-o)/2),p=a((o-e)/2),m=i((o-e)/2);switch(r){case"XYX":n.set(v*l,c*u,c*f,v*s);break;case"YZY":n.set(c*f,v*l,c*u,v*s);break;case"ZXZ":n.set(c*u,c*f,v*l,v*s);break;case"XZX":n.set(v*l,c*m,c*p,v*s);break;case"YXY":n.set(c*p,v*l,c*m,v*s);break;case"ZYZ":n.set(c*m,c*p,v*l,v*s);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}},normalize:oo,denormalize:to}),ao=function(n){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;g(this,e),e.prototype.isVector2=!0,this.x=n,this.y=t}return b(e,[{key:"width",get:function(){return this.x},set:function(n){this.x=n}},{key:"height",get:function(){return this.y},set:function(n){this.y=n}},{key:"set",value:function(n,e){return this.x=n,this.y=e,this}},{key:"setScalar",value:function(n){return this.x=n,this.y=n,this}},{key:"setX",value:function(n){return this.x=n,this}},{key:"setY",value:function(n){return this.y=n,this}},{key:"setComponent",value:function(n,e){switch(n){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+n)}return this}},{key:"getComponent",value:function(n){switch(n){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+n)}}},{key:"clone",value:function(){return new this.constructor(this.x,this.y)}},{key:"copy",value:function(n){return this.x=n.x,this.y=n.y,this}},{key:"add",value:function(n){return this.x+=n.x,this.y+=n.y,this}},{key:"addScalar",value:function(n){return this.x+=n,this.y+=n,this}},{key:"addVectors",value:function(n,e){return this.x=n.x+e.x,this.y=n.y+e.y,this}},{key:"addScaledVector",value:function(n,e){return this.x+=n.x*e,this.y+=n.y*e,this}},{key:"sub",value:function(n){return this.x-=n.x,this.y-=n.y,this}},{key:"subScalar",value:function(n){return this.x-=n,this.y-=n,this}},{key:"subVectors",value:function(n,e){return this.x=n.x-e.x,this.y=n.y-e.y,this}},{key:"multiply",value:function(n){return this.x*=n.x,this.y*=n.y,this}},{key:"multiplyScalar",value:function(n){return this.x*=n,this.y*=n,this}},{key:"divide",value:function(n){return this.x/=n.x,this.y/=n.y,this}},{key:"divideScalar",value:function(n){return this.multiplyScalar(1/n)}},{key:"applyMatrix3",value:function(n){var e=this.x,t=this.y,o=n.elements;return this.x=o[0]*e+o[3]*t+o[6],this.y=o[1]*e+o[4]*t+o[7],this}},{key:"min",value:function(n){return this.x=Math.min(this.x,n.x),this.y=Math.min(this.y,n.y),this}},{key:"max",value:function(n){return this.x=Math.max(this.x,n.x),this.y=Math.max(this.y,n.y),this}},{key:"clamp",value:function(n,e){return this.x=Math.max(n.x,Math.min(e.x,this.x)),this.y=Math.max(n.y,Math.min(e.y,this.y)),this}},{key:"clampScalar",value:function(n,e){return this.x=Math.max(n,Math.min(e,this.x)),this.y=Math.max(n,Math.min(e,this.y)),this}},{key:"clampLength",value:function(n,e){var t=this.length();return this.divideScalar(t||1).multiplyScalar(Math.max(n,Math.min(e,t)))}},{key:"floor",value:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}},{key:"ceil",value:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}},{key:"round",value:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}},{key:"roundToZero",value:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}},{key:"negate",value:function(){return this.x=-this.x,this.y=-this.y,this}},{key:"dot",value:function(n){return this.x*n.x+this.y*n.y}},{key:"cross",value:function(n){return this.x*n.y-this.y*n.x}},{key:"lengthSq",value:function(){return this.x*this.x+this.y*this.y}},{key:"length",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y)}},{key:"manhattanLength",value:function(){return Math.abs(this.x)+Math.abs(this.y)}},{key:"normalize",value:function(){return this.divideScalar(this.length()||1)}},{key:"angle",value:function(){var n=Math.atan2(-this.y,-this.x)+Math.PI;return n}},{key:"distanceTo",value:function(n){return Math.sqrt(this.distanceToSquared(n))}},{key:"distanceToSquared",value:function(n){var e=this.x-n.x,t=this.y-n.y;return e*e+t*t}},{key:"manhattanDistanceTo",value:function(n){return Math.abs(this.x-n.x)+Math.abs(this.y-n.y)}},{key:"setLength",value:function(n){return this.normalize().multiplyScalar(n)}},{key:"lerp",value:function(n,e){return this.x+=(n.x-this.x)*e,this.y+=(n.y-this.y)*e,this}},{key:"lerpVectors",value:function(n,e,t){return this.x=n.x+(e.x-n.x)*t,this.y=n.y+(e.y-n.y)*t,this}},{key:"equals",value:function(n){return n.x===this.x&&n.y===this.y}},{key:"fromArray",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=n[e],this.y=n[e+1],this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this.x,n[e+1]=this.y,n}},{key:"fromBufferAttribute",value:function(n,e){return this.x=n.getX(e),this.y=n.getY(e),this}},{key:"rotateAround",value:function(n,e){var t=Math.cos(e),o=Math.sin(e),r=this.x-n.x,a=this.y-n.y;return this.x=r*t-a*o+n.x,this.y=r*o+a*t+n.y,this}},{key:"random",value:function(){return this.x=Math.random(),this.y=Math.random(),this}},{key:Symbol.iterator,value:P().mark((function n(){return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this.x;case 2:return n.next=4,this.y;case 4:case"end":return n.stop()}}),n,this)}))}]),e}(),io=function(){function n(){g(this,n),n.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}return b(n,[{key:"set",value:function(n,e,t,o,r,a,i,v,c){var s=this.elements;return s[0]=n,s[1]=o,s[2]=i,s[3]=e,s[4]=r,s[5]=v,s[6]=t,s[7]=a,s[8]=c,this}},{key:"identity",value:function(){return this.set(1,0,0,0,1,0,0,0,1),this}},{key:"copy",value:function(n){var e=this.elements,t=n.elements;return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],this}},{key:"extractBasis",value:function(n,e,t){return n.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),t.setFromMatrix3Column(this,2),this}},{key:"setFromMatrix4",value:function(n){var e=n.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}},{key:"multiply",value:function(n){return this.multiplyMatrices(this,n)}},{key:"premultiply",value:function(n){return this.multiplyMatrices(n,this)}},{key:"multiplyMatrices",value:function(n,e){var t=n.elements,o=e.elements,r=this.elements,a=t[0],i=t[3],v=t[6],c=t[1],s=t[4],l=t[7],u=t[2],f=t[5],p=t[8],m=o[0],d=o[3],h=o[6],x=o[1],g=o[4],y=o[7],b=o[2],U=o[5],_=o[8];return r[0]=a*m+i*x+v*b,r[3]=a*d+i*g+v*U,r[6]=a*h+i*y+v*_,r[1]=c*m+s*x+l*b,r[4]=c*d+s*g+l*U,r[7]=c*h+s*y+l*_,r[2]=u*m+f*x+p*b,r[5]=u*d+f*g+p*U,r[8]=u*h+f*y+p*_,this}},{key:"multiplyScalar",value:function(n){var e=this.elements;return e[0]*=n,e[3]*=n,e[6]*=n,e[1]*=n,e[4]*=n,e[7]*=n,e[2]*=n,e[5]*=n,e[8]*=n,this}},{key:"determinant",value:function(){var n=this.elements,e=n[0],t=n[1],o=n[2],r=n[3],a=n[4],i=n[5],v=n[6],c=n[7],s=n[8];return e*a*s-e*i*c-t*r*s+t*i*v+o*r*c-o*a*v}},{key:"invert",value:function(){var n=this.elements,e=n[0],t=n[1],o=n[2],r=n[3],a=n[4],i=n[5],v=n[6],c=n[7],s=n[8],l=s*a-i*c,u=i*v-s*r,f=c*r-a*v,p=e*l+t*u+o*f;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);var m=1/p;return n[0]=l*m,n[1]=(o*c-s*t)*m,n[2]=(i*t-o*a)*m,n[3]=u*m,n[4]=(s*e-o*v)*m,n[5]=(o*r-i*e)*m,n[6]=f*m,n[7]=(t*v-c*e)*m,n[8]=(a*e-t*r)*m,this}},{key:"transpose",value:function(){var n,e=this.elements;return n=e[1],e[1]=e[3],e[3]=n,n=e[2],e[2]=e[6],e[6]=n,n=e[5],e[5]=e[7],e[7]=n,this}},{key:"getNormalMatrix",value:function(n){return this.setFromMatrix4(n).invert().transpose()}},{key:"transposeIntoArray",value:function(n){var e=this.elements;return n[0]=e[0],n[1]=e[3],n[2]=e[6],n[3]=e[1],n[4]=e[4],n[5]=e[7],n[6]=e[2],n[7]=e[5],n[8]=e[8],this}},{key:"setUvTransform",value:function(n,e,t,o,r,a,i){var v=Math.cos(r),c=Math.sin(r);return this.set(t*v,t*c,-t*(v*a+c*i)+a+n,-o*c,o*v,-o*(-c*a+v*i)+i+e,0,0,1),this}},{key:"scale",value:function(n,e){var t=this.elements;return t[0]*=n,t[3]*=n,t[6]*=n,t[1]*=e,t[4]*=e,t[7]*=e,this}},{key:"rotate",value:function(n){var e=Math.cos(n),t=Math.sin(n),o=this.elements,r=o[0],a=o[3],i=o[6],v=o[1],c=o[4],s=o[7];return o[0]=e*r+t*v,o[3]=e*a+t*c,o[6]=e*i+t*s,o[1]=-t*r+e*v,o[4]=-t*a+e*c,o[7]=-t*i+e*s,this}},{key:"translate",value:function(n,e){var t=this.elements;return t[0]+=n*t[2],t[3]+=n*t[5],t[6]+=n*t[8],t[1]+=e*t[2],t[4]+=e*t[5],t[7]+=e*t[8],this}},{key:"equals",value:function(n){for(var e=this.elements,t=n.elements,o=0;o<9;o++)if(e[o]!==t[o])return!1;return!0}},{key:"fromArray",value:function(n){for(var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=0;t<9;t++)this.elements[t]=n[t+e];return this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=this.elements;return n[e]=t[0],n[e+1]=t[1],n[e+2]=t[2],n[e+3]=t[3],n[e+4]=t[4],n[e+5]=t[5],n[e+6]=t[6],n[e+7]=t[7],n[e+8]=t[8],n}},{key:"clone",value:function(){return(new this.constructor).fromArray(this.elements)}}]),n}();function vo(n){for(var e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}var co={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function so(n,e){return new co[n](e)}function lo(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function uo(n){return n<.04045?.0773993808*n:Math.pow(.9478672986*n+.0521327014,2.4)}function fo(n){return n<.0031308?12.92*n:1.055*Math.pow(n,.41666)-.055}var po=(s(n={},mt,s({},dt,uo)),s(n,dt,s({},mt,fo)),n),mo={legacyMode:!0,get workingColorSpace(){return dt},set workingColorSpace(n){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(n,e,t){if(this.legacyMode||e===t||!e||!t)return n;if(po[e]&&void 0!==po[e][t]){var o=po[e][t];return n.r=o(n.r),n.g=o(n.g),n.b=o(n.b),n}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(n,e){return this.convert(n,this.workingColorSpace,e)},toWorkingColorSpace:function(n,e){return this.convert(n,e,this.workingColorSpace)}},ho={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},xo={r:0,g:0,b:0},go={h:0,s:0,l:0},yo={h:0,s:0,l:0};function bo(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+6*(e-n)*t:t<.5?e:t<2/3?n+6*(e-n)*(2/3-t):n}function Uo(n,e){return e.r=n.r,e.g=n.g,e.b=n.b,e}var _o,wo=function(n){function e(n,t,o){return g(this,e),this.isColor=!0,this.r=1,this.g=1,this.b=1,void 0===t&&void 0===o?this.set(n):this.setRGB(n,t,o)}return b(e,[{key:"set",value:function(n){return n&&n.isColor?this.copy(n):"number"===typeof n?this.setHex(n):"string"===typeof n&&this.setStyle(n),this}},{key:"setScalar",value:function(n){return this.r=n,this.g=n,this.b=n,this}},{key:"setHex",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:mt;return n=Math.floor(n),this.r=(n>>16&255)/255,this.g=(n>>8&255)/255,this.b=(255&n)/255,mo.toWorkingColorSpace(this,e),this}},{key:"setRGB",value:function(n,e,t){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:dt;return this.r=n,this.g=e,this.b=t,mo.toWorkingColorSpace(this,o),this}},{key:"setHSL",value:function(n,e,t){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:dt;if(n=Jt(n,1),e=Qt(e,0,1),t=Qt(t,0,1),0===e)this.r=this.g=this.b=t;else{var r=t<=.5?t*(1+e):t+e-t*e,a=2*t-r;this.r=bo(a,r,n+1/3),this.g=bo(a,r,n),this.b=bo(a,r,n-1/3)}return mo.toWorkingColorSpace(this,o),this}},{key:"setStyle",value:function(n){var e,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:mt;function o(e){void 0!==e&&parseFloat(e)<1&&console.warn("THREE.Color: Alpha component of "+n+" will be ignored.")}if(e=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(n)){var r,a=e[1],i=e[2];switch(a){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,mo.toWorkingColorSpace(this,t),o(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,mo.toWorkingColorSpace(this,t),o(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)){var v=parseFloat(r[1])/360,c=parseFloat(r[2])/100,s=parseFloat(r[3])/100;return o(r[4]),this.setHSL(v,c,s,t)}}}else if(e=/^\#([A-Fa-f\d]+)$/.exec(n)){var l=e[1],u=l.length;if(3===u)return this.r=parseInt(l.charAt(0)+l.charAt(0),16)/255,this.g=parseInt(l.charAt(1)+l.charAt(1),16)/255,this.b=parseInt(l.charAt(2)+l.charAt(2),16)/255,mo.toWorkingColorSpace(this,t),this;if(6===u)return this.r=parseInt(l.charAt(0)+l.charAt(1),16)/255,this.g=parseInt(l.charAt(2)+l.charAt(3),16)/255,this.b=parseInt(l.charAt(4)+l.charAt(5),16)/255,mo.toWorkingColorSpace(this,t),this}return n&&n.length>0?this.setColorName(n,t):this}},{key:"setColorName",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:mt,t=ho[n.toLowerCase()];return void 0!==t?this.setHex(t,e):console.warn("THREE.Color: Unknown color "+n),this}},{key:"clone",value:function(){return new this.constructor(this.r,this.g,this.b)}},{key:"copy",value:function(n){return this.r=n.r,this.g=n.g,this.b=n.b,this}},{key:"copySRGBToLinear",value:function(n){return this.r=uo(n.r),this.g=uo(n.g),this.b=uo(n.b),this}},{key:"copyLinearToSRGB",value:function(n){return this.r=fo(n.r),this.g=fo(n.g),this.b=fo(n.b),this}},{key:"convertSRGBToLinear",value:function(){return this.copySRGBToLinear(this),this}},{key:"convertLinearToSRGB",value:function(){return this.copyLinearToSRGB(this),this}},{key:"getHex",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:mt;return mo.fromWorkingColorSpace(Uo(this,xo),n),Qt(255*xo.r,0,255)<<16^Qt(255*xo.g,0,255)<<8^Qt(255*xo.b,0,255)<<0}},{key:"getHexString",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:mt;return("000000"+this.getHex(n).toString(16)).slice(-6)}},{key:"getHSL",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:dt;mo.fromWorkingColorSpace(Uo(this,xo),e);var t,o,r=xo.r,a=xo.g,i=xo.b,v=Math.max(r,a,i),c=Math.min(r,a,i),s=(c+v)/2;if(c===v)t=0,o=0;else{var l=v-c;switch(o=s<=.5?l/(v+c):l/(2-v-c),v){case r:t=(a-i)/l+(a<i?6:0);break;case a:t=(i-r)/l+2;break;case i:t=(r-a)/l+4}t/=6}return n.h=t,n.s=o,n.l=s,n}},{key:"getRGB",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:dt;return mo.fromWorkingColorSpace(Uo(this,xo),e),n.r=xo.r,n.g=xo.g,n.b=xo.b,n}},{key:"getStyle",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:mt;return mo.fromWorkingColorSpace(Uo(this,xo),n),n!==mt?"color(".concat(n," ").concat(xo.r," ").concat(xo.g," ").concat(xo.b,")"):"rgb(".concat(255*xo.r|0,",").concat(255*xo.g|0,",").concat(255*xo.b|0,")")}},{key:"offsetHSL",value:function(n,e,t){return this.getHSL(go),go.h+=n,go.s+=e,go.l+=t,this.setHSL(go.h,go.s,go.l),this}},{key:"add",value:function(n){return this.r+=n.r,this.g+=n.g,this.b+=n.b,this}},{key:"addColors",value:function(n,e){return this.r=n.r+e.r,this.g=n.g+e.g,this.b=n.b+e.b,this}},{key:"addScalar",value:function(n){return this.r+=n,this.g+=n,this.b+=n,this}},{key:"sub",value:function(n){return this.r=Math.max(0,this.r-n.r),this.g=Math.max(0,this.g-n.g),this.b=Math.max(0,this.b-n.b),this}},{key:"multiply",value:function(n){return this.r*=n.r,this.g*=n.g,this.b*=n.b,this}},{key:"multiplyScalar",value:function(n){return this.r*=n,this.g*=n,this.b*=n,this}},{key:"lerp",value:function(n,e){return this.r+=(n.r-this.r)*e,this.g+=(n.g-this.g)*e,this.b+=(n.b-this.b)*e,this}},{key:"lerpColors",value:function(n,e,t){return this.r=n.r+(e.r-n.r)*t,this.g=n.g+(e.g-n.g)*t,this.b=n.b+(e.b-n.b)*t,this}},{key:"lerpHSL",value:function(n,e){this.getHSL(go),n.getHSL(yo);var t=Kt(go.h,yo.h,e),o=Kt(go.s,yo.s,e),r=Kt(go.l,yo.l,e);return this.setHSL(t,o,r),this}},{key:"equals",value:function(n){return n.r===this.r&&n.g===this.g&&n.b===this.b}},{key:"fromArray",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=n[e],this.g=n[e+1],this.b=n[e+2],this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this.r,n[e+1]=this.g,n[e+2]=this.b,n}},{key:"fromBufferAttribute",value:function(n,e){return this.r=n.getX(e),this.g=n.getY(e),this.b=n.getZ(e),this}},{key:"toJSON",value:function(){return this.getHex()}},{key:Symbol.iterator,value:P().mark((function n(){return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this.r;case 2:return n.next=4,this.g;case 4:return n.next=6,this.b;case 6:case"end":return n.stop()}}),n,this)}))}]),e}();wo.NAMES=ho;var So=function(){function n(){g(this,n)}return b(n,null,[{key:"getDataURL",value:function(n){if(/^data:/i.test(n.src))return n.src;if("undefined"==typeof HTMLCanvasElement)return n.src;var e;if(n instanceof HTMLCanvasElement)e=n;else{void 0===_o&&(_o=lo("canvas")),_o.width=n.width,_o.height=n.height;var t=_o.getContext("2d");n instanceof ImageData?t.putImageData(n,0,0):t.drawImage(n,0,0,n.width,n.height),e=_o}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",n),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}},{key:"sRGBToLinear",value:function(n){if("undefined"!==typeof HTMLImageElement&&n instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&n instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&n instanceof ImageBitmap){var e=lo("canvas");e.width=n.width,e.height=n.height;var t=e.getContext("2d");t.drawImage(n,0,0,n.width,n.height);for(var o=t.getImageData(0,0,n.width,n.height),r=o.data,a=0;a<r.length;a++)r[a]=255*uo(r[a]/255);return t.putImageData(o,0,0),e}if(n.data){for(var i=n.data.slice(0),v=0;v<i.length;v++)i instanceof Uint8Array||i instanceof Uint8ClampedArray?i[v]=Math.floor(255*uo(i[v]/255)):i[v]=uo(i[v]);return{data:i,width:n.width,height:n.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),n}}]),n}(),Mo=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;g(this,n),this.isSource=!0,this.uuid=Zt(),this.data=e,this.version=0}return b(n,[{key:"needsUpdate",set:function(n){!0===n&&this.version++}},{key:"toJSON",value:function(n){var e=void 0===n||"string"===typeof n;if(!e&&void 0!==n.images[this.uuid])return n.images[this.uuid];var t={uuid:this.uuid,url:""},o=this.data;if(null!==o){var r;if(Array.isArray(o)){r=[];for(var a=0,i=o.length;a<i;a++)o[a].isDataTexture?r.push(ko(o[a].image)):r.push(ko(o[a]))}else r=ko(o);t.url=r}return e||(n.images[this.uuid]=t),t}}]),n}();function ko(n){return"undefined"!==typeof HTMLImageElement&&n instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&n instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&n instanceof ImageBitmap?So.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}var zo=0,Co=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.DEFAULT_IMAGE,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.DEFAULT_MAPPING,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Gn,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Gn,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Xn,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:Qn,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:ue,l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:Kn,u=arguments.length>8&&void 0!==arguments[8]?arguments[8]:1,f=arguments.length>9&&void 0!==arguments[9]?arguments[9]:vt;return g(this,t),(n=e.call(this)).isTexture=!0,Object.defineProperty(S(n),"id",{value:zo++}),n.uuid=Zt(),n.name="",n.source=new Mo(o),n.mipmaps=[],n.mapping=r,n.wrapS=a,n.wrapT=i,n.magFilter=v,n.minFilter=c,n.anisotropy=u,n.format=s,n.internalFormat=null,n.type=l,n.offset=new ao(0,0),n.repeat=new ao(1,1),n.center=new ao(0,0),n.rotation=0,n.matrixAutoUpdate=!0,n.matrix=new io,n.generateMipmaps=!0,n.premultiplyAlpha=!1,n.flipY=!0,n.unpackAlignment=4,n.encoding=f,n.userData={},n.version=0,n.onUpdate=null,n.isRenderTargetTexture=!1,n.needsPMREMUpdate=!1,n}return b(t,[{key:"image",get:function(){return this.source.data},set:function(n){this.source.data=n}},{key:"updateMatrix",value:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){return this.name=n.name,this.source=n.source,this.mipmaps=n.mipmaps.slice(0),this.mapping=n.mapping,this.wrapS=n.wrapS,this.wrapT=n.wrapT,this.magFilter=n.magFilter,this.minFilter=n.minFilter,this.anisotropy=n.anisotropy,this.format=n.format,this.internalFormat=n.internalFormat,this.type=n.type,this.offset.copy(n.offset),this.repeat.copy(n.repeat),this.center.copy(n.center),this.rotation=n.rotation,this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrix.copy(n.matrix),this.generateMipmaps=n.generateMipmaps,this.premultiplyAlpha=n.premultiplyAlpha,this.flipY=n.flipY,this.unpackAlignment=n.unpackAlignment,this.encoding=n.encoding,this.userData=JSON.parse(JSON.stringify(n.userData)),this.needsUpdate=!0,this}},{key:"toJSON",value:function(n){var e=void 0===n||"string"===typeof n;if(!e&&void 0!==n.textures[this.uuid])return n.textures[this.uuid];var t={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(n).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return"{}"!==JSON.stringify(this.userData)&&(t.userData=this.userData),e||(n.textures[this.uuid]=t),t}},{key:"dispose",value:function(){this.dispatchEvent({type:"dispose"})}},{key:"transformUv",value:function(n){if(this.mapping!==Fn)return n;if(n.applyMatrix3(this.matrix),n.x<0||n.x>1)switch(this.wrapS){case Ln:n.x=n.x-Math.floor(n.x);break;case Gn:n.x=n.x<0?0:1;break;case Nn:1===Math.abs(Math.floor(n.x)%2)?n.x=Math.ceil(n.x)-n.x:n.x=n.x-Math.floor(n.x)}if(n.y<0||n.y>1)switch(this.wrapT){case Ln:n.y=n.y-Math.floor(n.y);break;case Gn:n.y=n.y<0?0:1;break;case Nn:1===Math.abs(Math.floor(n.y)%2)?n.y=Math.ceil(n.y)-n.y:n.y=n.y-Math.floor(n.y)}return this.flipY&&(n.y=1-n.y),n}},{key:"needsUpdate",set:function(n){!0===n&&(this.version++,this.source.needsUpdate=!0)}}]),t}(Vt);Co.DEFAULT_IMAGE=null,Co.DEFAULT_MAPPING=Fn;var To=function(n){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;g(this,e),e.prototype.isVector4=!0,this.x=n,this.y=t,this.z=o,this.w=r}return b(e,[{key:"width",get:function(){return this.z},set:function(n){this.z=n}},{key:"height",get:function(){return this.w},set:function(n){this.w=n}},{key:"set",value:function(n,e,t,o){return this.x=n,this.y=e,this.z=t,this.w=o,this}},{key:"setScalar",value:function(n){return this.x=n,this.y=n,this.z=n,this.w=n,this}},{key:"setX",value:function(n){return this.x=n,this}},{key:"setY",value:function(n){return this.y=n,this}},{key:"setZ",value:function(n){return this.z=n,this}},{key:"setW",value:function(n){return this.w=n,this}},{key:"setComponent",value:function(n,e){switch(n){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+n)}return this}},{key:"getComponent",value:function(n){switch(n){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+n)}}},{key:"clone",value:function(){return new this.constructor(this.x,this.y,this.z,this.w)}},{key:"copy",value:function(n){return this.x=n.x,this.y=n.y,this.z=n.z,this.w=void 0!==n.w?n.w:1,this}},{key:"add",value:function(n){return this.x+=n.x,this.y+=n.y,this.z+=n.z,this.w+=n.w,this}},{key:"addScalar",value:function(n){return this.x+=n,this.y+=n,this.z+=n,this.w+=n,this}},{key:"addVectors",value:function(n,e){return this.x=n.x+e.x,this.y=n.y+e.y,this.z=n.z+e.z,this.w=n.w+e.w,this}},{key:"addScaledVector",value:function(n,e){return this.x+=n.x*e,this.y+=n.y*e,this.z+=n.z*e,this.w+=n.w*e,this}},{key:"sub",value:function(n){return this.x-=n.x,this.y-=n.y,this.z-=n.z,this.w-=n.w,this}},{key:"subScalar",value:function(n){return this.x-=n,this.y-=n,this.z-=n,this.w-=n,this}},{key:"subVectors",value:function(n,e){return this.x=n.x-e.x,this.y=n.y-e.y,this.z=n.z-e.z,this.w=n.w-e.w,this}},{key:"multiply",value:function(n){return this.x*=n.x,this.y*=n.y,this.z*=n.z,this.w*=n.w,this}},{key:"multiplyScalar",value:function(n){return this.x*=n,this.y*=n,this.z*=n,this.w*=n,this}},{key:"applyMatrix4",value:function(n){var e=this.x,t=this.y,o=this.z,r=this.w,a=n.elements;return this.x=a[0]*e+a[4]*t+a[8]*o+a[12]*r,this.y=a[1]*e+a[5]*t+a[9]*o+a[13]*r,this.z=a[2]*e+a[6]*t+a[10]*o+a[14]*r,this.w=a[3]*e+a[7]*t+a[11]*o+a[15]*r,this}},{key:"divideScalar",value:function(n){return this.multiplyScalar(1/n)}},{key:"setAxisAngleFromQuaternion",value:function(n){this.w=2*Math.acos(n.w);var e=Math.sqrt(1-n.w*n.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=n.x/e,this.y=n.y/e,this.z=n.z/e),this}},{key:"setAxisAngleFromRotationMatrix",value:function(n){var e,t,o,r,a=.01,i=.1,v=n.elements,c=v[0],s=v[4],l=v[8],u=v[1],f=v[5],p=v[9],m=v[2],d=v[6],h=v[10];if(Math.abs(s-u)<a&&Math.abs(l-m)<a&&Math.abs(p-d)<a){if(Math.abs(s+u)<i&&Math.abs(l+m)<i&&Math.abs(p+d)<i&&Math.abs(c+f+h-3)<i)return this.set(1,0,0,0),this;e=Math.PI;var x=(c+1)/2,g=(f+1)/2,y=(h+1)/2,b=(s+u)/4,U=(l+m)/4,_=(p+d)/4;return x>g&&x>y?x<a?(t=0,o=.707106781,r=.707106781):(o=b/(t=Math.sqrt(x)),r=U/t):g>y?g<a?(t=.707106781,o=0,r=.707106781):(t=b/(o=Math.sqrt(g)),r=_/o):y<a?(t=.707106781,o=.707106781,r=0):(t=U/(r=Math.sqrt(y)),o=_/r),this.set(t,o,r,e),this}var w=Math.sqrt((d-p)*(d-p)+(l-m)*(l-m)+(u-s)*(u-s));return Math.abs(w)<.001&&(w=1),this.x=(d-p)/w,this.y=(l-m)/w,this.z=(u-s)/w,this.w=Math.acos((c+f+h-1)/2),this}},{key:"min",value:function(n){return this.x=Math.min(this.x,n.x),this.y=Math.min(this.y,n.y),this.z=Math.min(this.z,n.z),this.w=Math.min(this.w,n.w),this}},{key:"max",value:function(n){return this.x=Math.max(this.x,n.x),this.y=Math.max(this.y,n.y),this.z=Math.max(this.z,n.z),this.w=Math.max(this.w,n.w),this}},{key:"clamp",value:function(n,e){return this.x=Math.max(n.x,Math.min(e.x,this.x)),this.y=Math.max(n.y,Math.min(e.y,this.y)),this.z=Math.max(n.z,Math.min(e.z,this.z)),this.w=Math.max(n.w,Math.min(e.w,this.w)),this}},{key:"clampScalar",value:function(n,e){return this.x=Math.max(n,Math.min(e,this.x)),this.y=Math.max(n,Math.min(e,this.y)),this.z=Math.max(n,Math.min(e,this.z)),this.w=Math.max(n,Math.min(e,this.w)),this}},{key:"clampLength",value:function(n,e){var t=this.length();return this.divideScalar(t||1).multiplyScalar(Math.max(n,Math.min(e,t)))}},{key:"floor",value:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}},{key:"ceil",value:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}},{key:"round",value:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}},{key:"roundToZero",value:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}},{key:"negate",value:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}},{key:"dot",value:function(n){return this.x*n.x+this.y*n.y+this.z*n.z+this.w*n.w}},{key:"lengthSq",value:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}},{key:"length",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}},{key:"manhattanLength",value:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}},{key:"normalize",value:function(){return this.divideScalar(this.length()||1)}},{key:"setLength",value:function(n){return this.normalize().multiplyScalar(n)}},{key:"lerp",value:function(n,e){return this.x+=(n.x-this.x)*e,this.y+=(n.y-this.y)*e,this.z+=(n.z-this.z)*e,this.w+=(n.w-this.w)*e,this}},{key:"lerpVectors",value:function(n,e,t){return this.x=n.x+(e.x-n.x)*t,this.y=n.y+(e.y-n.y)*t,this.z=n.z+(e.z-n.z)*t,this.w=n.w+(e.w-n.w)*t,this}},{key:"equals",value:function(n){return n.x===this.x&&n.y===this.y&&n.z===this.z&&n.w===this.w}},{key:"fromArray",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=n[e],this.y=n[e+1],this.z=n[e+2],this.w=n[e+3],this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this.x,n[e+1]=this.y,n[e+2]=this.z,n[e+3]=this.w,n}},{key:"fromBufferAttribute",value:function(n,e){return this.x=n.getX(e),this.y=n.getY(e),this.z=n.getZ(e),this.w=n.getW(e),this}},{key:"random",value:function(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}},{key:Symbol.iterator,value:P().mark((function n(){return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this.x;case 2:return n.next=4,this.y;case 4:return n.next=6,this.z;case 6:return n.next=8,this.w;case 8:case"end":return n.stop()}}),n,this)}))}]),e}(),Ro=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};g(this,t),(n=e.call(this)).isWebGLRenderTarget=!0,n.width=o,n.height=r,n.depth=1,n.scissor=new To(0,0,o,r),n.scissorTest=!1,n.viewport=new To(0,0,o,r);var i={width:o,height:r,depth:1};return n.texture=new Co(i,a.mapping,a.wrapS,a.wrapT,a.magFilter,a.minFilter,a.format,a.type,a.anisotropy,a.encoding),n.texture.isRenderTargetTexture=!0,n.texture.flipY=!1,n.texture.generateMipmaps=void 0!==a.generateMipmaps&&a.generateMipmaps,n.texture.internalFormat=void 0!==a.internalFormat?a.internalFormat:null,n.texture.minFilter=void 0!==a.minFilter?a.minFilter:Xn,n.depthBuffer=void 0===a.depthBuffer||a.depthBuffer,n.stencilBuffer=void 0!==a.stencilBuffer&&a.stencilBuffer,n.depthTexture=void 0!==a.depthTexture?a.depthTexture:null,n.samples=void 0!==a.samples?a.samples:0,n}return b(t,[{key:"setSize",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;this.width===n&&this.height===e&&this.depth===t||(this.width=n,this.height=e,this.depth=t,this.texture.image.width=n,this.texture.image.height=e,this.texture.image.depth=t,this.dispose()),this.viewport.set(0,0,n,e),this.scissor.set(0,0,n,e)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){this.width=n.width,this.height=n.height,this.depth=n.depth,this.viewport.copy(n.viewport),this.texture=n.texture.clone(),this.texture.isRenderTargetTexture=!0;var e=Object.assign({},n.texture.image);return this.texture.source=new Mo(e),this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,null!==n.depthTexture&&(this.depthTexture=n.depthTexture.clone()),this.samples=n.samples,this}},{key:"dispose",value:function(){this.dispatchEvent({type:"dispose"})}}]),t}(Vt),Do=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;return g(this,t),(n=e.call(this,null)).isDataArrayTexture=!0,n.image={data:o,width:r,height:a,depth:i},n.magFilter=Bn,n.minFilter=Bn,n.wrapR=Gn,n.generateMipmaps=!1,n.flipY=!1,n.unpackAlignment=1,n}return b(t)}(Co),Po=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return g(this,t),(n=e.call(this,o,r)).isWebGLArrayRenderTarget=!0,n.depth=a,n.texture=new Do(null,o,r,a),n.texture.isRenderTargetTexture=!0,n}return b(t)}(Ro),Fo=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;return g(this,t),(n=e.call(this,null)).isData3DTexture=!0,n.image={data:o,width:r,height:a,depth:i},n.magFilter=Bn,n.minFilter=Bn,n.wrapR=Gn,n.generateMipmaps=!1,n.flipY=!1,n.unpackAlignment=1,n}return b(t)}(Co),jo=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return g(this,t),(n=e.call(this,o,r)).isWebGL3DRenderTarget=!0,n.depth=a,n.texture=new Fo(null,o,r,a),n.texture.isRenderTargetTexture=!0,n}return b(t)}(Ro),Io=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};g(this,t),(n=e.call(this,o,r,i)).isWebGLMultipleRenderTargets=!0;var v=n.texture;n.texture=[];for(var c=0;c<a;c++)n.texture[c]=v.clone(),n.texture[c].isRenderTargetTexture=!0;return n}return b(t,[{key:"setSize",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(this.width!==n||this.height!==e||this.depth!==t){this.width=n,this.height=e,this.depth=t;for(var o=0,r=this.texture.length;o<r;o++)this.texture[o].image.width=n,this.texture[o].image.height=e,this.texture[o].image.depth=t;this.dispose()}return this.viewport.set(0,0,n,e),this.scissor.set(0,0,n,e),this}},{key:"copy",value:function(n){this.dispose(),this.width=n.width,this.height=n.height,this.depth=n.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,null!==n.depthTexture&&(this.depthTexture=n.depthTexture.clone()),this.texture.length=0;for(var e=0,t=n.texture.length;e<t;e++)this.texture[e]=n.texture[e].clone(),this.texture[e].isRenderTargetTexture=!0;return this}}]),t}(Ro),Eo=function(n){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;g(this,e),this.isQuaternion=!0,this._x=n,this._y=t,this._z=o,this._w=r}return b(e,[{key:"x",get:function(){return this._x},set:function(n){this._x=n,this._onChangeCallback()}},{key:"y",get:function(){return this._y},set:function(n){this._y=n,this._onChangeCallback()}},{key:"z",get:function(){return this._z},set:function(n){this._z=n,this._onChangeCallback()}},{key:"w",get:function(){return this._w},set:function(n){this._w=n,this._onChangeCallback()}},{key:"set",value:function(n,e,t,o){return this._x=n,this._y=e,this._z=t,this._w=o,this._onChangeCallback(),this}},{key:"clone",value:function(){return new this.constructor(this._x,this._y,this._z,this._w)}},{key:"copy",value:function(n){return this._x=n.x,this._y=n.y,this._z=n.z,this._w=n.w,this._onChangeCallback(),this}},{key:"setFromEuler",value:function(n,e){var t=n._x,o=n._y,r=n._z,a=n._order,i=Math.cos,v=Math.sin,c=i(t/2),s=i(o/2),l=i(r/2),u=v(t/2),f=v(o/2),p=v(r/2);switch(a){case"XYZ":this._x=u*s*l+c*f*p,this._y=c*f*l-u*s*p,this._z=c*s*p+u*f*l,this._w=c*s*l-u*f*p;break;case"YXZ":this._x=u*s*l+c*f*p,this._y=c*f*l-u*s*p,this._z=c*s*p-u*f*l,this._w=c*s*l+u*f*p;break;case"ZXY":this._x=u*s*l-c*f*p,this._y=c*f*l+u*s*p,this._z=c*s*p+u*f*l,this._w=c*s*l-u*f*p;break;case"ZYX":this._x=u*s*l-c*f*p,this._y=c*f*l+u*s*p,this._z=c*s*p-u*f*l,this._w=c*s*l+u*f*p;break;case"YZX":this._x=u*s*l+c*f*p,this._y=c*f*l+u*s*p,this._z=c*s*p-u*f*l,this._w=c*s*l-u*f*p;break;case"XZY":this._x=u*s*l-c*f*p,this._y=c*f*l-u*s*p,this._z=c*s*p+u*f*l,this._w=c*s*l+u*f*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return!1!==e&&this._onChangeCallback(),this}},{key:"setFromAxisAngle",value:function(n,e){var t=e/2,o=Math.sin(t);return this._x=n.x*o,this._y=n.y*o,this._z=n.z*o,this._w=Math.cos(t),this._onChangeCallback(),this}},{key:"setFromRotationMatrix",value:function(n){var e=n.elements,t=e[0],o=e[4],r=e[8],a=e[1],i=e[5],v=e[9],c=e[2],s=e[6],l=e[10],u=t+i+l;if(u>0){var f=.5/Math.sqrt(u+1);this._w=.25/f,this._x=(s-v)*f,this._y=(r-c)*f,this._z=(a-o)*f}else if(t>i&&t>l){var p=2*Math.sqrt(1+t-i-l);this._w=(s-v)/p,this._x=.25*p,this._y=(o+a)/p,this._z=(r+c)/p}else if(i>l){var m=2*Math.sqrt(1+i-t-l);this._w=(r-c)/m,this._x=(o+a)/m,this._y=.25*m,this._z=(v+s)/m}else{var d=2*Math.sqrt(1+l-t-i);this._w=(a-o)/d,this._x=(r+c)/d,this._y=(v+s)/d,this._z=.25*d}return this._onChangeCallback(),this}},{key:"setFromUnitVectors",value:function(n,e){var t=n.dot(e)+1;return t<Number.EPSILON?(t=0,Math.abs(n.x)>Math.abs(n.z)?(this._x=-n.y,this._y=n.x,this._z=0,this._w=t):(this._x=0,this._y=-n.z,this._z=n.y,this._w=t)):(this._x=n.y*e.z-n.z*e.y,this._y=n.z*e.x-n.x*e.z,this._z=n.x*e.y-n.y*e.x,this._w=t),this.normalize()}},{key:"angleTo",value:function(n){return 2*Math.acos(Math.abs(Qt(this.dot(n),-1,1)))}},{key:"rotateTowards",value:function(n,e){var t=this.angleTo(n);if(0===t)return this;var o=Math.min(1,e/t);return this.slerp(n,o),this}},{key:"identity",value:function(){return this.set(0,0,0,1)}},{key:"invert",value:function(){return this.conjugate()}},{key:"conjugate",value:function(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}},{key:"dot",value:function(n){return this._x*n._x+this._y*n._y+this._z*n._z+this._w*n._w}},{key:"lengthSq",value:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}},{key:"length",value:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}},{key:"normalize",value:function(){var n=this.length();return 0===n?(this._x=0,this._y=0,this._z=0,this._w=1):(n=1/n,this._x=this._x*n,this._y=this._y*n,this._z=this._z*n,this._w=this._w*n),this._onChangeCallback(),this}},{key:"multiply",value:function(n){return this.multiplyQuaternions(this,n)}},{key:"premultiply",value:function(n){return this.multiplyQuaternions(n,this)}},{key:"multiplyQuaternions",value:function(n,e){var t=n._x,o=n._y,r=n._z,a=n._w,i=e._x,v=e._y,c=e._z,s=e._w;return this._x=t*s+a*i+o*c-r*v,this._y=o*s+a*v+r*i-t*c,this._z=r*s+a*c+t*v-o*i,this._w=a*s-t*i-o*v-r*c,this._onChangeCallback(),this}},{key:"slerp",value:function(n,e){if(0===e)return this;if(1===e)return this.copy(n);var t=this._x,o=this._y,r=this._z,a=this._w,i=a*n._w+t*n._x+o*n._y+r*n._z;if(i<0?(this._w=-n._w,this._x=-n._x,this._y=-n._y,this._z=-n._z,i=-i):this.copy(n),i>=1)return this._w=a,this._x=t,this._y=o,this._z=r,this;var v=1-i*i;if(v<=Number.EPSILON){var c=1-e;return this._w=c*a+e*this._w,this._x=c*t+e*this._x,this._y=c*o+e*this._y,this._z=c*r+e*this._z,this.normalize(),this._onChangeCallback(),this}var s=Math.sqrt(v),l=Math.atan2(s,i),u=Math.sin((1-e)*l)/s,f=Math.sin(e*l)/s;return this._w=a*u+this._w*f,this._x=t*u+this._x*f,this._y=o*u+this._y*f,this._z=r*u+this._z*f,this._onChangeCallback(),this}},{key:"slerpQuaternions",value:function(n,e,t){return this.copy(n).slerp(e,t)}},{key:"random",value:function(){var n=Math.random(),e=Math.sqrt(1-n),t=Math.sqrt(n),o=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(e*Math.cos(o),t*Math.sin(r),t*Math.cos(r),e*Math.sin(o))}},{key:"equals",value:function(n){return n._x===this._x&&n._y===this._y&&n._z===this._z&&n._w===this._w}},{key:"fromArray",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._x=n[e],this._y=n[e+1],this._z=n[e+2],this._w=n[e+3],this._onChangeCallback(),this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this._x,n[e+1]=this._y,n[e+2]=this._z,n[e+3]=this._w,n}},{key:"fromBufferAttribute",value:function(n,e){return this._x=n.getX(e),this._y=n.getY(e),this._z=n.getZ(e),this._w=n.getW(e),this}},{key:"_onChange",value:function(n){return this._onChangeCallback=n,this}},{key:"_onChangeCallback",value:function(){}},{key:Symbol.iterator,value:P().mark((function n(){return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this._x;case 2:return n.next=4,this._y;case 4:return n.next=6,this._z;case 6:return n.next=8,this._w;case 8:case"end":return n.stop()}}),n,this)}))}],[{key:"slerpFlat",value:function(n,e,t,o,r,a,i){var v=t[o+0],c=t[o+1],s=t[o+2],l=t[o+3],u=r[a+0],f=r[a+1],p=r[a+2],m=r[a+3];if(0===i)return n[e+0]=v,n[e+1]=c,n[e+2]=s,void(n[e+3]=l);if(1===i)return n[e+0]=u,n[e+1]=f,n[e+2]=p,void(n[e+3]=m);if(l!==m||v!==u||c!==f||s!==p){var d=1-i,h=v*u+c*f+s*p+l*m,x=h>=0?1:-1,g=1-h*h;if(g>Number.EPSILON){var y=Math.sqrt(g),b=Math.atan2(y,h*x);d=Math.sin(d*b)/y,i=Math.sin(i*b)/y}var U=i*x;if(v=v*d+u*U,c=c*d+f*U,s=s*d+p*U,l=l*d+m*U,d===1-i){var _=1/Math.sqrt(v*v+c*c+s*s+l*l);v*=_,c*=_,s*=_,l*=_}}n[e]=v,n[e+1]=c,n[e+2]=s,n[e+3]=l}},{key:"multiplyQuaternionsFlat",value:function(n,e,t,o,r,a){var i=t[o],v=t[o+1],c=t[o+2],s=t[o+3],l=r[a],u=r[a+1],f=r[a+2],p=r[a+3];return n[e]=i*p+s*l+v*f-c*u,n[e+1]=v*p+s*u+c*l-i*f,n[e+2]=c*p+s*f+i*u-v*l,n[e+3]=s*p-i*l-v*u-c*f,n}}]),e}(),Oo=function(n){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;g(this,e),e.prototype.isVector3=!0,this.x=n,this.y=t,this.z=o}return b(e,[{key:"set",value:function(n,e,t){return void 0===t&&(t=this.z),this.x=n,this.y=e,this.z=t,this}},{key:"setScalar",value:function(n){return this.x=n,this.y=n,this.z=n,this}},{key:"setX",value:function(n){return this.x=n,this}},{key:"setY",value:function(n){return this.y=n,this}},{key:"setZ",value:function(n){return this.z=n,this}},{key:"setComponent",value:function(n,e){switch(n){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+n)}return this}},{key:"getComponent",value:function(n){switch(n){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+n)}}},{key:"clone",value:function(){return new this.constructor(this.x,this.y,this.z)}},{key:"copy",value:function(n){return this.x=n.x,this.y=n.y,this.z=n.z,this}},{key:"add",value:function(n){return this.x+=n.x,this.y+=n.y,this.z+=n.z,this}},{key:"addScalar",value:function(n){return this.x+=n,this.y+=n,this.z+=n,this}},{key:"addVectors",value:function(n,e){return this.x=n.x+e.x,this.y=n.y+e.y,this.z=n.z+e.z,this}},{key:"addScaledVector",value:function(n,e){return this.x+=n.x*e,this.y+=n.y*e,this.z+=n.z*e,this}},{key:"sub",value:function(n){return this.x-=n.x,this.y-=n.y,this.z-=n.z,this}},{key:"subScalar",value:function(n){return this.x-=n,this.y-=n,this.z-=n,this}},{key:"subVectors",value:function(n,e){return this.x=n.x-e.x,this.y=n.y-e.y,this.z=n.z-e.z,this}},{key:"multiply",value:function(n){return this.x*=n.x,this.y*=n.y,this.z*=n.z,this}},{key:"multiplyScalar",value:function(n){return this.x*=n,this.y*=n,this.z*=n,this}},{key:"multiplyVectors",value:function(n,e){return this.x=n.x*e.x,this.y=n.y*e.y,this.z=n.z*e.z,this}},{key:"applyEuler",value:function(n){return this.applyQuaternion(Lo.setFromEuler(n))}},{key:"applyAxisAngle",value:function(n,e){return this.applyQuaternion(Lo.setFromAxisAngle(n,e))}},{key:"applyMatrix3",value:function(n){var e=this.x,t=this.y,o=this.z,r=n.elements;return this.x=r[0]*e+r[3]*t+r[6]*o,this.y=r[1]*e+r[4]*t+r[7]*o,this.z=r[2]*e+r[5]*t+r[8]*o,this}},{key:"applyNormalMatrix",value:function(n){return this.applyMatrix3(n).normalize()}},{key:"applyMatrix4",value:function(n){var e=this.x,t=this.y,o=this.z,r=n.elements,a=1/(r[3]*e+r[7]*t+r[11]*o+r[15]);return this.x=(r[0]*e+r[4]*t+r[8]*o+r[12])*a,this.y=(r[1]*e+r[5]*t+r[9]*o+r[13])*a,this.z=(r[2]*e+r[6]*t+r[10]*o+r[14])*a,this}},{key:"applyQuaternion",value:function(n){var e=this.x,t=this.y,o=this.z,r=n.x,a=n.y,i=n.z,v=n.w,c=v*e+a*o-i*t,s=v*t+i*e-r*o,l=v*o+r*t-a*e,u=-r*e-a*t-i*o;return this.x=c*v+u*-r+s*-i-l*-a,this.y=s*v+u*-a+l*-r-c*-i,this.z=l*v+u*-i+c*-a-s*-r,this}},{key:"project",value:function(n){return this.applyMatrix4(n.matrixWorldInverse).applyMatrix4(n.projectionMatrix)}},{key:"unproject",value:function(n){return this.applyMatrix4(n.projectionMatrixInverse).applyMatrix4(n.matrixWorld)}},{key:"transformDirection",value:function(n){var e=this.x,t=this.y,o=this.z,r=n.elements;return this.x=r[0]*e+r[4]*t+r[8]*o,this.y=r[1]*e+r[5]*t+r[9]*o,this.z=r[2]*e+r[6]*t+r[10]*o,this.normalize()}},{key:"divide",value:function(n){return this.x/=n.x,this.y/=n.y,this.z/=n.z,this}},{key:"divideScalar",value:function(n){return this.multiplyScalar(1/n)}},{key:"min",value:function(n){return this.x=Math.min(this.x,n.x),this.y=Math.min(this.y,n.y),this.z=Math.min(this.z,n.z),this}},{key:"max",value:function(n){return this.x=Math.max(this.x,n.x),this.y=Math.max(this.y,n.y),this.z=Math.max(this.z,n.z),this}},{key:"clamp",value:function(n,e){return this.x=Math.max(n.x,Math.min(e.x,this.x)),this.y=Math.max(n.y,Math.min(e.y,this.y)),this.z=Math.max(n.z,Math.min(e.z,this.z)),this}},{key:"clampScalar",value:function(n,e){return this.x=Math.max(n,Math.min(e,this.x)),this.y=Math.max(n,Math.min(e,this.y)),this.z=Math.max(n,Math.min(e,this.z)),this}},{key:"clampLength",value:function(n,e){var t=this.length();return this.divideScalar(t||1).multiplyScalar(Math.max(n,Math.min(e,t)))}},{key:"floor",value:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}},{key:"ceil",value:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}},{key:"round",value:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}},{key:"roundToZero",value:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}},{key:"negate",value:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}},{key:"dot",value:function(n){return this.x*n.x+this.y*n.y+this.z*n.z}},{key:"lengthSq",value:function(){return this.x*this.x+this.y*this.y+this.z*this.z}},{key:"length",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}},{key:"manhattanLength",value:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}},{key:"normalize",value:function(){return this.divideScalar(this.length()||1)}},{key:"setLength",value:function(n){return this.normalize().multiplyScalar(n)}},{key:"lerp",value:function(n,e){return this.x+=(n.x-this.x)*e,this.y+=(n.y-this.y)*e,this.z+=(n.z-this.z)*e,this}},{key:"lerpVectors",value:function(n,e,t){return this.x=n.x+(e.x-n.x)*t,this.y=n.y+(e.y-n.y)*t,this.z=n.z+(e.z-n.z)*t,this}},{key:"cross",value:function(n){return this.crossVectors(this,n)}},{key:"crossVectors",value:function(n,e){var t=n.x,o=n.y,r=n.z,a=e.x,i=e.y,v=e.z;return this.x=o*v-r*i,this.y=r*a-t*v,this.z=t*i-o*a,this}},{key:"projectOnVector",value:function(n){var e=n.lengthSq();if(0===e)return this.set(0,0,0);var t=n.dot(this)/e;return this.copy(n).multiplyScalar(t)}},{key:"projectOnPlane",value:function(n){return Ao.copy(this).projectOnVector(n),this.sub(Ao)}},{key:"reflect",value:function(n){return this.sub(Ao.copy(n).multiplyScalar(2*this.dot(n)))}},{key:"angleTo",value:function(n){var e=Math.sqrt(this.lengthSq()*n.lengthSq());if(0===e)return Math.PI/2;var t=this.dot(n)/e;return Math.acos(Qt(t,-1,1))}},{key:"distanceTo",value:function(n){return Math.sqrt(this.distanceToSquared(n))}},{key:"distanceToSquared",value:function(n){var e=this.x-n.x,t=this.y-n.y,o=this.z-n.z;return e*e+t*t+o*o}},{key:"manhattanDistanceTo",value:function(n){return Math.abs(this.x-n.x)+Math.abs(this.y-n.y)+Math.abs(this.z-n.z)}},{key:"setFromSpherical",value:function(n){return this.setFromSphericalCoords(n.radius,n.phi,n.theta)}},{key:"setFromSphericalCoords",value:function(n,e,t){var o=Math.sin(e)*n;return this.x=o*Math.sin(t),this.y=Math.cos(e)*n,this.z=o*Math.cos(t),this}},{key:"setFromCylindrical",value:function(n){return this.setFromCylindricalCoords(n.radius,n.theta,n.y)}},{key:"setFromCylindricalCoords",value:function(n,e,t){return this.x=n*Math.sin(e),this.y=t,this.z=n*Math.cos(e),this}},{key:"setFromMatrixPosition",value:function(n){var e=n.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}},{key:"setFromMatrixScale",value:function(n){var e=this.setFromMatrixColumn(n,0).length(),t=this.setFromMatrixColumn(n,1).length(),o=this.setFromMatrixColumn(n,2).length();return this.x=e,this.y=t,this.z=o,this}},{key:"setFromMatrixColumn",value:function(n,e){return this.fromArray(n.elements,4*e)}},{key:"setFromMatrix3Column",value:function(n,e){return this.fromArray(n.elements,3*e)}},{key:"setFromEuler",value:function(n){return this.x=n._x,this.y=n._y,this.z=n._z,this}},{key:"equals",value:function(n){return n.x===this.x&&n.y===this.y&&n.z===this.z}},{key:"fromArray",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.x=n[e],this.y=n[e+1],this.z=n[e+2],this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this.x,n[e+1]=this.y,n[e+2]=this.z,n}},{key:"fromBufferAttribute",value:function(n,e){return this.x=n.getX(e),this.y=n.getY(e),this.z=n.getZ(e),this}},{key:"random",value:function(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}},{key:"randomDirection",value:function(){var n=2*(Math.random()-.5),e=Math.random()*Math.PI*2,t=Math.sqrt(1-Math.pow(n,2));return this.x=t*Math.cos(e),this.y=t*Math.sin(e),this.z=n,this}},{key:Symbol.iterator,value:P().mark((function n(){return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this.x;case 2:return n.next=4,this.y;case 4:return n.next=6,this.z;case 6:case"end":return n.stop()}}),n,this)}))}]),e}(),Ao=new Oo,Lo=new Eo,Go=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo(1/0,1/0,1/0),t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo(-1/0,-1/0,-1/0);g(this,n),this.isBox3=!0,this.min=e,this.max=t}return b(n,[{key:"set",value:function(n,e){return this.min.copy(n),this.max.copy(e),this}},{key:"setFromArray",value:function(n){for(var e=1/0,t=1/0,o=1/0,r=-1/0,a=-1/0,i=-1/0,v=0,c=n.length;v<c;v+=3){var s=n[v],l=n[v+1],u=n[v+2];s<e&&(e=s),l<t&&(t=l),u<o&&(o=u),s>r&&(r=s),l>a&&(a=l),u>i&&(i=u)}return this.min.set(e,t,o),this.max.set(r,a,i),this}},{key:"setFromBufferAttribute",value:function(n){for(var e=1/0,t=1/0,o=1/0,r=-1/0,a=-1/0,i=-1/0,v=0,c=n.count;v<c;v++){var s=n.getX(v),l=n.getY(v),u=n.getZ(v);s<e&&(e=s),l<t&&(t=l),u<o&&(o=u),s>r&&(r=s),l>a&&(a=l),u>i&&(i=u)}return this.min.set(e,t,o),this.max.set(r,a,i),this}},{key:"setFromPoints",value:function(n){this.makeEmpty();for(var e=0,t=n.length;e<t;e++)this.expandByPoint(n[e]);return this}},{key:"setFromCenterAndSize",value:function(n,e){var t=Bo.copy(e).multiplyScalar(.5);return this.min.copy(n).sub(t),this.max.copy(n).add(t),this}},{key:"setFromObject",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return this.makeEmpty(),this.expandByObject(n,e)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){return this.min.copy(n.min),this.max.copy(n.max),this}},{key:"makeEmpty",value:function(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}},{key:"isEmpty",value:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}},{key:"getCenter",value:function(n){return this.isEmpty()?n.set(0,0,0):n.addVectors(this.min,this.max).multiplyScalar(.5)}},{key:"getSize",value:function(n){return this.isEmpty()?n.set(0,0,0):n.subVectors(this.max,this.min)}},{key:"expandByPoint",value:function(n){return this.min.min(n),this.max.max(n),this}},{key:"expandByVector",value:function(n){return this.min.sub(n),this.max.add(n),this}},{key:"expandByScalar",value:function(n){return this.min.addScalar(-n),this.max.addScalar(n),this}},{key:"expandByObject",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];n.updateWorldMatrix(!1,!1);var t=n.geometry;if(void 0!==t)if(e&&void 0!=t.attributes&&void 0!==t.attributes.position)for(var o=t.attributes.position,r=0,a=o.count;r<a;r++)Bo.fromBufferAttribute(o,r).applyMatrix4(n.matrixWorld),this.expandByPoint(Bo);else null===t.boundingBox&&t.computeBoundingBox(),qo.copy(t.boundingBox),qo.applyMatrix4(n.matrixWorld),this.union(qo);for(var i=n.children,v=0,c=i.length;v<c;v++)this.expandByObject(i[v],e);return this}},{key:"containsPoint",value:function(n){return!(n.x<this.min.x||n.x>this.max.x||n.y<this.min.y||n.y>this.max.y||n.z<this.min.z||n.z>this.max.z)}},{key:"containsBox",value:function(n){return this.min.x<=n.min.x&&n.max.x<=this.max.x&&this.min.y<=n.min.y&&n.max.y<=this.max.y&&this.min.z<=n.min.z&&n.max.z<=this.max.z}},{key:"getParameter",value:function(n,e){return e.set((n.x-this.min.x)/(this.max.x-this.min.x),(n.y-this.min.y)/(this.max.y-this.min.y),(n.z-this.min.z)/(this.max.z-this.min.z))}},{key:"intersectsBox",value:function(n){return!(n.max.x<this.min.x||n.min.x>this.max.x||n.max.y<this.min.y||n.min.y>this.max.y||n.max.z<this.min.z||n.min.z>this.max.z)}},{key:"intersectsSphere",value:function(n){return this.clampPoint(n.center,Bo),Bo.distanceToSquared(n.center)<=n.radius*n.radius}},{key:"intersectsPlane",value:function(n){var e,t;return n.normal.x>0?(e=n.normal.x*this.min.x,t=n.normal.x*this.max.x):(e=n.normal.x*this.max.x,t=n.normal.x*this.min.x),n.normal.y>0?(e+=n.normal.y*this.min.y,t+=n.normal.y*this.max.y):(e+=n.normal.y*this.max.y,t+=n.normal.y*this.min.y),n.normal.z>0?(e+=n.normal.z*this.min.z,t+=n.normal.z*this.max.z):(e+=n.normal.z*this.max.z,t+=n.normal.z*this.min.z),e<=-n.constant&&t>=-n.constant}},{key:"intersectsTriangle",value:function(n){if(this.isEmpty())return!1;this.getCenter(Qo),Jo.subVectors(this.max,Qo),Vo.subVectors(n.a,Qo),Wo.subVectors(n.b,Qo),Ho.subVectors(n.c,Qo),Xo.subVectors(Wo,Vo),Yo.subVectors(Ho,Wo),Zo.subVectors(Vo,Ho);var e=[0,-Xo.z,Xo.y,0,-Yo.z,Yo.y,0,-Zo.z,Zo.y,Xo.z,0,-Xo.x,Yo.z,0,-Yo.x,Zo.z,0,-Zo.x,-Xo.y,Xo.x,0,-Yo.y,Yo.x,0,-Zo.y,Zo.x,0];return!!nr(e,Vo,Wo,Ho,Jo)&&(!!nr(e=[1,0,0,0,1,0,0,0,1],Vo,Wo,Ho,Jo)&&(Ko.crossVectors(Xo,Yo),nr(e=[Ko.x,Ko.y,Ko.z],Vo,Wo,Ho,Jo)))}},{key:"clampPoint",value:function(n,e){return e.copy(n).clamp(this.min,this.max)}},{key:"distanceToPoint",value:function(n){return Bo.copy(n).clamp(this.min,this.max).sub(n).length()}},{key:"getBoundingSphere",value:function(n){return this.getCenter(n.center),n.radius=.5*this.getSize(Bo).length(),n}},{key:"intersect",value:function(n){return this.min.max(n.min),this.max.min(n.max),this.isEmpty()&&this.makeEmpty(),this}},{key:"union",value:function(n){return this.min.min(n.min),this.max.max(n.max),this}},{key:"applyMatrix4",value:function(n){return this.isEmpty()||(No[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(n),No[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(n),No[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(n),No[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(n),No[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(n),No[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(n),No[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(n),No[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(n),this.setFromPoints(No)),this}},{key:"translate",value:function(n){return this.min.add(n),this.max.add(n),this}},{key:"equals",value:function(n){return n.min.equals(this.min)&&n.max.equals(this.max)}}]),n}(),No=[new Oo,new Oo,new Oo,new Oo,new Oo,new Oo,new Oo,new Oo],Bo=new Oo,qo=new Go,Vo=new Oo,Wo=new Oo,Ho=new Oo,Xo=new Oo,Yo=new Oo,Zo=new Oo,Qo=new Oo,Jo=new Oo,Ko=new Oo,$o=new Oo;function nr(n,e,t,o,r){for(var a=0,i=n.length-3;a<=i;a+=3){$o.fromArray(n,a);var v=r.x*Math.abs($o.x)+r.y*Math.abs($o.y)+r.z*Math.abs($o.z),c=e.dot($o),s=t.dot($o),l=o.dot($o);if(Math.max(-Math.max(c,s,l),Math.min(c,s,l))>v)return!1}return!0}var er=new Go,tr=new Oo,or=new Oo,rr=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;g(this,n),this.center=e,this.radius=t}return b(n,[{key:"set",value:function(n,e){return this.center.copy(n),this.radius=e,this}},{key:"setFromPoints",value:function(n,e){var t=this.center;void 0!==e?t.copy(e):er.setFromPoints(n).getCenter(t);for(var o=0,r=0,a=n.length;r<a;r++)o=Math.max(o,t.distanceToSquared(n[r]));return this.radius=Math.sqrt(o),this}},{key:"copy",value:function(n){return this.center.copy(n.center),this.radius=n.radius,this}},{key:"isEmpty",value:function(){return this.radius<0}},{key:"makeEmpty",value:function(){return this.center.set(0,0,0),this.radius=-1,this}},{key:"containsPoint",value:function(n){return n.distanceToSquared(this.center)<=this.radius*this.radius}},{key:"distanceToPoint",value:function(n){return n.distanceTo(this.center)-this.radius}},{key:"intersectsSphere",value:function(n){var e=this.radius+n.radius;return n.center.distanceToSquared(this.center)<=e*e}},{key:"intersectsBox",value:function(n){return n.intersectsSphere(this)}},{key:"intersectsPlane",value:function(n){return Math.abs(n.distanceToPoint(this.center))<=this.radius}},{key:"clampPoint",value:function(n,e){var t=this.center.distanceToSquared(n);return e.copy(n),t>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}},{key:"getBoundingBox",value:function(n){return this.isEmpty()?(n.makeEmpty(),n):(n.set(this.center,this.center),n.expandByScalar(this.radius),n)}},{key:"applyMatrix4",value:function(n){return this.center.applyMatrix4(n),this.radius=this.radius*n.getMaxScaleOnAxis(),this}},{key:"translate",value:function(n){return this.center.add(n),this}},{key:"expandByPoint",value:function(n){if(this.isEmpty())return this.center.copy(n),this.radius=0,this;tr.subVectors(n,this.center);var e=tr.lengthSq();if(e>this.radius*this.radius){var t=Math.sqrt(e),o=.5*(t-this.radius);this.center.addScaledVector(tr,o/t),this.radius+=o}return this}},{key:"union",value:function(n){return n.isEmpty()?this:this.isEmpty()?(this.copy(n),this):(!0===this.center.equals(n.center)?this.radius=Math.max(this.radius,n.radius):(or.subVectors(n.center,this.center).setLength(n.radius),this.expandByPoint(tr.copy(n.center).add(or)),this.expandByPoint(tr.copy(n.center).sub(or))),this)}},{key:"equals",value:function(n){return n.center.equals(this.center)&&n.radius===this.radius}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),ar=new Oo,ir=new Oo,vr=new Oo,cr=new Oo,sr=new Oo,lr=new Oo,ur=new Oo,fr=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo(0,0,-1);g(this,n),this.origin=e,this.direction=t}return b(n,[{key:"set",value:function(n,e){return this.origin.copy(n),this.direction.copy(e),this}},{key:"copy",value:function(n){return this.origin.copy(n.origin),this.direction.copy(n.direction),this}},{key:"at",value:function(n,e){return e.copy(this.direction).multiplyScalar(n).add(this.origin)}},{key:"lookAt",value:function(n){return this.direction.copy(n).sub(this.origin).normalize(),this}},{key:"recast",value:function(n){return this.origin.copy(this.at(n,ar)),this}},{key:"closestPointToPoint",value:function(n,e){e.subVectors(n,this.origin);var t=e.dot(this.direction);return t<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(t).add(this.origin)}},{key:"distanceToPoint",value:function(n){return Math.sqrt(this.distanceSqToPoint(n))}},{key:"distanceSqToPoint",value:function(n){var e=ar.subVectors(n,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(n):(ar.copy(this.direction).multiplyScalar(e).add(this.origin),ar.distanceToSquared(n))}},{key:"distanceSqToSegment",value:function(n,e,t,o){ir.copy(n).add(e).multiplyScalar(.5),vr.copy(e).sub(n).normalize(),cr.copy(this.origin).sub(ir);var r,a,i,v,c=.5*n.distanceTo(e),s=-this.direction.dot(vr),l=cr.dot(this.direction),u=-cr.dot(vr),f=cr.lengthSq(),p=Math.abs(1-s*s);if(p>0)if(a=s*l-u,v=c*p,(r=s*u-l)>=0)if(a>=-v)if(a<=v){var m=1/p;i=(r*=m)*(r+s*(a*=m)+2*l)+a*(s*r+a+2*u)+f}else a=c,i=-(r=Math.max(0,-(s*a+l)))*r+a*(a+2*u)+f;else a=-c,i=-(r=Math.max(0,-(s*a+l)))*r+a*(a+2*u)+f;else a<=-v?i=-(r=Math.max(0,-(-s*c+l)))*r+(a=r>0?-c:Math.min(Math.max(-c,-u),c))*(a+2*u)+f:a<=v?(r=0,i=(a=Math.min(Math.max(-c,-u),c))*(a+2*u)+f):i=-(r=Math.max(0,-(s*c+l)))*r+(a=r>0?c:Math.min(Math.max(-c,-u),c))*(a+2*u)+f;else a=s>0?-c:c,i=-(r=Math.max(0,-(s*a+l)))*r+a*(a+2*u)+f;return t&&t.copy(this.direction).multiplyScalar(r).add(this.origin),o&&o.copy(vr).multiplyScalar(a).add(ir),i}},{key:"intersectSphere",value:function(n,e){ar.subVectors(n.center,this.origin);var t=ar.dot(this.direction),o=ar.dot(ar)-t*t,r=n.radius*n.radius;if(o>r)return null;var a=Math.sqrt(r-o),i=t-a,v=t+a;return i<0&&v<0?null:i<0?this.at(v,e):this.at(i,e)}},{key:"intersectsSphere",value:function(n){return this.distanceSqToPoint(n.center)<=n.radius*n.radius}},{key:"distanceToPlane",value:function(n){var e=n.normal.dot(this.direction);if(0===e)return 0===n.distanceToPoint(this.origin)?0:null;var t=-(this.origin.dot(n.normal)+n.constant)/e;return t>=0?t:null}},{key:"intersectPlane",value:function(n,e){var t=this.distanceToPlane(n);return null===t?null:this.at(t,e)}},{key:"intersectsPlane",value:function(n){var e=n.distanceToPoint(this.origin);return 0===e||n.normal.dot(this.direction)*e<0}},{key:"intersectBox",value:function(n,e){var t,o,r,a,i,v,c=1/this.direction.x,s=1/this.direction.y,l=1/this.direction.z,u=this.origin;return c>=0?(t=(n.min.x-u.x)*c,o=(n.max.x-u.x)*c):(t=(n.max.x-u.x)*c,o=(n.min.x-u.x)*c),s>=0?(r=(n.min.y-u.y)*s,a=(n.max.y-u.y)*s):(r=(n.max.y-u.y)*s,a=(n.min.y-u.y)*s),t>a||r>o?null:((r>t||isNaN(t))&&(t=r),(a<o||isNaN(o))&&(o=a),l>=0?(i=(n.min.z-u.z)*l,v=(n.max.z-u.z)*l):(i=(n.max.z-u.z)*l,v=(n.min.z-u.z)*l),t>v||i>o?null:((i>t||t!==t)&&(t=i),(v<o||o!==o)&&(o=v),o<0?null:this.at(t>=0?t:o,e)))}},{key:"intersectsBox",value:function(n){return null!==this.intersectBox(n,ar)}},{key:"intersectTriangle",value:function(n,e,t,o,r){sr.subVectors(e,n),lr.subVectors(t,n),ur.crossVectors(sr,lr);var a,i=this.direction.dot(ur);if(i>0){if(o)return null;a=1}else{if(!(i<0))return null;a=-1,i=-i}cr.subVectors(this.origin,n);var v=a*this.direction.dot(lr.crossVectors(cr,lr));if(v<0)return null;var c=a*this.direction.dot(sr.cross(cr));if(c<0)return null;if(v+c>i)return null;var s=-a*cr.dot(ur);return s<0?null:this.at(s/i,r)}},{key:"applyMatrix4",value:function(n){return this.origin.applyMatrix4(n),this.direction.transformDirection(n),this}},{key:"equals",value:function(n){return n.origin.equals(this.origin)&&n.direction.equals(this.direction)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),pr=function(){function n(){g(this,n),n.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}return b(n,[{key:"set",value:function(n,e,t,o,r,a,i,v,c,s,l,u,f,p,m,d){var h=this.elements;return h[0]=n,h[4]=e,h[8]=t,h[12]=o,h[1]=r,h[5]=a,h[9]=i,h[13]=v,h[2]=c,h[6]=s,h[10]=l,h[14]=u,h[3]=f,h[7]=p,h[11]=m,h[15]=d,this}},{key:"identity",value:function(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}},{key:"clone",value:function(){return(new n).fromArray(this.elements)}},{key:"copy",value:function(n){var e=this.elements,t=n.elements;return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],this}},{key:"copyPosition",value:function(n){var e=this.elements,t=n.elements;return e[12]=t[12],e[13]=t[13],e[14]=t[14],this}},{key:"setFromMatrix3",value:function(n){var e=n.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}},{key:"extractBasis",value:function(n,e,t){return n.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),t.setFromMatrixColumn(this,2),this}},{key:"makeBasis",value:function(n,e,t){return this.set(n.x,e.x,t.x,0,n.y,e.y,t.y,0,n.z,e.z,t.z,0,0,0,0,1),this}},{key:"extractRotation",value:function(n){var e=this.elements,t=n.elements,o=1/mr.setFromMatrixColumn(n,0).length(),r=1/mr.setFromMatrixColumn(n,1).length(),a=1/mr.setFromMatrixColumn(n,2).length();return e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o,e[3]=0,e[4]=t[4]*r,e[5]=t[5]*r,e[6]=t[6]*r,e[7]=0,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}},{key:"makeRotationFromEuler",value:function(n){var e=this.elements,t=n.x,o=n.y,r=n.z,a=Math.cos(t),i=Math.sin(t),v=Math.cos(o),c=Math.sin(o),s=Math.cos(r),l=Math.sin(r);if("XYZ"===n.order){var u=a*s,f=a*l,p=i*s,m=i*l;e[0]=v*s,e[4]=-v*l,e[8]=c,e[1]=f+p*c,e[5]=u-m*c,e[9]=-i*v,e[2]=m-u*c,e[6]=p+f*c,e[10]=a*v}else if("YXZ"===n.order){var d=v*s,h=v*l,x=c*s,g=c*l;e[0]=d+g*i,e[4]=x*i-h,e[8]=a*c,e[1]=a*l,e[5]=a*s,e[9]=-i,e[2]=h*i-x,e[6]=g+d*i,e[10]=a*v}else if("ZXY"===n.order){var y=v*s,b=v*l,U=c*s,_=c*l;e[0]=y-_*i,e[4]=-a*l,e[8]=U+b*i,e[1]=b+U*i,e[5]=a*s,e[9]=_-y*i,e[2]=-a*c,e[6]=i,e[10]=a*v}else if("ZYX"===n.order){var w=a*s,S=a*l,M=i*s,k=i*l;e[0]=v*s,e[4]=M*c-S,e[8]=w*c+k,e[1]=v*l,e[5]=k*c+w,e[9]=S*c-M,e[2]=-c,e[6]=i*v,e[10]=a*v}else if("YZX"===n.order){var z=a*v,C=a*c,T=i*v,R=i*c;e[0]=v*s,e[4]=R-z*l,e[8]=T*l+C,e[1]=l,e[5]=a*s,e[9]=-i*s,e[2]=-c*s,e[6]=C*l+T,e[10]=z-R*l}else if("XZY"===n.order){var D=a*v,P=a*c,F=i*v,j=i*c;e[0]=v*s,e[4]=-l,e[8]=c*s,e[1]=D*l+j,e[5]=a*s,e[9]=P*l-F,e[2]=F*l-P,e[6]=i*s,e[10]=j*l+D}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}},{key:"makeRotationFromQuaternion",value:function(n){return this.compose(hr,n,xr)}},{key:"lookAt",value:function(n,e,t){var o=this.elements;return br.subVectors(n,e),0===br.lengthSq()&&(br.z=1),br.normalize(),gr.crossVectors(t,br),0===gr.lengthSq()&&(1===Math.abs(t.z)?br.x+=1e-4:br.z+=1e-4,br.normalize(),gr.crossVectors(t,br)),gr.normalize(),yr.crossVectors(br,gr),o[0]=gr.x,o[4]=yr.x,o[8]=br.x,o[1]=gr.y,o[5]=yr.y,o[9]=br.y,o[2]=gr.z,o[6]=yr.z,o[10]=br.z,this}},{key:"multiply",value:function(n){return this.multiplyMatrices(this,n)}},{key:"premultiply",value:function(n){return this.multiplyMatrices(n,this)}},{key:"multiplyMatrices",value:function(n,e){var t=n.elements,o=e.elements,r=this.elements,a=t[0],i=t[4],v=t[8],c=t[12],s=t[1],l=t[5],u=t[9],f=t[13],p=t[2],m=t[6],d=t[10],h=t[14],x=t[3],g=t[7],y=t[11],b=t[15],U=o[0],_=o[4],w=o[8],S=o[12],M=o[1],k=o[5],z=o[9],C=o[13],T=o[2],R=o[6],D=o[10],P=o[14],F=o[3],j=o[7],I=o[11],E=o[15];return r[0]=a*U+i*M+v*T+c*F,r[4]=a*_+i*k+v*R+c*j,r[8]=a*w+i*z+v*D+c*I,r[12]=a*S+i*C+v*P+c*E,r[1]=s*U+l*M+u*T+f*F,r[5]=s*_+l*k+u*R+f*j,r[9]=s*w+l*z+u*D+f*I,r[13]=s*S+l*C+u*P+f*E,r[2]=p*U+m*M+d*T+h*F,r[6]=p*_+m*k+d*R+h*j,r[10]=p*w+m*z+d*D+h*I,r[14]=p*S+m*C+d*P+h*E,r[3]=x*U+g*M+y*T+b*F,r[7]=x*_+g*k+y*R+b*j,r[11]=x*w+g*z+y*D+b*I,r[15]=x*S+g*C+y*P+b*E,this}},{key:"multiplyScalar",value:function(n){var e=this.elements;return e[0]*=n,e[4]*=n,e[8]*=n,e[12]*=n,e[1]*=n,e[5]*=n,e[9]*=n,e[13]*=n,e[2]*=n,e[6]*=n,e[10]*=n,e[14]*=n,e[3]*=n,e[7]*=n,e[11]*=n,e[15]*=n,this}},{key:"determinant",value:function(){var n=this.elements,e=n[0],t=n[4],o=n[8],r=n[12],a=n[1],i=n[5],v=n[9],c=n[13],s=n[2],l=n[6],u=n[10],f=n[14];return n[3]*(+r*v*l-o*c*l-r*i*u+t*c*u+o*i*f-t*v*f)+n[7]*(+e*v*f-e*c*u+r*a*u-o*a*f+o*c*s-r*v*s)+n[11]*(+e*c*l-e*i*f-r*a*l+t*a*f+r*i*s-t*c*s)+n[15]*(-o*i*s-e*v*l+e*i*u+o*a*l-t*a*u+t*v*s)}},{key:"transpose",value:function(){var n,e=this.elements;return n=e[1],e[1]=e[4],e[4]=n,n=e[2],e[2]=e[8],e[8]=n,n=e[6],e[6]=e[9],e[9]=n,n=e[3],e[3]=e[12],e[12]=n,n=e[7],e[7]=e[13],e[13]=n,n=e[11],e[11]=e[14],e[14]=n,this}},{key:"setPosition",value:function(n,e,t){var o=this.elements;return n.isVector3?(o[12]=n.x,o[13]=n.y,o[14]=n.z):(o[12]=n,o[13]=e,o[14]=t),this}},{key:"invert",value:function(){var n=this.elements,e=n[0],t=n[1],o=n[2],r=n[3],a=n[4],i=n[5],v=n[6],c=n[7],s=n[8],l=n[9],u=n[10],f=n[11],p=n[12],m=n[13],d=n[14],h=n[15],x=l*d*c-m*u*c+m*v*f-i*d*f-l*v*h+i*u*h,g=p*u*c-s*d*c-p*v*f+a*d*f+s*v*h-a*u*h,y=s*m*c-p*l*c+p*i*f-a*m*f-s*i*h+a*l*h,b=p*l*v-s*m*v-p*i*u+a*m*u+s*i*d-a*l*d,U=e*x+t*g+o*y+r*b;if(0===U)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);var _=1/U;return n[0]=x*_,n[1]=(m*u*r-l*d*r-m*o*f+t*d*f+l*o*h-t*u*h)*_,n[2]=(i*d*r-m*v*r+m*o*c-t*d*c-i*o*h+t*v*h)*_,n[3]=(l*v*r-i*u*r-l*o*c+t*u*c+i*o*f-t*v*f)*_,n[4]=g*_,n[5]=(s*d*r-p*u*r+p*o*f-e*d*f-s*o*h+e*u*h)*_,n[6]=(p*v*r-a*d*r-p*o*c+e*d*c+a*o*h-e*v*h)*_,n[7]=(a*u*r-s*v*r+s*o*c-e*u*c-a*o*f+e*v*f)*_,n[8]=y*_,n[9]=(p*l*r-s*m*r-p*t*f+e*m*f+s*t*h-e*l*h)*_,n[10]=(a*m*r-p*i*r+p*t*c-e*m*c-a*t*h+e*i*h)*_,n[11]=(s*i*r-a*l*r-s*t*c+e*l*c+a*t*f-e*i*f)*_,n[12]=b*_,n[13]=(s*m*o-p*l*o+p*t*u-e*m*u-s*t*d+e*l*d)*_,n[14]=(p*i*o-a*m*o-p*t*v+e*m*v+a*t*d-e*i*d)*_,n[15]=(a*l*o-s*i*o+s*t*v-e*l*v-a*t*u+e*i*u)*_,this}},{key:"scale",value:function(n){var e=this.elements,t=n.x,o=n.y,r=n.z;return e[0]*=t,e[4]*=o,e[8]*=r,e[1]*=t,e[5]*=o,e[9]*=r,e[2]*=t,e[6]*=o,e[10]*=r,e[3]*=t,e[7]*=o,e[11]*=r,this}},{key:"getMaxScaleOnAxis",value:function(){var n=this.elements,e=n[0]*n[0]+n[1]*n[1]+n[2]*n[2],t=n[4]*n[4]+n[5]*n[5]+n[6]*n[6],o=n[8]*n[8]+n[9]*n[9]+n[10]*n[10];return Math.sqrt(Math.max(e,t,o))}},{key:"makeTranslation",value:function(n,e,t){return this.set(1,0,0,n,0,1,0,e,0,0,1,t,0,0,0,1),this}},{key:"makeRotationX",value:function(n){var e=Math.cos(n),t=Math.sin(n);return this.set(1,0,0,0,0,e,-t,0,0,t,e,0,0,0,0,1),this}},{key:"makeRotationY",value:function(n){var e=Math.cos(n),t=Math.sin(n);return this.set(e,0,t,0,0,1,0,0,-t,0,e,0,0,0,0,1),this}},{key:"makeRotationZ",value:function(n){var e=Math.cos(n),t=Math.sin(n);return this.set(e,-t,0,0,t,e,0,0,0,0,1,0,0,0,0,1),this}},{key:"makeRotationAxis",value:function(n,e){var t=Math.cos(e),o=Math.sin(e),r=1-t,a=n.x,i=n.y,v=n.z,c=r*a,s=r*i;return this.set(c*a+t,c*i-o*v,c*v+o*i,0,c*i+o*v,s*i+t,s*v-o*a,0,c*v-o*i,s*v+o*a,r*v*v+t,0,0,0,0,1),this}},{key:"makeScale",value:function(n,e,t){return this.set(n,0,0,0,0,e,0,0,0,0,t,0,0,0,0,1),this}},{key:"makeShear",value:function(n,e,t,o,r,a){return this.set(1,t,r,0,n,1,a,0,e,o,1,0,0,0,0,1),this}},{key:"compose",value:function(n,e,t){var o=this.elements,r=e._x,a=e._y,i=e._z,v=e._w,c=r+r,s=a+a,l=i+i,u=r*c,f=r*s,p=r*l,m=a*s,d=a*l,h=i*l,x=v*c,g=v*s,y=v*l,b=t.x,U=t.y,_=t.z;return o[0]=(1-(m+h))*b,o[1]=(f+y)*b,o[2]=(p-g)*b,o[3]=0,o[4]=(f-y)*U,o[5]=(1-(u+h))*U,o[6]=(d+x)*U,o[7]=0,o[8]=(p+g)*_,o[9]=(d-x)*_,o[10]=(1-(u+m))*_,o[11]=0,o[12]=n.x,o[13]=n.y,o[14]=n.z,o[15]=1,this}},{key:"decompose",value:function(n,e,t){var o=this.elements,r=mr.set(o[0],o[1],o[2]).length(),a=mr.set(o[4],o[5],o[6]).length(),i=mr.set(o[8],o[9],o[10]).length();this.determinant()<0&&(r=-r),n.x=o[12],n.y=o[13],n.z=o[14],dr.copy(this);var v=1/r,c=1/a,s=1/i;return dr.elements[0]*=v,dr.elements[1]*=v,dr.elements[2]*=v,dr.elements[4]*=c,dr.elements[5]*=c,dr.elements[6]*=c,dr.elements[8]*=s,dr.elements[9]*=s,dr.elements[10]*=s,e.setFromRotationMatrix(dr),t.x=r,t.y=a,t.z=i,this}},{key:"makePerspective",value:function(n,e,t,o,r,a){var i=this.elements,v=2*r/(e-n),c=2*r/(t-o),s=(e+n)/(e-n),l=(t+o)/(t-o),u=-(a+r)/(a-r),f=-2*a*r/(a-r);return i[0]=v,i[4]=0,i[8]=s,i[12]=0,i[1]=0,i[5]=c,i[9]=l,i[13]=0,i[2]=0,i[6]=0,i[10]=u,i[14]=f,i[3]=0,i[7]=0,i[11]=-1,i[15]=0,this}},{key:"makeOrthographic",value:function(n,e,t,o,r,a){var i=this.elements,v=1/(e-n),c=1/(t-o),s=1/(a-r),l=(e+n)*v,u=(t+o)*c,f=(a+r)*s;return i[0]=2*v,i[4]=0,i[8]=0,i[12]=-l,i[1]=0,i[5]=2*c,i[9]=0,i[13]=-u,i[2]=0,i[6]=0,i[10]=-2*s,i[14]=-f,i[3]=0,i[7]=0,i[11]=0,i[15]=1,this}},{key:"equals",value:function(n){for(var e=this.elements,t=n.elements,o=0;o<16;o++)if(e[o]!==t[o])return!1;return!0}},{key:"fromArray",value:function(n){for(var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=0;t<16;t++)this.elements[t]=n[t+e];return this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=this.elements;return n[e]=t[0],n[e+1]=t[1],n[e+2]=t[2],n[e+3]=t[3],n[e+4]=t[4],n[e+5]=t[5],n[e+6]=t[6],n[e+7]=t[7],n[e+8]=t[8],n[e+9]=t[9],n[e+10]=t[10],n[e+11]=t[11],n[e+12]=t[12],n[e+13]=t[13],n[e+14]=t[14],n[e+15]=t[15],n}}]),n}(),mr=new Oo,dr=new pr,hr=new Oo(0,0,0),xr=new Oo(1,1,1),gr=new Oo,yr=new Oo,br=new Oo,Ur=new pr,_r=new Eo,wr=function(n){function e(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.DefaultOrder;g(this,e),this.isEuler=!0,this._x=n,this._y=t,this._z=o,this._order=r}return b(e,[{key:"x",get:function(){return this._x},set:function(n){this._x=n,this._onChangeCallback()}},{key:"y",get:function(){return this._y},set:function(n){this._y=n,this._onChangeCallback()}},{key:"z",get:function(){return this._z},set:function(n){this._z=n,this._onChangeCallback()}},{key:"order",get:function(){return this._order},set:function(n){this._order=n,this._onChangeCallback()}},{key:"set",value:function(n,e,t){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this._order;return this._x=n,this._y=e,this._z=t,this._order=o,this._onChangeCallback(),this}},{key:"clone",value:function(){return new this.constructor(this._x,this._y,this._z,this._order)}},{key:"copy",value:function(n){return this._x=n._x,this._y=n._y,this._z=n._z,this._order=n._order,this._onChangeCallback(),this}},{key:"setFromRotationMatrix",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this._order,t=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],o=n.elements,r=o[0],a=o[4],i=o[8],v=o[1],c=o[5],s=o[9],l=o[2],u=o[6],f=o[10];switch(e){case"XYZ":this._y=Math.asin(Qt(i,-1,1)),Math.abs(i)<.9999999?(this._x=Math.atan2(-s,f),this._z=Math.atan2(-a,r)):(this._x=Math.atan2(u,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Qt(s,-1,1)),Math.abs(s)<.9999999?(this._y=Math.atan2(i,f),this._z=Math.atan2(v,c)):(this._y=Math.atan2(-l,r),this._z=0);break;case"ZXY":this._x=Math.asin(Qt(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-l,f),this._z=Math.atan2(-a,c)):(this._y=0,this._z=Math.atan2(v,r));break;case"ZYX":this._y=Math.asin(-Qt(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(u,f),this._z=Math.atan2(v,r)):(this._x=0,this._z=Math.atan2(-a,c));break;case"YZX":this._z=Math.asin(Qt(v,-1,1)),Math.abs(v)<.9999999?(this._x=Math.atan2(-s,c),this._y=Math.atan2(-l,r)):(this._x=0,this._y=Math.atan2(i,f));break;case"XZY":this._z=Math.asin(-Qt(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(u,c),this._y=Math.atan2(i,r)):(this._x=Math.atan2(-s,f),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,!0===t&&this._onChangeCallback(),this}},{key:"setFromQuaternion",value:function(n,e,t){return Ur.makeRotationFromQuaternion(n),this.setFromRotationMatrix(Ur,e,t)}},{key:"setFromVector3",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this._order;return this.set(n.x,n.y,n.z,e)}},{key:"reorder",value:function(n){return _r.setFromEuler(this),this.setFromQuaternion(_r,n)}},{key:"equals",value:function(n){return n._x===this._x&&n._y===this._y&&n._z===this._z&&n._order===this._order}},{key:"fromArray",value:function(n){return this._x=n[0],this._y=n[1],this._z=n[2],void 0!==n[3]&&(this._order=n[3]),this._onChangeCallback(),this}},{key:"toArray",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[e]=this._x,n[e+1]=this._y,n[e+2]=this._z,n[e+3]=this._order,n}},{key:"_onChange",value:function(n){return this._onChangeCallback=n,this}},{key:"_onChangeCallback",value:function(){}},{key:Symbol.iterator,value:P().mark((function n(){return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this._x;case 2:return n.next=4,this._y;case 4:return n.next=6,this._z;case 6:return n.next=8,this._order;case 8:case"end":return n.stop()}}),n,this)}))},{key:"toVector3",value:function(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}]),e}();wr.DefaultOrder="XYZ",wr.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];var Sr=function(){function n(){g(this,n),this.mask=1}return b(n,[{key:"set",value:function(n){this.mask=(1<<n|0)>>>0}},{key:"enable",value:function(n){this.mask|=1<<n|0}},{key:"enableAll",value:function(){this.mask=-1}},{key:"toggle",value:function(n){this.mask^=1<<n|0}},{key:"disable",value:function(n){this.mask&=~(1<<n|0)}},{key:"disableAll",value:function(){this.mask=0}},{key:"test",value:function(n){return 0!==(this.mask&n.mask)}},{key:"isEnabled",value:function(n){return 0!==(this.mask&(1<<n|0))}}]),n}(),Mr=0,kr=new Oo,zr=new Eo,Cr=new pr,Tr=new Oo,Rr=new Oo,Dr=new Oo,Pr=new Eo,Fr=new Oo(1,0,0),jr=new Oo(0,1,0),Ir=new Oo(0,0,1),Er={type:"added"},Or={type:"removed"},Ar=function(n){U(t,n);var e=k(t);function t(){var n;g(this,t),(n=e.call(this)).isObject3D=!0,Object.defineProperty(S(n),"id",{value:Mr++}),n.uuid=Zt(),n.name="",n.type="Object3D",n.parent=null,n.children=[],n.up=t.DefaultUp.clone();var o=new Oo,r=new wr,a=new Eo,i=new Oo(1,1,1);return r._onChange((function(){a.setFromEuler(r,!1)})),a._onChange((function(){r.setFromQuaternion(a,void 0,!1)})),Object.defineProperties(S(n),{position:{configurable:!0,enumerable:!0,value:o},rotation:{configurable:!0,enumerable:!0,value:r},quaternion:{configurable:!0,enumerable:!0,value:a},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new pr},normalMatrix:{value:new io}}),n.matrix=new pr,n.matrixWorld=new pr,n.matrixAutoUpdate=t.DefaultMatrixAutoUpdate,n.matrixWorldNeedsUpdate=!1,n.matrixWorldAutoUpdate=t.DefaultMatrixWorldAutoUpdate,n.layers=new Sr,n.visible=!0,n.castShadow=!1,n.receiveShadow=!1,n.frustumCulled=!0,n.renderOrder=0,n.animations=[],n.userData={},n}return b(t,[{key:"onBeforeRender",value:function(){}},{key:"onAfterRender",value:function(){}},{key:"applyMatrix4",value:function(n){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(n),this.matrix.decompose(this.position,this.quaternion,this.scale)}},{key:"applyQuaternion",value:function(n){return this.quaternion.premultiply(n),this}},{key:"setRotationFromAxisAngle",value:function(n,e){this.quaternion.setFromAxisAngle(n,e)}},{key:"setRotationFromEuler",value:function(n){this.quaternion.setFromEuler(n,!0)}},{key:"setRotationFromMatrix",value:function(n){this.quaternion.setFromRotationMatrix(n)}},{key:"setRotationFromQuaternion",value:function(n){this.quaternion.copy(n)}},{key:"rotateOnAxis",value:function(n,e){return zr.setFromAxisAngle(n,e),this.quaternion.multiply(zr),this}},{key:"rotateOnWorldAxis",value:function(n,e){return zr.setFromAxisAngle(n,e),this.quaternion.premultiply(zr),this}},{key:"rotateX",value:function(n){return this.rotateOnAxis(Fr,n)}},{key:"rotateY",value:function(n){return this.rotateOnAxis(jr,n)}},{key:"rotateZ",value:function(n){return this.rotateOnAxis(Ir,n)}},{key:"translateOnAxis",value:function(n,e){return kr.copy(n).applyQuaternion(this.quaternion),this.position.add(kr.multiplyScalar(e)),this}},{key:"translateX",value:function(n){return this.translateOnAxis(Fr,n)}},{key:"translateY",value:function(n){return this.translateOnAxis(jr,n)}},{key:"translateZ",value:function(n){return this.translateOnAxis(Ir,n)}},{key:"localToWorld",value:function(n){return n.applyMatrix4(this.matrixWorld)}},{key:"worldToLocal",value:function(n){return n.applyMatrix4(Cr.copy(this.matrixWorld).invert())}},{key:"lookAt",value:function(n,e,t){n.isVector3?Tr.copy(n):Tr.set(n,e,t);var o=this.parent;this.updateWorldMatrix(!0,!1),Rr.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Cr.lookAt(Rr,Tr,this.up):Cr.lookAt(Tr,Rr,this.up),this.quaternion.setFromRotationMatrix(Cr),o&&(Cr.extractRotation(o.matrixWorld),zr.setFromRotationMatrix(Cr),this.quaternion.premultiply(zr.invert()))}},{key:"add",value:function(n){if(arguments.length>1){for(var e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return n===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",n),this):(n&&n.isObject3D?(null!==n.parent&&n.parent.remove(n),n.parent=this,this.children.push(n),n.dispatchEvent(Er)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",n),this)}},{key:"remove",value:function(n){if(arguments.length>1){for(var e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}var t=this.children.indexOf(n);return-1!==t&&(n.parent=null,this.children.splice(t,1),n.dispatchEvent(Or)),this}},{key:"removeFromParent",value:function(){var n=this.parent;return null!==n&&n.remove(this),this}},{key:"clear",value:function(){for(var n=0;n<this.children.length;n++){var e=this.children[n];e.parent=null,e.dispatchEvent(Or)}return this.children.length=0,this}},{key:"attach",value:function(n){return this.updateWorldMatrix(!0,!1),Cr.copy(this.matrixWorld).invert(),null!==n.parent&&(n.parent.updateWorldMatrix(!0,!1),Cr.multiply(n.parent.matrixWorld)),n.applyMatrix4(Cr),this.add(n),n.updateWorldMatrix(!1,!0),this}},{key:"getObjectById",value:function(n){return this.getObjectByProperty("id",n)}},{key:"getObjectByName",value:function(n){return this.getObjectByProperty("name",n)}},{key:"getObjectByProperty",value:function(n,e){if(this[n]===e)return this;for(var t=0,o=this.children.length;t<o;t++){var r=this.children[t].getObjectByProperty(n,e);if(void 0!==r)return r}}},{key:"getWorldPosition",value:function(n){return this.updateWorldMatrix(!0,!1),n.setFromMatrixPosition(this.matrixWorld)}},{key:"getWorldQuaternion",value:function(n){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Rr,n,Dr),n}},{key:"getWorldScale",value:function(n){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Rr,Pr,n),n}},{key:"getWorldDirection",value:function(n){this.updateWorldMatrix(!0,!1);var e=this.matrixWorld.elements;return n.set(e[8],e[9],e[10]).normalize()}},{key:"raycast",value:function(){}},{key:"traverse",value:function(n){n(this);for(var e=this.children,t=0,o=e.length;t<o;t++)e[t].traverse(n)}},{key:"traverseVisible",value:function(n){if(!1!==this.visible){n(this);for(var e=this.children,t=0,o=e.length;t<o;t++)e[t].traverseVisible(n)}}},{key:"traverseAncestors",value:function(n){var e=this.parent;null!==e&&(n(e),e.traverseAncestors(n))}},{key:"updateMatrix",value:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}},{key:"updateMatrixWorld",value:function(n){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||n)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,n=!0);for(var e=this.children,t=0,o=e.length;t<o;t++){var r=e[t];!0!==r.matrixWorldAutoUpdate&&!0!==n||r.updateMatrixWorld(n)}}},{key:"updateWorldMatrix",value:function(n,e){var t=this.parent;if(!0===n&&null!==t&&!0===t.matrixWorldAutoUpdate&&t.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===e)for(var o=this.children,r=0,a=o.length;r<a;r++){var i=o[r];!0===i.matrixWorldAutoUpdate&&i.updateWorldMatrix(!1,!0)}}},{key:"toJSON",value:function(n){var e=void 0===n||"string"===typeof n,t={};e&&(n={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},t.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});var o={};function r(e,t){return void 0===e[t.uuid]&&(e[t.uuid]=t.toJSON(n)),t.uuid}if(o.uuid=this.uuid,o.type=this.type,""!==this.name&&(o.name=this.name),!0===this.castShadow&&(o.castShadow=!0),!0===this.receiveShadow&&(o.receiveShadow=!0),!1===this.visible&&(o.visible=!1),!1===this.frustumCulled&&(o.frustumCulled=!1),0!==this.renderOrder&&(o.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(o.userData=this.userData),o.layers=this.layers.mask,o.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(o.matrixAutoUpdate=!1),this.isInstancedMesh&&(o.type="InstancedMesh",o.count=this.count,o.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(o.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?o.background=this.background.toJSON():this.background.isTexture&&(o.background=this.background.toJSON(n).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(o.environment=this.environment.toJSON(n).uuid);else if(this.isMesh||this.isLine||this.isPoints){o.geometry=r(n.geometries,this.geometry);var a=this.geometry.parameters;if(void 0!==a&&void 0!==a.shapes){var i=a.shapes;if(Array.isArray(i))for(var v=0,c=i.length;v<c;v++){var s=i[v];r(n.shapes,s)}else r(n.shapes,i)}}if(this.isSkinnedMesh&&(o.bindMode=this.bindMode,o.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(r(n.skeletons,this.skeleton),o.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){for(var l=[],u=0,f=this.material.length;u<f;u++)l.push(r(n.materials,this.material[u]));o.material=l}else o.material=r(n.materials,this.material);if(this.children.length>0){o.children=[];for(var p=0;p<this.children.length;p++)o.children.push(this.children[p].toJSON(n).object)}if(this.animations.length>0){o.animations=[];for(var m=0;m<this.animations.length;m++){var d=this.animations[m];o.animations.push(r(n.animations,d))}}if(e){var h=S(n.geometries),x=S(n.materials),g=S(n.textures),y=S(n.images),b=S(n.shapes),U=S(n.skeletons),_=S(n.animations),w=S(n.nodes);h.length>0&&(t.geometries=h),x.length>0&&(t.materials=x),g.length>0&&(t.textures=g),y.length>0&&(t.images=y),b.length>0&&(t.shapes=b),U.length>0&&(t.skeletons=U),_.length>0&&(t.animations=_),w.length>0&&(t.nodes=w)}return t.object=o,t;function S(n){var e=[];for(var t in n){var o=n[t];delete o.metadata,e.push(o)}return e}}},{key:"clone",value:function(n){return(new this.constructor).copy(this,n)}},{key:"copy",value:function(n){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(this.name=n.name,this.up.copy(n.up),this.position.copy(n.position),this.rotation.order=n.rotation.order,this.quaternion.copy(n.quaternion),this.scale.copy(n.scale),this.matrix.copy(n.matrix),this.matrixWorld.copy(n.matrixWorld),this.matrixAutoUpdate=n.matrixAutoUpdate,this.matrixWorldNeedsUpdate=n.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=n.matrixWorldAutoUpdate,this.layers.mask=n.layers.mask,this.visible=n.visible,this.castShadow=n.castShadow,this.receiveShadow=n.receiveShadow,this.frustumCulled=n.frustumCulled,this.renderOrder=n.renderOrder,this.userData=JSON.parse(JSON.stringify(n.userData)),!0===e)for(var t=0;t<n.children.length;t++){var o=n.children[t];this.add(o.clone())}return this}}]),t}(Vt);Ar.DefaultUp=new Oo(0,1,0),Ar.DefaultMatrixAutoUpdate=!0,Ar.DefaultMatrixWorldAutoUpdate=!0;var Lr=new Oo,Gr=new Oo,Nr=new Oo,Br=new Oo,qr=new Oo,Vr=new Oo,Wr=new Oo,Hr=new Oo,Xr=new Oo,Yr=new Oo,Zr=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Oo;g(this,n),this.a=e,this.b=t,this.c=o}return b(n,[{key:"set",value:function(n,e,t){return this.a.copy(n),this.b.copy(e),this.c.copy(t),this}},{key:"setFromPointsAndIndices",value:function(n,e,t,o){return this.a.copy(n[e]),this.b.copy(n[t]),this.c.copy(n[o]),this}},{key:"setFromAttributeAndIndices",value:function(n,e,t,o){return this.a.fromBufferAttribute(n,e),this.b.fromBufferAttribute(n,t),this.c.fromBufferAttribute(n,o),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){return this.a.copy(n.a),this.b.copy(n.b),this.c.copy(n.c),this}},{key:"getArea",value:function(){return Lr.subVectors(this.c,this.b),Gr.subVectors(this.a,this.b),.5*Lr.cross(Gr).length()}},{key:"getMidpoint",value:function(n){return n.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}},{key:"getNormal",value:function(e){return n.getNormal(this.a,this.b,this.c,e)}},{key:"getPlane",value:function(n){return n.setFromCoplanarPoints(this.a,this.b,this.c)}},{key:"getBarycoord",value:function(e,t){return n.getBarycoord(e,this.a,this.b,this.c,t)}},{key:"getUV",value:function(e,t,o,r,a){return n.getUV(e,this.a,this.b,this.c,t,o,r,a)}},{key:"containsPoint",value:function(e){return n.containsPoint(e,this.a,this.b,this.c)}},{key:"isFrontFacing",value:function(e){return n.isFrontFacing(this.a,this.b,this.c,e)}},{key:"intersectsBox",value:function(n){return n.intersectsTriangle(this)}},{key:"closestPointToPoint",value:function(n,e){var t,o,r=this.a,a=this.b,i=this.c;qr.subVectors(a,r),Vr.subVectors(i,r),Hr.subVectors(n,r);var v=qr.dot(Hr),c=Vr.dot(Hr);if(v<=0&&c<=0)return e.copy(r);Xr.subVectors(n,a);var s=qr.dot(Xr),l=Vr.dot(Xr);if(s>=0&&l<=s)return e.copy(a);var u=v*l-s*c;if(u<=0&&v>=0&&s<=0)return t=v/(v-s),e.copy(r).addScaledVector(qr,t);Yr.subVectors(n,i);var f=qr.dot(Yr),p=Vr.dot(Yr);if(p>=0&&f<=p)return e.copy(i);var m=f*c-v*p;if(m<=0&&c>=0&&p<=0)return o=c/(c-p),e.copy(r).addScaledVector(Vr,o);var d=s*p-f*l;if(d<=0&&l-s>=0&&f-p>=0)return Wr.subVectors(i,a),o=(l-s)/(l-s+(f-p)),e.copy(a).addScaledVector(Wr,o);var h=1/(d+m+u);return t=m*h,o=u*h,e.copy(r).addScaledVector(qr,t).addScaledVector(Vr,o)}},{key:"equals",value:function(n){return n.a.equals(this.a)&&n.b.equals(this.b)&&n.c.equals(this.c)}}],[{key:"getNormal",value:function(n,e,t,o){o.subVectors(t,e),Lr.subVectors(n,e),o.cross(Lr);var r=o.lengthSq();return r>0?o.multiplyScalar(1/Math.sqrt(r)):o.set(0,0,0)}},{key:"getBarycoord",value:function(n,e,t,o,r){Lr.subVectors(o,e),Gr.subVectors(t,e),Nr.subVectors(n,e);var a=Lr.dot(Lr),i=Lr.dot(Gr),v=Lr.dot(Nr),c=Gr.dot(Gr),s=Gr.dot(Nr),l=a*c-i*i;if(0===l)return r.set(-2,-1,-1);var u=1/l,f=(c*v-i*s)*u,p=(a*s-i*v)*u;return r.set(1-f-p,p,f)}},{key:"containsPoint",value:function(n,e,t,o){return this.getBarycoord(n,e,t,o,Br),Br.x>=0&&Br.y>=0&&Br.x+Br.y<=1}},{key:"getUV",value:function(n,e,t,o,r,a,i,v){return this.getBarycoord(n,e,t,o,Br),v.set(0,0),v.addScaledVector(r,Br.x),v.addScaledVector(a,Br.y),v.addScaledVector(i,Br.z),v}},{key:"isFrontFacing",value:function(n,e,t,o){return Lr.subVectors(t,e),Gr.subVectors(n,e),Lr.cross(Gr).dot(o)<0}}]),n}(),Qr=0,Jr=function(n){U(t,n);var e=k(t);function t(){var n;return g(this,t),(n=e.call(this)).isMaterial=!0,Object.defineProperty(S(n),"id",{value:Qr++}),n.uuid=Zt(),n.name="",n.type="Material",n.blending=Y,n.side=V,n.vertexColors=!1,n.opacity=1,n.transparent=!1,n.blendSrc=sn,n.blendDst=ln,n.blendEquation=$,n.blendSrcAlpha=null,n.blendDstAlpha=null,n.blendEquationAlpha=null,n.depthFunc=yn,n.depthTest=!0,n.depthWrite=!0,n.stencilWriteMask=255,n.stencilFunc=Dt,n.stencilRef=0,n.stencilFuncMask=255,n.stencilFail=xt,n.stencilZFail=xt,n.stencilZPass=xt,n.stencilWrite=!1,n.clippingPlanes=null,n.clipIntersection=!1,n.clipShadows=!1,n.shadowSide=null,n.colorWrite=!0,n.precision=null,n.polygonOffset=!1,n.polygonOffsetFactor=0,n.polygonOffsetUnits=0,n.dithering=!1,n.alphaToCoverage=!1,n.premultipliedAlpha=!1,n.visible=!0,n.toneMapped=!0,n.userData={},n.version=0,n._alphaTest=0,n}return b(t,[{key:"alphaTest",get:function(){return this._alphaTest},set:function(n){this._alphaTest>0!==n>0&&this.version++,this._alphaTest=n}},{key:"onBuild",value:function(){}},{key:"onBeforeRender",value:function(){}},{key:"onBeforeCompile",value:function(){}},{key:"customProgramCacheKey",value:function(){return this.onBeforeCompile.toString()}},{key:"setValues",value:function(n){if(void 0!==n)for(var e in n){var t=n[e];if(void 0!==t){var o=this[e];void 0!==o?o&&o.isColor?o.set(t):o&&o.isVector3&&t&&t.isVector3?o.copy(t):this[e]=t:console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.")}else console.warn("THREE.Material: '"+e+"' parameter is undefined.")}}},{key:"toJSON",value:function(n){var e=void 0===n||"string"===typeof n;e&&(n={textures:{},images:{}});var t={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function o(n){var e=[];for(var t in n){var o=n[t];delete o.metadata,e.push(o)}return e}if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),this.color&&this.color.isColor&&(t.color=this.color.getHex()),void 0!==this.roughness&&(t.roughness=this.roughness),void 0!==this.metalness&&(t.metalness=this.metalness),void 0!==this.sheen&&(t.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(t.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(t.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(t.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(t.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(t.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(t.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(t.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(t.shininess=this.shininess),void 0!==this.clearcoat&&(t.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(t.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(t.clearcoatMap=this.clearcoatMap.toJSON(n).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(t.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(n).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(t.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(n).uuid,t.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.iridescence&&(t.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(t.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(t.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(t.iridescenceMap=this.iridescenceMap.toJSON(n).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(t.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(n).uuid),this.map&&this.map.isTexture&&(t.map=this.map.toJSON(n).uuid),this.matcap&&this.matcap.isTexture&&(t.matcap=this.matcap.toJSON(n).uuid),this.alphaMap&&this.alphaMap.isTexture&&(t.alphaMap=this.alphaMap.toJSON(n).uuid),this.lightMap&&this.lightMap.isTexture&&(t.lightMap=this.lightMap.toJSON(n).uuid,t.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(t.aoMap=this.aoMap.toJSON(n).uuid,t.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(t.bumpMap=this.bumpMap.toJSON(n).uuid,t.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(t.normalMap=this.normalMap.toJSON(n).uuid,t.normalMapType=this.normalMapType,t.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(t.displacementMap=this.displacementMap.toJSON(n).uuid,t.displacementScale=this.displacementScale,t.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(t.roughnessMap=this.roughnessMap.toJSON(n).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(t.metalnessMap=this.metalnessMap.toJSON(n).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(t.emissiveMap=this.emissiveMap.toJSON(n).uuid),this.specularMap&&this.specularMap.isTexture&&(t.specularMap=this.specularMap.toJSON(n).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(t.specularIntensityMap=this.specularIntensityMap.toJSON(n).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(t.specularColorMap=this.specularColorMap.toJSON(n).uuid),this.envMap&&this.envMap.isTexture&&(t.envMap=this.envMap.toJSON(n).uuid,void 0!==this.combine&&(t.combine=this.combine)),void 0!==this.envMapIntensity&&(t.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(t.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(t.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(t.gradientMap=this.gradientMap.toJSON(n).uuid),void 0!==this.transmission&&(t.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(t.transmissionMap=this.transmissionMap.toJSON(n).uuid),void 0!==this.thickness&&(t.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(t.thicknessMap=this.thicknessMap.toJSON(n).uuid),void 0!==this.attenuationDistance&&this.attenuationDistance!==1/0&&(t.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(t.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(t.size=this.size),null!==this.shadowSide&&(t.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(t.sizeAttenuation=this.sizeAttenuation),this.blending!==Y&&(t.blending=this.blending),this.side!==V&&(t.side=this.side),this.vertexColors&&(t.vertexColors=!0),this.opacity<1&&(t.opacity=this.opacity),!0===this.transparent&&(t.transparent=this.transparent),t.depthFunc=this.depthFunc,t.depthTest=this.depthTest,t.depthWrite=this.depthWrite,t.colorWrite=this.colorWrite,t.stencilWrite=this.stencilWrite,t.stencilWriteMask=this.stencilWriteMask,t.stencilFunc=this.stencilFunc,t.stencilRef=this.stencilRef,t.stencilFuncMask=this.stencilFuncMask,t.stencilFail=this.stencilFail,t.stencilZFail=this.stencilZFail,t.stencilZPass=this.stencilZPass,void 0!==this.rotation&&0!==this.rotation&&(t.rotation=this.rotation),!0===this.polygonOffset&&(t.polygonOffset=!0),0!==this.polygonOffsetFactor&&(t.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(t.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(t.linewidth=this.linewidth),void 0!==this.dashSize&&(t.dashSize=this.dashSize),void 0!==this.gapSize&&(t.gapSize=this.gapSize),void 0!==this.scale&&(t.scale=this.scale),!0===this.dithering&&(t.dithering=!0),this.alphaTest>0&&(t.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(t.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(t.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(t.wireframe=this.wireframe),this.wireframeLinewidth>1&&(t.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(t.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(t.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(t.flatShading=this.flatShading),!1===this.visible&&(t.visible=!1),!1===this.toneMapped&&(t.toneMapped=!1),!1===this.fog&&(t.fog=!1),"{}"!==JSON.stringify(this.userData)&&(t.userData=this.userData),e){var r=o(n.textures),a=o(n.images);r.length>0&&(t.textures=r),a.length>0&&(t.images=a)}return t}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){this.name=n.name,this.blending=n.blending,this.side=n.side,this.vertexColors=n.vertexColors,this.opacity=n.opacity,this.transparent=n.transparent,this.blendSrc=n.blendSrc,this.blendDst=n.blendDst,this.blendEquation=n.blendEquation,this.blendSrcAlpha=n.blendSrcAlpha,this.blendDstAlpha=n.blendDstAlpha,this.blendEquationAlpha=n.blendEquationAlpha,this.depthFunc=n.depthFunc,this.depthTest=n.depthTest,this.depthWrite=n.depthWrite,this.stencilWriteMask=n.stencilWriteMask,this.stencilFunc=n.stencilFunc,this.stencilRef=n.stencilRef,this.stencilFuncMask=n.stencilFuncMask,this.stencilFail=n.stencilFail,this.stencilZFail=n.stencilZFail,this.stencilZPass=n.stencilZPass,this.stencilWrite=n.stencilWrite;var e=n.clippingPlanes,t=null;if(null!==e){var o=e.length;t=new Array(o);for(var r=0;r!==o;++r)t[r]=e[r].clone()}return this.clippingPlanes=t,this.clipIntersection=n.clipIntersection,this.clipShadows=n.clipShadows,this.shadowSide=n.shadowSide,this.colorWrite=n.colorWrite,this.precision=n.precision,this.polygonOffset=n.polygonOffset,this.polygonOffsetFactor=n.polygonOffsetFactor,this.polygonOffsetUnits=n.polygonOffsetUnits,this.dithering=n.dithering,this.alphaTest=n.alphaTest,this.alphaToCoverage=n.alphaToCoverage,this.premultipliedAlpha=n.premultipliedAlpha,this.visible=n.visible,this.toneMapped=n.toneMapped,this.userData=JSON.parse(JSON.stringify(n.userData)),this}},{key:"dispose",value:function(){this.dispatchEvent({type:"dispose"})}},{key:"needsUpdate",set:function(n){!0===n&&this.version++}}]),t}(Vt),Kr=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).isMeshBasicMaterial=!0,o.type="MeshBasicMaterial",o.color=new wo(16777215),o.map=null,o.lightMap=null,o.lightMapIntensity=1,o.aoMap=null,o.aoMapIntensity=1,o.specularMap=null,o.alphaMap=null,o.envMap=null,o.combine=Sn,o.reflectivity=1,o.refractionRatio=.98,o.wireframe=!1,o.wireframeLinewidth=1,o.wireframeLinecap="round",o.wireframeLinejoin="round",o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.fog=n.fog,this}}]),t}(Jr),$r=new Oo,na=new ao,ea=function(){function n(e,t,o){if(g(this,n),Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=void 0!==e?e.length/t:0,this.normalized=!0===o,this.usage=Pt,this.updateRange={offset:0,count:-1},this.version=0}return b(n,[{key:"onUploadCallback",value:function(){}},{key:"needsUpdate",set:function(n){!0===n&&this.version++}},{key:"setUsage",value:function(n){return this.usage=n,this}},{key:"copy",value:function(n){return this.name=n.name,this.array=new n.array.constructor(n.array),this.itemSize=n.itemSize,this.count=n.count,this.normalized=n.normalized,this.usage=n.usage,this}},{key:"copyAt",value:function(n,e,t){n*=this.itemSize,t*=e.itemSize;for(var o=0,r=this.itemSize;o<r;o++)this.array[n+o]=e.array[t+o];return this}},{key:"copyArray",value:function(n){return this.array.set(n),this}},{key:"applyMatrix3",value:function(n){if(2===this.itemSize)for(var e=0,t=this.count;e<t;e++)na.fromBufferAttribute(this,e),na.applyMatrix3(n),this.setXY(e,na.x,na.y);else if(3===this.itemSize)for(var o=0,r=this.count;o<r;o++)$r.fromBufferAttribute(this,o),$r.applyMatrix3(n),this.setXYZ(o,$r.x,$r.y,$r.z);return this}},{key:"applyMatrix4",value:function(n){for(var e=0,t=this.count;e<t;e++)$r.fromBufferAttribute(this,e),$r.applyMatrix4(n),this.setXYZ(e,$r.x,$r.y,$r.z);return this}},{key:"applyNormalMatrix",value:function(n){for(var e=0,t=this.count;e<t;e++)$r.fromBufferAttribute(this,e),$r.applyNormalMatrix(n),this.setXYZ(e,$r.x,$r.y,$r.z);return this}},{key:"transformDirection",value:function(n){for(var e=0,t=this.count;e<t;e++)$r.fromBufferAttribute(this,e),$r.transformDirection(n),this.setXYZ(e,$r.x,$r.y,$r.z);return this}},{key:"set",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.array.set(n,e),this}},{key:"getX",value:function(n){var e=this.array[n*this.itemSize];return this.normalized&&(e=to(e,this.array)),e}},{key:"setX",value:function(n,e){return this.normalized&&(e=oo(e,this.array)),this.array[n*this.itemSize]=e,this}},{key:"getY",value:function(n){var e=this.array[n*this.itemSize+1];return this.normalized&&(e=to(e,this.array)),e}},{key:"setY",value:function(n,e){return this.normalized&&(e=oo(e,this.array)),this.array[n*this.itemSize+1]=e,this}},{key:"getZ",value:function(n){var e=this.array[n*this.itemSize+2];return this.normalized&&(e=to(e,this.array)),e}},{key:"setZ",value:function(n,e){return this.normalized&&(e=oo(e,this.array)),this.array[n*this.itemSize+2]=e,this}},{key:"getW",value:function(n){var e=this.array[n*this.itemSize+3];return this.normalized&&(e=to(e,this.array)),e}},{key:"setW",value:function(n,e){return this.normalized&&(e=oo(e,this.array)),this.array[n*this.itemSize+3]=e,this}},{key:"setXY",value:function(n,e,t){return n*=this.itemSize,this.normalized&&(e=oo(e,this.array),t=oo(t,this.array)),this.array[n+0]=e,this.array[n+1]=t,this}},{key:"setXYZ",value:function(n,e,t,o){return n*=this.itemSize,this.normalized&&(e=oo(e,this.array),t=oo(t,this.array),o=oo(o,this.array)),this.array[n+0]=e,this.array[n+1]=t,this.array[n+2]=o,this}},{key:"setXYZW",value:function(n,e,t,o,r){return n*=this.itemSize,this.normalized&&(e=oo(e,this.array),t=oo(t,this.array),o=oo(o,this.array),r=oo(r,this.array)),this.array[n+0]=e,this.array[n+1]=t,this.array[n+2]=o,this.array[n+3]=r,this}},{key:"onUpload",value:function(n){return this.onUploadCallback=n,this}},{key:"clone",value:function(){return new this.constructor(this.array,this.itemSize).copy(this)}},{key:"toJSON",value:function(){var n={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(n.name=this.name),this.usage!==Pt&&(n.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(n.updateRange=this.updateRange),n}},{key:"copyColorsArray",value:function(){console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")}},{key:"copyVector2sArray",value:function(){console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")}},{key:"copyVector3sArray",value:function(){console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")}},{key:"copyVector4sArray",value:function(){console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")}}]),n}(),ta=function(n){U(t,n);var e=k(t);function t(n,o,r){return g(this,t),e.call(this,new Int8Array(n),o,r)}return b(t)}(ea),oa=function(n){U(t,n);var e=k(t);function t(n,o,r){return g(this,t),e.call(this,new Uint8Array(n),o,r)}return b(t)}(ea),ra=function(n){U(t,n);var e=k(t);function t(n,o,r){return g(this,t),e.call(this,new Uint8ClampedArray(n),o,r)}return b(t)}(ea),aa=function(n){U(t,n);var e=k(t);function t(n,o,r){return g(this,t),e.call(this,new Int16Array(n),o,r)}return b(t)}(ea),ia=function(n){U(t,n);var e=k(t);function t(n,o,r){return g(this,t),e.call(this,new Uint16Array(n),o,r)}return b(t)}(ea),va=function(n){U(t,n);var e=k(t);function t(n,o,r){return g(this,t),e.call(this,new Int32Array(n),o,r)}return b(t)}(ea),ca=function(n){U(t,n);var e=k(t);function t(n,o,r){return g(this,t),e.call(this,new Uint32Array(n),o,r)}return b(t)}(ea),sa=function(n){U(t,n);var e=k(t);function t(n,o,r){var a;return g(this,t),(a=e.call(this,new Uint16Array(n),o,r)).isFloat16BufferAttribute=!0,a}return b(t)}(ea),la=function(n){U(t,n);var e=k(t);function t(n,o,r){return g(this,t),e.call(this,new Float32Array(n),o,r)}return b(t)}(ea),ua=function(n){U(t,n);var e=k(t);function t(n,o,r){return g(this,t),e.call(this,new Float64Array(n),o,r)}return b(t)}(ea),fa=0,pa=new pr,ma=new Ar,da=new Oo,ha=new Go,xa=new Go,ga=new Oo,ya=function(n){U(t,n);var e=k(t);function t(){var n;return g(this,t),(n=e.call(this)).isBufferGeometry=!0,Object.defineProperty(S(n),"id",{value:fa++}),n.uuid=Zt(),n.name="",n.type="BufferGeometry",n.index=null,n.attributes={},n.morphAttributes={},n.morphTargetsRelative=!1,n.groups=[],n.boundingBox=null,n.boundingSphere=null,n.drawRange={start:0,count:1/0},n.userData={},n}return b(t,[{key:"getIndex",value:function(){return this.index}},{key:"setIndex",value:function(n){return Array.isArray(n)?this.index=new(vo(n)?ca:ia)(n,1):this.index=n,this}},{key:"getAttribute",value:function(n){return this.attributes[n]}},{key:"setAttribute",value:function(n,e){return this.attributes[n]=e,this}},{key:"deleteAttribute",value:function(n){return delete this.attributes[n],this}},{key:"hasAttribute",value:function(n){return void 0!==this.attributes[n]}},{key:"addGroup",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.groups.push({start:n,count:e,materialIndex:t})}},{key:"clearGroups",value:function(){this.groups=[]}},{key:"setDrawRange",value:function(n,e){this.drawRange.start=n,this.drawRange.count=e}},{key:"applyMatrix4",value:function(n){var e=this.attributes.position;void 0!==e&&(e.applyMatrix4(n),e.needsUpdate=!0);var t=this.attributes.normal;if(void 0!==t){var o=(new io).getNormalMatrix(n);t.applyNormalMatrix(o),t.needsUpdate=!0}var r=this.attributes.tangent;return void 0!==r&&(r.transformDirection(n),r.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}},{key:"applyQuaternion",value:function(n){return pa.makeRotationFromQuaternion(n),this.applyMatrix4(pa),this}},{key:"rotateX",value:function(n){return pa.makeRotationX(n),this.applyMatrix4(pa),this}},{key:"rotateY",value:function(n){return pa.makeRotationY(n),this.applyMatrix4(pa),this}},{key:"rotateZ",value:function(n){return pa.makeRotationZ(n),this.applyMatrix4(pa),this}},{key:"translate",value:function(n,e,t){return pa.makeTranslation(n,e,t),this.applyMatrix4(pa),this}},{key:"scale",value:function(n,e,t){return pa.makeScale(n,e,t),this.applyMatrix4(pa),this}},{key:"lookAt",value:function(n){return ma.lookAt(n),ma.updateMatrix(),this.applyMatrix4(ma.matrix),this}},{key:"center",value:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(da).negate(),this.translate(da.x,da.y,da.z),this}},{key:"setFromPoints",value:function(n){for(var e=[],t=0,o=n.length;t<o;t++){var r=n[t];e.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new la(e,3)),this}},{key:"computeBoundingBox",value:function(){null===this.boundingBox&&(this.boundingBox=new Go);var n=this.attributes.position,e=this.morphAttributes.position;if(n&&n.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new Oo(-1/0,-1/0,-1/0),new Oo(1/0,1/0,1/0));if(void 0!==n){if(this.boundingBox.setFromBufferAttribute(n),e)for(var t=0,o=e.length;t<o;t++){var r=e[t];ha.setFromBufferAttribute(r),this.morphTargetsRelative?(ga.addVectors(this.boundingBox.min,ha.min),this.boundingBox.expandByPoint(ga),ga.addVectors(this.boundingBox.max,ha.max),this.boundingBox.expandByPoint(ga)):(this.boundingBox.expandByPoint(ha.min),this.boundingBox.expandByPoint(ha.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}},{key:"computeBoundingSphere",value:function(){null===this.boundingSphere&&(this.boundingSphere=new rr);var n=this.attributes.position,e=this.morphAttributes.position;if(n&&n.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new Oo,1/0);if(n){var t=this.boundingSphere.center;if(ha.setFromBufferAttribute(n),e)for(var o=0,r=e.length;o<r;o++){var a=e[o];xa.setFromBufferAttribute(a),this.morphTargetsRelative?(ga.addVectors(ha.min,xa.min),ha.expandByPoint(ga),ga.addVectors(ha.max,xa.max),ha.expandByPoint(ga)):(ha.expandByPoint(xa.min),ha.expandByPoint(xa.max))}ha.getCenter(t);for(var i=0,v=0,c=n.count;v<c;v++)ga.fromBufferAttribute(n,v),i=Math.max(i,t.distanceToSquared(ga));if(e)for(var s=0,l=e.length;s<l;s++)for(var u=e[s],f=this.morphTargetsRelative,p=0,m=u.count;p<m;p++)ga.fromBufferAttribute(u,p),f&&(da.fromBufferAttribute(n,p),ga.add(da)),i=Math.max(i,t.distanceToSquared(ga));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}},{key:"computeTangents",value:function(){var n=this.index,e=this.attributes;if(null!==n&&void 0!==e.position&&void 0!==e.normal&&void 0!==e.uv){var t=n.array,o=e.position.array,r=e.normal.array,a=e.uv.array,i=o.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new ea(new Float32Array(4*i),4));for(var v=this.getAttribute("tangent").array,c=[],s=[],l=0;l<i;l++)c[l]=new Oo,s[l]=new Oo;var u=new Oo,f=new Oo,p=new Oo,m=new ao,d=new ao,h=new ao,x=new Oo,g=new Oo,y=this.groups;0===y.length&&(y=[{start:0,count:t.length}]);for(var b=0,U=y.length;b<U;++b)for(var _=y[b],w=_.start,S=w,M=w+_.count;S<M;S+=3)E(t[S+0],t[S+1],t[S+2]);for(var k=new Oo,z=new Oo,C=new Oo,T=new Oo,R=0,D=y.length;R<D;++R)for(var P=y[R],F=P.start,j=F,I=F+P.count;j<I;j+=3)O(t[j+0]),O(t[j+1]),O(t[j+2])}else console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");function E(n,e,t){u.fromArray(o,3*n),f.fromArray(o,3*e),p.fromArray(o,3*t),m.fromArray(a,2*n),d.fromArray(a,2*e),h.fromArray(a,2*t),f.sub(u),p.sub(u),d.sub(m),h.sub(m);var r=1/(d.x*h.y-h.x*d.y);isFinite(r)&&(x.copy(f).multiplyScalar(h.y).addScaledVector(p,-d.y).multiplyScalar(r),g.copy(p).multiplyScalar(d.x).addScaledVector(f,-h.x).multiplyScalar(r),c[n].add(x),c[e].add(x),c[t].add(x),s[n].add(g),s[e].add(g),s[t].add(g))}function O(n){C.fromArray(r,3*n),T.copy(C);var e=c[n];k.copy(e),k.sub(C.multiplyScalar(C.dot(e))).normalize(),z.crossVectors(T,e);var t=z.dot(s[n])<0?-1:1;v[4*n]=k.x,v[4*n+1]=k.y,v[4*n+2]=k.z,v[4*n+3]=t}}},{key:"computeVertexNormals",value:function(){var n=this.index,e=this.getAttribute("position");if(void 0!==e){var t=this.getAttribute("normal");if(void 0===t)t=new ea(new Float32Array(3*e.count),3),this.setAttribute("normal",t);else for(var o=0,r=t.count;o<r;o++)t.setXYZ(o,0,0,0);var a=new Oo,i=new Oo,v=new Oo,c=new Oo,s=new Oo,l=new Oo,u=new Oo,f=new Oo;if(n)for(var p=0,m=n.count;p<m;p+=3){var d=n.getX(p+0),h=n.getX(p+1),x=n.getX(p+2);a.fromBufferAttribute(e,d),i.fromBufferAttribute(e,h),v.fromBufferAttribute(e,x),u.subVectors(v,i),f.subVectors(a,i),u.cross(f),c.fromBufferAttribute(t,d),s.fromBufferAttribute(t,h),l.fromBufferAttribute(t,x),c.add(u),s.add(u),l.add(u),t.setXYZ(d,c.x,c.y,c.z),t.setXYZ(h,s.x,s.y,s.z),t.setXYZ(x,l.x,l.y,l.z)}else for(var g=0,y=e.count;g<y;g+=3)a.fromBufferAttribute(e,g+0),i.fromBufferAttribute(e,g+1),v.fromBufferAttribute(e,g+2),u.subVectors(v,i),f.subVectors(a,i),u.cross(f),t.setXYZ(g+0,u.x,u.y,u.z),t.setXYZ(g+1,u.x,u.y,u.z),t.setXYZ(g+2,u.x,u.y,u.z);this.normalizeNormals(),t.needsUpdate=!0}}},{key:"merge",value:function(){return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),this}},{key:"normalizeNormals",value:function(){for(var n=this.attributes.normal,e=0,t=n.count;e<t;e++)ga.fromBufferAttribute(n,e),ga.normalize(),n.setXYZ(e,ga.x,ga.y,ga.z)}},{key:"toNonIndexed",value:function(){function n(n,e){for(var t=n.array,o=n.itemSize,r=n.normalized,a=new t.constructor(e.length*o),i=0,v=0,c=0,s=e.length;c<s;c++){i=n.isInterleavedBufferAttribute?e[c]*n.data.stride+n.offset:e[c]*o;for(var l=0;l<o;l++)a[v++]=t[i++]}return new ea(a,o,r)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;var e=new t,o=this.index.array,r=this.attributes;for(var a in r){var i=n(r[a],o);e.setAttribute(a,i)}var v=this.morphAttributes;for(var c in v){for(var s=[],l=v[c],u=0,f=l.length;u<f;u++){var p=n(l[u],o);s.push(p)}e.morphAttributes[c]=s}e.morphTargetsRelative=this.morphTargetsRelative;for(var m=this.groups,d=0,h=m.length;d<h;d++){var x=m[d];e.addGroup(x.start,x.count,x.materialIndex)}return e}},{key:"toJSON",value:function(){var n={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),Object.keys(this.userData).length>0&&(n.userData=this.userData),void 0!==this.parameters){var e=this.parameters;for(var t in e)void 0!==e[t]&&(n[t]=e[t]);return n}n.data={attributes:{}};var o=this.index;null!==o&&(n.data.index={type:o.array.constructor.name,array:Array.prototype.slice.call(o.array)});var r=this.attributes;for(var a in r){var i=r[a];n.data.attributes[a]=i.toJSON(n.data)}var v={},c=!1;for(var s in this.morphAttributes){for(var l=this.morphAttributes[s],u=[],f=0,p=l.length;f<p;f++){var m=l[f];u.push(m.toJSON(n.data))}u.length>0&&(v[s]=u,c=!0)}c&&(n.data.morphAttributes=v,n.data.morphTargetsRelative=this.morphTargetsRelative);var d=this.groups;d.length>0&&(n.data.groups=JSON.parse(JSON.stringify(d)));var h=this.boundingSphere;return null!==h&&(n.data.boundingSphere={center:h.center.toArray(),radius:h.radius}),n}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;var e={};this.name=n.name;var t=n.index;null!==t&&this.setIndex(t.clone(e));var o=n.attributes;for(var r in o){var a=o[r];this.setAttribute(r,a.clone(e))}var i=n.morphAttributes;for(var v in i){for(var c=[],s=i[v],l=0,u=s.length;l<u;l++)c.push(s[l].clone(e));this.morphAttributes[v]=c}this.morphTargetsRelative=n.morphTargetsRelative;for(var f=n.groups,p=0,m=f.length;p<m;p++){var d=f[p];this.addGroup(d.start,d.count,d.materialIndex)}var h=n.boundingBox;null!==h&&(this.boundingBox=h.clone());var x=n.boundingSphere;return null!==x&&(this.boundingSphere=x.clone()),this.drawRange.start=n.drawRange.start,this.drawRange.count=n.drawRange.count,this.userData=n.userData,void 0!==n.parameters&&(this.parameters=Object.assign({},n.parameters)),this}},{key:"dispose",value:function(){this.dispatchEvent({type:"dispose"})}}]),t}(Vt),ba=new pr,Ua=new fr,_a=new rr,wa=new Oo,Sa=new Oo,Ma=new Oo,ka=new Oo,za=new Oo,Ca=new Oo,Ta=new Oo,Ra=new Oo,Da=new Oo,Pa=new ao,Fa=new ao,ja=new ao,Ia=new Oo,Ea=new Oo,Oa=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ya,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Kr;return g(this,t),(n=e.call(this)).isMesh=!0,n.type="Mesh",n.geometry=o,n.material=r,n.updateMorphTargets(),n}return b(t,[{key:"copy",value:function(n,e){return D(_(t.prototype),"copy",this).call(this,n,e),void 0!==n.morphTargetInfluences&&(this.morphTargetInfluences=n.morphTargetInfluences.slice()),void 0!==n.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},n.morphTargetDictionary)),this.material=n.material,this.geometry=n.geometry,this}},{key:"updateMorphTargets",value:function(){var n=this.geometry.morphAttributes,e=Object.keys(n);if(e.length>0){var t=n[e[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(var o=0,r=t.length;o<r;o++){var a=t[o].name||String(o);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=o}}}}},{key:"raycast",value:function(n,e){var t=this.geometry,o=this.material,r=this.matrixWorld;if(void 0!==o&&(null===t.boundingSphere&&t.computeBoundingSphere(),_a.copy(t.boundingSphere),_a.applyMatrix4(r),!1!==n.ray.intersectsSphere(_a)&&(ba.copy(r).invert(),Ua.copy(n.ray).applyMatrix4(ba),null===t.boundingBox||!1!==Ua.intersectsBox(t.boundingBox)))){var a,i=t.index,v=t.attributes.position,c=t.morphAttributes.position,s=t.morphTargetsRelative,l=t.attributes.uv,u=t.attributes.uv2,f=t.groups,p=t.drawRange;if(null!==i)if(Array.isArray(o))for(var m=0,d=f.length;m<d;m++)for(var h=f[m],x=o[h.materialIndex],g=Math.max(h.start,p.start),y=Math.min(i.count,Math.min(h.start+h.count,p.start+p.count));g<y;g+=3){var b=i.getX(g),U=i.getX(g+1),_=i.getX(g+2);(a=Aa(this,x,n,Ua,v,c,s,l,u,b,U,_))&&(a.faceIndex=Math.floor(g/3),a.face.materialIndex=h.materialIndex,e.push(a))}else for(var w=Math.max(0,p.start),S=Math.min(i.count,p.start+p.count);w<S;w+=3){var M=i.getX(w),k=i.getX(w+1),z=i.getX(w+2);(a=Aa(this,o,n,Ua,v,c,s,l,u,M,k,z))&&(a.faceIndex=Math.floor(w/3),e.push(a))}else if(void 0!==v)if(Array.isArray(o))for(var C=0,T=f.length;C<T;C++)for(var R=f[C],D=o[R.materialIndex],P=Math.max(R.start,p.start),F=Math.min(v.count,Math.min(R.start+R.count,p.start+p.count));P<F;P+=3){(a=Aa(this,D,n,Ua,v,c,s,l,u,P,P+1,P+2))&&(a.faceIndex=Math.floor(P/3),a.face.materialIndex=R.materialIndex,e.push(a))}else for(var j=Math.max(0,p.start),I=Math.min(v.count,p.start+p.count);j<I;j+=3){(a=Aa(this,o,n,Ua,v,c,s,l,u,j,j+1,j+2))&&(a.faceIndex=Math.floor(j/3),e.push(a))}}}}]),t}(Ar);function Aa(n,e,t,o,r,a,i,v,c,s,l,u){wa.fromBufferAttribute(r,s),Sa.fromBufferAttribute(r,l),Ma.fromBufferAttribute(r,u);var f=n.morphTargetInfluences;if(a&&f){Ta.set(0,0,0),Ra.set(0,0,0),Da.set(0,0,0);for(var p=0,m=a.length;p<m;p++){var d=f[p],h=a[p];0!==d&&(ka.fromBufferAttribute(h,s),za.fromBufferAttribute(h,l),Ca.fromBufferAttribute(h,u),i?(Ta.addScaledVector(ka,d),Ra.addScaledVector(za,d),Da.addScaledVector(Ca,d)):(Ta.addScaledVector(ka.sub(wa),d),Ra.addScaledVector(za.sub(Sa),d),Da.addScaledVector(Ca.sub(Ma),d)))}wa.add(Ta),Sa.add(Ra),Ma.add(Da)}n.isSkinnedMesh&&(n.boneTransform(s,wa),n.boneTransform(l,Sa),n.boneTransform(u,Ma));var x=function(n,e,t,o,r,a,i,v){if(null===(e.side===W?o.intersectTriangle(i,a,r,!0,v):o.intersectTriangle(r,a,i,e.side!==H,v)))return null;Ea.copy(v),Ea.applyMatrix4(n.matrixWorld);var c=t.ray.origin.distanceTo(Ea);return c<t.near||c>t.far?null:{distance:c,point:Ea.clone(),object:n}}(n,e,t,o,wa,Sa,Ma,Ia);if(x){v&&(Pa.fromBufferAttribute(v,s),Fa.fromBufferAttribute(v,l),ja.fromBufferAttribute(v,u),x.uv=Zr.getUV(Ia,wa,Sa,Ma,Pa,Fa,ja,new ao)),c&&(Pa.fromBufferAttribute(c,s),Fa.fromBufferAttribute(c,l),ja.fromBufferAttribute(c,u),x.uv2=Zr.getUV(Ia,wa,Sa,Ma,Pa,Fa,ja,new ao));var g={a:s,b:l,c:u,normal:new Oo,materialIndex:0};Zr.getNormal(wa,Sa,Ma,g.normal),x.face=g}return x}var La=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;g(this,t),(n=e.call(this)).type="BoxGeometry",n.parameters={width:o,height:r,depth:a,widthSegments:i,heightSegments:v,depthSegments:c};var s=S(n);i=Math.floor(i),v=Math.floor(v),c=Math.floor(c);var l=[],u=[],f=[],p=[],m=0,d=0;function h(n,e,t,o,r,a,i,v,c,h,x){for(var g=a/c,y=i/h,b=a/2,U=i/2,_=v/2,w=c+1,S=h+1,M=0,k=0,z=new Oo,C=0;C<S;C++)for(var T=C*y-U,R=0;R<w;R++){var D=R*g-b;z[n]=D*o,z[e]=T*r,z[t]=_,u.push(z.x,z.y,z.z),z[n]=0,z[e]=0,z[t]=v>0?1:-1,f.push(z.x,z.y,z.z),p.push(R/c),p.push(1-C/h),M+=1}for(var P=0;P<h;P++)for(var F=0;F<c;F++){var j=m+F+w*P,I=m+F+w*(P+1),E=m+(F+1)+w*(P+1),O=m+(F+1)+w*P;l.push(j,I,O),l.push(I,E,O),k+=6}s.addGroup(d,k,x),d+=k,m+=M}return h("z","y","x",-1,-1,a,r,o,c,v,0),h("z","y","x",1,-1,a,r,-o,c,v,1),h("x","z","y",1,1,o,a,r,i,c,2),h("x","z","y",1,-1,o,a,-r,i,c,3),h("x","y","z",1,-1,o,r,a,i,v,4),h("x","y","z",-1,-1,o,r,-a,i,v,5),n.setIndex(l),n.setAttribute("position",new la(u,3)),n.setAttribute("normal",new la(f,3)),n.setAttribute("uv",new la(p,2)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.width,n.height,n.depth,n.widthSegments,n.heightSegments,n.depthSegments)}}]),t}(ya);function Ga(n){var e={};for(var t in n)for(var o in e[t]={},n[t]){var r=n[t][o];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?e[t][o]=r.clone():Array.isArray(r)?e[t][o]=r.slice():e[t][o]=r}return e}function Na(n){for(var e={},t=0;t<n.length;t++){var o=Ga(n[t]);for(var r in o)e[r]=o[r]}return e}var Ba={clone:Ga,merge:Na},qa=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).isShaderMaterial=!0,o.type="ShaderMaterial",o.defines={},o.uniforms={},o.uniformsGroups=[],o.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",o.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",o.linewidth=1,o.wireframe=!1,o.wireframeLinewidth=1,o.fog=!1,o.lights=!1,o.clipping=!1,o.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},o.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},o.index0AttributeName=void 0,o.uniformsNeedUpdate=!1,o.glslVersion=null,void 0!==n&&o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.fragmentShader=n.fragmentShader,this.vertexShader=n.vertexShader,this.uniforms=Ga(n.uniforms),this.uniformsGroups=function(n){for(var e=[],t=0;t<n.length;t++)e.push(n[t].clone());return e}(n.uniformsGroups),this.defines=Object.assign({},n.defines),this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.fog=n.fog,this.lights=n.lights,this.clipping=n.clipping,this.extensions=Object.assign({},n.extensions),this.glslVersion=n.glslVersion,this}},{key:"toJSON",value:function(n){var e=D(_(t.prototype),"toJSON",this).call(this,n);for(var o in e.glslVersion=this.glslVersion,e.uniforms={},this.uniforms){var r=this.uniforms[o].value;r&&r.isTexture?e.uniforms[o]={type:"t",value:r.toJSON(n).uuid}:r&&r.isColor?e.uniforms[o]={type:"c",value:r.getHex()}:r&&r.isVector2?e.uniforms[o]={type:"v2",value:r.toArray()}:r&&r.isVector3?e.uniforms[o]={type:"v3",value:r.toArray()}:r&&r.isVector4?e.uniforms[o]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?e.uniforms[o]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?e.uniforms[o]={type:"m4",value:r.toArray()}:e.uniforms[o]={value:r}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;var a={};for(var i in this.extensions)!0===this.extensions[i]&&(a[i]=!0);return Object.keys(a).length>0&&(e.extensions=a),e}}]),t}(Jr),Va=function(n){U(t,n);var e=k(t);function t(){var n;return g(this,t),(n=e.call(this)).isCamera=!0,n.type="Camera",n.matrixWorldInverse=new pr,n.projectionMatrix=new pr,n.projectionMatrixInverse=new pr,n}return b(t,[{key:"copy",value:function(n,e){return D(_(t.prototype),"copy",this).call(this,n,e),this.matrixWorldInverse.copy(n.matrixWorldInverse),this.projectionMatrix.copy(n.projectionMatrix),this.projectionMatrixInverse.copy(n.projectionMatrixInverse),this}},{key:"getWorldDirection",value:function(n){this.updateWorldMatrix(!0,!1);var e=this.matrixWorld.elements;return n.set(-e[8],-e[9],-e[10]).normalize()}},{key:"updateMatrixWorld",value:function(n){D(_(t.prototype),"updateMatrixWorld",this).call(this,n),this.matrixWorldInverse.copy(this.matrixWorld).invert()}},{key:"updateWorldMatrix",value:function(n,e){D(_(t.prototype),"updateWorldMatrix",this).call(this,n,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),t}(Ar),Wa=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:50,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:2e3;return g(this,t),(n=e.call(this)).isPerspectiveCamera=!0,n.type="PerspectiveCamera",n.fov=o,n.zoom=1,n.near=a,n.far=i,n.focus=10,n.aspect=r,n.view=null,n.filmGauge=35,n.filmOffset=0,n.updateProjectionMatrix(),n}return b(t,[{key:"copy",value:function(n,e){return D(_(t.prototype),"copy",this).call(this,n,e),this.fov=n.fov,this.zoom=n.zoom,this.near=n.near,this.far=n.far,this.focus=n.focus,this.aspect=n.aspect,this.view=null===n.view?null:Object.assign({},n.view),this.filmGauge=n.filmGauge,this.filmOffset=n.filmOffset,this}},{key:"setFocalLength",value:function(n){var e=.5*this.getFilmHeight()/n;this.fov=2*Yt*Math.atan(e),this.updateProjectionMatrix()}},{key:"getFocalLength",value:function(){var n=Math.tan(.5*Xt*this.fov);return.5*this.getFilmHeight()/n}},{key:"getEffectiveFOV",value:function(){return 2*Yt*Math.atan(Math.tan(.5*Xt*this.fov)/this.zoom)}},{key:"getFilmWidth",value:function(){return this.filmGauge*Math.min(this.aspect,1)}},{key:"getFilmHeight",value:function(){return this.filmGauge/Math.max(this.aspect,1)}},{key:"setViewOffset",value:function(n,e,t,o,r,a){this.aspect=n/e,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=o,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}},{key:"clearViewOffset",value:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}},{key:"updateProjectionMatrix",value:function(){var n=this.near,e=n*Math.tan(.5*Xt*this.fov)/this.zoom,t=2*e,o=this.aspect*t,r=-.5*o,a=this.view;if(null!==this.view&&this.view.enabled){var i=a.fullWidth,v=a.fullHeight;r+=a.offsetX*o/i,e-=a.offsetY*t/v,o*=a.width/i,t*=a.height/v}var c=this.filmOffset;0!==c&&(r+=n*c/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+o,e,e-t,n,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}},{key:"toJSON",value:function(n){var e=D(_(t.prototype),"toJSON",this).call(this,n);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,null!==this.view&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}]),t}(Va),Ha=90,Xa=function(n){U(t,n);var e=k(t);function t(n,o,r){var a;g(this,t),(a=e.call(this)).type="CubeCamera",a.renderTarget=r;var i=new Wa(Ha,1,n,o);i.layers=a.layers,i.up.set(0,-1,0),i.lookAt(new Oo(1,0,0)),a.add(i);var v=new Wa(Ha,1,n,o);v.layers=a.layers,v.up.set(0,-1,0),v.lookAt(new Oo(-1,0,0)),a.add(v);var c=new Wa(Ha,1,n,o);c.layers=a.layers,c.up.set(0,0,1),c.lookAt(new Oo(0,1,0)),a.add(c);var s=new Wa(Ha,1,n,o);s.layers=a.layers,s.up.set(0,0,-1),s.lookAt(new Oo(0,-1,0)),a.add(s);var l=new Wa(Ha,1,n,o);l.layers=a.layers,l.up.set(0,-1,0),l.lookAt(new Oo(0,0,1)),a.add(l);var u=new Wa(Ha,1,n,o);return u.layers=a.layers,u.up.set(0,-1,0),u.lookAt(new Oo(0,0,-1)),a.add(u),a}return b(t,[{key:"update",value:function(n,e){null===this.parent&&this.updateMatrixWorld();var t=this.renderTarget,o=c(this.children,6),r=o[0],a=o[1],i=o[2],v=o[3],s=o[4],l=o[5],u=n.getRenderTarget(),f=n.toneMapping,p=n.xr.enabled;n.toneMapping=zn,n.xr.enabled=!1;var m=t.texture.generateMipmaps;t.texture.generateMipmaps=!1,n.setRenderTarget(t,0),n.render(e,r),n.setRenderTarget(t,1),n.render(e,a),n.setRenderTarget(t,2),n.render(e,i),n.setRenderTarget(t,3),n.render(e,v),n.setRenderTarget(t,4),n.render(e,s),t.texture.generateMipmaps=m,n.setRenderTarget(t,5),n.render(e,l),n.setRenderTarget(u),n.toneMapping=f,n.xr.enabled=p,t.texture.needsPMREMUpdate=!0}}]),t}(Ar),Ya=function(n){U(t,n);var e=k(t);function t(n,o,r,a,i,v,c,s,l,u){var f;return g(this,t),n=void 0!==n?n:[],o=void 0!==o?o:jn,(f=e.call(this,n,o,r,a,i,v,c,s,l,u)).isCubeTexture=!0,f.flipY=!1,f}return b(t,[{key:"images",get:function(){return this.image},set:function(n){this.image=n}}]),t}(Co),Za=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};g(this,t),(n=e.call(this,o,o,r)).isWebGLCubeRenderTarget=!0;var a={width:o,height:o,depth:1},i=[a,a,a,a,a,a];return n.texture=new Ya(i,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.encoding),n.texture.isRenderTargetTexture=!0,n.texture.generateMipmaps=void 0!==r.generateMipmaps&&r.generateMipmaps,n.texture.minFilter=void 0!==r.minFilter?r.minFilter:Xn,n}return b(t,[{key:"fromEquirectangularTexture",value:function(n,e){this.texture.type=e.type,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;var t={tEquirect:{value:null}},o="\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",r="\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",a=new La(5,5,5),i=new qa({name:"CubemapFromEquirect",uniforms:Ga(t),vertexShader:o,fragmentShader:r,side:W,blending:X});i.uniforms.tEquirect.value=e;var v=new Oa(a,i),c=e.minFilter;return e.minFilter===Qn&&(e.minFilter=Xn),new Xa(1,10,this).update(n,v),e.minFilter=c,v.geometry.dispose(),v.material.dispose(),this}},{key:"clear",value:function(n,e,t,o){for(var r=n.getRenderTarget(),a=0;a<6;a++)n.setRenderTarget(this,a),n.clear(e,t,o);n.setRenderTarget(r)}}]),t}(Ro),Qa=new Oo,Ja=new Oo,Ka=new io,$a=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo(1,0,0),t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;g(this,n),this.isPlane=!0,this.normal=e,this.constant=t}return b(n,[{key:"set",value:function(n,e){return this.normal.copy(n),this.constant=e,this}},{key:"setComponents",value:function(n,e,t,o){return this.normal.set(n,e,t),this.constant=o,this}},{key:"setFromNormalAndCoplanarPoint",value:function(n,e){return this.normal.copy(n),this.constant=-e.dot(this.normal),this}},{key:"setFromCoplanarPoints",value:function(n,e,t){var o=Qa.subVectors(t,e).cross(Ja.subVectors(n,e)).normalize();return this.setFromNormalAndCoplanarPoint(o,n),this}},{key:"copy",value:function(n){return this.normal.copy(n.normal),this.constant=n.constant,this}},{key:"normalize",value:function(){var n=1/this.normal.length();return this.normal.multiplyScalar(n),this.constant*=n,this}},{key:"negate",value:function(){return this.constant*=-1,this.normal.negate(),this}},{key:"distanceToPoint",value:function(n){return this.normal.dot(n)+this.constant}},{key:"distanceToSphere",value:function(n){return this.distanceToPoint(n.center)-n.radius}},{key:"projectPoint",value:function(n,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(n)).add(n)}},{key:"intersectLine",value:function(n,e){var t=n.delta(Qa),o=this.normal.dot(t);if(0===o)return 0===this.distanceToPoint(n.start)?e.copy(n.start):null;var r=-(n.start.dot(this.normal)+this.constant)/o;return r<0||r>1?null:e.copy(t).multiplyScalar(r).add(n.start)}},{key:"intersectsLine",value:function(n){var e=this.distanceToPoint(n.start),t=this.distanceToPoint(n.end);return e<0&&t>0||t<0&&e>0}},{key:"intersectsBox",value:function(n){return n.intersectsPlane(this)}},{key:"intersectsSphere",value:function(n){return n.intersectsPlane(this)}},{key:"coplanarPoint",value:function(n){return n.copy(this.normal).multiplyScalar(-this.constant)}},{key:"applyMatrix4",value:function(n,e){var t=e||Ka.getNormalMatrix(n),o=this.coplanarPoint(Qa).applyMatrix4(n),r=this.normal.applyMatrix3(t).normalize();return this.constant=-o.dot(r),this}},{key:"translate",value:function(n){return this.constant-=n.dot(this.normal),this}},{key:"equals",value:function(n){return n.normal.equals(this.normal)&&n.constant===this.constant}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),ni=new rr,ei=new Oo,ti=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new $a,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new $a,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new $a,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new $a,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new $a,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:new $a;g(this,n),this.planes=[e,t,o,r,a,i]}return b(n,[{key:"set",value:function(n,e,t,o,r,a){var i=this.planes;return i[0].copy(n),i[1].copy(e),i[2].copy(t),i[3].copy(o),i[4].copy(r),i[5].copy(a),this}},{key:"copy",value:function(n){for(var e=this.planes,t=0;t<6;t++)e[t].copy(n.planes[t]);return this}},{key:"setFromProjectionMatrix",value:function(n){var e=this.planes,t=n.elements,o=t[0],r=t[1],a=t[2],i=t[3],v=t[4],c=t[5],s=t[6],l=t[7],u=t[8],f=t[9],p=t[10],m=t[11],d=t[12],h=t[13],x=t[14],g=t[15];return e[0].setComponents(i-o,l-v,m-u,g-d).normalize(),e[1].setComponents(i+o,l+v,m+u,g+d).normalize(),e[2].setComponents(i+r,l+c,m+f,g+h).normalize(),e[3].setComponents(i-r,l-c,m-f,g-h).normalize(),e[4].setComponents(i-a,l-s,m-p,g-x).normalize(),e[5].setComponents(i+a,l+s,m+p,g+x).normalize(),this}},{key:"intersectsObject",value:function(n){var e=n.geometry;return null===e.boundingSphere&&e.computeBoundingSphere(),ni.copy(e.boundingSphere).applyMatrix4(n.matrixWorld),this.intersectsSphere(ni)}},{key:"intersectsSprite",value:function(n){return ni.center.set(0,0,0),ni.radius=.7071067811865476,ni.applyMatrix4(n.matrixWorld),this.intersectsSphere(ni)}},{key:"intersectsSphere",value:function(n){for(var e=this.planes,t=n.center,o=-n.radius,r=0;r<6;r++){if(e[r].distanceToPoint(t)<o)return!1}return!0}},{key:"intersectsBox",value:function(n){for(var e=this.planes,t=0;t<6;t++){var o=e[t];if(ei.x=o.normal.x>0?n.max.x:n.min.x,ei.y=o.normal.y>0?n.max.y:n.min.y,ei.z=o.normal.z>0?n.max.z:n.min.z,o.distanceToPoint(ei)<0)return!1}return!0}},{key:"containsPoint",value:function(n){for(var e=this.planes,t=0;t<6;t++)if(e[t].distanceToPoint(n)<0)return!1;return!0}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}();function oi(){var n=null,e=!1,t=null,o=null;function r(e,a){t(e,a),o=n.requestAnimationFrame(r)}return{start:function(){!0!==e&&null!==t&&(o=n.requestAnimationFrame(r),e=!0)},stop:function(){n.cancelAnimationFrame(o),e=!1},setAnimationLoop:function(n){t=n},setContext:function(e){n=e}}}function ri(n,e){var t=e.isWebGL2,o=new WeakMap;return{get:function(n){return n.isInterleavedBufferAttribute&&(n=n.data),o.get(n)},remove:function(e){e.isInterleavedBufferAttribute&&(e=e.data);var t=o.get(e);t&&(n.deleteBuffer(t.buffer),o.delete(e))},update:function(e,r){if(e.isGLBufferAttribute){var a=o.get(e);(!a||a.version<e.version)&&o.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version})}else{e.isInterleavedBufferAttribute&&(e=e.data);var i=o.get(e);void 0===i?o.set(e,function(e,o){var r,a=e.array,i=e.usage,v=n.createBuffer();if(n.bindBuffer(o,v),n.bufferData(o,a,i),e.onUploadCallback(),a instanceof Float32Array)r=5126;else if(a instanceof Uint16Array)if(e.isFloat16BufferAttribute){if(!t)throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");r=5131}else r=5123;else if(a instanceof Int16Array)r=5122;else if(a instanceof Uint32Array)r=5125;else if(a instanceof Int32Array)r=5124;else if(a instanceof Int8Array)r=5120;else if(a instanceof Uint8Array)r=5121;else{if(!(a instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+a);r=5121}return{buffer:v,type:r,bytesPerElement:a.BYTES_PER_ELEMENT,version:e.version}}(e,r)):i.version<e.version&&(!function(e,o,r){var a=o.array,i=o.updateRange;n.bindBuffer(r,e),-1===i.count?n.bufferSubData(r,0,a):(t?n.bufferSubData(r,i.offset*a.BYTES_PER_ELEMENT,a,i.offset,i.count):n.bufferSubData(r,i.offset*a.BYTES_PER_ELEMENT,a.subarray(i.offset,i.offset+i.count)),i.count=-1)}(i.buffer,e,r),i.version=e.version)}}}}var ai=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;g(this,t),(n=e.call(this)).type="PlaneGeometry",n.parameters={width:o,height:r,widthSegments:a,heightSegments:i};for(var v=o/2,c=r/2,s=Math.floor(a),l=Math.floor(i),u=s+1,f=l+1,p=o/s,m=r/l,d=[],h=[],x=[],y=[],b=0;b<f;b++)for(var U=b*m-c,_=0;_<u;_++){var w=_*p-v;h.push(w,-U,0),x.push(0,0,1),y.push(_/s),y.push(1-b/l)}for(var S=0;S<l;S++)for(var M=0;M<s;M++){var k=M+u*S,z=M+u*(S+1),C=M+1+u*(S+1),T=M+1+u*S;d.push(k,z,T),d.push(z,C,T)}return n.setIndex(d),n.setAttribute("position",new la(h,3)),n.setAttribute("normal",new la(x,3)),n.setAttribute("uv",new la(y,2)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.width,n.height,n.widthSegments,n.heightSegments)}}]),t}(ya),ii={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",iridescence_fragment:"#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_fragment:"LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",lights_lambert_pars_fragment:"varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert\n#define Material_LightProbeLOD( material )\t(0)",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#if NUM_SPOT_LIGHT_COORDS > 0\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#if NUM_SPOT_LIGHT_COORDS > 0\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",backgroundCube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",backgroundCube_frag:"#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"},vi={common:{diffuse:{value:new wo(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new io},uv2Transform:{value:new io},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new ao(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new wo(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new wo(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new io}},sprite:{diffuse:{value:new wo(16777215)},opacity:{value:1},center:{value:new ao(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new io}}},ci={basic:{uniforms:Na([vi.common,vi.specularmap,vi.envmap,vi.aomap,vi.lightmap,vi.fog]),vertexShader:ii.meshbasic_vert,fragmentShader:ii.meshbasic_frag},lambert:{uniforms:Na([vi.common,vi.specularmap,vi.envmap,vi.aomap,vi.lightmap,vi.emissivemap,vi.bumpmap,vi.normalmap,vi.displacementmap,vi.fog,vi.lights,{emissive:{value:new wo(0)}}]),vertexShader:ii.meshlambert_vert,fragmentShader:ii.meshlambert_frag},phong:{uniforms:Na([vi.common,vi.specularmap,vi.envmap,vi.aomap,vi.lightmap,vi.emissivemap,vi.bumpmap,vi.normalmap,vi.displacementmap,vi.fog,vi.lights,{emissive:{value:new wo(0)},specular:{value:new wo(1118481)},shininess:{value:30}}]),vertexShader:ii.meshphong_vert,fragmentShader:ii.meshphong_frag},standard:{uniforms:Na([vi.common,vi.envmap,vi.aomap,vi.lightmap,vi.emissivemap,vi.bumpmap,vi.normalmap,vi.displacementmap,vi.roughnessmap,vi.metalnessmap,vi.fog,vi.lights,{emissive:{value:new wo(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ii.meshphysical_vert,fragmentShader:ii.meshphysical_frag},toon:{uniforms:Na([vi.common,vi.aomap,vi.lightmap,vi.emissivemap,vi.bumpmap,vi.normalmap,vi.displacementmap,vi.gradientmap,vi.fog,vi.lights,{emissive:{value:new wo(0)}}]),vertexShader:ii.meshtoon_vert,fragmentShader:ii.meshtoon_frag},matcap:{uniforms:Na([vi.common,vi.bumpmap,vi.normalmap,vi.displacementmap,vi.fog,{matcap:{value:null}}]),vertexShader:ii.meshmatcap_vert,fragmentShader:ii.meshmatcap_frag},points:{uniforms:Na([vi.points,vi.fog]),vertexShader:ii.points_vert,fragmentShader:ii.points_frag},dashed:{uniforms:Na([vi.common,vi.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ii.linedashed_vert,fragmentShader:ii.linedashed_frag},depth:{uniforms:Na([vi.common,vi.displacementmap]),vertexShader:ii.depth_vert,fragmentShader:ii.depth_frag},normal:{uniforms:Na([vi.common,vi.bumpmap,vi.normalmap,vi.displacementmap,{opacity:{value:1}}]),vertexShader:ii.meshnormal_vert,fragmentShader:ii.meshnormal_frag},sprite:{uniforms:Na([vi.sprite,vi.fog]),vertexShader:ii.sprite_vert,fragmentShader:ii.sprite_frag},background:{uniforms:{uvTransform:{value:new io},t2D:{value:null}},vertexShader:ii.background_vert,fragmentShader:ii.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0}},vertexShader:ii.backgroundCube_vert,fragmentShader:ii.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:ii.cube_vert,fragmentShader:ii.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ii.equirect_vert,fragmentShader:ii.equirect_frag},distanceRGBA:{uniforms:Na([vi.common,vi.displacementmap,{referencePosition:{value:new Oo},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ii.distanceRGBA_vert,fragmentShader:ii.distanceRGBA_frag},shadow:{uniforms:Na([vi.lights,vi.fog,{color:{value:new wo(0)},opacity:{value:1}}]),vertexShader:ii.shadow_vert,fragmentShader:ii.shadow_frag}};function si(n,e,t,o,r,a,i){var v,c,s=new wo(0),l=!0===a?0:1,u=null,f=0,p=null;function m(n,e){o.buffers.color.setClear(n.r,n.g,n.b,e,i)}return{getClearColor:function(){return s},setClearColor:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;s.set(n),m(s,l=e)},getClearAlpha:function(){return l},setClearAlpha:function(n){m(s,l=n)},render:function(o,a){var i=!1,d=!0===a.isScene?a.background:null;d&&d.isTexture&&(d=(a.backgroundBlurriness>0?t:e).get(d));var h=n.xr,x=h.getSession&&h.getSession();x&&"additive"===x.environmentBlendMode&&(d=null),null===d?m(s,l):d&&d.isColor&&(m(d,1),i=!0),(n.autoClear||i)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),d&&(d.isCubeTexture||d.mapping===An)?(void 0===c&&((c=new Oa(new La(1,1,1),new qa({name:"BackgroundCubeMaterial",uniforms:Ga(ci.backgroundCube.uniforms),vertexShader:ci.backgroundCube.vertexShader,fragmentShader:ci.backgroundCube.fragmentShader,side:W,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(n,e,t){this.matrixWorld.copyPosition(t.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(c)),c.material.uniforms.envMap.value=d,c.material.uniforms.flipEnvMap.value=d.isCubeTexture&&!1===d.isRenderTargetTexture?-1:1,c.material.uniforms.backgroundBlurriness.value=a.backgroundBlurriness,u===d&&f===d.version&&p===n.toneMapping||(c.material.needsUpdate=!0,u=d,f=d.version,p=n.toneMapping),c.layers.enableAll(),o.unshift(c,c.geometry,c.material,0,0,null)):d&&d.isTexture&&(void 0===v&&((v=new Oa(new ai(2,2),new qa({name:"BackgroundMaterial",uniforms:Ga(ci.background.uniforms),vertexShader:ci.background.vertexShader,fragmentShader:ci.background.fragmentShader,side:V,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),Object.defineProperty(v.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(v)),v.material.uniforms.t2D.value=d,!0===d.matrixAutoUpdate&&d.updateMatrix(),v.material.uniforms.uvTransform.value.copy(d.matrix),u===d&&f===d.version&&p===n.toneMapping||(v.material.needsUpdate=!0,u=d,f=d.version,p=n.toneMapping),v.layers.enableAll(),o.unshift(v,v.geometry,v.material,0,0,null))}}}function li(n,e,t,o){var r=n.getParameter(34921),a=o.isWebGL2?null:e.get("OES_vertex_array_object"),i=o.isWebGL2||null!==a,v={},c=p(null),s=c,l=!1;function u(e){return o.isWebGL2?n.bindVertexArray(e):a.bindVertexArrayOES(e)}function f(e){return o.isWebGL2?n.deleteVertexArray(e):a.deleteVertexArrayOES(e)}function p(n){for(var e=[],t=[],o=[],a=0;a<r;a++)e[a]=0,t[a]=0,o[a]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:e,enabledAttributes:t,attributeDivisors:o,object:n,attributes:{},index:null}}function m(){for(var n=s.newAttributes,e=0,t=n.length;e<t;e++)n[e]=0}function d(n){h(n,0)}function h(t,r){var a=s.newAttributes,i=s.enabledAttributes,v=s.attributeDivisors;(a[t]=1,0===i[t]&&(n.enableVertexAttribArray(t),i[t]=1),v[t]!==r)&&((o.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[o.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](t,r),v[t]=r)}function x(){for(var e=s.newAttributes,t=s.enabledAttributes,o=0,r=t.length;o<r;o++)t[o]!==e[o]&&(n.disableVertexAttribArray(o),t[o]=0)}function g(e,t,r,a,i,v){!0!==o.isWebGL2||5124!==r&&5125!==r?n.vertexAttribPointer(e,t,r,a,i,v):n.vertexAttribIPointer(e,t,r,i,v)}function y(){b(),l=!0,s!==c&&u((s=c).object)}function b(){c.geometry=null,c.program=null,c.wireframe=!1}return{setup:function(r,c,f,y,b){var U=!1;if(i){var _=function(e,t,r){var i=!0===r.wireframe,c=v[e.id];void 0===c&&(c={},v[e.id]=c);var s=c[t.id];void 0===s&&(s={},c[t.id]=s);var l=s[i];void 0===l&&(l=p(o.isWebGL2?n.createVertexArray():a.createVertexArrayOES()),s[i]=l);return l}(y,f,c);s!==_&&u((s=_).object),U=function(n,e,t,o){var r=s.attributes,a=e.attributes,i=0,v=t.getAttributes();for(var c in v){if(v[c].location>=0){var l=r[c],u=a[c];if(void 0===u&&("instanceMatrix"===c&&n.instanceMatrix&&(u=n.instanceMatrix),"instanceColor"===c&&n.instanceColor&&(u=n.instanceColor)),void 0===l)return!0;if(l.attribute!==u)return!0;if(u&&l.data!==u.data)return!0;i++}}return s.attributesNum!==i||s.index!==o}(r,y,f,b),U&&function(n,e,t,o){var r={},a=e.attributes,i=0,v=t.getAttributes();for(var c in v){if(v[c].location>=0){var l=a[c];void 0===l&&("instanceMatrix"===c&&n.instanceMatrix&&(l=n.instanceMatrix),"instanceColor"===c&&n.instanceColor&&(l=n.instanceColor));var u={};u.attribute=l,l&&l.data&&(u.data=l.data),r[c]=u,i++}}s.attributes=r,s.attributesNum=i,s.index=o}(r,y,f,b)}else{var w=!0===c.wireframe;s.geometry===y.id&&s.program===f.id&&s.wireframe===w||(s.geometry=y.id,s.program=f.id,s.wireframe=w,U=!0)}null!==b&&t.update(b,34963),(U||l)&&(l=!1,function(r,a,i,v){if(!1===o.isWebGL2&&(r.isInstancedMesh||v.isInstancedBufferGeometry)&&null===e.get("ANGLE_instanced_arrays"))return;m();var c=v.attributes,s=i.getAttributes(),l=a.defaultAttributeValues;for(var u in s){var f=s[u];if(f.location>=0){var p=c[u];if(void 0===p&&("instanceMatrix"===u&&r.instanceMatrix&&(p=r.instanceMatrix),"instanceColor"===u&&r.instanceColor&&(p=r.instanceColor)),void 0!==p){var y=p.normalized,b=p.itemSize,U=t.get(p);if(void 0===U)continue;var _=U.buffer,w=U.type,S=U.bytesPerElement;if(p.isInterleavedBufferAttribute){var M=p.data,k=M.stride,z=p.offset;if(M.isInstancedInterleavedBuffer){for(var C=0;C<f.locationSize;C++)h(f.location+C,M.meshPerAttribute);!0!==r.isInstancedMesh&&void 0===v._maxInstanceCount&&(v._maxInstanceCount=M.meshPerAttribute*M.count)}else for(var T=0;T<f.locationSize;T++)d(f.location+T);n.bindBuffer(34962,_);for(var R=0;R<f.locationSize;R++)g(f.location+R,b/f.locationSize,w,y,k*S,(z+b/f.locationSize*R)*S)}else{if(p.isInstancedBufferAttribute){for(var D=0;D<f.locationSize;D++)h(f.location+D,p.meshPerAttribute);!0!==r.isInstancedMesh&&void 0===v._maxInstanceCount&&(v._maxInstanceCount=p.meshPerAttribute*p.count)}else for(var P=0;P<f.locationSize;P++)d(f.location+P);n.bindBuffer(34962,_);for(var F=0;F<f.locationSize;F++)g(f.location+F,b/f.locationSize,w,y,b*S,b/f.locationSize*F*S)}}else if(void 0!==l){var j=l[u];if(void 0!==j)switch(j.length){case 2:n.vertexAttrib2fv(f.location,j);break;case 3:n.vertexAttrib3fv(f.location,j);break;case 4:n.vertexAttrib4fv(f.location,j);break;default:n.vertexAttrib1fv(f.location,j)}}}}x()}(r,c,f,y),null!==b&&n.bindBuffer(34963,t.get(b).buffer))},reset:y,resetDefaultState:b,dispose:function(){for(var n in y(),v){var e=v[n];for(var t in e){var o=e[t];for(var r in o)f(o[r].object),delete o[r];delete e[t]}delete v[n]}},releaseStatesOfGeometry:function(n){if(void 0!==v[n.id]){var e=v[n.id];for(var t in e){var o=e[t];for(var r in o)f(o[r].object),delete o[r];delete e[t]}delete v[n.id]}},releaseStatesOfProgram:function(n){for(var e in v){var t=v[e];if(void 0!==t[n.id]){var o=t[n.id];for(var r in o)f(o[r].object),delete o[r];delete t[n.id]}}},initAttributes:m,enableAttribute:d,disableUnusedAttributes:x}}function ui(n,e,t,o){var r,a=o.isWebGL2;this.setMode=function(n){r=n},this.render=function(e,o){n.drawArrays(r,e,o),t.update(o,r,1)},this.renderInstances=function(o,i,v){if(0!==v){var c,s;if(a)c=n,s="drawArraysInstanced";else if(s="drawArraysInstancedANGLE",null===(c=e.get("ANGLE_instanced_arrays")))return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");c[s](r,o,i,v),t.update(i,r,v)}}}function fi(n,e,t){var o;function r(e){if("highp"===e){if(n.getShaderPrecisionFormat(35633,36338).precision>0&&n.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";e="mediump"}return"mediump"===e&&n.getShaderPrecisionFormat(35633,36337).precision>0&&n.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}var a="undefined"!==typeof WebGL2RenderingContext&&n instanceof WebGL2RenderingContext||"undefined"!==typeof WebGL2ComputeRenderingContext&&n instanceof WebGL2ComputeRenderingContext,i=void 0!==t.precision?t.precision:"highp",v=r(i);v!==i&&(console.warn("THREE.WebGLRenderer:",i,"not supported, using",v,"instead."),i=v);var c=a||e.has("WEBGL_draw_buffers"),s=!0===t.logarithmicDepthBuffer,l=n.getParameter(34930),u=n.getParameter(35660),f=n.getParameter(3379),p=n.getParameter(34076),m=n.getParameter(34921),d=n.getParameter(36347),h=n.getParameter(36348),x=n.getParameter(36349),g=u>0,y=a||e.has("OES_texture_float");return{isWebGL2:a,drawBuffers:c,getMaxAnisotropy:function(){if(void 0!==o)return o;if(!0===e.has("EXT_texture_filter_anisotropic")){var t=e.get("EXT_texture_filter_anisotropic");o=n.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else o=0;return o},getMaxPrecision:r,precision:i,logarithmicDepthBuffer:s,maxTextures:l,maxVertexTextures:u,maxTextureSize:f,maxCubemapSize:p,maxAttributes:m,maxVertexUniforms:d,maxVaryings:h,maxFragmentUniforms:x,vertexTextures:g,floatFragmentTextures:y,floatVertexTextures:g&&y,maxSamples:a?n.getParameter(36183):0}}function pi(n){var e=this,t=null,o=0,r=!1,a=!1,i=new $a,v=new io,c={value:null,needsUpdate:!1};function s(){c.value!==t&&(c.value=t,c.needsUpdate=o>0),e.numPlanes=o,e.numIntersection=0}function l(n,t,o,r){var a=null!==n?n.length:0,s=null;if(0!==a){if(s=c.value,!0!==r||null===s){var l=o+4*a,u=t.matrixWorldInverse;v.getNormalMatrix(u),(null===s||s.length<l)&&(s=new Float32Array(l));for(var f=0,p=o;f!==a;++f,p+=4)i.copy(n[f]).applyMatrix4(u,v),i.normal.toArray(s,p),s[p+3]=i.constant}c.value=s,c.needsUpdate=!0}return e.numPlanes=a,e.numIntersection=0,s}this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(n,e,a){var i=0!==n.length||e||0!==o||r;return r=e,t=l(n,a,0),o=n.length,i},this.beginShadows=function(){a=!0,l(null)},this.endShadows=function(){a=!1,s()},this.setState=function(e,i,v){var u=e.clippingPlanes,f=e.clipIntersection,p=e.clipShadows,m=n.get(e);if(!r||null===u||0===u.length||a&&!p)a?l(null):s();else{var d=a?0:o,h=4*d,x=m.clippingState||null;c.value=x,x=l(u,i,h,v);for(var g=0;g!==h;++g)x[g]=t[g];m.clippingState=x,this.numIntersection=f?this.numPlanes:0,this.numPlanes+=d}}}function mi(n){var e=new WeakMap;function t(n,e){return e===En?n.mapping=jn:e===On&&(n.mapping=In),n}function o(n){var t=n.target;t.removeEventListener("dispose",o);var r=e.get(t);void 0!==r&&(e.delete(t),r.dispose())}return{get:function(r){if(r&&r.isTexture&&!1===r.isRenderTargetTexture){var a=r.mapping;if(a===En||a===On){if(e.has(r))return t(e.get(r).texture,r.mapping);var i=r.image;if(i&&i.height>0){var v=new Za(i.height/2);return v.fromEquirectangularTexture(n,r),e.set(r,v),r.addEventListener("dispose",o),t(v.texture,r.mapping)}return null}}return r},dispose:function(){e=new WeakMap}}}ci.physical={uniforms:Na([ci.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new ao(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new wo(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new ao},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new wo(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new wo(1,1,1)},specularColorMap:{value:null}}]),vertexShader:ii.meshphysical_vert,fragmentShader:ii.meshphysical_frag};var di=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.1,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2e3;return g(this,t),(n=e.call(this)).isOrthographicCamera=!0,n.type="OrthographicCamera",n.zoom=1,n.view=null,n.left=o,n.right=r,n.top=a,n.bottom=i,n.near=v,n.far=c,n.updateProjectionMatrix(),n}return b(t,[{key:"copy",value:function(n,e){return D(_(t.prototype),"copy",this).call(this,n,e),this.left=n.left,this.right=n.right,this.top=n.top,this.bottom=n.bottom,this.near=n.near,this.far=n.far,this.zoom=n.zoom,this.view=null===n.view?null:Object.assign({},n.view),this}},{key:"setViewOffset",value:function(n,e,t,o,r,a){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=n,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=o,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}},{key:"clearViewOffset",value:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}},{key:"updateProjectionMatrix",value:function(){var n=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),t=(this.right+this.left)/2,o=(this.top+this.bottom)/2,r=t-n,a=t+n,i=o+e,v=o-e;if(null!==this.view&&this.view.enabled){var c=(this.right-this.left)/this.view.fullWidth/this.zoom,s=(this.top-this.bottom)/this.view.fullHeight/this.zoom;a=(r+=c*this.view.offsetX)+c*this.view.width,v=(i-=s*this.view.offsetY)-s*this.view.height}this.projectionMatrix.makeOrthographic(r,a,i,v,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}},{key:"toJSON",value:function(n){var e=D(_(t.prototype),"toJSON",this).call(this,n);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,null!==this.view&&(e.object.view=Object.assign({},this.view)),e}}]),t}(Va),hi=[.125,.215,.35,.446,.526,.582],xi=20,gi=new di,yi=new wo,bi=null,Ui=(1+Math.sqrt(5))/2,_i=1/Ui,wi=[new Oo(1,1,1),new Oo(-1,1,1),new Oo(1,1,-1),new Oo(-1,1,-1),new Oo(0,Ui,_i),new Oo(0,Ui,-_i),new Oo(_i,0,Ui),new Oo(-_i,0,Ui),new Oo(Ui,_i,0),new Oo(-Ui,_i,0)],Si=function(){function n(e){g(this,n),this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}return b(n,[{key:"fromScene",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.1,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100;bi=this._renderer.getRenderTarget(),this._setSize(256);var r=this._allocateTargets();return r.depthBuffer=!0,this._sceneToCubeUV(n,t,o,r),e>0&&this._blur(r,0,0,e),this._applyPMREM(r),this._cleanup(r),r}},{key:"fromEquirectangular",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return this._fromTexture(n,e)}},{key:"fromCubemap",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return this._fromTexture(n,e)}},{key:"compileCubemapShader",value:function(){null===this._cubemapMaterial&&(this._cubemapMaterial=Ci(),this._compileMaterial(this._cubemapMaterial))}},{key:"compileEquirectangularShader",value:function(){null===this._equirectMaterial&&(this._equirectMaterial=zi(),this._compileMaterial(this._equirectMaterial))}},{key:"dispose",value:function(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}},{key:"_setSize",value:function(n){this._lodMax=Math.floor(Math.log2(n)),this._cubeSize=Math.pow(2,this._lodMax)}},{key:"_dispose",value:function(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(var n=0;n<this._lodPlanes.length;n++)this._lodPlanes[n].dispose()}},{key:"_cleanup",value:function(n){this._renderer.setRenderTarget(bi),n.scissorTest=!1,ki(n,0,0,n.width,n.height)}},{key:"_fromTexture",value:function(n,e){n.mapping===jn||n.mapping===In?this._setSize(0===n.image.length?16:n.image[0].width||n.image[0].image.width):this._setSize(n.image.width/4),bi=this._renderer.getRenderTarget();var t=e||this._allocateTargets();return this._textureToCubeUV(n,t),this._applyPMREM(t),this._cleanup(t),t}},{key:"_allocateTargets",value:function(){var n=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,t={magFilter:Xn,minFilter:Xn,generateMipmaps:!1,type:ae,format:ue,encoding:vt,depthBuffer:!1},o=Mi(n,e,t);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==n){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=Mi(n,e,t);var r=this._lodMax,a=function(n){for(var e=[],t=[],o=[],r=n,a=n-4+1+hi.length,i=0;i<a;i++){var v=Math.pow(2,r);t.push(v);var c=1/v;i>n-4?c=hi[i-n+4-1]:0===i&&(c=0),o.push(c);for(var s=1/(v-2),l=-s,u=1+s,f=[l,l,u,l,u,u,l,l,u,u,l,u],p=6,m=6,d=3,h=2,x=1,g=new Float32Array(d*m*p),y=new Float32Array(h*m*p),b=new Float32Array(x*m*p),U=0;U<p;U++){var _=U%3*2/3-1,w=U>2?0:-1,S=[_,w,0,_+2/3,w,0,_+2/3,w+1,0,_,w,0,_+2/3,w+1,0,_,w+1,0];g.set(S,d*m*U),y.set(f,h*m*U);var M=[U,U,U,U,U,U];b.set(M,x*m*U)}var k=new ya;k.setAttribute("position",new ea(g,d)),k.setAttribute("uv",new ea(y,h)),k.setAttribute("faceIndex",new ea(b,x)),e.push(k),r>4&&r--}return{lodPlanes:e,sizeLods:t,sigmas:o}}(r);this._sizeLods=a.sizeLods,this._lodPlanes=a.lodPlanes,this._sigmas=a.sigmas,this._blurMaterial=function(n,e,t){var o=new Float32Array(xi),r=new Oo(0,1,0);return new qa({name:"SphericalGaussianBlur",defines:{n:xi,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:"".concat(n,".0")},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:o},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:r}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:X,depthTest:!1,depthWrite:!1})}(r,n,e)}return o}},{key:"_compileMaterial",value:function(n){var e=new Oa(this._lodPlanes[0],n);this._renderer.compile(e,gi)}},{key:"_sceneToCubeUV",value:function(n,e,t,o){var r=new Wa(90,1,e,t),a=[1,-1,1,1,1,1],i=[1,1,1,-1,-1,-1],v=this._renderer,c=v.autoClear,s=v.toneMapping;v.getClearColor(yi),v.toneMapping=zn,v.autoClear=!1;var l=new Kr({name:"PMREM.Background",side:W,depthWrite:!1,depthTest:!1}),u=new Oa(new La,l),f=!1,p=n.background;p?p.isColor&&(l.color.copy(p),n.background=null,f=!0):(l.color.copy(yi),f=!0);for(var m=0;m<6;m++){var d=m%3;0===d?(r.up.set(0,a[m],0),r.lookAt(i[m],0,0)):1===d?(r.up.set(0,0,a[m]),r.lookAt(0,i[m],0)):(r.up.set(0,a[m],0),r.lookAt(0,0,i[m]));var h=this._cubeSize;ki(o,d*h,m>2?h:0,h,h),v.setRenderTarget(o),f&&v.render(u,r),v.render(n,r)}u.geometry.dispose(),u.material.dispose(),v.toneMapping=s,v.autoClear=c,n.background=p}},{key:"_textureToCubeUV",value:function(n,e){var t=this._renderer,o=n.mapping===jn||n.mapping===In;o?(null===this._cubemapMaterial&&(this._cubemapMaterial=Ci()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===n.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=zi());var r=o?this._cubemapMaterial:this._equirectMaterial,a=new Oa(this._lodPlanes[0],r);r.uniforms.envMap.value=n;var i=this._cubeSize;ki(e,0,0,3*i,2*i),t.setRenderTarget(e),t.render(a,gi)}},{key:"_applyPMREM",value:function(n){var e=this._renderer,t=e.autoClear;e.autoClear=!1;for(var o=1;o<this._lodPlanes.length;o++){var r=Math.sqrt(this._sigmas[o]*this._sigmas[o]-this._sigmas[o-1]*this._sigmas[o-1]),a=wi[(o-1)%wi.length];this._blur(n,o-1,o,r,a)}e.autoClear=t}},{key:"_blur",value:function(n,e,t,o,r){var a=this._pingPongRenderTarget;this._halfBlur(n,a,e,t,o,"latitudinal",r),this._halfBlur(a,n,t,t,o,"longitudinal",r)}},{key:"_halfBlur",value:function(n,e,t,o,r,a,i){var v=this._renderer,c=this._blurMaterial;"latitudinal"!==a&&"longitudinal"!==a&&console.error("blur direction must be either latitudinal or longitudinal!");var s=new Oa(this._lodPlanes[o],c),l=c.uniforms,u=this._sizeLods[t]-1,f=isFinite(r)?Math.PI/(2*u):2*Math.PI/39,p=r/f,m=isFinite(r)?1+Math.floor(3*p):xi;m>xi&&console.warn("sigmaRadians, ".concat(r,", is too large and will clip, as it requested ").concat(m," samples when the maximum is set to ").concat(xi));for(var d=[],h=0,x=0;x<xi;++x){var g=x/p,y=Math.exp(-g*g/2);d.push(y),0===x?h+=y:x<m&&(h+=2*y)}for(var b=0;b<d.length;b++)d[b]=d[b]/h;l.envMap.value=n.texture,l.samples.value=m,l.weights.value=d,l.latitudinal.value="latitudinal"===a,i&&(l.poleAxis.value=i);var U=this._lodMax;l.dTheta.value=f,l.mipInt.value=U-t;var _=this._sizeLods[o];ki(e,3*_*(o>U-4?o-U+4:0),4*(this._cubeSize-_),3*_,2*_),v.setRenderTarget(e),v.render(s,gi)}}]),n}();function Mi(n,e,t){var o=new Ro(n,e,t);return o.texture.mapping=An,o.texture.name="PMREM.cubeUv",o.scissorTest=!0,o}function ki(n,e,t,o,r){n.viewport.set(e,t,o,r),n.scissor.set(e,t,o,r)}function zi(){return new qa({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:X,depthTest:!1,depthWrite:!1})}function Ci(){return new qa({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:X,depthTest:!1,depthWrite:!1})}function Ti(n){var e=new WeakMap,t=null;function o(n){var t=n.target;t.removeEventListener("dispose",o);var r=e.get(t);void 0!==r&&(e.delete(t),r.dispose())}return{get:function(r){if(r&&r.isTexture){var a=r.mapping,i=a===En||a===On,v=a===jn||a===In;if(i||v){if(r.isRenderTargetTexture&&!0===r.needsPMREMUpdate){r.needsPMREMUpdate=!1;var c=e.get(r);return null===t&&(t=new Si(n)),c=i?t.fromEquirectangular(r,c):t.fromCubemap(r,c),e.set(r,c),c.texture}if(e.has(r))return e.get(r).texture;var s=r.image;if(i&&s&&s.height>0||v&&s&&function(n){for(var e=0,t=6,o=0;o<t;o++)void 0!==n[o]&&e++;return e===t}(s)){null===t&&(t=new Si(n));var l=i?t.fromEquirectangular(r):t.fromCubemap(r);return e.set(r,l),r.addEventListener("dispose",o),l.texture}return null}}return r},dispose:function(){e=new WeakMap,null!==t&&(t.dispose(),t=null)}}}function Ri(n){var e={};function t(t){if(void 0!==e[t])return e[t];var o;switch(t){case"WEBGL_depth_texture":o=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":o=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":o=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":o=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:o=n.getExtension(t)}return e[t]=o,o}return{has:function(n){return null!==t(n)},init:function(n){n.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(n){var e=t(n);return null===e&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),e}}}function Di(n,e,t,o){var r={},a=new WeakMap;function i(n){var v=n.target;for(var c in null!==v.index&&e.remove(v.index),v.attributes)e.remove(v.attributes[c]);v.removeEventListener("dispose",i),delete r[v.id];var s=a.get(v);s&&(e.remove(s),a.delete(v)),o.releaseStatesOfGeometry(v),!0===v.isInstancedBufferGeometry&&delete v._maxInstanceCount,t.memory.geometries--}function v(n){var t=[],o=n.index,r=n.attributes.position,i=0;if(null!==o){var v=o.array;i=o.version;for(var c=0,s=v.length;c<s;c+=3){var l=v[c+0],u=v[c+1],f=v[c+2];t.push(l,u,u,f,f,l)}}else{var p=r.array;i=r.version;for(var m=0,d=p.length/3-1;m<d;m+=3){var h=m+0,x=m+1,g=m+2;t.push(h,x,x,g,g,h)}}var y=new(vo(t)?ca:ia)(t,1);y.version=i;var b=a.get(n);b&&e.remove(b),a.set(n,y)}return{get:function(n,e){return!0===r[e.id]||(e.addEventListener("dispose",i),r[e.id]=!0,t.memory.geometries++),e},update:function(n){var t=n.attributes;for(var o in t)e.update(t[o],34962);var r=n.morphAttributes;for(var a in r)for(var i=r[a],v=0,c=i.length;v<c;v++)e.update(i[v],34962)},getWireframeAttribute:function(n){var e=a.get(n);if(e){var t=n.index;null!==t&&e.version<t.version&&v(n)}else v(n);return a.get(n)}}}function Pi(n,e,t,o){var r,a,i,v=o.isWebGL2;this.setMode=function(n){r=n},this.setIndex=function(n){a=n.type,i=n.bytesPerElement},this.render=function(e,o){n.drawElements(r,o,a,e*i),t.update(o,r,1)},this.renderInstances=function(o,c,s){if(0!==s){var l,u;if(v)l=n,u="drawElementsInstanced";else if(u="drawElementsInstancedANGLE",null===(l=e.get("ANGLE_instanced_arrays")))return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[u](r,c,a,o*i,s),t.update(c,r,s)}}}function Fi(n){var e={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:e,programs:null,autoReset:!0,reset:function(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0},update:function(n,t,o){switch(e.calls++,t){case 4:e.triangles+=o*(n/3);break;case 1:e.lines+=o*(n/2);break;case 3:e.lines+=o*(n-1);break;case 2:e.lines+=o*n;break;case 0:e.points+=o*n;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",t)}}}}function ji(n,e){return n[0]-e[0]}function Ii(n,e){return Math.abs(e[1])-Math.abs(n[1])}function Ei(n,e,t){for(var o={},r=new Float32Array(8),a=new WeakMap,i=new To,v=[],c=0;c<8;c++)v[c]=[c,0];return{update:function(c,s,l,u){var f=c.morphTargetInfluences;if(!0===e.isWebGL2){var p=s.morphAttributes.position||s.morphAttributes.normal||s.morphAttributes.color,m=void 0!==p?p.length:0,d=a.get(s);if(void 0===d||d.count!==m){void 0!==d&&d.texture.dispose();var h=void 0!==s.morphAttributes.position,x=void 0!==s.morphAttributes.normal,g=void 0!==s.morphAttributes.color,y=s.morphAttributes.position||[],b=s.morphAttributes.normal||[],U=s.morphAttributes.color||[],_=0;!0===h&&(_=1),!0===x&&(_=2),!0===g&&(_=3);var w=s.attributes.position.count*_,S=1;w>e.maxTextureSize&&(S=Math.ceil(w/e.maxTextureSize),w=e.maxTextureSize);var M=new Float32Array(w*S*4*m),k=new Do(M,w,S,m);k.type=re,k.needsUpdate=!0;for(var z=4*_,C=0;C<m;C++)for(var T=y[C],R=b[C],D=U[C],P=w*S*4*C,F=0;F<T.count;F++){var j=F*z;!0===h&&(i.fromBufferAttribute(T,F),M[P+j+0]=i.x,M[P+j+1]=i.y,M[P+j+2]=i.z,M[P+j+3]=0),!0===x&&(i.fromBufferAttribute(R,F),M[P+j+4]=i.x,M[P+j+5]=i.y,M[P+j+6]=i.z,M[P+j+7]=0),!0===g&&(i.fromBufferAttribute(D,F),M[P+j+8]=i.x,M[P+j+9]=i.y,M[P+j+10]=i.z,M[P+j+11]=4===D.itemSize?i.w:1)}d={count:m,texture:k,size:new ao(w,S)},a.set(s,d),s.addEventListener("dispose",(function n(){k.dispose(),a.delete(s),s.removeEventListener("dispose",n)}))}for(var I=0,E=0;E<f.length;E++)I+=f[E];var O=s.morphTargetsRelative?1:1-I;u.getUniforms().setValue(n,"morphTargetBaseInfluence",O),u.getUniforms().setValue(n,"morphTargetInfluences",f),u.getUniforms().setValue(n,"morphTargetsTexture",d.texture,t),u.getUniforms().setValue(n,"morphTargetsTextureSize",d.size)}else{var A=void 0===f?0:f.length,L=o[s.id];if(void 0===L||L.length!==A){L=[];for(var G=0;G<A;G++)L[G]=[G,0];o[s.id]=L}for(var N=0;N<A;N++){var B=L[N];B[0]=N,B[1]=f[N]}L.sort(Ii);for(var q=0;q<8;q++)q<A&&L[q][1]?(v[q][0]=L[q][0],v[q][1]=L[q][1]):(v[q][0]=Number.MAX_SAFE_INTEGER,v[q][1]=0);v.sort(ji);for(var V=s.morphAttributes.position,W=s.morphAttributes.normal,H=0,X=0;X<8;X++){var Y=v[X],Z=Y[0],Q=Y[1];Z!==Number.MAX_SAFE_INTEGER&&Q?(V&&s.getAttribute("morphTarget"+X)!==V[Z]&&s.setAttribute("morphTarget"+X,V[Z]),W&&s.getAttribute("morphNormal"+X)!==W[Z]&&s.setAttribute("morphNormal"+X,W[Z]),r[X]=Q,H+=Q):(V&&!0===s.hasAttribute("morphTarget"+X)&&s.deleteAttribute("morphTarget"+X),W&&!0===s.hasAttribute("morphNormal"+X)&&s.deleteAttribute("morphNormal"+X),r[X]=0)}var J=s.morphTargetsRelative?1:1-H;u.getUniforms().setValue(n,"morphTargetBaseInfluence",J),u.getUniforms().setValue(n,"morphTargetInfluences",r)}}}}function Oi(n,e,t,o){var r=new WeakMap;function a(n){var e=n.target;e.removeEventListener("dispose",a),t.remove(e.instanceMatrix),null!==e.instanceColor&&t.remove(e.instanceColor)}return{update:function(n){var i=o.render.frame,v=n.geometry,c=e.get(n,v);return r.get(c)!==i&&(e.update(c),r.set(c,i)),n.isInstancedMesh&&(!1===n.hasEventListener("dispose",a)&&n.addEventListener("dispose",a),t.update(n.instanceMatrix,34962),null!==n.instanceColor&&t.update(n.instanceColor,34962)),c},dispose:function(){r=new WeakMap}}}var Ai=new Co,Li=new Do,Gi=new Fo,Ni=new Ya,Bi=[],qi=[],Vi=new Float32Array(16),Wi=new Float32Array(9),Hi=new Float32Array(4);function Xi(n,e,t){var o=n[0];if(o<=0||o>0)return n;var r=e*t,a=Bi[r];if(void 0===a&&(a=new Float32Array(r),Bi[r]=a),0!==e){o.toArray(a,0);for(var i=1,v=0;i!==e;++i)v+=t,n[i].toArray(a,v)}return a}function Yi(n,e){if(n.length!==e.length)return!1;for(var t=0,o=n.length;t<o;t++)if(n[t]!==e[t])return!1;return!0}function Zi(n,e){for(var t=0,o=e.length;t<o;t++)n[t]=e[t]}function Qi(n,e){var t=qi[e];void 0===t&&(t=new Int32Array(e),qi[e]=t);for(var o=0;o!==e;++o)t[o]=n.allocateTextureUnit();return t}function Ji(n,e){var t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function Ki(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y||(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Yi(t,e))return;n.uniform2fv(this.addr,e),Zi(t,e)}}function $i(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z||(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(void 0!==e.r)t[0]===e.r&&t[1]===e.g&&t[2]===e.b||(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Yi(t,e))return;n.uniform3fv(this.addr,e),Zi(t,e)}}function nv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z&&t[3]===e.w||(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Yi(t,e))return;n.uniform4fv(this.addr,e),Zi(t,e)}}function ev(n,e){var t=this.cache,o=e.elements;if(void 0===o){if(Yi(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Zi(t,e)}else{if(Yi(t,o))return;Hi.set(o),n.uniformMatrix2fv(this.addr,!1,Hi),Zi(t,o)}}function tv(n,e){var t=this.cache,o=e.elements;if(void 0===o){if(Yi(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Zi(t,e)}else{if(Yi(t,o))return;Wi.set(o),n.uniformMatrix3fv(this.addr,!1,Wi),Zi(t,o)}}function ov(n,e){var t=this.cache,o=e.elements;if(void 0===o){if(Yi(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Zi(t,e)}else{if(Yi(t,o))return;Vi.set(o),n.uniformMatrix4fv(this.addr,!1,Vi),Zi(t,o)}}function rv(n,e){var t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function av(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y||(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Yi(t,e))return;n.uniform2iv(this.addr,e),Zi(t,e)}}function iv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z||(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Yi(t,e))return;n.uniform3iv(this.addr,e),Zi(t,e)}}function vv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z&&t[3]===e.w||(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Yi(t,e))return;n.uniform4iv(this.addr,e),Zi(t,e)}}function cv(n,e){var t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function sv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y||(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Yi(t,e))return;n.uniform2uiv(this.addr,e),Zi(t,e)}}function lv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z||(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Yi(t,e))return;n.uniform3uiv(this.addr,e),Zi(t,e)}}function uv(n,e){var t=this.cache;if(void 0!==e.x)t[0]===e.x&&t[1]===e.y&&t[2]===e.z&&t[3]===e.w||(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Yi(t,e))return;n.uniform4uiv(this.addr,e),Zi(t,e)}}function fv(n,e,t){var o=this.cache,r=t.allocateTextureUnit();o[0]!==r&&(n.uniform1i(this.addr,r),o[0]=r),t.setTexture2D(e||Ai,r)}function pv(n,e,t){var o=this.cache,r=t.allocateTextureUnit();o[0]!==r&&(n.uniform1i(this.addr,r),o[0]=r),t.setTexture3D(e||Gi,r)}function mv(n,e,t){var o=this.cache,r=t.allocateTextureUnit();o[0]!==r&&(n.uniform1i(this.addr,r),o[0]=r),t.setTextureCube(e||Ni,r)}function dv(n,e,t){var o=this.cache,r=t.allocateTextureUnit();o[0]!==r&&(n.uniform1i(this.addr,r),o[0]=r),t.setTexture2DArray(e||Li,r)}function hv(n,e){n.uniform1fv(this.addr,e)}function xv(n,e){var t=Xi(e,this.size,2);n.uniform2fv(this.addr,t)}function gv(n,e){var t=Xi(e,this.size,3);n.uniform3fv(this.addr,t)}function yv(n,e){var t=Xi(e,this.size,4);n.uniform4fv(this.addr,t)}function bv(n,e){var t=Xi(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function Uv(n,e){var t=Xi(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function _v(n,e){var t=Xi(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function wv(n,e){n.uniform1iv(this.addr,e)}function Sv(n,e){n.uniform2iv(this.addr,e)}function Mv(n,e){n.uniform3iv(this.addr,e)}function kv(n,e){n.uniform4iv(this.addr,e)}function zv(n,e){n.uniform1uiv(this.addr,e)}function Cv(n,e){n.uniform2uiv(this.addr,e)}function Tv(n,e){n.uniform3uiv(this.addr,e)}function Rv(n,e){n.uniform4uiv(this.addr,e)}function Dv(n,e,t){var o=this.cache,r=e.length,a=Qi(t,r);Yi(o,a)||(n.uniform1iv(this.addr,a),Zi(o,a));for(var i=0;i!==r;++i)t.setTexture2D(e[i]||Ai,a[i])}function Pv(n,e,t){var o=this.cache,r=e.length,a=Qi(t,r);Yi(o,a)||(n.uniform1iv(this.addr,a),Zi(o,a));for(var i=0;i!==r;++i)t.setTexture3D(e[i]||Gi,a[i])}function Fv(n,e,t){var o=this.cache,r=e.length,a=Qi(t,r);Yi(o,a)||(n.uniform1iv(this.addr,a),Zi(o,a));for(var i=0;i!==r;++i)t.setTextureCube(e[i]||Ni,a[i])}function jv(n,e,t){var o=this.cache,r=e.length,a=Qi(t,r);Yi(o,a)||(n.uniform1iv(this.addr,a),Zi(o,a));for(var i=0;i!==r;++i)t.setTexture2DArray(e[i]||Li,a[i])}var Iv=b((function n(e,t,o){g(this,n),this.id=e,this.addr=o,this.cache=[],this.setValue=function(n){switch(n){case 5126:return Ji;case 35664:return Ki;case 35665:return $i;case 35666:return nv;case 35674:return ev;case 35675:return tv;case 35676:return ov;case 5124:case 35670:return rv;case 35667:case 35671:return av;case 35668:case 35672:return iv;case 35669:case 35673:return vv;case 5125:return cv;case 36294:return sv;case 36295:return lv;case 36296:return uv;case 35678:case 36198:case 36298:case 36306:case 35682:return fv;case 35679:case 36299:case 36307:return pv;case 35680:case 36300:case 36308:case 36293:return mv;case 36289:case 36303:case 36311:case 36292:return dv}}(t.type)})),Ev=b((function n(e,t,o){g(this,n),this.id=e,this.addr=o,this.cache=[],this.size=t.size,this.setValue=function(n){switch(n){case 5126:return hv;case 35664:return xv;case 35665:return gv;case 35666:return yv;case 35674:return bv;case 35675:return Uv;case 35676:return _v;case 5124:case 35670:return wv;case 35667:case 35671:return Sv;case 35668:case 35672:return Mv;case 35669:case 35673:return kv;case 5125:return zv;case 36294:return Cv;case 36295:return Tv;case 36296:return Rv;case 35678:case 36198:case 36298:case 36306:case 35682:return Dv;case 35679:case 36299:case 36307:return Pv;case 35680:case 36300:case 36308:case 36293:return Fv;case 36289:case 36303:case 36311:case 36292:return jv}}(t.type)})),Ov=function(){function n(e){g(this,n),this.id=e,this.seq=[],this.map={}}return b(n,[{key:"setValue",value:function(n,e,t){for(var o=this.seq,r=0,a=o.length;r!==a;++r){var i=o[r];i.setValue(n,e[i.id],t)}}}]),n}(),Av=/(\w+)(\])?(\[|\.)?/g;function Lv(n,e){n.seq.push(e),n.map[e.id]=e}function Gv(n,e,t){var o=n.name,r=o.length;for(Av.lastIndex=0;;){var a=Av.exec(o),i=Av.lastIndex,v=a[1],c="]"===a[2],s=a[3];if(c&&(v|=0),void 0===s||"["===s&&i+2===r){Lv(t,void 0===s?new Iv(v,n,e):new Ev(v,n,e));break}var l=t.map[v];void 0===l&&Lv(t,l=new Ov(v)),t=l}}var Nv=function(){function n(e,t){g(this,n),this.seq=[],this.map={};for(var o=e.getProgramParameter(t,35718),r=0;r<o;++r){var a=e.getActiveUniform(t,r);Gv(a,e.getUniformLocation(t,a.name),this)}}return b(n,[{key:"setValue",value:function(n,e,t,o){var r=this.map[e];void 0!==r&&r.setValue(n,t,o)}},{key:"setOptional",value:function(n,e,t){var o=e[t];void 0!==o&&this.setValue(n,t,o)}}],[{key:"upload",value:function(n,e,t,o){for(var r=0,a=e.length;r!==a;++r){var i=e[r],v=t[i.id];!1!==v.needsUpdate&&i.setValue(n,v.value,o)}}},{key:"seqWithValue",value:function(n,e){for(var t=[],o=0,r=n.length;o!==r;++o){var a=n[o];a.id in e&&t.push(a)}return t}}]),n}();function Bv(n,e,t){var o=n.createShader(e);return n.shaderSource(o,t),n.compileShader(o),o}var qv=0;function Vv(n,e,t){var o=n.getShaderParameter(e,35713),r=n.getShaderInfoLog(e).trim();if(o&&""===r)return"";var a=/ERROR: 0:(\d+)/.exec(r);if(a){var i=parseInt(a[1]);return t.toUpperCase()+"\n\n"+r+"\n\n"+function(n,e){for(var t=n.split("\n"),o=[],r=Math.max(e-6,0),a=Math.min(e+6,t.length),i=r;i<a;i++){var v=i+1;o.push("".concat(v===e?">":" "," ").concat(v,": ").concat(t[i]))}return o.join("\n")}(n.getShaderSource(e),i)}return r}function Wv(n,e){var t=function(n){switch(n){case vt:return["Linear","( value )"];case ct:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",n),["Linear","( value )"]}}(e);return"vec4 "+n+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function Hv(n,e){var t;switch(e){case Cn:t="Linear";break;case Tn:t="Reinhard";break;case Rn:t="OptimizedCineon";break;case Dn:t="ACESFilmic";break;case Pn:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function Xv(n){return""!==n}function Yv(n,e){var t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Zv(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}var Qv=/^[ \t]*#include +<([\w\d./]+)>/gm;function Jv(n){return n.replace(Qv,Kv)}function Kv(n,e){var t=ii[e];if(void 0===t)throw new Error("Can not resolve #include <"+e+">");return Jv(t)}var $v=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function nc(n){return n.replace($v,ec)}function ec(n,e,t,o){for(var r="",a=parseInt(e);a<parseInt(t);a++)r+=o.replace(/\[\s*i\s*\]/g,"[ "+a+" ]").replace(/UNROLLED_LOOP_INDEX/g,a);return r}function tc(n){var e="precision "+n.precision+" float;\nprecision "+n.precision+" int;";return"highp"===n.precision?e+="\n#define HIGH_PRECISION":"mediump"===n.precision?e+="\n#define MEDIUM_PRECISION":"lowp"===n.precision&&(e+="\n#define LOW_PRECISION"),e}function oc(n,e,t,o){var r,a,i=n.getContext(),v=t.defines,c=t.vertexShader,s=t.fragmentShader,l=function(n){var e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===N?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===B?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===q&&(e="SHADOWMAP_TYPE_VSM"),e}(t),u=function(n){var e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case jn:case In:e="ENVMAP_TYPE_CUBE";break;case An:e="ENVMAP_TYPE_CUBE_UV"}return e}(t),f=function(n){var e="ENVMAP_MODE_REFLECTION";n.envMap&&n.envMapMode===In&&(e="ENVMAP_MODE_REFRACTION");return e}(t),p=function(n){var e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case Sn:e="ENVMAP_BLENDING_MULTIPLY";break;case Mn:e="ENVMAP_BLENDING_MIX";break;case kn:e="ENVMAP_BLENDING_ADD"}return e}(t),m=function(n){var e=n.envMapCubeUVHeight;if(null===e)return null;var t=Math.log2(e)-2,o=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),112)),texelHeight:o,maxMip:t}}(t),d=t.isWebGL2?"":function(n){return[n.extensionDerivatives||n.envMapCubeUVHeight||n.bumpMap||n.tangentSpaceNormalMap||n.clearcoatNormalMap||n.flatShading||"physical"===n.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap||n.transmission)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Xv).join("\n")}(t),h=function(n){var e=[];for(var t in n){var o=n[t];!1!==o&&e.push("#define "+t+" "+o)}return e.join("\n")}(v),x=i.createProgram(),g=t.glslVersion?"#version "+t.glslVersion+"\n":"";t.isRawShaderMaterial?((r=[h].filter(Xv).join("\n")).length>0&&(r+="\n"),(a=[d,h].filter(Xv).join("\n")).length>0&&(a+="\n")):(r=[tc(t),"#define SHADER_NAME "+t.shaderName,h,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+f:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&!1===t.flatShading?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(Xv).join("\n"),a=[d,tc(t),"#define SHADER_NAME "+t.shaderName,h,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.envMap?"#define "+f:"",t.envMap?"#define "+p:"",m?"#define CUBEUV_TEXEL_WIDTH "+m.texelWidth:"",m?"#define CUBEUV_TEXEL_HEIGHT "+m.texelHeight:"",m?"#define CUBEUV_MAX_MIP "+m.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==zn?"#define TONE_MAPPING":"",t.toneMapping!==zn?ii.tonemapping_pars_fragment:"",t.toneMapping!==zn?Hv("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",ii.encodings_pars_fragment,Wv("linearToOutputTexel",t.outputEncoding),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"","\n"].filter(Xv).join("\n")),c=Zv(c=Yv(c=Jv(c),t),t),s=Zv(s=Yv(s=Jv(s),t),t),c=nc(c),s=nc(s),t.isWebGL2&&!0!==t.isRawShaderMaterial&&(g="#version 300 es\n",r=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+r,a=["#define varying in",t.glslVersion===Bt?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===Bt?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+a);var y,b,U=g+a+s,_=Bv(i,35633,g+r+c),w=Bv(i,35632,U);if(i.attachShader(x,_),i.attachShader(x,w),void 0!==t.index0AttributeName?i.bindAttribLocation(x,0,t.index0AttributeName):!0===t.morphTargets&&i.bindAttribLocation(x,0,"position"),i.linkProgram(x),n.debug.checkShaderErrors){var S=i.getProgramInfoLog(x).trim(),M=i.getShaderInfoLog(_).trim(),k=i.getShaderInfoLog(w).trim(),z=!0,C=!0;if(!1===i.getProgramParameter(x,35714)){z=!1;var T=Vv(i,_,"vertex"),R=Vv(i,w,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(x,35715)+"\n\nProgram Info Log: "+S+"\n"+T+"\n"+R)}else""!==S?console.warn("THREE.WebGLProgram: Program Info Log:",S):""!==M&&""!==k||(C=!1);C&&(this.diagnostics={runnable:z,programLog:S,vertexShader:{log:M,prefix:r},fragmentShader:{log:k,prefix:a}})}return i.deleteShader(_),i.deleteShader(w),this.getUniforms=function(){return void 0===y&&(y=new Nv(i,x)),y},this.getAttributes=function(){return void 0===b&&(b=function(n,e){for(var t={},o=n.getProgramParameter(e,35721),r=0;r<o;r++){var a=n.getActiveAttrib(e,r),i=a.name,v=1;35674===a.type&&(v=2),35675===a.type&&(v=3),35676===a.type&&(v=4),t[i]={type:a.type,location:n.getAttribLocation(e,i),locationSize:v}}return t}(i,x)),b},this.destroy=function(){o.releaseStatesOfProgram(this),i.deleteProgram(x),this.program=void 0},this.name=t.shaderName,this.id=qv++,this.cacheKey=e,this.usedTimes=1,this.program=x,this.vertexShader=_,this.fragmentShader=w,this}var rc=0,ac=function(){function n(){g(this,n),this.shaderCache=new Map,this.materialCache=new Map}return b(n,[{key:"update",value:function(n){var e=n.vertexShader,t=n.fragmentShader,o=this._getShaderStage(e),r=this._getShaderStage(t),a=this._getShaderCacheForMaterial(n);return!1===a.has(o)&&(a.add(o),o.usedTimes++),!1===a.has(r)&&(a.add(r),r.usedTimes++),this}},{key:"remove",value:function(n){var e,t=f(this.materialCache.get(n));try{for(t.s();!(e=t.n()).done;){var o=e.value;o.usedTimes--,0===o.usedTimes&&this.shaderCache.delete(o.code)}}catch(r){t.e(r)}finally{t.f()}return this.materialCache.delete(n),this}},{key:"getVertexShaderID",value:function(n){return this._getShaderStage(n.vertexShader).id}},{key:"getFragmentShaderID",value:function(n){return this._getShaderStage(n.fragmentShader).id}},{key:"dispose",value:function(){this.shaderCache.clear(),this.materialCache.clear()}},{key:"_getShaderCacheForMaterial",value:function(n){var e=this.materialCache,t=e.get(n);return void 0===t&&(t=new Set,e.set(n,t)),t}},{key:"_getShaderStage",value:function(n){var e=this.shaderCache,t=e.get(n);return void 0===t&&(t=new ic(n),e.set(n,t)),t}}]),n}(),ic=b((function n(e){g(this,n),this.id=rc++,this.code=e,this.usedTimes=0}));function vc(n,e,t,o,r,a,i){var v=new Sr,c=new ac,s=[],l=r.isWebGL2,u=r.logarithmicDepthBuffer,f=r.vertexTextures,p=r.precision,m={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};return{getParameters:function(a,v,s,d,h){var x=d.fog,g=h.geometry,y=a.isMeshStandardMaterial?d.environment:null,b=(a.isMeshStandardMaterial?t:e).get(a.envMap||y),U=b&&b.mapping===An?b.image.height:null,_=m[a.type];null!==a.precision&&(p=r.getMaxPrecision(a.precision))!==a.precision&&console.warn("THREE.WebGLProgram.getParameters:",a.precision,"not supported, using",p,"instead.");var w,S,M,k,z=g.morphAttributes.position||g.morphAttributes.normal||g.morphAttributes.color,C=void 0!==z?z.length:0,T=0;if(void 0!==g.morphAttributes.position&&(T=1),void 0!==g.morphAttributes.normal&&(T=2),void 0!==g.morphAttributes.color&&(T=3),_){var R=ci[_];w=R.vertexShader,S=R.fragmentShader}else w=a.vertexShader,S=a.fragmentShader,c.update(a),M=c.getVertexShaderID(a),k=c.getFragmentShaderID(a);var D=n.getRenderTarget(),P=a.alphaTest>0,F=a.clearcoat>0,j=a.iridescence>0;return{isWebGL2:l,shaderID:_,shaderName:a.type,vertexShader:w,fragmentShader:S,defines:a.defines,customVertexShaderID:M,customFragmentShaderID:k,isRawShaderMaterial:!0===a.isRawShaderMaterial,glslVersion:a.glslVersion,precision:p,instancing:!0===h.isInstancedMesh,instancingColor:!0===h.isInstancedMesh&&null!==h.instanceColor,supportsVertexTextures:f,outputEncoding:null===D?n.outputEncoding:!0===D.isXRRenderTarget?D.texture.encoding:vt,map:!!a.map,matcap:!!a.matcap,envMap:!!b,envMapMode:b&&b.mapping,envMapCubeUVHeight:U,lightMap:!!a.lightMap,aoMap:!!a.aoMap,emissiveMap:!!a.emissiveMap,bumpMap:!!a.bumpMap,normalMap:!!a.normalMap,objectSpaceNormalMap:a.normalMapType===ft,tangentSpaceNormalMap:a.normalMapType===ut,decodeVideoTexture:!!a.map&&!0===a.map.isVideoTexture&&a.map.encoding===ct,clearcoat:F,clearcoatMap:F&&!!a.clearcoatMap,clearcoatRoughnessMap:F&&!!a.clearcoatRoughnessMap,clearcoatNormalMap:F&&!!a.clearcoatNormalMap,iridescence:j,iridescenceMap:j&&!!a.iridescenceMap,iridescenceThicknessMap:j&&!!a.iridescenceThicknessMap,displacementMap:!!a.displacementMap,roughnessMap:!!a.roughnessMap,metalnessMap:!!a.metalnessMap,specularMap:!!a.specularMap,specularIntensityMap:!!a.specularIntensityMap,specularColorMap:!!a.specularColorMap,opaque:!1===a.transparent&&a.blending===Y,alphaMap:!!a.alphaMap,alphaTest:P,gradientMap:!!a.gradientMap,sheen:a.sheen>0,sheenColorMap:!!a.sheenColorMap,sheenRoughnessMap:!!a.sheenRoughnessMap,transmission:a.transmission>0,transmissionMap:!!a.transmissionMap,thicknessMap:!!a.thicknessMap,combine:a.combine,vertexTangents:!!a.normalMap&&!!g.attributes.tangent,vertexColors:a.vertexColors,vertexAlphas:!0===a.vertexColors&&!!g.attributes.color&&4===g.attributes.color.itemSize,vertexUvs:!!a.map||!!a.bumpMap||!!a.normalMap||!!a.specularMap||!!a.alphaMap||!!a.emissiveMap||!!a.roughnessMap||!!a.metalnessMap||!!a.clearcoatMap||!!a.clearcoatRoughnessMap||!!a.clearcoatNormalMap||!!a.iridescenceMap||!!a.iridescenceThicknessMap||!!a.displacementMap||!!a.transmissionMap||!!a.thicknessMap||!!a.specularIntensityMap||!!a.specularColorMap||!!a.sheenColorMap||!!a.sheenRoughnessMap,uvsVertexOnly:!(a.map||a.bumpMap||a.normalMap||a.specularMap||a.alphaMap||a.emissiveMap||a.roughnessMap||a.metalnessMap||a.clearcoatNormalMap||a.iridescenceMap||a.iridescenceThicknessMap||a.transmission>0||a.transmissionMap||a.thicknessMap||a.specularIntensityMap||a.specularColorMap||a.sheen>0||a.sheenColorMap||a.sheenRoughnessMap)&&!!a.displacementMap,fog:!!x,useFog:!0===a.fog,fogExp2:x&&x.isFogExp2,flatShading:!!a.flatShading,sizeAttenuation:a.sizeAttenuation,logarithmicDepthBuffer:u,skinning:!0===h.isSkinnedMesh,morphTargets:void 0!==g.morphAttributes.position,morphNormals:void 0!==g.morphAttributes.normal,morphColors:void 0!==g.morphAttributes.color,morphTargetsCount:C,morphTextureStride:T,numDirLights:v.directional.length,numPointLights:v.point.length,numSpotLights:v.spot.length,numSpotLightMaps:v.spotLightMap.length,numRectAreaLights:v.rectArea.length,numHemiLights:v.hemi.length,numDirLightShadows:v.directionalShadowMap.length,numPointLightShadows:v.pointShadowMap.length,numSpotLightShadows:v.spotShadowMap.length,numSpotLightShadowsWithMaps:v.numSpotLightShadowsWithMaps,numClippingPlanes:i.numPlanes,numClipIntersection:i.numIntersection,dithering:a.dithering,shadowMapEnabled:n.shadowMap.enabled&&s.length>0,shadowMapType:n.shadowMap.type,toneMapping:a.toneMapped?n.toneMapping:zn,physicallyCorrectLights:n.physicallyCorrectLights,premultipliedAlpha:a.premultipliedAlpha,doubleSided:a.side===H,flipSided:a.side===W,useDepthPacking:!!a.depthPacking,depthPacking:a.depthPacking||0,index0AttributeName:a.index0AttributeName,extensionDerivatives:a.extensions&&a.extensions.derivatives,extensionFragDepth:a.extensions&&a.extensions.fragDepth,extensionDrawBuffers:a.extensions&&a.extensions.drawBuffers,extensionShaderTextureLOD:a.extensions&&a.extensions.shaderTextureLOD,rendererExtensionFragDepth:l||o.has("EXT_frag_depth"),rendererExtensionDrawBuffers:l||o.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:l||o.has("EXT_shader_texture_lod"),customProgramCacheKey:a.customProgramCacheKey()}},getProgramCacheKey:function(e){var t=[];if(e.shaderID?t.push(e.shaderID):(t.push(e.customVertexShaderID),t.push(e.customFragmentShaderID)),void 0!==e.defines)for(var o in e.defines)t.push(o),t.push(e.defines[o]);return!1===e.isRawShaderMaterial&&(!function(n,e){n.push(e.precision),n.push(e.outputEncoding),n.push(e.envMapMode),n.push(e.envMapCubeUVHeight),n.push(e.combine),n.push(e.vertexUvs),n.push(e.fogExp2),n.push(e.sizeAttenuation),n.push(e.morphTargetsCount),n.push(e.morphAttributeCount),n.push(e.numDirLights),n.push(e.numPointLights),n.push(e.numSpotLights),n.push(e.numSpotLightMaps),n.push(e.numHemiLights),n.push(e.numRectAreaLights),n.push(e.numDirLightShadows),n.push(e.numPointLightShadows),n.push(e.numSpotLightShadows),n.push(e.numSpotLightShadowsWithMaps),n.push(e.shadowMapType),n.push(e.toneMapping),n.push(e.numClippingPlanes),n.push(e.numClipIntersection),n.push(e.depthPacking)}(t,e),function(n,e){v.disableAll(),e.isWebGL2&&v.enable(0);e.supportsVertexTextures&&v.enable(1);e.instancing&&v.enable(2);e.instancingColor&&v.enable(3);e.map&&v.enable(4);e.matcap&&v.enable(5);e.envMap&&v.enable(6);e.lightMap&&v.enable(7);e.aoMap&&v.enable(8);e.emissiveMap&&v.enable(9);e.bumpMap&&v.enable(10);e.normalMap&&v.enable(11);e.objectSpaceNormalMap&&v.enable(12);e.tangentSpaceNormalMap&&v.enable(13);e.clearcoat&&v.enable(14);e.clearcoatMap&&v.enable(15);e.clearcoatRoughnessMap&&v.enable(16);e.clearcoatNormalMap&&v.enable(17);e.iridescence&&v.enable(18);e.iridescenceMap&&v.enable(19);e.iridescenceThicknessMap&&v.enable(20);e.displacementMap&&v.enable(21);e.specularMap&&v.enable(22);e.roughnessMap&&v.enable(23);e.metalnessMap&&v.enable(24);e.gradientMap&&v.enable(25);e.alphaMap&&v.enable(26);e.alphaTest&&v.enable(27);e.vertexColors&&v.enable(28);e.vertexAlphas&&v.enable(29);e.vertexUvs&&v.enable(30);e.vertexTangents&&v.enable(31);e.uvsVertexOnly&&v.enable(32);n.push(v.mask),v.disableAll(),e.fog&&v.enable(0);e.useFog&&v.enable(1);e.flatShading&&v.enable(2);e.logarithmicDepthBuffer&&v.enable(3);e.skinning&&v.enable(4);e.morphTargets&&v.enable(5);e.morphNormals&&v.enable(6);e.morphColors&&v.enable(7);e.premultipliedAlpha&&v.enable(8);e.shadowMapEnabled&&v.enable(9);e.physicallyCorrectLights&&v.enable(10);e.doubleSided&&v.enable(11);e.flipSided&&v.enable(12);e.useDepthPacking&&v.enable(13);e.dithering&&v.enable(14);e.specularIntensityMap&&v.enable(15);e.specularColorMap&&v.enable(16);e.transmission&&v.enable(17);e.transmissionMap&&v.enable(18);e.thicknessMap&&v.enable(19);e.sheen&&v.enable(20);e.sheenColorMap&&v.enable(21);e.sheenRoughnessMap&&v.enable(22);e.decodeVideoTexture&&v.enable(23);e.opaque&&v.enable(24);n.push(v.mask)}(t,e),t.push(n.outputEncoding)),t.push(e.customProgramCacheKey),t.join()},getUniforms:function(n){var e,t=m[n.type];if(t){var o=ci[t];e=Ba.clone(o.uniforms)}else e=n.uniforms;return e},acquireProgram:function(e,t){for(var o,r=0,i=s.length;r<i;r++){var v=s[r];if(v.cacheKey===t){++(o=v).usedTimes;break}}return void 0===o&&(o=new oc(n,t,e,a),s.push(o)),o},releaseProgram:function(n){if(0===--n.usedTimes){var e=s.indexOf(n);s[e]=s[s.length-1],s.pop(),n.destroy()}},releaseShaderCache:function(n){c.remove(n)},programs:s,dispose:function(){c.dispose()}}}function cc(){var n=new WeakMap;return{get:function(e){var t=n.get(e);return void 0===t&&(t={},n.set(e,t)),t},remove:function(e){n.delete(e)},update:function(e,t,o){n.get(e)[t]=o},dispose:function(){n=new WeakMap}}}function sc(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function lc(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function uc(){var n=[],e=0,t=[],o=[],r=[];function a(t,o,r,a,i,v){var c=n[e];return void 0===c?(c={id:t.id,object:t,geometry:o,material:r,groupOrder:a,renderOrder:t.renderOrder,z:i,group:v},n[e]=c):(c.id=t.id,c.object=t,c.geometry=o,c.material=r,c.groupOrder=a,c.renderOrder=t.renderOrder,c.z=i,c.group=v),e++,c}return{opaque:t,transmissive:o,transparent:r,init:function(){e=0,t.length=0,o.length=0,r.length=0},push:function(n,e,i,v,c,s){var l=a(n,e,i,v,c,s);i.transmission>0?o.push(l):!0===i.transparent?r.push(l):t.push(l)},unshift:function(n,e,i,v,c,s){var l=a(n,e,i,v,c,s);i.transmission>0?o.unshift(l):!0===i.transparent?r.unshift(l):t.unshift(l)},finish:function(){for(var t=e,o=n.length;t<o;t++){var r=n[t];if(null===r.id)break;r.id=null,r.object=null,r.geometry=null,r.material=null,r.group=null}},sort:function(n,e){t.length>1&&t.sort(n||sc),o.length>1&&o.sort(e||lc),r.length>1&&r.sort(e||lc)}}}function fc(){var n=new WeakMap;return{get:function(e,t){var o,r=n.get(e);return void 0===r?(o=new uc,n.set(e,[o])):t>=r.length?(o=new uc,r.push(o)):o=r[t],o},dispose:function(){n=new WeakMap}}}function pc(){var n={};return{get:function(e){if(void 0!==n[e.id])return n[e.id];var t;switch(e.type){case"DirectionalLight":t={direction:new Oo,color:new wo};break;case"SpotLight":t={position:new Oo,direction:new Oo,color:new wo,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new Oo,color:new wo,distance:0,decay:0};break;case"HemisphereLight":t={direction:new Oo,skyColor:new wo,groundColor:new wo};break;case"RectAreaLight":t={color:new wo,position:new Oo,halfWidth:new Oo,halfHeight:new Oo}}return n[e.id]=t,t}}}var mc=0;function dc(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}function hc(n,e){for(var t=new pc,o=function(){var n={};return{get:function(e){if(void 0!==n[e.id])return n[e.id];var t;switch(e.type){case"DirectionalLight":case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ao};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ao,shadowCameraNear:1,shadowCameraFar:1e3}}return n[e.id]=t,t}}}(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0},a=0;a<9;a++)r.probe.push(new Oo);var i=new Oo,v=new pr,c=new pr;return{setup:function(a,i){for(var v=0,c=0,s=0,l=0;l<9;l++)r.probe[l].set(0,0,0);var u=0,f=0,p=0,m=0,d=0,h=0,x=0,g=0,y=0,b=0;a.sort(dc);for(var U=!0!==i?Math.PI:1,_=0,w=a.length;_<w;_++){var S=a[_],M=S.color,k=S.intensity,z=S.distance,C=S.shadow&&S.shadow.map?S.shadow.map.texture:null;if(S.isAmbientLight)v+=M.r*k*U,c+=M.g*k*U,s+=M.b*k*U;else if(S.isLightProbe)for(var T=0;T<9;T++)r.probe[T].addScaledVector(S.sh.coefficients[T],k);else if(S.isDirectionalLight){var R=t.get(S);if(R.color.copy(S.color).multiplyScalar(S.intensity*U),S.castShadow){var D=S.shadow,P=o.get(S);P.shadowBias=D.bias,P.shadowNormalBias=D.normalBias,P.shadowRadius=D.radius,P.shadowMapSize=D.mapSize,r.directionalShadow[u]=P,r.directionalShadowMap[u]=C,r.directionalShadowMatrix[u]=S.shadow.matrix,h++}r.directional[u]=R,u++}else if(S.isSpotLight){var F=t.get(S);F.position.setFromMatrixPosition(S.matrixWorld),F.color.copy(M).multiplyScalar(k*U),F.distance=z,F.coneCos=Math.cos(S.angle),F.penumbraCos=Math.cos(S.angle*(1-S.penumbra)),F.decay=S.decay,r.spot[p]=F;var j=S.shadow;if(S.map&&(r.spotLightMap[y]=S.map,y++,j.updateMatrices(S),S.castShadow&&b++),r.spotLightMatrix[p]=j.matrix,S.castShadow){var I=o.get(S);I.shadowBias=j.bias,I.shadowNormalBias=j.normalBias,I.shadowRadius=j.radius,I.shadowMapSize=j.mapSize,r.spotShadow[p]=I,r.spotShadowMap[p]=C,g++}p++}else if(S.isRectAreaLight){var E=t.get(S);E.color.copy(M).multiplyScalar(k),E.halfWidth.set(.5*S.width,0,0),E.halfHeight.set(0,.5*S.height,0),r.rectArea[m]=E,m++}else if(S.isPointLight){var O=t.get(S);if(O.color.copy(S.color).multiplyScalar(S.intensity*U),O.distance=S.distance,O.decay=S.decay,S.castShadow){var A=S.shadow,L=o.get(S);L.shadowBias=A.bias,L.shadowNormalBias=A.normalBias,L.shadowRadius=A.radius,L.shadowMapSize=A.mapSize,L.shadowCameraNear=A.camera.near,L.shadowCameraFar=A.camera.far,r.pointShadow[f]=L,r.pointShadowMap[f]=C,r.pointShadowMatrix[f]=S.shadow.matrix,x++}r.point[f]=O,f++}else if(S.isHemisphereLight){var G=t.get(S);G.skyColor.copy(S.color).multiplyScalar(k*U),G.groundColor.copy(S.groundColor).multiplyScalar(k*U),r.hemi[d]=G,d++}}m>0&&(e.isWebGL2||!0===n.has("OES_texture_float_linear")?(r.rectAreaLTC1=vi.LTC_FLOAT_1,r.rectAreaLTC2=vi.LTC_FLOAT_2):!0===n.has("OES_texture_half_float_linear")?(r.rectAreaLTC1=vi.LTC_HALF_1,r.rectAreaLTC2=vi.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=v,r.ambient[1]=c,r.ambient[2]=s;var N=r.hash;N.directionalLength===u&&N.pointLength===f&&N.spotLength===p&&N.rectAreaLength===m&&N.hemiLength===d&&N.numDirectionalShadows===h&&N.numPointShadows===x&&N.numSpotShadows===g&&N.numSpotMaps===y||(r.directional.length=u,r.spot.length=p,r.rectArea.length=m,r.point.length=f,r.hemi.length=d,r.directionalShadow.length=h,r.directionalShadowMap.length=h,r.pointShadow.length=x,r.pointShadowMap.length=x,r.spotShadow.length=g,r.spotShadowMap.length=g,r.directionalShadowMatrix.length=h,r.pointShadowMatrix.length=x,r.spotLightMatrix.length=g+y-b,r.spotLightMap.length=y,r.numSpotLightShadowsWithMaps=b,N.directionalLength=u,N.pointLength=f,N.spotLength=p,N.rectAreaLength=m,N.hemiLength=d,N.numDirectionalShadows=h,N.numPointShadows=x,N.numSpotShadows=g,N.numSpotMaps=y,r.version=mc++)},setupView:function(n,e){for(var t=0,o=0,a=0,s=0,l=0,u=e.matrixWorldInverse,f=0,p=n.length;f<p;f++){var m=n[f];if(m.isDirectionalLight){var d=r.directional[t];d.direction.setFromMatrixPosition(m.matrixWorld),i.setFromMatrixPosition(m.target.matrixWorld),d.direction.sub(i),d.direction.transformDirection(u),t++}else if(m.isSpotLight){var h=r.spot[a];h.position.setFromMatrixPosition(m.matrixWorld),h.position.applyMatrix4(u),h.direction.setFromMatrixPosition(m.matrixWorld),i.setFromMatrixPosition(m.target.matrixWorld),h.direction.sub(i),h.direction.transformDirection(u),a++}else if(m.isRectAreaLight){var x=r.rectArea[s];x.position.setFromMatrixPosition(m.matrixWorld),x.position.applyMatrix4(u),c.identity(),v.copy(m.matrixWorld),v.premultiply(u),c.extractRotation(v),x.halfWidth.set(.5*m.width,0,0),x.halfHeight.set(0,.5*m.height,0),x.halfWidth.applyMatrix4(c),x.halfHeight.applyMatrix4(c),s++}else if(m.isPointLight){var g=r.point[o];g.position.setFromMatrixPosition(m.matrixWorld),g.position.applyMatrix4(u),o++}else if(m.isHemisphereLight){var y=r.hemi[l];y.direction.setFromMatrixPosition(m.matrixWorld),y.direction.transformDirection(u),l++}}},state:r}}function xc(n,e){var t=new hc(n,e),o=[],r=[];return{init:function(){o.length=0,r.length=0},state:{lightsArray:o,shadowsArray:r,lights:t},setupLights:function(n){t.setup(o,n)},setupLightsView:function(n){t.setupView(o,n)},pushLight:function(n){o.push(n)},pushShadow:function(n){r.push(n)}}}function gc(n,e){var t=new WeakMap;return{get:function(o){var r,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=t.get(o);return void 0===i?(r=new xc(n,e),t.set(o,[r])):a>=i.length?(r=new xc(n,e),i.push(r)):r=i[a],r},dispose:function(){t=new WeakMap}}}var yc=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).isMeshDepthMaterial=!0,o.type="MeshDepthMaterial",o.depthPacking=st,o.map=null,o.alphaMap=null,o.displacementMap=null,o.displacementScale=1,o.displacementBias=0,o.wireframe=!1,o.wireframeLinewidth=1,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.depthPacking=n.depthPacking,this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this}}]),t}(Jr),bc=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).isMeshDistanceMaterial=!0,o.type="MeshDistanceMaterial",o.referencePosition=new Oo,o.nearDistance=1,o.farDistance=1e3,o.map=null,o.alphaMap=null,o.displacementMap=null,o.displacementScale=1,o.displacementBias=0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.referencePosition.copy(n.referencePosition),this.nearDistance=n.nearDistance,this.farDistance=n.farDistance,this.map=n.map,this.alphaMap=n.alphaMap,this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this}}]),t}(Jr);function Uc(n,e,t){var o=new ti,r=new ao,a=new ao,i=new To,v=new yc({depthPacking:lt}),c=new bc,s={},l=t.maxTextureSize,u={0:W,1:V,2:H},f=new qa({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new ao},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),p=f.clone();p.defines.HORIZONTAL_PASS=1;var m=new ya;m.setAttribute("position",new ea(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));var d=new Oa(m,f),h=this;function x(t,o){var a=e.update(d);f.defines.VSM_SAMPLES!==t.blurSamples&&(f.defines.VSM_SAMPLES=t.blurSamples,p.defines.VSM_SAMPLES=t.blurSamples,f.needsUpdate=!0,p.needsUpdate=!0),null===t.mapPass&&(t.mapPass=new Ro(r.x,r.y)),f.uniforms.shadow_pass.value=t.map.texture,f.uniforms.resolution.value=t.mapSize,f.uniforms.radius.value=t.radius,n.setRenderTarget(t.mapPass),n.clear(),n.renderBufferDirect(o,null,a,f,d,null),p.uniforms.shadow_pass.value=t.mapPass.texture,p.uniforms.resolution.value=t.mapSize,p.uniforms.radius.value=t.radius,n.setRenderTarget(t.map),n.clear(),n.renderBufferDirect(o,null,a,p,d,null)}function g(e,t,o,r,a,i){var l=null,f=!0===o.isPointLight?e.customDistanceMaterial:e.customDepthMaterial;if(l=void 0!==f?f:!0===o.isPointLight?c:v,n.localClippingEnabled&&!0===t.clipShadows&&Array.isArray(t.clippingPlanes)&&0!==t.clippingPlanes.length||t.displacementMap&&0!==t.displacementScale||t.alphaMap&&t.alphaTest>0){var p=l.uuid,m=t.uuid,d=s[p];void 0===d&&(d={},s[p]=d);var h=d[m];void 0===h&&(h=l.clone(),d[m]=h),l=h}return l.visible=t.visible,l.wireframe=t.wireframe,l.side=i===q?null!==t.shadowSide?t.shadowSide:t.side:null!==t.shadowSide?t.shadowSide:u[t.side],l.alphaMap=t.alphaMap,l.alphaTest=t.alphaTest,l.clipShadows=t.clipShadows,l.clippingPlanes=t.clippingPlanes,l.clipIntersection=t.clipIntersection,l.displacementMap=t.displacementMap,l.displacementScale=t.displacementScale,l.displacementBias=t.displacementBias,l.wireframeLinewidth=t.wireframeLinewidth,l.linewidth=t.linewidth,!0===o.isPointLight&&!0===l.isMeshDistanceMaterial&&(l.referencePosition.setFromMatrixPosition(o.matrixWorld),l.nearDistance=r,l.farDistance=a),l}function y(t,r,a,i,v){if(!1!==t.visible){if(t.layers.test(r.layers)&&(t.isMesh||t.isLine||t.isPoints)&&(t.castShadow||t.receiveShadow&&v===q)&&(!t.frustumCulled||o.intersectsObject(t))){t.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse,t.matrixWorld);var c=e.update(t),s=t.material;if(Array.isArray(s))for(var l=c.groups,u=0,f=l.length;u<f;u++){var p=l[u],m=s[p.materialIndex];if(m&&m.visible){var d=g(t,m,i,a.near,a.far,v);n.renderBufferDirect(a,null,c,d,t,p)}}else if(s.visible){var h=g(t,s,i,a.near,a.far,v);n.renderBufferDirect(a,null,c,h,t,null)}}for(var x=t.children,b=0,U=x.length;b<U;b++)y(x[b],r,a,i,v)}}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=N,this.render=function(e,t,v){if(!1!==h.enabled&&(!1!==h.autoUpdate||!1!==h.needsUpdate)&&0!==e.length){var c=n.getRenderTarget(),s=n.getActiveCubeFace(),u=n.getActiveMipmapLevel(),f=n.state;f.setBlending(X),f.buffers.color.setClear(1,1,1,1),f.buffers.depth.setTest(!0),f.setScissorTest(!1);for(var p=0,m=e.length;p<m;p++){var d=e[p],g=d.shadow;if(void 0!==g){if(!1!==g.autoUpdate||!1!==g.needsUpdate){r.copy(g.mapSize);var b=g.getFrameExtents();if(r.multiply(b),a.copy(g.mapSize),(r.x>l||r.y>l)&&(r.x>l&&(a.x=Math.floor(l/b.x),r.x=a.x*b.x,g.mapSize.x=a.x),r.y>l&&(a.y=Math.floor(l/b.y),r.y=a.y*b.y,g.mapSize.y=a.y)),null===g.map){var U=this.type!==q?{minFilter:Bn,magFilter:Bn}:{};g.map=new Ro(r.x,r.y,U),g.map.texture.name=d.name+".shadowMap",g.camera.updateProjectionMatrix()}n.setRenderTarget(g.map),n.clear();for(var _=g.getViewportCount(),w=0;w<_;w++){var S=g.getViewport(w);i.set(a.x*S.x,a.y*S.y,a.x*S.z,a.y*S.w),f.viewport(i),g.updateMatrices(d,w),o=g.getFrustum(),y(t,v,g.camera,d,this.type)}!0!==g.isPointLightShadow&&this.type===q&&x(g,v),g.needsUpdate=!1}}else console.warn("THREE.WebGLShadowMap:",d,"has no shadow.")}h.needsUpdate=!1,n.setRenderTarget(c,s,u)}}}function _c(n,e,t){var o,r,a=t.isWebGL2;var i=new function(){var e=!1,t=new To,o=null,r=new To(0,0,0,0);return{setMask:function(t){o===t||e||(n.colorMask(t,t,t,t),o=t)},setLocked:function(n){e=n},setClear:function(e,o,a,i,v){!0===v&&(e*=i,o*=i,a*=i),t.set(e,o,a,i),!1===r.equals(t)&&(n.clearColor(e,o,a,i),r.copy(t))},reset:function(){e=!1,o=null,r.set(-1,0,0,0)}}},v=new function(){var e=!1,t=null,o=null,r=null;return{setTest:function(n){n?Mn(2929):kn(2929)},setMask:function(o){t===o||e||(n.depthMask(o),t=o)},setFunc:function(e){if(o!==e){switch(e){case hn:n.depthFunc(512);break;case xn:n.depthFunc(519);break;case gn:n.depthFunc(513);break;case yn:n.depthFunc(515);break;case bn:n.depthFunc(514);break;case Un:n.depthFunc(518);break;case _n:n.depthFunc(516);break;case wn:n.depthFunc(517);break;default:n.depthFunc(515)}o=e}},setLocked:function(n){e=n},setClear:function(e){r!==e&&(n.clearDepth(e),r=e)},reset:function(){e=!1,t=null,o=null,r=null}}},c=new function(){var e=!1,t=null,o=null,r=null,a=null,i=null,v=null,c=null,s=null;return{setTest:function(n){e||(n?Mn(2960):kn(2960))},setMask:function(o){t===o||e||(n.stencilMask(o),t=o)},setFunc:function(e,t,i){o===e&&r===t&&a===i||(n.stencilFunc(e,t,i),o=e,r=t,a=i)},setOp:function(e,t,o){i===e&&v===t&&c===o||(n.stencilOp(e,t,o),i=e,v=t,c=o)},setLocked:function(n){e=n},setClear:function(e){s!==e&&(n.clearStencil(e),s=e)},reset:function(){e=!1,t=null,o=null,r=null,a=null,i=null,v=null,c=null,s=null}}},l=new WeakMap,u=new WeakMap,f={},p={},m=new WeakMap,d=[],h=null,x=!1,g=null,y=null,b=null,U=null,_=null,w=null,S=null,M=!1,k=null,z=null,C=null,T=null,R=null,D=n.getParameter(35661),P=!1,F=0,j=n.getParameter(7938);-1!==j.indexOf("WebGL")?(F=parseFloat(/^WebGL (\d)/.exec(j)[1]),P=F>=1):-1!==j.indexOf("OpenGL ES")&&(F=parseFloat(/^OpenGL ES (\d)/.exec(j)[1]),P=F>=2);var I=null,L={},G=n.getParameter(3088),N=n.getParameter(2978),B=(new To).fromArray(G),q=(new To).fromArray(N);function V(e,t,o){var r=new Uint8Array(4),a=n.createTexture();n.bindTexture(e,a),n.texParameteri(e,10241,9728),n.texParameteri(e,10240,9728);for(var i=0;i<o;i++)n.texImage2D(t+i,0,6408,1,1,0,6408,5121,r);return a}var Sn={};function Mn(e){!0!==f[e]&&(n.enable(e),f[e]=!0)}function kn(e){!1!==f[e]&&(n.disable(e),f[e]=!1)}Sn[3553]=V(3553,3553,1),Sn[34067]=V(34067,34069,6),i.setClear(0,0,0,1),v.setClear(1),c.setClear(0),Mn(2929),v.setFunc(yn),Dn(!1),Pn(O),Mn(2884),Rn(X);var zn=(s(o={},$,32774),s(o,nn,32778),s(o,en,32779),o);if(a)zn[tn]=32775,zn[on]=32776;else{var Cn=e.get("EXT_blend_minmax");null!==Cn&&(zn[tn]=Cn.MIN_EXT,zn[on]=Cn.MAX_EXT)}var Tn=(s(r={},rn,0),s(r,an,1),s(r,vn,768),s(r,sn,770),s(r,dn,776),s(r,pn,774),s(r,un,772),s(r,cn,769),s(r,ln,771),s(r,mn,775),s(r,fn,773),r);function Rn(e,t,o,r,a,i,v,c){if(e!==X){if(!1===x&&(Mn(3042),x=!0),e===K)a=a||t,i=i||o,v=v||r,t===y&&a===_||(n.blendEquationSeparate(zn[t],zn[a]),y=t,_=a),o===b&&r===U&&i===w&&v===S||(n.blendFuncSeparate(Tn[o],Tn[r],Tn[i],Tn[v]),b=o,U=r,w=i,S=v),g=e,M=null;else if(e!==g||c!==M){if(y===$&&_===$||(n.blendEquation(32774),y=$,_=$),c)switch(e){case Y:n.blendFuncSeparate(1,771,1,771);break;case Z:n.blendFunc(1,1);break;case Q:n.blendFuncSeparate(0,769,0,1);break;case J:n.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case Y:n.blendFuncSeparate(770,771,1,771);break;case Z:n.blendFunc(770,1);break;case Q:n.blendFuncSeparate(0,769,0,1);break;case J:n.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}b=null,U=null,w=null,S=null,g=e,M=c}}else!0===x&&(kn(3042),x=!1)}function Dn(e){k!==e&&(e?n.frontFace(2304):n.frontFace(2305),k=e)}function Pn(e){e!==E?(Mn(2884),e!==z&&(e===O?n.cullFace(1029):e===A?n.cullFace(1028):n.cullFace(1032))):kn(2884),z=e}function Fn(e,t,o){e?(Mn(32823),T===t&&R===o||(n.polygonOffset(t,o),T=t,R=o)):kn(32823)}return{buffers:{color:i,depth:v,stencil:c},enable:Mn,disable:kn,bindFramebuffer:function(e,t){return p[e]!==t&&(n.bindFramebuffer(e,t),p[e]=t,a&&(36009===e&&(p[36160]=t),36160===e&&(p[36009]=t)),!0)},drawBuffers:function(o,r){var a=d,i=!1;if(o)if(void 0===(a=m.get(r))&&(a=[],m.set(r,a)),o.isWebGLMultipleRenderTargets){var v=o.texture;if(a.length!==v.length||36064!==a[0]){for(var c=0,s=v.length;c<s;c++)a[c]=36064+c;a.length=v.length,i=!0}}else 36064!==a[0]&&(a[0]=36064,i=!0);else 1029!==a[0]&&(a[0]=1029,i=!0);i&&(t.isWebGL2?n.drawBuffers(a):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(a))},useProgram:function(e){return h!==e&&(n.useProgram(e),h=e,!0)},setBlending:Rn,setMaterial:function(n,e){n.side===H?kn(2884):Mn(2884);var t=n.side===W;e&&(t=!t),Dn(t),n.blending===Y&&!1===n.transparent?Rn(X):Rn(n.blending,n.blendEquation,n.blendSrc,n.blendDst,n.blendEquationAlpha,n.blendSrcAlpha,n.blendDstAlpha,n.premultipliedAlpha),v.setFunc(n.depthFunc),v.setTest(n.depthTest),v.setMask(n.depthWrite),i.setMask(n.colorWrite);var o=n.stencilWrite;c.setTest(o),o&&(c.setMask(n.stencilWriteMask),c.setFunc(n.stencilFunc,n.stencilRef,n.stencilFuncMask),c.setOp(n.stencilFail,n.stencilZFail,n.stencilZPass)),Fn(n.polygonOffset,n.polygonOffsetFactor,n.polygonOffsetUnits),!0===n.alphaToCoverage?Mn(32926):kn(32926)},setFlipSided:Dn,setCullFace:Pn,setLineWidth:function(e){e!==C&&(P&&n.lineWidth(e),C=e)},setPolygonOffset:Fn,setScissorTest:function(n){n?Mn(3089):kn(3089)},activeTexture:function(e){void 0===e&&(e=33984+D-1),I!==e&&(n.activeTexture(e),I=e)},bindTexture:function(e,t,o){void 0===o&&(o=null===I?33984+D-1:I);var r=L[o];void 0===r&&(r={type:void 0,texture:void 0},L[o]=r),r.type===e&&r.texture===t||(I!==o&&(n.activeTexture(o),I=o),n.bindTexture(e,t||Sn[e]),r.type=e,r.texture=t)},unbindTexture:function(){var e=L[I];void 0!==e&&void 0!==e.type&&(n.bindTexture(e.type,null),e.type=void 0,e.texture=void 0)},compressedTexImage2D:function(){try{n.compressedTexImage2D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},compressedTexImage3D:function(){try{n.compressedTexImage3D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage2D:function(){try{n.texImage2D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage3D:function(){try{n.texImage3D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},updateUBOMapping:function(e,t){var o=u.get(t);void 0===o&&(o=new WeakMap,u.set(t,o));var r=o.get(e);void 0===r&&(r=n.getUniformBlockIndex(t,e.name),o.set(e,r))},uniformBlockBinding:function(e,t){var o=u.get(t).get(e);l.get(e)!==o&&(n.uniformBlockBinding(t,o,e.__bindingPointIndex),l.set(e,o))},texStorage2D:function(){try{n.texStorage2D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texStorage3D:function(){try{n.texStorage3D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texSubImage2D:function(){try{n.texSubImage2D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texSubImage3D:function(){try{n.texSubImage3D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},compressedTexSubImage2D:function(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},compressedTexSubImage3D:function(){try{n.compressedTexSubImage3D.apply(n,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},scissor:function(e){!1===B.equals(e)&&(n.scissor(e.x,e.y,e.z,e.w),B.copy(e))},viewport:function(e){!1===q.equals(e)&&(n.viewport(e.x,e.y,e.z,e.w),q.copy(e))},reset:function(){n.disable(3042),n.disable(2884),n.disable(2929),n.disable(32823),n.disable(3089),n.disable(2960),n.disable(32926),n.blendEquation(32774),n.blendFunc(1,0),n.blendFuncSeparate(1,0,1,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(513),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(519,0,4294967295),n.stencilOp(7680,7680,7680),n.clearStencil(0),n.cullFace(1029),n.frontFace(2305),n.polygonOffset(0,0),n.activeTexture(33984),n.bindFramebuffer(36160,null),!0===a&&(n.bindFramebuffer(36009,null),n.bindFramebuffer(36008,null)),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),f={},I=null,L={},p={},m=new WeakMap,d=[],h=null,x=!1,g=null,y=null,b=null,U=null,_=null,w=null,S=null,M=!1,k=null,z=null,C=null,T=null,R=null,B.set(0,0,n.canvas.width,n.canvas.height),q.set(0,0,n.canvas.width,n.canvas.height),i.reset(),v.reset(),c.reset()}}}function wc(n,e,t,o,r,a,i){var v,c,l,u=r.isWebGL2,f=r.maxTextures,p=r.maxCubemapSize,m=r.maxTextureSize,d=r.maxSamples,h=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,x=/OculusBrowser/g.test("undefined"===typeof navigator?"":navigator.userAgent),g=new WeakMap,y=new WeakMap,b=!1;try{b="undefined"!==typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(W){}function U(n,e){return b?new OffscreenCanvas(n,e):lo("canvas")}function _(n,e,t,o){var r=1;if((n.width>o||n.height>o)&&(r=o/Math.max(n.width,n.height)),r<1||!0===e){if("undefined"!==typeof HTMLImageElement&&n instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&n instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&n instanceof ImageBitmap){var a=e?eo:Math.floor,i=a(r*n.width),v=a(r*n.height);void 0===l&&(l=U(i,v));var c=t?U(i,v):l;return c.width=i,c.height=v,c.getContext("2d").drawImage(n,0,0,i,v),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+n.width+"x"+n.height+") to ("+i+"x"+v+")."),c}return"data"in n&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+n.width+"x"+n.height+")."),n}return n}function w(n){return $t(n.width)&&$t(n.height)}function S(n,e){return n.generateMipmaps&&e&&n.minFilter!==Bn&&n.minFilter!==Xn}function M(e){n.generateMipmap(e)}function k(t,o,r,a){var i=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!1===u)return o;if(null!==t){if(void 0!==n[t])return n[t];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+t+"'")}var v=o;return 6403===o&&(5126===r&&(v=33326),5131===r&&(v=33325),5121===r&&(v=33321)),33319===o&&(5126===r&&(v=33328),5131===r&&(v=33327),5121===r&&(v=33323)),6408===o&&(5126===r&&(v=34836),5131===r&&(v=34842),5121===r&&(v=a===ct&&!1===i?35907:32856),32819===r&&(v=32854),32820===r&&(v=32855)),33325!==v&&33326!==v&&33327!==v&&33328!==v&&34842!==v&&34836!==v||e.get("EXT_color_buffer_float"),v}function z(n,e,t){return!0===S(n,t)||n.isFramebufferTexture&&n.minFilter!==Bn&&n.minFilter!==Xn?Math.log2(Math.max(e.width,e.height))+1:void 0!==n.mipmaps&&n.mipmaps.length>0?n.mipmaps.length:n.isCompressedTexture&&Array.isArray(n.image)?e.mipmaps.length:1}function C(n){return n===Bn||n===qn||n===Wn?9728:9729}function T(n){var e=n.target;e.removeEventListener("dispose",T),function(n){var e=o.get(n);if(void 0===e.__webglInit)return;var t=n.source,r=y.get(t);if(r){var a=r[e.__cacheKey];a.usedTimes--,0===a.usedTimes&&D(n),0===Object.keys(r).length&&y.delete(t)}o.remove(n)}(e),e.isVideoTexture&&g.delete(e)}function R(e){var t=e.target;t.removeEventListener("dispose",R),function(e){var t=e.texture,r=o.get(e),a=o.get(t);void 0!==a.__webglTexture&&(n.deleteTexture(a.__webglTexture),i.memory.textures--);e.depthTexture&&e.depthTexture.dispose();if(e.isWebGLCubeRenderTarget)for(var v=0;v<6;v++)n.deleteFramebuffer(r.__webglFramebuffer[v]),r.__webglDepthbuffer&&n.deleteRenderbuffer(r.__webglDepthbuffer[v]);else{if(n.deleteFramebuffer(r.__webglFramebuffer),r.__webglDepthbuffer&&n.deleteRenderbuffer(r.__webglDepthbuffer),r.__webglMultisampledFramebuffer&&n.deleteFramebuffer(r.__webglMultisampledFramebuffer),r.__webglColorRenderbuffer)for(var c=0;c<r.__webglColorRenderbuffer.length;c++)r.__webglColorRenderbuffer[c]&&n.deleteRenderbuffer(r.__webglColorRenderbuffer[c]);r.__webglDepthRenderbuffer&&n.deleteRenderbuffer(r.__webglDepthRenderbuffer)}if(e.isWebGLMultipleRenderTargets)for(var s=0,l=t.length;s<l;s++){var u=o.get(t[s]);u.__webglTexture&&(n.deleteTexture(u.__webglTexture),i.memory.textures--),o.remove(t[s])}o.remove(t),o.remove(e)}(t)}function D(e){var t=o.get(e);n.deleteTexture(t.__webglTexture);var r=e.source;delete y.get(r)[t.__cacheKey],i.memory.textures--}var P=0;function F(n,e){var r=o.get(n);if(n.isVideoTexture&&function(n){var e=i.render.frame;g.get(n)!==e&&(g.set(n,e),n.update())}(n),!1===n.isRenderTargetTexture&&n.version>0&&r.__version!==n.version){var a=n.image;if(null===a)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==a.complete)return void A(r,n,e);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}t.bindTexture(3553,r.__webglTexture,33984+e)}var j=(s(v={},Ln,10497),s(v,Gn,33071),s(v,Nn,33648),v),I=(s(c={},Bn,9728),s(c,qn,9984),s(c,Wn,9986),s(c,Xn,9729),s(c,Yn,9985),s(c,Qn,9987),c);function E(t,a,i){if(i?(n.texParameteri(t,10242,j[a.wrapS]),n.texParameteri(t,10243,j[a.wrapT]),32879!==t&&35866!==t||n.texParameteri(t,32882,j[a.wrapR]),n.texParameteri(t,10240,I[a.magFilter]),n.texParameteri(t,10241,I[a.minFilter])):(n.texParameteri(t,10242,33071),n.texParameteri(t,10243,33071),32879!==t&&35866!==t||n.texParameteri(t,32882,33071),a.wrapS===Gn&&a.wrapT===Gn||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(t,10240,C(a.magFilter)),n.texParameteri(t,10241,C(a.minFilter)),a.minFilter!==Bn&&a.minFilter!==Xn&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===e.has("EXT_texture_filter_anisotropic")){var v=e.get("EXT_texture_filter_anisotropic");if(a.type===re&&!1===e.has("OES_texture_float_linear"))return;if(!1===u&&a.type===ae&&!1===e.has("OES_texture_half_float_linear"))return;(a.anisotropy>1||o.get(a).__currentAnisotropy)&&(n.texParameterf(t,v.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(a.anisotropy,r.getMaxAnisotropy())),o.get(a).__currentAnisotropy=a.anisotropy)}}function O(e,t){var o=!1;void 0===e.__webglInit&&(e.__webglInit=!0,t.addEventListener("dispose",T));var r=t.source,a=y.get(r);void 0===a&&(a={},y.set(r,a));var v=function(n){var e=[];return e.push(n.wrapS),e.push(n.wrapT),e.push(n.wrapR||0),e.push(n.magFilter),e.push(n.minFilter),e.push(n.anisotropy),e.push(n.internalFormat),e.push(n.format),e.push(n.type),e.push(n.generateMipmaps),e.push(n.premultiplyAlpha),e.push(n.flipY),e.push(n.unpackAlignment),e.push(n.encoding),e.join()}(t);if(v!==e.__cacheKey){void 0===a[v]&&(a[v]={texture:n.createTexture(),usedTimes:0},i.memory.textures++,o=!0),a[v].usedTimes++;var c=a[e.__cacheKey];void 0!==c&&(a[e.__cacheKey].usedTimes--,0===c.usedTimes&&D(t)),e.__cacheKey=v,e.__webglTexture=a[v].texture}return o}function A(e,r,i){var v=3553;(r.isDataArrayTexture||r.isCompressedArrayTexture)&&(v=35866),r.isData3DTexture&&(v=32879);var c=O(e,r),s=r.source;t.bindTexture(v,e.__webglTexture,33984+i);var l=o.get(s);if(s.version!==l.__version||!0===c){t.activeTexture(33984+i),n.pixelStorei(37440,r.flipY),n.pixelStorei(37441,r.premultiplyAlpha),n.pixelStorei(3317,r.unpackAlignment),n.pixelStorei(37443,0);var f,p=function(n){return!u&&(n.wrapS!==Gn||n.wrapT!==Gn||n.minFilter!==Bn&&n.minFilter!==Xn)}(r)&&!1===w(r.image),d=_(r.image,p,!1,m),h=w(d=V(r,d))||u,x=a.convert(r.format,r.encoding),g=a.convert(r.type),y=k(r.internalFormat,x,g,r.encoding,r.isVideoTexture);E(v,r,h);var b=r.mipmaps,U=u&&!0!==r.isVideoTexture,C=void 0===l.__version||!0===c,T=z(r,d,h);if(r.isDepthTexture)y=6402,u?y=r.type===re?36012:r.type===oe?33190:r.type===ce?35056:33189:r.type===re&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),r.format===me&&6402===y&&r.type!==ee&&r.type!==oe&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),r.type=oe,g=a.convert(r.type)),r.format===de&&6402===y&&(y=34041,r.type!==ce&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),r.type=ce,g=a.convert(r.type))),C&&(U?t.texStorage2D(3553,1,y,d.width,d.height):t.texImage2D(3553,0,y,d.width,d.height,0,x,g,null));else if(r.isDataTexture)if(b.length>0&&h){U&&C&&t.texStorage2D(3553,T,y,b[0].width,b[0].height);for(var R=0,D=b.length;R<D;R++)f=b[R],U?t.texSubImage2D(3553,R,0,0,f.width,f.height,x,g,f.data):t.texImage2D(3553,R,y,f.width,f.height,0,x,g,f.data);r.generateMipmaps=!1}else U?(C&&t.texStorage2D(3553,T,y,d.width,d.height),t.texSubImage2D(3553,0,0,0,d.width,d.height,x,g,d.data)):t.texImage2D(3553,0,y,d.width,d.height,0,x,g,d.data);else if(r.isCompressedTexture)if(r.isCompressedArrayTexture){U&&C&&t.texStorage3D(35866,T,y,b[0].width,b[0].height,d.depth);for(var P=0,F=b.length;P<F;P++)f=b[P],r.format!==ue?null!==x?U?t.compressedTexSubImage3D(35866,P,0,0,0,f.width,f.height,d.depth,x,f.data,0,0):t.compressedTexImage3D(35866,P,y,f.width,f.height,d.depth,0,f.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):U?t.texSubImage3D(35866,P,0,0,0,f.width,f.height,d.depth,x,g,f.data):t.texImage3D(35866,P,y,f.width,f.height,d.depth,0,x,g,f.data)}else{U&&C&&t.texStorage2D(3553,T,y,b[0].width,b[0].height);for(var j=0,I=b.length;j<I;j++)f=b[j],r.format!==ue?null!==x?U?t.compressedTexSubImage2D(3553,j,0,0,f.width,f.height,x,f.data):t.compressedTexImage2D(3553,j,y,f.width,f.height,0,f.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):U?t.texSubImage2D(3553,j,0,0,f.width,f.height,x,g,f.data):t.texImage2D(3553,j,y,f.width,f.height,0,x,g,f.data)}else if(r.isDataArrayTexture)U?(C&&t.texStorage3D(35866,T,y,d.width,d.height,d.depth),t.texSubImage3D(35866,0,0,0,0,d.width,d.height,d.depth,x,g,d.data)):t.texImage3D(35866,0,y,d.width,d.height,d.depth,0,x,g,d.data);else if(r.isData3DTexture)U?(C&&t.texStorage3D(32879,T,y,d.width,d.height,d.depth),t.texSubImage3D(32879,0,0,0,0,d.width,d.height,d.depth,x,g,d.data)):t.texImage3D(32879,0,y,d.width,d.height,d.depth,0,x,g,d.data);else if(r.isFramebufferTexture){if(C)if(U)t.texStorage2D(3553,T,y,d.width,d.height);else for(var A=d.width,L=d.height,G=0;G<T;G++)t.texImage2D(3553,G,y,A,L,0,x,g,null),A>>=1,L>>=1}else if(b.length>0&&h){U&&C&&t.texStorage2D(3553,T,y,b[0].width,b[0].height);for(var N=0,B=b.length;N<B;N++)f=b[N],U?t.texSubImage2D(3553,N,0,0,x,g,f):t.texImage2D(3553,N,y,x,g,f);r.generateMipmaps=!1}else U?(C&&t.texStorage2D(3553,T,y,d.width,d.height),t.texSubImage2D(3553,0,0,0,x,g,d)):t.texImage2D(3553,0,y,x,g,d);S(r,h)&&M(v),l.__version=s.version,r.onUpdate&&r.onUpdate(r)}e.__version=r.version}function L(e,r,i,v,c){var s=a.convert(i.format,i.encoding),l=a.convert(i.type),u=k(i.internalFormat,s,l,i.encoding);o.get(r).__hasExternalTextures||(32879===c||35866===c?t.texImage3D(c,0,u,r.width,r.height,r.depth,0,s,l,null):t.texImage2D(c,0,u,r.width,r.height,0,s,l,null)),t.bindFramebuffer(36160,e),q(r)?h.framebufferTexture2DMultisampleEXT(36160,v,c,o.get(i).__webglTexture,0,B(r)):(3553===c||c>=34069&&c<=34074)&&n.framebufferTexture2D(36160,v,c,o.get(i).__webglTexture,0),t.bindFramebuffer(36160,null)}function G(e,t,o){if(n.bindRenderbuffer(36161,e),t.depthBuffer&&!t.stencilBuffer){var r=33189;if(o||q(t)){var i=t.depthTexture;i&&i.isDepthTexture&&(i.type===re?r=36012:i.type===oe&&(r=33190));var v=B(t);q(t)?h.renderbufferStorageMultisampleEXT(36161,v,r,t.width,t.height):n.renderbufferStorageMultisample(36161,v,r,t.width,t.height)}else n.renderbufferStorage(36161,r,t.width,t.height);n.framebufferRenderbuffer(36160,36096,36161,e)}else if(t.depthBuffer&&t.stencilBuffer){var c=B(t);o&&!1===q(t)?n.renderbufferStorageMultisample(36161,c,35056,t.width,t.height):q(t)?h.renderbufferStorageMultisampleEXT(36161,c,35056,t.width,t.height):n.renderbufferStorage(36161,34041,t.width,t.height),n.framebufferRenderbuffer(36160,33306,36161,e)}else for(var s=!0===t.isWebGLMultipleRenderTargets?t.texture:[t.texture],l=0;l<s.length;l++){var u=s[l],f=a.convert(u.format,u.encoding),p=a.convert(u.type),m=k(u.internalFormat,f,p,u.encoding),d=B(t);o&&!1===q(t)?n.renderbufferStorageMultisample(36161,d,m,t.width,t.height):q(t)?h.renderbufferStorageMultisampleEXT(36161,d,m,t.width,t.height):n.renderbufferStorage(36161,m,t.width,t.height)}n.bindRenderbuffer(36161,null)}function N(e){var r=o.get(e),a=!0===e.isWebGLCubeRenderTarget;if(e.depthTexture&&!r.__autoAllocateDepthBuffer){if(a)throw new Error("target.depthTexture not supported in Cube render targets");!function(e,r){if(r&&r.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,e),!r.depthTexture||!r.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");o.get(r.depthTexture).__webglTexture&&r.depthTexture.image.width===r.width&&r.depthTexture.image.height===r.height||(r.depthTexture.image.width=r.width,r.depthTexture.image.height=r.height,r.depthTexture.needsUpdate=!0),F(r.depthTexture,0);var a=o.get(r.depthTexture).__webglTexture,i=B(r);if(r.depthTexture.format===me)q(r)?h.framebufferTexture2DMultisampleEXT(36160,36096,3553,a,0,i):n.framebufferTexture2D(36160,36096,3553,a,0);else{if(r.depthTexture.format!==de)throw new Error("Unknown depthTexture format");q(r)?h.framebufferTexture2DMultisampleEXT(36160,33306,3553,a,0,i):n.framebufferTexture2D(36160,33306,3553,a,0)}}(r.__webglFramebuffer,e)}else if(a){r.__webglDepthbuffer=[];for(var i=0;i<6;i++)t.bindFramebuffer(36160,r.__webglFramebuffer[i]),r.__webglDepthbuffer[i]=n.createRenderbuffer(),G(r.__webglDepthbuffer[i],e,!1)}else t.bindFramebuffer(36160,r.__webglFramebuffer),r.__webglDepthbuffer=n.createRenderbuffer(),G(r.__webglDepthbuffer,e,!1);t.bindFramebuffer(36160,null)}function B(n){return Math.min(d,n.samples)}function q(n){var t=o.get(n);return u&&n.samples>0&&!0===e.has("WEBGL_multisampled_render_to_texture")&&!1!==t.__useRenderToTexture}function V(n,t){var o=n.encoding,r=n.format,a=n.type;return!0===n.isCompressedTexture||!0===n.isVideoTexture||n.format===qt||o!==vt&&(o===ct?!1===u?!0===e.has("EXT_sRGB")&&r===ue?(n.format=qt,n.minFilter=Xn,n.generateMipmaps=!1):t=So.sRGBToLinear(t):r===ue&&a===Kn||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",o)),t}this.allocateTextureUnit=function(){var n=P;return n>=f&&console.warn("THREE.WebGLTextures: Trying to use "+n+" texture units while this GPU supports only "+f),P+=1,n},this.resetTextureUnits=function(){P=0},this.setTexture2D=F,this.setTexture2DArray=function(n,e){var r=o.get(n);n.version>0&&r.__version!==n.version?A(r,n,e):t.bindTexture(35866,r.__webglTexture,33984+e)},this.setTexture3D=function(n,e){var r=o.get(n);n.version>0&&r.__version!==n.version?A(r,n,e):t.bindTexture(32879,r.__webglTexture,33984+e)},this.setTextureCube=function(e,r){var i=o.get(e);e.version>0&&i.__version!==e.version?function(e,r,i){if(6!==r.image.length)return;var v=O(e,r),c=r.source;t.bindTexture(34067,e.__webglTexture,33984+i);var s=o.get(c);if(c.version!==s.__version||!0===v){t.activeTexture(33984+i),n.pixelStorei(37440,r.flipY),n.pixelStorei(37441,r.premultiplyAlpha),n.pixelStorei(3317,r.unpackAlignment),n.pixelStorei(37443,0);for(var l=r.isCompressedTexture||r.image[0].isCompressedTexture,f=r.image[0]&&r.image[0].isDataTexture,m=[],d=0;d<6;d++)m[d]=l||f?f?r.image[d].image:r.image[d]:_(r.image[d],!1,!0,p),m[d]=V(r,m[d]);var h,x=m[0],g=w(x)||u,y=a.convert(r.format,r.encoding),b=a.convert(r.type),U=k(r.internalFormat,y,b,r.encoding),C=u&&!0!==r.isVideoTexture,T=void 0===s.__version||!0===v,R=z(r,x,g);if(E(34067,r,g),l){C&&T&&t.texStorage2D(34067,R,U,x.width,x.height);for(var D=0;D<6;D++){h=m[D].mipmaps;for(var P=0;P<h.length;P++){var F=h[P];r.format!==ue?null!==y?C?t.compressedTexSubImage2D(34069+D,P,0,0,F.width,F.height,y,F.data):t.compressedTexImage2D(34069+D,P,U,F.width,F.height,0,F.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):C?t.texSubImage2D(34069+D,P,0,0,F.width,F.height,y,b,F.data):t.texImage2D(34069+D,P,U,F.width,F.height,0,y,b,F.data)}}}else{h=r.mipmaps,C&&T&&(h.length>0&&R++,t.texStorage2D(34067,R,U,m[0].width,m[0].height));for(var j=0;j<6;j++)if(f){C?t.texSubImage2D(34069+j,0,0,0,m[j].width,m[j].height,y,b,m[j].data):t.texImage2D(34069+j,0,U,m[j].width,m[j].height,0,y,b,m[j].data);for(var I=0;I<h.length;I++){var A=h[I].image[j].image;C?t.texSubImage2D(34069+j,I+1,0,0,A.width,A.height,y,b,A.data):t.texImage2D(34069+j,I+1,U,A.width,A.height,0,y,b,A.data)}}else{C?t.texSubImage2D(34069+j,0,0,0,y,b,m[j]):t.texImage2D(34069+j,0,U,y,b,m[j]);for(var L=0;L<h.length;L++){var G=h[L];C?t.texSubImage2D(34069+j,L+1,0,0,y,b,G.image[j]):t.texImage2D(34069+j,L+1,U,y,b,G.image[j])}}}S(r,g)&&M(34067),s.__version=c.version,r.onUpdate&&r.onUpdate(r)}e.__version=r.version}(i,e,r):t.bindTexture(34067,i.__webglTexture,33984+r)},this.rebindTextures=function(n,e,t){var r=o.get(n);void 0!==e&&L(r.__webglFramebuffer,n,n.texture,36064,3553),void 0!==t&&N(n)},this.setupRenderTarget=function(e){var v=e.texture,c=o.get(e),s=o.get(v);e.addEventListener("dispose",R),!0!==e.isWebGLMultipleRenderTargets&&(void 0===s.__webglTexture&&(s.__webglTexture=n.createTexture()),s.__version=v.version,i.memory.textures++);var l=!0===e.isWebGLCubeRenderTarget,f=!0===e.isWebGLMultipleRenderTargets,p=w(e)||u;if(l){c.__webglFramebuffer=[];for(var m=0;m<6;m++)c.__webglFramebuffer[m]=n.createFramebuffer()}else{if(c.__webglFramebuffer=n.createFramebuffer(),f)if(r.drawBuffers)for(var d=e.texture,h=0,x=d.length;h<x;h++){var g=o.get(d[h]);void 0===g.__webglTexture&&(g.__webglTexture=n.createTexture(),i.memory.textures++)}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(u&&e.samples>0&&!1===q(e)){var y=f?v:[v];c.__webglMultisampledFramebuffer=n.createFramebuffer(),c.__webglColorRenderbuffer=[],t.bindFramebuffer(36160,c.__webglMultisampledFramebuffer);for(var b=0;b<y.length;b++){var U=y[b];c.__webglColorRenderbuffer[b]=n.createRenderbuffer(),n.bindRenderbuffer(36161,c.__webglColorRenderbuffer[b]);var _=a.convert(U.format,U.encoding),z=a.convert(U.type),C=k(U.internalFormat,_,z,U.encoding,!0===e.isXRRenderTarget),T=B(e);n.renderbufferStorageMultisample(36161,T,C,e.width,e.height),n.framebufferRenderbuffer(36160,36064+b,36161,c.__webglColorRenderbuffer[b])}n.bindRenderbuffer(36161,null),e.depthBuffer&&(c.__webglDepthRenderbuffer=n.createRenderbuffer(),G(c.__webglDepthRenderbuffer,e,!0)),t.bindFramebuffer(36160,null)}}if(l){t.bindTexture(34067,s.__webglTexture),E(34067,v,p);for(var D=0;D<6;D++)L(c.__webglFramebuffer[D],e,v,36064,34069+D);S(v,p)&&M(34067),t.unbindTexture()}else if(f){for(var P=e.texture,F=0,j=P.length;F<j;F++){var I=P[F],O=o.get(I);t.bindTexture(3553,O.__webglTexture),E(3553,I,p),L(c.__webglFramebuffer,e,I,36064+F,3553),S(I,p)&&M(3553)}t.unbindTexture()}else{var A=3553;(e.isWebGL3DRenderTarget||e.isWebGLArrayRenderTarget)&&(u?A=e.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(A,s.__webglTexture),E(A,v,p),L(c.__webglFramebuffer,e,v,36064,A),S(v,p)&&M(A),t.unbindTexture()}e.depthBuffer&&N(e)},this.updateRenderTargetMipmap=function(n){for(var e=w(n)||u,r=!0===n.isWebGLMultipleRenderTargets?n.texture:[n.texture],a=0,i=r.length;a<i;a++){var v=r[a];if(S(v,e)){var c=n.isWebGLCubeRenderTarget?34067:3553,s=o.get(v).__webglTexture;t.bindTexture(c,s),M(c),t.unbindTexture()}}},this.updateMultisampleRenderTarget=function(e){if(u&&e.samples>0&&!1===q(e)){var r=e.isWebGLMultipleRenderTargets?e.texture:[e.texture],a=e.width,i=e.height,v=16384,c=[],s=e.stencilBuffer?33306:36096,l=o.get(e),f=!0===e.isWebGLMultipleRenderTargets;if(f)for(var p=0;p<r.length;p++)t.bindFramebuffer(36160,l.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064+p,36161,null),t.bindFramebuffer(36160,l.__webglFramebuffer),n.framebufferTexture2D(36009,36064+p,3553,null,0);t.bindFramebuffer(36008,l.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,l.__webglFramebuffer);for(var m=0;m<r.length;m++){c.push(36064+m),e.depthBuffer&&c.push(s);var d=void 0!==l.__ignoreDepthValues&&l.__ignoreDepthValues;if(!1===d&&(e.depthBuffer&&(v|=256),e.stencilBuffer&&(v|=1024)),f&&n.framebufferRenderbuffer(36008,36064,36161,l.__webglColorRenderbuffer[m]),!0===d&&(n.invalidateFramebuffer(36008,[s]),n.invalidateFramebuffer(36009,[s])),f){var h=o.get(r[m]).__webglTexture;n.framebufferTexture2D(36009,36064,3553,h,0)}n.blitFramebuffer(0,0,a,i,0,0,a,i,v,9728),x&&n.invalidateFramebuffer(36008,c)}if(t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,null),f)for(var g=0;g<r.length;g++){t.bindFramebuffer(36160,l.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064+g,36161,l.__webglColorRenderbuffer[g]);var y=o.get(r[g]).__webglTexture;t.bindFramebuffer(36160,l.__webglFramebuffer),n.framebufferTexture2D(36009,36064+g,3553,y,0)}t.bindFramebuffer(36009,l.__webglMultisampledFramebuffer)}},this.setupDepthRenderbuffer=N,this.setupFrameBufferTexture=L,this.useMultisampledRTT=q}function Sc(n,e,t){var o=t.isWebGL2;return{convert:function(t){var r,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t===Kn)return 5121;if(t===ie)return 32819;if(t===ve)return 32820;if(t===$n)return 5120;if(t===ne)return 5122;if(t===ee)return 5123;if(t===te)return 5124;if(t===oe)return 5125;if(t===re)return 5126;if(t===ae)return o?5131:null!==(r=e.get("OES_texture_half_float"))?r.HALF_FLOAT_OES:null;if(t===se)return 6406;if(t===ue)return 6408;if(t===fe)return 6409;if(t===pe)return 6410;if(t===me)return 6402;if(t===de)return 34041;if(t===he)return 6403;if(t===le)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(t===qt)return null!==(r=e.get("EXT_sRGB"))?r.SRGB_ALPHA_EXT:null;if(t===xe)return 36244;if(t===ge)return 33319;if(t===ye)return 33320;if(t===be)return 36249;if(t===Ue||t===_e||t===we||t===Se)if(a===ct){if(null===(r=e.get("WEBGL_compressed_texture_s3tc_srgb")))return null;if(t===Ue)return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(t===_e)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(t===we)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(t===Se)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(null===(r=e.get("WEBGL_compressed_texture_s3tc")))return null;if(t===Ue)return r.COMPRESSED_RGB_S3TC_DXT1_EXT;if(t===_e)return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(t===we)return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(t===Se)return r.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(t===Me||t===ke||t===ze||t===Ce){if(null===(r=e.get("WEBGL_compressed_texture_pvrtc")))return null;if(t===Me)return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(t===ke)return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(t===ze)return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(t===Ce)return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(t===Te)return null!==(r=e.get("WEBGL_compressed_texture_etc1"))?r.COMPRESSED_RGB_ETC1_WEBGL:null;if(t===Re||t===De){if(null===(r=e.get("WEBGL_compressed_texture_etc")))return null;if(t===Re)return a===ct?r.COMPRESSED_SRGB8_ETC2:r.COMPRESSED_RGB8_ETC2;if(t===De)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:r.COMPRESSED_RGBA8_ETC2_EAC}if(t===Pe||t===Fe||t===je||t===Ie||t===Ee||t===Oe||t===Ae||t===Le||t===Ge||t===Ne||t===Be||t===qe||t===Ve||t===We){if(null===(r=e.get("WEBGL_compressed_texture_astc")))return null;if(t===Pe)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:r.COMPRESSED_RGBA_ASTC_4x4_KHR;if(t===Fe)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:r.COMPRESSED_RGBA_ASTC_5x4_KHR;if(t===je)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:r.COMPRESSED_RGBA_ASTC_5x5_KHR;if(t===Ie)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:r.COMPRESSED_RGBA_ASTC_6x5_KHR;if(t===Ee)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:r.COMPRESSED_RGBA_ASTC_6x6_KHR;if(t===Oe)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:r.COMPRESSED_RGBA_ASTC_8x5_KHR;if(t===Ae)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:r.COMPRESSED_RGBA_ASTC_8x6_KHR;if(t===Le)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:r.COMPRESSED_RGBA_ASTC_8x8_KHR;if(t===Ge)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:r.COMPRESSED_RGBA_ASTC_10x5_KHR;if(t===Ne)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:r.COMPRESSED_RGBA_ASTC_10x6_KHR;if(t===Be)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:r.COMPRESSED_RGBA_ASTC_10x8_KHR;if(t===qe)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:r.COMPRESSED_RGBA_ASTC_10x10_KHR;if(t===Ve)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:r.COMPRESSED_RGBA_ASTC_12x10_KHR;if(t===We)return a===ct?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:r.COMPRESSED_RGBA_ASTC_12x12_KHR}if(t===He){if(null===(r=e.get("EXT_texture_compression_bptc")))return null;if(t===He)return a===ct?r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:r.COMPRESSED_RGBA_BPTC_UNORM_EXT}return t===ce?o?34042:null!==(r=e.get("WEBGL_depth_texture"))?r.UNSIGNED_INT_24_8_WEBGL:null:void 0!==n[t]?n[t]:null}}}var Mc=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return g(this,t),(n=e.call(this)).isArrayCamera=!0,n.cameras=o,n}return b(t)}(Wa),kc=function(n){U(t,n);var e=k(t);function t(){var n;return g(this,t),(n=e.call(this)).isGroup=!0,n.type="Group",n}return b(t)}(Ar),zc={type:"move"},Cc=function(){function n(){g(this,n),this._targetRay=null,this._grip=null,this._hand=null}return b(n,[{key:"getHandSpace",value:function(){return null===this._hand&&(this._hand=new kc,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}},{key:"getTargetRaySpace",value:function(){return null===this._targetRay&&(this._targetRay=new kc,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Oo,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Oo),this._targetRay}},{key:"getGripSpace",value:function(){return null===this._grip&&(this._grip=new kc,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Oo,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Oo),this._grip}},{key:"dispatchEvent",value:function(n){return null!==this._targetRay&&this._targetRay.dispatchEvent(n),null!==this._grip&&this._grip.dispatchEvent(n),null!==this._hand&&this._hand.dispatchEvent(n),this}},{key:"disconnect",value:function(n){return this.dispatchEvent({type:"disconnected",data:n}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}},{key:"update",value:function(n,e,t){var o=null,r=null,a=null,i=this._targetRay,v=this._grip,c=this._hand;if(n&&"visible-blurred"!==e.session.visibilityState){if(c&&n.hand){a=!0;var s,l=f(n.hand.values());try{for(l.s();!(s=l.n()).done;){var u=s.value,p=e.getJointPose(u,t);if(void 0===c.joints[u.jointName]){var m=new kc;m.matrixAutoUpdate=!1,m.visible=!1,c.joints[u.jointName]=m,c.add(m)}var d=c.joints[u.jointName];null!==p&&(d.matrix.fromArray(p.transform.matrix),d.matrix.decompose(d.position,d.rotation,d.scale),d.jointRadius=p.radius),d.visible=null!==p}}catch(y){l.e(y)}finally{l.f()}var h=c.joints["index-finger-tip"],x=c.joints["thumb-tip"],g=h.position.distanceTo(x.position);c.inputState.pinching&&g>.025?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:n.handedness,target:this})):!c.inputState.pinching&&g<=.015&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:n.handedness,target:this}))}else null!==v&&n.gripSpace&&null!==(r=e.getPose(n.gripSpace,t))&&(v.matrix.fromArray(r.transform.matrix),v.matrix.decompose(v.position,v.rotation,v.scale),r.linearVelocity?(v.hasLinearVelocity=!0,v.linearVelocity.copy(r.linearVelocity)):v.hasLinearVelocity=!1,r.angularVelocity?(v.hasAngularVelocity=!0,v.angularVelocity.copy(r.angularVelocity)):v.hasAngularVelocity=!1);null!==i&&(null===(o=e.getPose(n.targetRaySpace,t))&&null!==r&&(o=r),null!==o&&(i.matrix.fromArray(o.transform.matrix),i.matrix.decompose(i.position,i.rotation,i.scale),o.linearVelocity?(i.hasLinearVelocity=!0,i.linearVelocity.copy(o.linearVelocity)):i.hasLinearVelocity=!1,o.angularVelocity?(i.hasAngularVelocity=!0,i.angularVelocity.copy(o.angularVelocity)):i.hasAngularVelocity=!1,this.dispatchEvent(zc)))}return null!==i&&(i.visible=null!==o),null!==v&&(v.visible=null!==r),null!==c&&(c.visible=null!==a),this}}]),n}(),Tc=function(n){U(t,n);var e=k(t);function t(n,o,r,a,i,v,c,s,l,u){var f;if(g(this,t),(u=void 0!==u?u:me)!==me&&u!==de)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");return void 0===r&&u===me&&(r=oe),void 0===r&&u===de&&(r=ce),(f=e.call(this,null,a,i,v,c,s,u,r,l)).isDepthTexture=!0,f.image={width:n,height:o},f.magFilter=void 0!==c?c:Bn,f.minFilter=void 0!==s?s:Bn,f.flipY=!1,f.generateMipmaps=!1,f}return b(t)}(Co),Rc=function(n){U(t,n);var e=k(t);function t(n,o){var r;g(this,t);var a=S(r=e.call(this)),i=null,v=1,c=null,s="local-floor",l=null,u=null,f=null,p=null,m=null,d=null,h=o.getContextAttributes(),x=null,y=null,b=[],U=[],_=new Wa;_.layers.enable(1),_.viewport=new To;var w=new Wa;w.layers.enable(2),w.viewport=new To;var M=[_,w],k=new Mc;k.layers.enable(1),k.layers.enable(2);var z=null,C=null;function R(n){var e=U.indexOf(n.inputSource);if(-1!==e){var t=b[e];void 0!==t&&t.dispatchEvent({type:n.type,data:n.inputSource})}}function D(){i.removeEventListener("select",R),i.removeEventListener("selectstart",R),i.removeEventListener("selectend",R),i.removeEventListener("squeeze",R),i.removeEventListener("squeezestart",R),i.removeEventListener("squeezeend",R),i.removeEventListener("end",D),i.removeEventListener("inputsourceschange",F);for(var e=0;e<b.length;e++){var t=U[e];null!==t&&(U[e]=null,b[e].disconnect(t))}z=null,C=null,n.setRenderTarget(x),m=null,p=null,f=null,i=null,y=null,A.stop(),a.isPresenting=!1,a.dispatchEvent({type:"sessionend"})}function F(n){for(var e=0;e<n.removed.length;e++){var t=n.removed[e],o=U.indexOf(t);o>=0&&(U[o]=null,b[o].dispatchEvent({type:"disconnected",data:t}))}for(var r=0;r<n.added.length;r++){var a=n.added[r],i=U.indexOf(a);if(-1===i){for(var v=0;v<b.length;v++){if(v>=U.length){U.push(a),i=v;break}if(null===U[v]){U[v]=a,i=v;break}}if(-1===i)break}var c=b[i];c&&c.dispatchEvent({type:"connected",data:a})}}r.cameraAutoUpdate=!0,r.enabled=!1,r.isPresenting=!1,r.getController=function(n){var e=b[n];return void 0===e&&(e=new Cc,b[n]=e),e.getTargetRaySpace()},r.getControllerGrip=function(n){var e=b[n];return void 0===e&&(e=new Cc,b[n]=e),e.getGripSpace()},r.getHand=function(n){var e=b[n];return void 0===e&&(e=new Cc,b[n]=e),e.getHandSpace()},r.setFramebufferScaleFactor=function(n){v=n,!0===a.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},r.setReferenceSpaceType=function(n){s=n,!0===a.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},r.getReferenceSpace=function(){return l||c},r.setReferenceSpace=function(n){l=n},r.getBaseLayer=function(){return null!==p?p:m},r.getBinding=function(){return f},r.getFrame=function(){return d},r.getSession=function(){return i},r.setSession=function(){var e=T(P().mark((function e(t){var r,u,d,g,b;return P().wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(null===(i=t)){e.next=25;break}if(x=n.getRenderTarget(),i.addEventListener("select",R),i.addEventListener("selectstart",R),i.addEventListener("selectend",R),i.addEventListener("squeeze",R),i.addEventListener("squeezestart",R),i.addEventListener("squeezeend",R),i.addEventListener("end",D),i.addEventListener("inputsourceschange",F),!0===h.xrCompatible){e.next=14;break}return e.next=14,o.makeXRCompatible();case 14:return void 0===i.renderState.layers||!1===n.capabilities.isWebGL2?(r={antialias:void 0!==i.renderState.layers||h.antialias,alpha:h.alpha,depth:h.depth,stencil:h.stencil,framebufferScaleFactor:v},m=new XRWebGLLayer(i,o,r),i.updateRenderState({baseLayer:m}),y=new Ro(m.framebufferWidth,m.framebufferHeight,{format:ue,type:Kn,encoding:n.outputEncoding,stencilBuffer:h.stencil})):(u=null,d=null,g=null,h.depth&&(g=h.stencil?35056:33190,u=h.stencil?de:me,d=h.stencil?ce:oe),b={colorFormat:32856,depthFormat:g,scaleFactor:v},f=new XRWebGLBinding(i,o),p=f.createProjectionLayer(b),i.updateRenderState({layers:[p]}),y=new Ro(p.textureWidth,p.textureHeight,{format:ue,type:Kn,depthTexture:new Tc(p.textureWidth,p.textureHeight,d,void 0,void 0,void 0,void 0,void 0,void 0,u),stencilBuffer:h.stencil,encoding:n.outputEncoding,samples:h.antialias?4:0}),n.properties.get(y).__ignoreDepthValues=p.ignoreDepthValues),y.isXRRenderTarget=!0,this.setFoveation(1),l=null,e.next=20,i.requestReferenceSpace(s);case 20:c=e.sent,A.setContext(i),A.start(),a.isPresenting=!0,a.dispatchEvent({type:"sessionstart"});case 25:case"end":return e.stop()}}),e,this)})));return function(n){return e.apply(this,arguments)}}();var j=new Oo,I=new Oo;function E(n,e){null===e?n.matrixWorld.copy(n.matrix):n.matrixWorld.multiplyMatrices(e.matrixWorld,n.matrix),n.matrixWorldInverse.copy(n.matrixWorld).invert()}r.updateCamera=function(n){if(null!==i){k.near=w.near=_.near=n.near,k.far=w.far=_.far=n.far,z===k.near&&C===k.far||(i.updateRenderState({depthNear:k.near,depthFar:k.far}),z=k.near,C=k.far);var e=n.parent,t=k.cameras;E(k,e);for(var o=0;o<t.length;o++)E(t[o],e);k.matrixWorld.decompose(k.position,k.quaternion,k.scale),n.matrix.copy(k.matrix),n.matrix.decompose(n.position,n.quaternion,n.scale);for(var r=n.children,a=0,v=r.length;a<v;a++)r[a].updateMatrixWorld(!0);2===t.length?function(n,e,t){j.setFromMatrixPosition(e.matrixWorld),I.setFromMatrixPosition(t.matrixWorld);var o=j.distanceTo(I),r=e.projectionMatrix.elements,a=t.projectionMatrix.elements,i=r[14]/(r[10]-1),v=r[14]/(r[10]+1),c=(r[9]+1)/r[5],s=(r[9]-1)/r[5],l=(r[8]-1)/r[0],u=(a[8]+1)/a[0],f=i*l,p=i*u,m=o/(-l+u),d=m*-l;e.matrixWorld.decompose(n.position,n.quaternion,n.scale),n.translateX(d),n.translateZ(m),n.matrixWorld.compose(n.position,n.quaternion,n.scale),n.matrixWorldInverse.copy(n.matrixWorld).invert();var h=i+m,x=v+m,g=f-d,y=p+(o-d),b=c*v/x*h,U=s*v/x*h;n.projectionMatrix.makePerspective(g,y,b,U,h,x)}(k,_,w):k.projectionMatrix.copy(_.projectionMatrix)}},r.getCamera=function(){return k},r.getFoveation=function(){return null!==p?p.fixedFoveation:null!==m?m.fixedFoveation:void 0},r.setFoveation=function(n){null!==p&&(p.fixedFoveation=n),null!==m&&void 0!==m.fixedFoveation&&(m.fixedFoveation=n)};var O=null;var A=new oi;return A.setAnimationLoop((function(e,t){if(u=t.getViewerPose(l||c),d=t,null!==u){var o=u.views;null!==m&&(n.setRenderTargetFramebuffer(y,m.framebuffer),n.setRenderTarget(y));var r=!1;o.length!==k.cameras.length&&(k.cameras.length=0,r=!0);for(var a=0;a<o.length;a++){var i=o[a],v=null;if(null!==m)v=m.getViewport(i);else{var s=f.getViewSubImage(p,i);v=s.viewport,0===a&&(n.setRenderTargetTextures(y,s.colorTexture,p.ignoreDepthValues?void 0:s.depthStencilTexture),n.setRenderTarget(y))}var h=M[a];void 0===h&&((h=new Wa).layers.enable(a),h.viewport=new To,M[a]=h),h.matrix.fromArray(i.transform.matrix),h.projectionMatrix.fromArray(i.projectionMatrix),h.viewport.set(v.x,v.y,v.width,v.height),0===a&&k.matrix.copy(h.matrix),!0===r&&k.cameras.push(h)}}for(var x=0;x<b.length;x++){var g=U[x],_=b[x];null!==g&&void 0!==_&&_.update(g,t,l||c)}O&&O(e,t),d=null})),r.setAnimationLoop=function(n){O=n},r.dispose=function(){},r}return b(t)}(Vt);function Dc(n,e){function t(t,o){t.opacity.value=o.opacity,o.color&&t.diffuse.value.copy(o.color),o.emissive&&t.emissive.value.copy(o.emissive).multiplyScalar(o.emissiveIntensity),o.map&&(t.map.value=o.map),o.alphaMap&&(t.alphaMap.value=o.alphaMap),o.bumpMap&&(t.bumpMap.value=o.bumpMap,t.bumpScale.value=o.bumpScale,o.side===W&&(t.bumpScale.value*=-1)),o.displacementMap&&(t.displacementMap.value=o.displacementMap,t.displacementScale.value=o.displacementScale,t.displacementBias.value=o.displacementBias),o.emissiveMap&&(t.emissiveMap.value=o.emissiveMap),o.normalMap&&(t.normalMap.value=o.normalMap,t.normalScale.value.copy(o.normalScale),o.side===W&&t.normalScale.value.negate()),o.specularMap&&(t.specularMap.value=o.specularMap),o.alphaTest>0&&(t.alphaTest.value=o.alphaTest);var r,a,i=e.get(o).envMap;if(i&&(t.envMap.value=i,t.flipEnvMap.value=i.isCubeTexture&&!1===i.isRenderTargetTexture?-1:1,t.reflectivity.value=o.reflectivity,t.ior.value=o.ior,t.refractionRatio.value=o.refractionRatio),o.lightMap){t.lightMap.value=o.lightMap;var v=!0!==n.physicallyCorrectLights?Math.PI:1;t.lightMapIntensity.value=o.lightMapIntensity*v}o.aoMap&&(t.aoMap.value=o.aoMap,t.aoMapIntensity.value=o.aoMapIntensity),o.map?r=o.map:o.specularMap?r=o.specularMap:o.displacementMap?r=o.displacementMap:o.normalMap?r=o.normalMap:o.bumpMap?r=o.bumpMap:o.roughnessMap?r=o.roughnessMap:o.metalnessMap?r=o.metalnessMap:o.alphaMap?r=o.alphaMap:o.emissiveMap?r=o.emissiveMap:o.clearcoatMap?r=o.clearcoatMap:o.clearcoatNormalMap?r=o.clearcoatNormalMap:o.clearcoatRoughnessMap?r=o.clearcoatRoughnessMap:o.iridescenceMap?r=o.iridescenceMap:o.iridescenceThicknessMap?r=o.iridescenceThicknessMap:o.specularIntensityMap?r=o.specularIntensityMap:o.specularColorMap?r=o.specularColorMap:o.transmissionMap?r=o.transmissionMap:o.thicknessMap?r=o.thicknessMap:o.sheenColorMap?r=o.sheenColorMap:o.sheenRoughnessMap&&(r=o.sheenRoughnessMap),void 0!==r&&(r.isWebGLRenderTarget&&(r=r.texture),!0===r.matrixAutoUpdate&&r.updateMatrix(),t.uvTransform.value.copy(r.matrix)),o.aoMap?a=o.aoMap:o.lightMap&&(a=o.lightMap),void 0!==a&&(a.isWebGLRenderTarget&&(a=a.texture),!0===a.matrixAutoUpdate&&a.updateMatrix(),t.uv2Transform.value.copy(a.matrix))}return{refreshFogUniforms:function(n,e){n.fogColor.value.copy(e.color),e.isFog?(n.fogNear.value=e.near,n.fogFar.value=e.far):e.isFogExp2&&(n.fogDensity.value=e.density)},refreshMaterialUniforms:function(n,o,r,a,i){o.isMeshBasicMaterial||o.isMeshLambertMaterial?t(n,o):o.isMeshToonMaterial?(t(n,o),function(n,e){e.gradientMap&&(n.gradientMap.value=e.gradientMap)}(n,o)):o.isMeshPhongMaterial?(t(n,o),function(n,e){n.specular.value.copy(e.specular),n.shininess.value=Math.max(e.shininess,1e-4)}(n,o)):o.isMeshStandardMaterial?(t(n,o),function(n,t){n.roughness.value=t.roughness,n.metalness.value=t.metalness,t.roughnessMap&&(n.roughnessMap.value=t.roughnessMap);t.metalnessMap&&(n.metalnessMap.value=t.metalnessMap);e.get(t).envMap&&(n.envMapIntensity.value=t.envMapIntensity)}(n,o),o.isMeshPhysicalMaterial&&function(n,e,t){n.ior.value=e.ior,e.sheen>0&&(n.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen),n.sheenRoughness.value=e.sheenRoughness,e.sheenColorMap&&(n.sheenColorMap.value=e.sheenColorMap),e.sheenRoughnessMap&&(n.sheenRoughnessMap.value=e.sheenRoughnessMap));e.clearcoat>0&&(n.clearcoat.value=e.clearcoat,n.clearcoatRoughness.value=e.clearcoatRoughness,e.clearcoatMap&&(n.clearcoatMap.value=e.clearcoatMap),e.clearcoatRoughnessMap&&(n.clearcoatRoughnessMap.value=e.clearcoatRoughnessMap),e.clearcoatNormalMap&&(n.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),n.clearcoatNormalMap.value=e.clearcoatNormalMap,e.side===W&&n.clearcoatNormalScale.value.negate()));e.iridescence>0&&(n.iridescence.value=e.iridescence,n.iridescenceIOR.value=e.iridescenceIOR,n.iridescenceThicknessMinimum.value=e.iridescenceThicknessRange[0],n.iridescenceThicknessMaximum.value=e.iridescenceThicknessRange[1],e.iridescenceMap&&(n.iridescenceMap.value=e.iridescenceMap),e.iridescenceThicknessMap&&(n.iridescenceThicknessMap.value=e.iridescenceThicknessMap));e.transmission>0&&(n.transmission.value=e.transmission,n.transmissionSamplerMap.value=t.texture,n.transmissionSamplerSize.value.set(t.width,t.height),e.transmissionMap&&(n.transmissionMap.value=e.transmissionMap),n.thickness.value=e.thickness,e.thicknessMap&&(n.thicknessMap.value=e.thicknessMap),n.attenuationDistance.value=e.attenuationDistance,n.attenuationColor.value.copy(e.attenuationColor));n.specularIntensity.value=e.specularIntensity,n.specularColor.value.copy(e.specularColor),e.specularIntensityMap&&(n.specularIntensityMap.value=e.specularIntensityMap);e.specularColorMap&&(n.specularColorMap.value=e.specularColorMap)}(n,o,i)):o.isMeshMatcapMaterial?(t(n,o),function(n,e){e.matcap&&(n.matcap.value=e.matcap)}(n,o)):o.isMeshDepthMaterial?t(n,o):o.isMeshDistanceMaterial?(t(n,o),function(n,e){n.referencePosition.value.copy(e.referencePosition),n.nearDistance.value=e.nearDistance,n.farDistance.value=e.farDistance}(n,o)):o.isMeshNormalMaterial?t(n,o):o.isLineBasicMaterial?(function(n,e){n.diffuse.value.copy(e.color),n.opacity.value=e.opacity}(n,o),o.isLineDashedMaterial&&function(n,e){n.dashSize.value=e.dashSize,n.totalSize.value=e.dashSize+e.gapSize,n.scale.value=e.scale}(n,o)):o.isPointsMaterial?function(n,e,t,o){n.diffuse.value.copy(e.color),n.opacity.value=e.opacity,n.size.value=e.size*t,n.scale.value=.5*o,e.map&&(n.map.value=e.map);e.alphaMap&&(n.alphaMap.value=e.alphaMap);e.alphaTest>0&&(n.alphaTest.value=e.alphaTest);var r;e.map?r=e.map:e.alphaMap&&(r=e.alphaMap);void 0!==r&&(!0===r.matrixAutoUpdate&&r.updateMatrix(),n.uvTransform.value.copy(r.matrix))}(n,o,r,a):o.isSpriteMaterial?function(n,e){n.diffuse.value.copy(e.color),n.opacity.value=e.opacity,n.rotation.value=e.rotation,e.map&&(n.map.value=e.map);e.alphaMap&&(n.alphaMap.value=e.alphaMap);e.alphaTest>0&&(n.alphaTest.value=e.alphaTest);var t;e.map?t=e.map:e.alphaMap&&(t=e.alphaMap);void 0!==t&&(!0===t.matrixAutoUpdate&&t.updateMatrix(),n.uvTransform.value.copy(t.matrix))}(n,o):o.isShadowMaterial?(n.color.value.copy(o.color),n.opacity.value=o.opacity):o.isShaderMaterial&&(o.uniformsNeedUpdate=!1)}}}function Pc(n,e,t,o){var r={},a={},i=[],v=t.isWebGL2?n.getParameter(35375):0;function c(n,e,t){var o=n.value;if(void 0===t[e])return t[e]="number"===typeof o?o:o.clone(),!0;if("number"===typeof o){if(t[e]!==o)return t[e]=o,!0}else{var r=t[e];if(!1===r.equals(o))return r.copy(o),!0}return!1}function s(n){var e=n.value,t={boundary:0,storage:0};return"number"===typeof e?(t.boundary=4,t.storage=4):e.isVector2?(t.boundary=8,t.storage=8):e.isVector3||e.isColor?(t.boundary=16,t.storage=12):e.isVector4?(t.boundary=16,t.storage=16):e.isMatrix3?(t.boundary=48,t.storage=48):e.isMatrix4?(t.boundary=64,t.storage=64):e.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",e),t}function l(e){var t=e.target;t.removeEventListener("dispose",l);var o=i.indexOf(t.__bindingPointIndex);i.splice(o,1),n.deleteBuffer(r[t.id]),delete r[t.id],delete a[t.id]}return{bind:function(n,e){var t=e.program;o.uniformBlockBinding(n,t)},update:function(t,u){var f=r[t.id];void 0===f&&(!function(n){for(var e=n.uniforms,t=0,o=16,r=0,a=0,i=e.length;a<i;a++){var v=e[a],c=s(v);if(v.__data=new Float32Array(c.storage/Float32Array.BYTES_PER_ELEMENT),v.__offset=t,a>0)0!==(r=t%o)&&o-r-c.boundary<0&&(t+=o-r,v.__offset=t);t+=c.storage}(r=t%o)>0&&(t+=o-r);n.__size=t,n.__cache={}}(t),f=function(e){var t=function(){for(var n=0;n<v;n++)if(-1===i.indexOf(n))return i.push(n),n;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();e.__bindingPointIndex=t;var o=n.createBuffer(),r=e.__size,a=e.usage;return n.bindBuffer(35345,o),n.bufferData(35345,r,a),n.bindBuffer(35345,null),n.bindBufferBase(35345,t,o),o}(t),r[t.id]=f,t.addEventListener("dispose",l));var p=u.program;o.updateUBOMapping(t,p);var m=e.render.frame;a[t.id]!==m&&(!function(e){var t=r[e.id],o=e.uniforms,a=e.__cache;n.bindBuffer(35345,t);for(var i=0,v=o.length;i<v;i++){var s=o[i];if(!0===c(s,i,a)){var l=s.value,u=s.__offset;"number"===typeof l?(s.__data[0]=l,n.bufferSubData(35345,u,s.__data)):(s.value.isMatrix3?(s.__data[0]=s.value.elements[0],s.__data[1]=s.value.elements[1],s.__data[2]=s.value.elements[2],s.__data[3]=s.value.elements[0],s.__data[4]=s.value.elements[3],s.__data[5]=s.value.elements[4],s.__data[6]=s.value.elements[5],s.__data[7]=s.value.elements[0],s.__data[8]=s.value.elements[6],s.__data[9]=s.value.elements[7],s.__data[10]=s.value.elements[8],s.__data[11]=s.value.elements[0]):l.toArray(s.__data),n.bufferSubData(35345,u,s.__data))}}n.bindBuffer(35345,null)}(t),a[t.id]=m)},dispose:function(){for(var e in r)n.deleteBuffer(r[e]);i=[],r={},a={}}}}function Fc(){var n=lo("canvas");return n.style.display="block",n}function jc(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.isWebGLRenderer=!0;var e,t=void 0!==n.canvas?n.canvas:Fc(),o=void 0!==n.context?n.context:null,r=void 0===n.depth||n.depth,a=void 0===n.stencil||n.stencil,i=void 0!==n.antialias&&n.antialias,v=void 0===n.premultipliedAlpha||n.premultipliedAlpha,c=void 0!==n.preserveDrawingBuffer&&n.preserveDrawingBuffer,s=void 0!==n.powerPreference?n.powerPreference:"default",l=void 0!==n.failIfMajorPerformanceCaveat&&n.failIfMajorPerformanceCaveat;e=null!==o?o.getContextAttributes().alpha:void 0!==n.alpha&&n.alpha;var u=null,f=null,p=[],m=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=vt,this.physicallyCorrectLights=!1,this.toneMapping=zn,this.toneMappingExposure=1,Object.defineProperties(this,{gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});var d=this,h=!1,x=0,g=0,y=null,b=-1,U=null,_=new To,w=new To,S=null,M=t.width,k=t.height,z=1,C=null,T=null,R=new To(0,0,M,k),D=new To(0,0,M,k),P=!1,j=new ti,I=!1,E=!1,O=null,A=new pr,L=new ao,G=new Oo,N={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function B(){return null===y?z:1}var q,X,Y,Z,Q,J,K,$,nn,en,tn,on,rn,an,vn,cn,sn,ln,un,fn,pn,mn,dn,hn,xn=o;function gn(n,e){for(var o=0;o<n.length;o++){var r=n[o],a=t.getContext(r,e);if(null!==a)return a}return null}try{var yn={alpha:!0,depth:r,stencil:a,antialias:i,premultipliedAlpha:v,preserveDrawingBuffer:c,powerPreference:s,failIfMajorPerformanceCaveat:l};if("setAttribute"in t&&t.setAttribute("data-engine","three.js r".concat(F)),t.addEventListener("webglcontextlost",wn,!1),t.addEventListener("webglcontextrestored",Sn,!1),t.addEventListener("webglcontextcreationerror",Mn,!1),null===xn){var bn=["webgl2","webgl","experimental-webgl"];if(!0===d.isWebGL1Renderer&&bn.shift(),null===(xn=gn(bn,yn)))throw gn(bn)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===xn.getShaderPrecisionFormat&&(xn.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(Wn){throw console.error("THREE.WebGLRenderer: "+Wn.message),Wn}function Un(){q=new Ri(xn),X=new fi(xn,q,n),q.init(X),mn=new Sc(xn,q,X),Y=new _c(xn,q,X),Z=new Fi,Q=new cc,J=new wc(xn,q,Y,Q,X,mn,Z),K=new mi(d),$=new Ti(d),nn=new ri(xn,X),dn=new li(xn,q,nn,X),en=new Di(xn,nn,Z,dn),tn=new Oi(xn,en,nn,Z),un=new Ei(xn,X,J),cn=new pi(Q),on=new vc(d,K,$,q,X,dn,cn),rn=new Dc(d,Q),an=new fc,vn=new gc(q,X),ln=new si(d,K,$,Y,tn,e,v),sn=new Uc(d,tn,X),hn=new Pc(xn,Z,X,Y),fn=new ui(xn,q,Z,X),pn=new Pi(xn,q,Z,X),Z.programs=on.programs,d.capabilities=X,d.extensions=q,d.properties=Q,d.renderLists=an,d.shadowMap=sn,d.state=Y,d.info=Z}Un();var _n=new Rc(d,xn);function wn(n){n.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),h=!0}function Sn(){console.log("THREE.WebGLRenderer: Context Restored."),h=!1;var n=Z.autoReset,e=sn.enabled,t=sn.autoUpdate,o=sn.needsUpdate,r=sn.type;Un(),Z.autoReset=n,sn.enabled=e,sn.autoUpdate=t,sn.needsUpdate=o,sn.type=r}function Mn(n){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",n.statusMessage)}function kn(n){var e=n.target;e.removeEventListener("dispose",kn),Cn(e)}function Cn(n){Tn(n),Q.remove(n)}function Tn(n){var e=Q.get(n).programs;void 0!==e&&(e.forEach((function(n){on.releaseProgram(n)})),n.isShaderMaterial&&on.releaseShaderCache(n))}this.xr=_n,this.getContext=function(){return xn},this.getContextAttributes=function(){return xn.getContextAttributes()},this.forceContextLoss=function(){var n=q.get("WEBGL_lose_context");n&&n.loseContext()},this.forceContextRestore=function(){var n=q.get("WEBGL_lose_context");n&&n.restoreContext()},this.getPixelRatio=function(){return z},this.setPixelRatio=function(n){void 0!==n&&(z=n,this.setSize(M,k,!1))},this.getSize=function(n){return n.set(M,k)},this.setSize=function(n,e,o){_n.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(M=n,k=e,t.width=Math.floor(n*z),t.height=Math.floor(e*z),!1!==o&&(t.style.width=n+"px",t.style.height=e+"px"),this.setViewport(0,0,n,e))},this.getDrawingBufferSize=function(n){return n.set(M*z,k*z).floor()},this.setDrawingBufferSize=function(n,e,o){M=n,k=e,z=o,t.width=Math.floor(n*o),t.height=Math.floor(e*o),this.setViewport(0,0,n,e)},this.getCurrentViewport=function(n){return n.copy(_)},this.getViewport=function(n){return n.copy(R)},this.setViewport=function(n,e,t,o){n.isVector4?R.set(n.x,n.y,n.z,n.w):R.set(n,e,t,o),Y.viewport(_.copy(R).multiplyScalar(z).floor())},this.getScissor=function(n){return n.copy(D)},this.setScissor=function(n,e,t,o){n.isVector4?D.set(n.x,n.y,n.z,n.w):D.set(n,e,t,o),Y.scissor(w.copy(D).multiplyScalar(z).floor())},this.getScissorTest=function(){return P},this.setScissorTest=function(n){Y.setScissorTest(P=n)},this.setOpaqueSort=function(n){C=n},this.setTransparentSort=function(n){T=n},this.getClearColor=function(n){return n.copy(ln.getClearColor())},this.setClearColor=function(){ln.setClearColor.apply(ln,arguments)},this.getClearAlpha=function(){return ln.getClearAlpha()},this.setClearAlpha=function(){ln.setClearAlpha.apply(ln,arguments)},this.clear=function(){var n=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],t=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],o=0;n&&(o|=16384),e&&(o|=256),t&&(o|=1024),xn.clear(o)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",wn,!1),t.removeEventListener("webglcontextrestored",Sn,!1),t.removeEventListener("webglcontextcreationerror",Mn,!1),an.dispose(),vn.dispose(),Q.dispose(),K.dispose(),$.dispose(),tn.dispose(),dn.dispose(),hn.dispose(),on.dispose(),_n.dispose(),_n.removeEventListener("sessionstart",Pn),_n.removeEventListener("sessionend",Fn),O&&(O.dispose(),O=null),jn.stop()},this.renderBufferDirect=function(n,e,t,o,r,a){null===e&&(e=N);var i=r.isMesh&&r.matrixWorld.determinant()<0,v=Bn(n,e,t,o,r);Y.setMaterial(o,i);var c=t.index,s=t.attributes.position;if(null===c){if(void 0===s||0===s.count)return}else if(0===c.count)return;var l,u=1;!0===o.wireframe&&(c=en.getWireframeAttribute(t),u=2),dn.setup(r,o,v,t,c);var f=fn;null!==c&&(l=nn.get(c),(f=pn).setIndex(l));var p=null!==c?c.count:s.count,m=t.drawRange.start*u,d=t.drawRange.count*u,h=null!==a?a.start*u:0,x=null!==a?a.count*u:1/0,g=Math.max(m,h),y=Math.min(p,m+d,h+x)-1,b=Math.max(0,y-g+1);if(0!==b){if(r.isMesh)!0===o.wireframe?(Y.setLineWidth(o.wireframeLinewidth*B()),f.setMode(1)):f.setMode(4);else if(r.isLine){var U=o.linewidth;void 0===U&&(U=1),Y.setLineWidth(U*B()),r.isLineSegments?f.setMode(1):r.isLineLoop?f.setMode(2):f.setMode(3)}else r.isPoints?f.setMode(0):r.isSprite&&f.setMode(4);if(r.isInstancedMesh)f.renderInstances(g,b,r.count);else if(t.isInstancedBufferGeometry){var _=Math.min(t.instanceCount,t._maxInstanceCount);f.renderInstances(g,b,_)}else f.render(g,b)}},this.compile=function(n,e){function t(n,e,t){!0===n.transparent&&n.side===H?(n.side=W,n.needsUpdate=!0,Gn(n,e,t),n.side=V,n.needsUpdate=!0,Gn(n,e,t),n.side=H):Gn(n,e,t)}(f=vn.get(n)).init(),m.push(f),n.traverseVisible((function(n){n.isLight&&n.layers.test(e.layers)&&(f.pushLight(n),n.castShadow&&f.pushShadow(n))})),f.setupLights(d.physicallyCorrectLights),n.traverse((function(e){var o=e.material;if(o)if(Array.isArray(o))for(var r=0;r<o.length;r++){t(o[r],n,e)}else t(o,n,e)})),m.pop(),f=null};var Rn=null;function Dn(n){Rn&&Rn(n)}function Pn(){jn.stop()}function Fn(){jn.start()}var jn=new oi;function In(n,e,t,o){if(!1!==n.visible){if(n.layers.test(e.layers))if(n.isGroup)t=n.renderOrder;else if(n.isLOD)!0===n.autoUpdate&&n.update(e);else if(n.isLight)f.pushLight(n),n.castShadow&&f.pushShadow(n);else if(n.isSprite){if(!n.frustumCulled||j.intersectsSprite(n)){o&&G.setFromMatrixPosition(n.matrixWorld).applyMatrix4(A);var r=tn.update(n),a=n.material;a.visible&&u.push(n,r,a,t,G.z,null)}}else if((n.isMesh||n.isLine||n.isPoints)&&(n.isSkinnedMesh&&n.skeleton.frame!==Z.render.frame&&(n.skeleton.update(),n.skeleton.frame=Z.render.frame),!n.frustumCulled||j.intersectsObject(n))){o&&G.setFromMatrixPosition(n.matrixWorld).applyMatrix4(A);var i=tn.update(n),v=n.material;if(Array.isArray(v))for(var c=i.groups,s=0,l=c.length;s<l;s++){var p=c[s],m=v[p.materialIndex];m&&m.visible&&u.push(n,i,m,t,G.z,p)}else v.visible&&u.push(n,i,v,t,G.z,null)}for(var d=n.children,h=0,x=d.length;h<x;h++)In(d[h],e,t,o)}}function En(n,e,t,o){var r=n.opaque,a=n.transmissive,i=n.transparent;f.setupLightsView(t),a.length>0&&On(r,e,t),o&&Y.viewport(_.copy(o)),r.length>0&&An(r,e,t),a.length>0&&An(a,e,t),i.length>0&&An(i,e,t),Y.buffers.depth.setTest(!0),Y.buffers.depth.setMask(!0),Y.buffers.color.setMask(!0),Y.setPolygonOffset(!1)}function On(n,e,t){var o=X.isWebGL2;null===O&&(O=new Ro(1,1,{generateMipmaps:!0,type:q.has("EXT_color_buffer_half_float")?ae:Kn,minFilter:Qn,samples:o&&!0===i?4:0})),d.getDrawingBufferSize(L),o?O.setSize(L.x,L.y):O.setSize(eo(L.x),eo(L.y));var r=d.getRenderTarget();d.setRenderTarget(O),d.clear();var a=d.toneMapping;d.toneMapping=zn,An(n,e,t),d.toneMapping=a,J.updateMultisampleRenderTarget(O),J.updateRenderTargetMipmap(O),d.setRenderTarget(r)}function An(n,e,t){for(var o=!0===e.isScene?e.overrideMaterial:null,r=0,a=n.length;r<a;r++){var i=n[r],v=i.object,c=i.geometry,s=null===o?i.material:o,l=i.group;v.layers.test(t.layers)&&Ln(v,e,t,c,s,l)}}function Ln(n,e,t,o,r,a){n.onBeforeRender(d,e,t,o,r,a),n.modelViewMatrix.multiplyMatrices(t.matrixWorldInverse,n.matrixWorld),n.normalMatrix.getNormalMatrix(n.modelViewMatrix),r.onBeforeRender(d,e,t,o,n,a),!0===r.transparent&&r.side===H?(r.side=W,r.needsUpdate=!0,d.renderBufferDirect(t,e,o,r,n,a),r.side=V,r.needsUpdate=!0,d.renderBufferDirect(t,e,o,r,n,a),r.side=H):d.renderBufferDirect(t,e,o,r,n,a),n.onAfterRender(d,e,t,o,r,a)}function Gn(n,e,t){!0!==e.isScene&&(e=N);var o=Q.get(n),r=f.state.lights,a=f.state.shadowsArray,i=r.state.version,v=on.getParameters(n,r.state,a,e,t),c=on.getProgramCacheKey(v),s=o.programs;o.environment=n.isMeshStandardMaterial?e.environment:null,o.fog=e.fog,o.envMap=(n.isMeshStandardMaterial?$:K).get(n.envMap||o.environment),void 0===s&&(n.addEventListener("dispose",kn),s=new Map,o.programs=s);var l=s.get(c);if(void 0!==l){if(o.currentProgram===l&&o.lightsStateVersion===i)return Nn(n,v),l}else v.uniforms=on.getUniforms(n),n.onBuild(t,v,d),n.onBeforeCompile(v,d),l=on.acquireProgram(v,c),s.set(c,l),o.uniforms=v.uniforms;var u=o.uniforms;(n.isShaderMaterial||n.isRawShaderMaterial)&&!0!==n.clipping||(u.clippingPlanes=cn.uniform),Nn(n,v),o.needsLights=Vn(n),o.lightsStateVersion=i,o.needsLights&&(u.ambientLightColor.value=r.state.ambient,u.lightProbe.value=r.state.probe,u.directionalLights.value=r.state.directional,u.directionalLightShadows.value=r.state.directionalShadow,u.spotLights.value=r.state.spot,u.spotLightShadows.value=r.state.spotShadow,u.rectAreaLights.value=r.state.rectArea,u.ltc_1.value=r.state.rectAreaLTC1,u.ltc_2.value=r.state.rectAreaLTC2,u.pointLights.value=r.state.point,u.pointLightShadows.value=r.state.pointShadow,u.hemisphereLights.value=r.state.hemi,u.directionalShadowMap.value=r.state.directionalShadowMap,u.directionalShadowMatrix.value=r.state.directionalShadowMatrix,u.spotShadowMap.value=r.state.spotShadowMap,u.spotLightMatrix.value=r.state.spotLightMatrix,u.spotLightMap.value=r.state.spotLightMap,u.pointShadowMap.value=r.state.pointShadowMap,u.pointShadowMatrix.value=r.state.pointShadowMatrix);var p=l.getUniforms(),m=Nv.seqWithValue(p.seq,u);return o.currentProgram=l,o.uniformsList=m,l}function Nn(n,e){var t=Q.get(n);t.outputEncoding=e.outputEncoding,t.instancing=e.instancing,t.skinning=e.skinning,t.morphTargets=e.morphTargets,t.morphNormals=e.morphNormals,t.morphColors=e.morphColors,t.morphTargetsCount=e.morphTargetsCount,t.numClippingPlanes=e.numClippingPlanes,t.numIntersection=e.numClipIntersection,t.vertexAlphas=e.vertexAlphas,t.vertexTangents=e.vertexTangents,t.toneMapping=e.toneMapping}function Bn(n,e,t,o,r){!0!==e.isScene&&(e=N),J.resetTextureUnits();var a=e.fog,i=o.isMeshStandardMaterial?e.environment:null,v=null===y?d.outputEncoding:!0===y.isXRRenderTarget?y.texture.encoding:vt,c=(o.isMeshStandardMaterial?$:K).get(o.envMap||i),s=!0===o.vertexColors&&!!t.attributes.color&&4===t.attributes.color.itemSize,l=!!o.normalMap&&!!t.attributes.tangent,u=!!t.morphAttributes.position,p=!!t.morphAttributes.normal,m=!!t.morphAttributes.color,h=o.toneMapped?d.toneMapping:zn,x=t.morphAttributes.position||t.morphAttributes.normal||t.morphAttributes.color,g=void 0!==x?x.length:0,_=Q.get(o),w=f.state.lights;if(!0===I&&(!0===E||n!==U)){var S=n===U&&o.id===b;cn.setState(o,n,S)}var M=!1;o.version===_.__version?_.needsLights&&_.lightsStateVersion!==w.state.version||_.outputEncoding!==v||r.isInstancedMesh&&!1===_.instancing?M=!0:r.isInstancedMesh||!0!==_.instancing?r.isSkinnedMesh&&!1===_.skinning?M=!0:r.isSkinnedMesh||!0!==_.skinning?_.envMap!==c||!0===o.fog&&_.fog!==a?M=!0:void 0===_.numClippingPlanes||_.numClippingPlanes===cn.numPlanes&&_.numIntersection===cn.numIntersection?(_.vertexAlphas!==s||_.vertexTangents!==l||_.morphTargets!==u||_.morphNormals!==p||_.morphColors!==m||_.toneMapping!==h||!0===X.isWebGL2&&_.morphTargetsCount!==g)&&(M=!0):M=!0:M=!0:M=!0:(M=!0,_.__version=o.version);var C=_.currentProgram;!0===M&&(C=Gn(o,e,r));var T=!1,R=!1,D=!1,P=C.getUniforms(),F=_.uniforms;if(Y.useProgram(C.program)&&(T=!0,R=!0,D=!0),o.id!==b&&(b=o.id,R=!0),T||U!==n){if(P.setValue(xn,"projectionMatrix",n.projectionMatrix),X.logarithmicDepthBuffer&&P.setValue(xn,"logDepthBufFC",2/(Math.log(n.far+1)/Math.LN2)),U!==n&&(U=n,R=!0,D=!0),o.isShaderMaterial||o.isMeshPhongMaterial||o.isMeshToonMaterial||o.isMeshStandardMaterial||o.envMap){var j=P.map.cameraPosition;void 0!==j&&j.setValue(xn,G.setFromMatrixPosition(n.matrixWorld))}(o.isMeshPhongMaterial||o.isMeshToonMaterial||o.isMeshLambertMaterial||o.isMeshBasicMaterial||o.isMeshStandardMaterial||o.isShaderMaterial)&&P.setValue(xn,"isOrthographic",!0===n.isOrthographicCamera),(o.isMeshPhongMaterial||o.isMeshToonMaterial||o.isMeshLambertMaterial||o.isMeshBasicMaterial||o.isMeshStandardMaterial||o.isShaderMaterial||o.isShadowMaterial||r.isSkinnedMesh)&&P.setValue(xn,"viewMatrix",n.matrixWorldInverse)}if(r.isSkinnedMesh){P.setOptional(xn,r,"bindMatrix"),P.setOptional(xn,r,"bindMatrixInverse");var A=r.skeleton;A&&(X.floatVertexTextures?(null===A.boneTexture&&A.computeBoneTexture(),P.setValue(xn,"boneTexture",A.boneTexture,J),P.setValue(xn,"boneTextureSize",A.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}var L=t.morphAttributes;if((void 0!==L.position||void 0!==L.normal||void 0!==L.color&&!0===X.isWebGL2)&&un.update(r,t,o,C),(R||_.receiveShadow!==r.receiveShadow)&&(_.receiveShadow=r.receiveShadow,P.setValue(xn,"receiveShadow",r.receiveShadow)),o.isMeshGouraudMaterial&&null!==o.envMap&&(F.envMap.value=c,F.flipEnvMap.value=c.isCubeTexture&&!1===c.isRenderTargetTexture?-1:1),R&&(P.setValue(xn,"toneMappingExposure",d.toneMappingExposure),_.needsLights&&qn(F,D),a&&!0===o.fog&&rn.refreshFogUniforms(F,a),rn.refreshMaterialUniforms(F,o,z,k,O),Nv.upload(xn,_.uniformsList,F,J)),o.isShaderMaterial&&!0===o.uniformsNeedUpdate&&(Nv.upload(xn,_.uniformsList,F,J),o.uniformsNeedUpdate=!1),o.isSpriteMaterial&&P.setValue(xn,"center",r.center),P.setValue(xn,"modelViewMatrix",r.modelViewMatrix),P.setValue(xn,"normalMatrix",r.normalMatrix),P.setValue(xn,"modelMatrix",r.matrixWorld),o.isShaderMaterial||o.isRawShaderMaterial)for(var B=o.uniformsGroups,q=0,V=B.length;q<V;q++)if(X.isWebGL2){var W=B[q];hn.update(W,C),hn.bind(W,C)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");return C}function qn(n,e){n.ambientLightColor.needsUpdate=e,n.lightProbe.needsUpdate=e,n.directionalLights.needsUpdate=e,n.directionalLightShadows.needsUpdate=e,n.pointLights.needsUpdate=e,n.pointLightShadows.needsUpdate=e,n.spotLights.needsUpdate=e,n.spotLightShadows.needsUpdate=e,n.rectAreaLights.needsUpdate=e,n.hemisphereLights.needsUpdate=e}function Vn(n){return n.isMeshLambertMaterial||n.isMeshToonMaterial||n.isMeshPhongMaterial||n.isMeshStandardMaterial||n.isShadowMaterial||n.isShaderMaterial&&!0===n.lights}jn.setAnimationLoop(Dn),"undefined"!==typeof self&&jn.setContext(self),this.setAnimationLoop=function(n){Rn=n,_n.setAnimationLoop(n),null===n?jn.stop():jn.start()},_n.addEventListener("sessionstart",Pn),_n.addEventListener("sessionend",Fn),this.render=function(n,e){if(void 0===e||!0===e.isCamera){if(!0!==h){!0===n.matrixWorldAutoUpdate&&n.updateMatrixWorld(),null===e.parent&&!0===e.matrixWorldAutoUpdate&&e.updateMatrixWorld(),!0===_n.enabled&&!0===_n.isPresenting&&(!0===_n.cameraAutoUpdate&&_n.updateCamera(e),e=_n.getCamera()),!0===n.isScene&&n.onBeforeRender(d,n,e,y),(f=vn.get(n,m.length)).init(),m.push(f),A.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),j.setFromProjectionMatrix(A),E=this.localClippingEnabled,I=cn.init(this.clippingPlanes,E,e),(u=an.get(n,p.length)).init(),p.push(u),In(n,e,0,d.sortObjects),u.finish(),!0===d.sortObjects&&u.sort(C,T),!0===I&&cn.beginShadows();var t=f.state.shadowsArray;if(sn.render(t,n,e),!0===I&&cn.endShadows(),!0===this.info.autoReset&&this.info.reset(),ln.render(u,n),f.setupLights(d.physicallyCorrectLights),e.isArrayCamera)for(var o=e.cameras,r=0,a=o.length;r<a;r++){var i=o[r];En(u,n,i,i.viewport)}else En(u,n,e);null!==y&&(J.updateMultisampleRenderTarget(y),J.updateRenderTargetMipmap(y)),!0===n.isScene&&n.onAfterRender(d,n,e),dn.resetDefaultState(),b=-1,U=null,m.pop(),f=m.length>0?m[m.length-1]:null,p.pop(),u=p.length>0?p[p.length-1]:null}}else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")},this.getActiveCubeFace=function(){return x},this.getActiveMipmapLevel=function(){return g},this.getRenderTarget=function(){return y},this.setRenderTargetTextures=function(n,e,t){Q.get(n.texture).__webglTexture=e,Q.get(n.depthTexture).__webglTexture=t;var o=Q.get(n);o.__hasExternalTextures=!0,o.__hasExternalTextures&&(o.__autoAllocateDepthBuffer=void 0===t,o.__autoAllocateDepthBuffer||!0===q.has("WEBGL_multisampled_render_to_texture")&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),o.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(n,e){var t=Q.get(n);t.__webglFramebuffer=e,t.__useDefaultFramebuffer=void 0===e},this.setRenderTarget=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;y=n,x=e,g=t;var o=!0,r=null,a=!1,i=!1;if(n){var v=Q.get(n);void 0!==v.__useDefaultFramebuffer?(Y.bindFramebuffer(36160,null),o=!1):void 0===v.__webglFramebuffer?J.setupRenderTarget(n):v.__hasExternalTextures&&J.rebindTextures(n,Q.get(n.texture).__webglTexture,Q.get(n.depthTexture).__webglTexture);var c=n.texture;(c.isData3DTexture||c.isDataArrayTexture||c.isCompressedArrayTexture)&&(i=!0);var s=Q.get(n).__webglFramebuffer;n.isWebGLCubeRenderTarget?(r=s[e],a=!0):r=X.isWebGL2&&n.samples>0&&!1===J.useMultisampledRTT(n)?Q.get(n).__webglMultisampledFramebuffer:s,_.copy(n.viewport),w.copy(n.scissor),S=n.scissorTest}else _.copy(R).multiplyScalar(z).floor(),w.copy(D).multiplyScalar(z).floor(),S=P;var l=Y.bindFramebuffer(36160,r);if(l&&X.drawBuffers&&o&&Y.drawBuffers(n,r),Y.viewport(_),Y.scissor(w),Y.setScissorTest(S),a){var u=Q.get(n.texture);xn.framebufferTexture2D(36160,36064,34069+e,u.__webglTexture,t)}else if(i){var f=Q.get(n.texture),p=e||0;xn.framebufferTextureLayer(36160,36064,f.__webglTexture,t||0,p)}b=-1},this.readRenderTargetPixels=function(n,e,t,o,r,a,i){if(n&&n.isWebGLRenderTarget){var v=Q.get(n).__webglFramebuffer;if(n.isWebGLCubeRenderTarget&&void 0!==i&&(v=v[i]),v){Y.bindFramebuffer(36160,v);try{var c=n.texture,s=c.format,l=c.type;if(s!==ue&&mn.convert(s)!==xn.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");var u=l===ae&&(q.has("EXT_color_buffer_half_float")||X.isWebGL2&&q.has("EXT_color_buffer_float"));if(l!==Kn&&mn.convert(l)!==xn.getParameter(35738)&&(l!==re||!(X.isWebGL2||q.has("OES_texture_float")||q.has("WEBGL_color_buffer_float")))&&!u)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");e>=0&&e<=n.width-o&&t>=0&&t<=n.height-r&&xn.readPixels(e,t,o,r,mn.convert(s),mn.convert(l),a)}finally{var f=null!==y?Q.get(y).__webglFramebuffer:null;Y.bindFramebuffer(36160,f)}}}else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")},this.copyFramebufferToTexture=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=Math.pow(2,-t),r=Math.floor(e.image.width*o),a=Math.floor(e.image.height*o);J.setTexture2D(e,0),xn.copyTexSubImage2D(3553,t,0,0,n.x,n.y,r,a),Y.unbindTexture()},this.copyTextureToTexture=function(n,e,t){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=e.image.width,a=e.image.height,i=mn.convert(t.format),v=mn.convert(t.type);J.setTexture2D(t,0),xn.pixelStorei(37440,t.flipY),xn.pixelStorei(37441,t.premultiplyAlpha),xn.pixelStorei(3317,t.unpackAlignment),e.isDataTexture?xn.texSubImage2D(3553,o,n.x,n.y,r,a,i,v,e.image.data):e.isCompressedTexture?xn.compressedTexSubImage2D(3553,o,n.x,n.y,e.mipmaps[0].width,e.mipmaps[0].height,i,e.mipmaps[0].data):xn.texSubImage2D(3553,o,n.x,n.y,i,v,e.image),0===o&&t.generateMipmaps&&xn.generateMipmap(3553),Y.unbindTexture()},this.copyTextureToTexture3D=function(n,e,t,o){var r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;if(d.isWebGL1Renderer)console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");else{var a,i=n.max.x-n.min.x+1,v=n.max.y-n.min.y+1,c=n.max.z-n.min.z+1,s=mn.convert(o.format),l=mn.convert(o.type);if(o.isData3DTexture)J.setTexture3D(o,0),a=32879;else{if(!o.isDataArrayTexture)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");J.setTexture2DArray(o,0),a=35866}xn.pixelStorei(37440,o.flipY),xn.pixelStorei(37441,o.premultiplyAlpha),xn.pixelStorei(3317,o.unpackAlignment);var u=xn.getParameter(3314),f=xn.getParameter(32878),p=xn.getParameter(3316),m=xn.getParameter(3315),h=xn.getParameter(32877),x=t.isCompressedTexture?t.mipmaps[0]:t.image;xn.pixelStorei(3314,x.width),xn.pixelStorei(32878,x.height),xn.pixelStorei(3316,n.min.x),xn.pixelStorei(3315,n.min.y),xn.pixelStorei(32877,n.min.z),t.isDataTexture||t.isData3DTexture?xn.texSubImage3D(a,r,e.x,e.y,e.z,i,v,c,s,l,x.data):t.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),xn.compressedTexSubImage3D(a,r,e.x,e.y,e.z,i,v,c,s,x.data)):xn.texSubImage3D(a,r,e.x,e.y,e.z,i,v,c,s,l,x),xn.pixelStorei(3314,u),xn.pixelStorei(32878,f),xn.pixelStorei(3316,p),xn.pixelStorei(3315,m),xn.pixelStorei(32877,h),0===r&&o.generateMipmaps&&xn.generateMipmap(a),Y.unbindTexture()}},this.initTexture=function(n){n.isCubeTexture?J.setTextureCube(n,0):n.isData3DTexture?J.setTexture3D(n,0):n.isDataArrayTexture||n.isCompressedArrayTexture?J.setTexture2DArray(n,0):J.setTexture2D(n,0),Y.unbindTexture()},this.resetState=function(){x=0,g=0,y=null,Y.reset(),dn.reset()},"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}var Ic=function(n){U(t,n);var e=k(t);function t(){return g(this,t),e.apply(this,arguments)}return b(t)}(jc);Ic.prototype.isWebGL1Renderer=!0;var Ec,Oc=function(){function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:25e-5;g(this,n),this.isFogExp2=!0,this.name="",this.color=new wo(e),this.density=t}return b(n,[{key:"clone",value:function(){return new n(this.color,this.density)}},{key:"toJSON",value:function(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}]),n}(),Ac=function(){function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;g(this,n),this.isFog=!0,this.name="",this.color=new wo(e),this.near=t,this.far=o}return b(n,[{key:"clone",value:function(){return new n(this.color,this.near,this.far)}},{key:"toJSON",value:function(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}]),n}(),Lc=function(n){U(t,n);var e=k(t);function t(){var n;return g(this,t),(n=e.call(this)).isScene=!0,n.type="Scene",n.background=null,n.environment=null,n.fog=null,n.backgroundBlurriness=0,n.overrideMaterial=null,"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:S(n)})),n}return b(t,[{key:"copy",value:function(n,e){return D(_(t.prototype),"copy",this).call(this,n,e),null!==n.background&&(this.background=n.background.clone()),null!==n.environment&&(this.environment=n.environment.clone()),null!==n.fog&&(this.fog=n.fog.clone()),this.backgroundBlurriness=n.backgroundBlurriness,null!==n.overrideMaterial&&(this.overrideMaterial=n.overrideMaterial.clone()),this.matrixAutoUpdate=n.matrixAutoUpdate,this}},{key:"toJSON",value:function(n){var e=D(_(t.prototype),"toJSON",this).call(this,n);return null!==this.fog&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.backgroundBlurriness=this.backgroundBlurriness),e}},{key:"autoUpdate",get:function(){return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate},set:function(n){console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate=n}}]),t}(Ar),Gc=function(){function n(e,t){g(this,n),this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=void 0!==e?e.length/t:0,this.usage=Pt,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Zt()}return b(n,[{key:"onUploadCallback",value:function(){}},{key:"needsUpdate",set:function(n){!0===n&&this.version++}},{key:"setUsage",value:function(n){return this.usage=n,this}},{key:"copy",value:function(n){return this.array=new n.array.constructor(n.array),this.count=n.count,this.stride=n.stride,this.usage=n.usage,this}},{key:"copyAt",value:function(n,e,t){n*=this.stride,t*=e.stride;for(var o=0,r=this.stride;o<r;o++)this.array[n+o]=e.array[t+o];return this}},{key:"set",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.array.set(n,e),this}},{key:"clone",value:function(n){void 0===n.arrayBuffers&&(n.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Zt()),void 0===n.arrayBuffers[this.array.buffer._uuid]&&(n.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);var e=new this.array.constructor(n.arrayBuffers[this.array.buffer._uuid]),t=new this.constructor(e,this.stride);return t.setUsage(this.usage),t}},{key:"onUpload",value:function(n){return this.onUploadCallback=n,this}},{key:"toJSON",value:function(n){return void 0===n.arrayBuffers&&(n.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=Zt()),void 0===n.arrayBuffers[this.array.buffer._uuid]&&(n.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}]),n}(),Nc=new Oo,Bc=function(){function n(e,t,o){var r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];g(this,n),this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=o,this.normalized=!0===r}return b(n,[{key:"count",get:function(){return this.data.count}},{key:"array",get:function(){return this.data.array}},{key:"needsUpdate",set:function(n){this.data.needsUpdate=n}},{key:"applyMatrix4",value:function(n){for(var e=0,t=this.data.count;e<t;e++)Nc.fromBufferAttribute(this,e),Nc.applyMatrix4(n),this.setXYZ(e,Nc.x,Nc.y,Nc.z);return this}},{key:"applyNormalMatrix",value:function(n){for(var e=0,t=this.count;e<t;e++)Nc.fromBufferAttribute(this,e),Nc.applyNormalMatrix(n),this.setXYZ(e,Nc.x,Nc.y,Nc.z);return this}},{key:"transformDirection",value:function(n){for(var e=0,t=this.count;e<t;e++)Nc.fromBufferAttribute(this,e),Nc.transformDirection(n),this.setXYZ(e,Nc.x,Nc.y,Nc.z);return this}},{key:"setX",value:function(n,e){return this.normalized&&(e=oo(e,this.array)),this.data.array[n*this.data.stride+this.offset]=e,this}},{key:"setY",value:function(n,e){return this.normalized&&(e=oo(e,this.array)),this.data.array[n*this.data.stride+this.offset+1]=e,this}},{key:"setZ",value:function(n,e){return this.normalized&&(e=oo(e,this.array)),this.data.array[n*this.data.stride+this.offset+2]=e,this}},{key:"setW",value:function(n,e){return this.normalized&&(e=oo(e,this.array)),this.data.array[n*this.data.stride+this.offset+3]=e,this}},{key:"getX",value:function(n){var e=this.data.array[n*this.data.stride+this.offset];return this.normalized&&(e=to(e,this.array)),e}},{key:"getY",value:function(n){var e=this.data.array[n*this.data.stride+this.offset+1];return this.normalized&&(e=to(e,this.array)),e}},{key:"getZ",value:function(n){var e=this.data.array[n*this.data.stride+this.offset+2];return this.normalized&&(e=to(e,this.array)),e}},{key:"getW",value:function(n){var e=this.data.array[n*this.data.stride+this.offset+3];return this.normalized&&(e=to(e,this.array)),e}},{key:"setXY",value:function(n,e,t){return n=n*this.data.stride+this.offset,this.normalized&&(e=oo(e,this.array),t=oo(t,this.array)),this.data.array[n+0]=e,this.data.array[n+1]=t,this}},{key:"setXYZ",value:function(n,e,t,o){return n=n*this.data.stride+this.offset,this.normalized&&(e=oo(e,this.array),t=oo(t,this.array),o=oo(o,this.array)),this.data.array[n+0]=e,this.data.array[n+1]=t,this.data.array[n+2]=o,this}},{key:"setXYZW",value:function(n,e,t,o,r){return n=n*this.data.stride+this.offset,this.normalized&&(e=oo(e,this.array),t=oo(t,this.array),o=oo(o,this.array),r=oo(r,this.array)),this.data.array[n+0]=e,this.data.array[n+1]=t,this.data.array[n+2]=o,this.data.array[n+3]=r,this}},{key:"clone",value:function(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");for(var t=[],o=0;o<this.count;o++)for(var r=o*this.data.stride+this.offset,a=0;a<this.itemSize;a++)t.push(this.data.array[r+a]);return new ea(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new n(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}},{key:"toJSON",value:function(n){if(void 0===n){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");for(var e=[],t=0;t<this.count;t++)for(var o=t*this.data.stride+this.offset,r=0;r<this.itemSize;r++)e.push(this.data.array[o+r]);return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}return void 0===n.interleavedBuffers&&(n.interleavedBuffers={}),void 0===n.interleavedBuffers[this.data.uuid]&&(n.interleavedBuffers[this.data.uuid]=this.data.toJSON(n)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}]),n}(),qc=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).isSpriteMaterial=!0,o.type="SpriteMaterial",o.color=new wo(16777215),o.map=null,o.alphaMap=null,o.rotation=0,o.sizeAttenuation=!0,o.transparent=!0,o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.rotation=n.rotation,this.sizeAttenuation=n.sizeAttenuation,this.fog=n.fog,this}}]),t}(Jr),Vc=new Oo,Wc=new Oo,Hc=new Oo,Xc=new ao,Yc=new ao,Zc=new pr,Qc=new Oo,Jc=new Oo,Kc=new Oo,$c=new ao,ns=new ao,es=new ao,ts=function(n){U(t,n);var e=k(t);function t(n){var o;if(g(this,t),(o=e.call(this)).isSprite=!0,o.type="Sprite",void 0===Ec){Ec=new ya;var r=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),a=new Gc(r,5);Ec.setIndex([0,1,2,0,2,3]),Ec.setAttribute("position",new Bc(a,3,0,!1)),Ec.setAttribute("uv",new Bc(a,2,3,!1))}return o.geometry=Ec,o.material=void 0!==n?n:new qc,o.center=new ao(.5,.5),o}return b(t,[{key:"raycast",value:function(n,e){null===n.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Wc.setFromMatrixScale(this.matrixWorld),Zc.copy(n.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(n.camera.matrixWorldInverse,this.matrixWorld),Hc.setFromMatrixPosition(this.modelViewMatrix),n.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Wc.multiplyScalar(-Hc.z);var t,o,r=this.material.rotation;0!==r&&(o=Math.cos(r),t=Math.sin(r));var a=this.center;os(Qc.set(-.5,-.5,0),Hc,a,Wc,t,o),os(Jc.set(.5,-.5,0),Hc,a,Wc,t,o),os(Kc.set(.5,.5,0),Hc,a,Wc,t,o),$c.set(0,0),ns.set(1,0),es.set(1,1);var i=n.ray.intersectTriangle(Qc,Jc,Kc,!1,Vc);if(null!==i||(os(Jc.set(-.5,.5,0),Hc,a,Wc,t,o),ns.set(0,1),null!==(i=n.ray.intersectTriangle(Qc,Kc,Jc,!1,Vc)))){var v=n.ray.origin.distanceTo(Vc);v<n.near||v>n.far||e.push({distance:v,point:Vc.clone(),uv:Zr.getUV(Vc,Qc,Jc,Kc,$c,ns,es,new ao),face:null,object:this})}}},{key:"copy",value:function(n,e){return D(_(t.prototype),"copy",this).call(this,n,e),void 0!==n.center&&this.center.copy(n.center),this.material=n.material,this}}]),t}(Ar);function os(n,e,t,o,r,a){Xc.subVectors(n,t).addScalar(.5).multiply(o),void 0!==r?(Yc.x=a*Xc.x-r*Xc.y,Yc.y=r*Xc.x+a*Xc.y):Yc.copy(Xc),n.copy(e),n.x+=Yc.x,n.y+=Yc.y,n.applyMatrix4(Zc)}var rs=new Oo,as=new Oo,is=function(n){U(t,n);var e=k(t);function t(){var n;return g(this,t),(n=e.call(this))._currentLevel=0,n.type="LOD",Object.defineProperties(S(n),{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),n.autoUpdate=!0,n}return b(t,[{key:"copy",value:function(n){D(_(t.prototype),"copy",this).call(this,n,!1);for(var e=n.levels,o=0,r=e.length;o<r;o++){var a=e[o];this.addLevel(a.object.clone(),a.distance)}return this.autoUpdate=n.autoUpdate,this}},{key:"addLevel",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;e=Math.abs(e);var t,o=this.levels;for(t=0;t<o.length&&!(e<o[t].distance);t++);return o.splice(t,0,{distance:e,object:n}),this.add(n),this}},{key:"getCurrentLevel",value:function(){return this._currentLevel}},{key:"getObjectForDistance",value:function(n){var e=this.levels;if(e.length>0){var t,o;for(t=1,o=e.length;t<o&&!(n<e[t].distance);t++);return e[t-1].object}return null}},{key:"raycast",value:function(n,e){if(this.levels.length>0){rs.setFromMatrixPosition(this.matrixWorld);var t=n.ray.origin.distanceTo(rs);this.getObjectForDistance(t).raycast(n,e)}}},{key:"update",value:function(n){var e=this.levels;if(e.length>1){rs.setFromMatrixPosition(n.matrixWorld),as.setFromMatrixPosition(this.matrixWorld);var t,o,r=rs.distanceTo(as)/n.zoom;for(e[0].object.visible=!0,t=1,o=e.length;t<o&&r>=e[t].distance;t++)e[t-1].object.visible=!1,e[t].object.visible=!0;for(this._currentLevel=t-1;t<o;t++)e[t].object.visible=!1}}},{key:"toJSON",value:function(n){var e=D(_(t.prototype),"toJSON",this).call(this,n);!1===this.autoUpdate&&(e.object.autoUpdate=!1),e.object.levels=[];for(var o=this.levels,r=0,a=o.length;r<a;r++){var i=o[r];e.object.levels.push({object:i.object.uuid,distance:i.distance})}return e}}]),t}(Ar),vs=new Oo,cs=new To,ss=new To,ls=new Oo,us=new pr,fs=function(n){U(t,n);var e=k(t);function t(n,o){var r;return g(this,t),(r=e.call(this,n,o)).isSkinnedMesh=!0,r.type="SkinnedMesh",r.bindMode="attached",r.bindMatrix=new pr,r.bindMatrixInverse=new pr,r}return b(t,[{key:"copy",value:function(n,e){return D(_(t.prototype),"copy",this).call(this,n,e),this.bindMode=n.bindMode,this.bindMatrix.copy(n.bindMatrix),this.bindMatrixInverse.copy(n.bindMatrixInverse),this.skeleton=n.skeleton,this}},{key:"bind",value:function(n,e){this.skeleton=n,void 0===e&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}},{key:"pose",value:function(){this.skeleton.pose()}},{key:"normalizeSkinWeights",value:function(){for(var n=new To,e=this.geometry.attributes.skinWeight,t=0,o=e.count;t<o;t++){n.fromBufferAttribute(e,t);var r=1/n.manhattanLength();r!==1/0?n.multiplyScalar(r):n.set(1,0,0,0),e.setXYZW(t,n.x,n.y,n.z,n.w)}}},{key:"updateMatrixWorld",value:function(n){D(_(t.prototype),"updateMatrixWorld",this).call(this,n),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}},{key:"boneTransform",value:function(n,e){var t=this.skeleton,o=this.geometry;cs.fromBufferAttribute(o.attributes.skinIndex,n),ss.fromBufferAttribute(o.attributes.skinWeight,n),vs.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(var r=0;r<4;r++){var a=ss.getComponent(r);if(0!==a){var i=cs.getComponent(r);us.multiplyMatrices(t.bones[i].matrixWorld,t.boneInverses[i]),e.addScaledVector(ls.copy(vs).applyMatrix4(us),a)}}return e.applyMatrix4(this.bindMatrixInverse)}}]),t}(Oa),ps=function(n){U(t,n);var e=k(t);function t(){var n;return g(this,t),(n=e.call(this)).isBone=!0,n.type="Bone",n}return b(t)}(Ar),ms=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3?arguments[3]:void 0,v=arguments.length>4?arguments[4]:void 0,c=arguments.length>5?arguments[5]:void 0,s=arguments.length>6?arguments[6]:void 0,l=arguments.length>7?arguments[7]:void 0,u=arguments.length>8&&void 0!==arguments[8]?arguments[8]:Bn,f=arguments.length>9&&void 0!==arguments[9]?arguments[9]:Bn,p=arguments.length>10?arguments[10]:void 0,m=arguments.length>11?arguments[11]:void 0;return g(this,t),(n=e.call(this,null,c,s,l,u,f,i,v,p,m)).isDataTexture=!0,n.image={data:o,width:r,height:a},n.generateMipmaps=!1,n.flipY=!1,n.unpackAlignment=1,n}return b(t)}(Co),ds=new pr,hs=new pr,xs=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];g(this,n),this.uuid=Zt(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}return b(n,[{key:"init",value:function(){var n=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(16*n.length),0===e.length)this.calculateInverses();else if(n.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(var t=0,o=this.bones.length;t<o;t++)this.boneInverses.push(new pr)}}},{key:"calculateInverses",value:function(){this.boneInverses.length=0;for(var n=0,e=this.bones.length;n<e;n++){var t=new pr;this.bones[n]&&t.copy(this.bones[n].matrixWorld).invert(),this.boneInverses.push(t)}}},{key:"pose",value:function(){for(var n=0,e=this.bones.length;n<e;n++){var t=this.bones[n];t&&t.matrixWorld.copy(this.boneInverses[n]).invert()}for(var o=0,r=this.bones.length;o<r;o++){var a=this.bones[o];a&&(a.parent&&a.parent.isBone?(a.matrix.copy(a.parent.matrixWorld).invert(),a.matrix.multiply(a.matrixWorld)):a.matrix.copy(a.matrixWorld),a.matrix.decompose(a.position,a.quaternion,a.scale))}}},{key:"update",value:function(){for(var n=this.bones,e=this.boneInverses,t=this.boneMatrices,o=this.boneTexture,r=0,a=n.length;r<a;r++){var i=n[r]?n[r].matrixWorld:hs;ds.multiplyMatrices(i,e[r]),ds.toArray(t,16*r)}null!==o&&(o.needsUpdate=!0)}},{key:"clone",value:function(){return new n(this.bones,this.boneInverses)}},{key:"computeBoneTexture",value:function(){var n=Math.sqrt(4*this.bones.length);n=no(n),n=Math.max(n,4);var e=new Float32Array(n*n*4);e.set(this.boneMatrices);var t=new ms(e,n,n,ue,re);return t.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=t,this.boneTextureSize=n,this}},{key:"getBoneByName",value:function(n){for(var e=0,t=this.bones.length;e<t;e++){var o=this.bones[e];if(o.name===n)return o}}},{key:"dispose",value:function(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}},{key:"fromJSON",value:function(n,e){this.uuid=n.uuid;for(var t=0,o=n.bones.length;t<o;t++){var r=n.bones[t],a=e[r];void 0===a&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),a=new ps),this.bones.push(a),this.boneInverses.push((new pr).fromArray(n.boneInverses[t]))}return this.init(),this}},{key:"toJSON",value:function(){var n={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};n.uuid=this.uuid;for(var e=this.bones,t=this.boneInverses,o=0,r=e.length;o<r;o++){var a=e[o];n.bones.push(a.uuid);var i=t[o];n.boneInverses.push(i.toArray())}return n}}]),n}(),gs=function(n){U(t,n);var e=k(t);function t(n,o,r){var a,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;return g(this,t),(a=e.call(this,n,o,r)).isInstancedBufferAttribute=!0,a.meshPerAttribute=i,a}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.meshPerAttribute=n.meshPerAttribute,this}},{key:"toJSON",value:function(){var n=D(_(t.prototype),"toJSON",this).call(this);return n.meshPerAttribute=this.meshPerAttribute,n.isInstancedBufferAttribute=!0,n}}]),t}(ea),ys=new pr,bs=new pr,Us=[],_s=new pr,ws=new Oa,Ss=function(n){U(t,n);var e=k(t);function t(n,o,r){var a;g(this,t),(a=e.call(this,n,o)).isInstancedMesh=!0,a.instanceMatrix=new gs(new Float32Array(16*r),16),a.instanceColor=null,a.count=r,a.frustumCulled=!1;for(var i=0;i<r;i++)a.setMatrixAt(i,_s);return a}return b(t,[{key:"copy",value:function(n,e){return D(_(t.prototype),"copy",this).call(this,n,e),this.instanceMatrix.copy(n.instanceMatrix),null!==n.instanceColor&&(this.instanceColor=n.instanceColor.clone()),this.count=n.count,this}},{key:"getColorAt",value:function(n,e){e.fromArray(this.instanceColor.array,3*n)}},{key:"getMatrixAt",value:function(n,e){e.fromArray(this.instanceMatrix.array,16*n)}},{key:"raycast",value:function(n,e){var t=this.matrixWorld,o=this.count;if(ws.geometry=this.geometry,ws.material=this.material,void 0!==ws.material)for(var r=0;r<o;r++){this.getMatrixAt(r,ys),bs.multiplyMatrices(t,ys),ws.matrixWorld=bs,ws.raycast(n,Us);for(var a=0,i=Us.length;a<i;a++){var v=Us[a];v.instanceId=r,v.object=this,e.push(v)}Us.length=0}}},{key:"setColorAt",value:function(n,e){null===this.instanceColor&&(this.instanceColor=new gs(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*n)}},{key:"setMatrixAt",value:function(n,e){e.toArray(this.instanceMatrix.array,16*n)}},{key:"updateMorphTargets",value:function(){}},{key:"dispose",value:function(){this.dispatchEvent({type:"dispose"})}}]),t}(Oa),Ms=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).isLineBasicMaterial=!0,o.type="LineBasicMaterial",o.color=new wo(16777215),o.linewidth=1,o.linecap="round",o.linejoin="round",o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.linewidth=n.linewidth,this.linecap=n.linecap,this.linejoin=n.linejoin,this.fog=n.fog,this}}]),t}(Jr),ks=new Oo,zs=new Oo,Cs=new pr,Ts=new fr,Rs=new rr,Ds=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ya,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Ms;return g(this,t),(n=e.call(this)).isLine=!0,n.type="Line",n.geometry=o,n.material=r,n.updateMorphTargets(),n}return b(t,[{key:"copy",value:function(n,e){return D(_(t.prototype),"copy",this).call(this,n,e),this.material=n.material,this.geometry=n.geometry,this}},{key:"computeLineDistances",value:function(){var n=this.geometry;if(null===n.index){for(var e=n.attributes.position,t=[0],o=1,r=e.count;o<r;o++)ks.fromBufferAttribute(e,o-1),zs.fromBufferAttribute(e,o),t[o]=t[o-1],t[o]+=ks.distanceTo(zs);n.setAttribute("lineDistance",new la(t,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}},{key:"raycast",value:function(n,e){var t=this.geometry,o=this.matrixWorld,r=n.params.Line.threshold,a=t.drawRange;if(null===t.boundingSphere&&t.computeBoundingSphere(),Rs.copy(t.boundingSphere),Rs.applyMatrix4(o),Rs.radius+=r,!1!==n.ray.intersectsSphere(Rs)){Cs.copy(o).invert(),Ts.copy(n.ray).applyMatrix4(Cs);var i=r/((this.scale.x+this.scale.y+this.scale.z)/3),v=i*i,c=new Oo,s=new Oo,l=new Oo,u=new Oo,f=this.isLineSegments?2:1,p=t.index,m=t.attributes.position;if(null!==p)for(var d=Math.max(0,a.start),h=Math.min(p.count,a.start+a.count)-1;d<h;d+=f){var x=p.getX(d),g=p.getX(d+1);if(c.fromBufferAttribute(m,x),s.fromBufferAttribute(m,g),!(Ts.distanceSqToSegment(c,s,u,l)>v)){u.applyMatrix4(this.matrixWorld);var y=n.ray.origin.distanceTo(u);y<n.near||y>n.far||e.push({distance:y,point:l.clone().applyMatrix4(this.matrixWorld),index:d,face:null,faceIndex:null,object:this})}}else for(var b=Math.max(0,a.start),U=Math.min(m.count,a.start+a.count)-1;b<U;b+=f){if(c.fromBufferAttribute(m,b),s.fromBufferAttribute(m,b+1),!(Ts.distanceSqToSegment(c,s,u,l)>v)){u.applyMatrix4(this.matrixWorld);var _=n.ray.origin.distanceTo(u);_<n.near||_>n.far||e.push({distance:_,point:l.clone().applyMatrix4(this.matrixWorld),index:b,face:null,faceIndex:null,object:this})}}}}},{key:"updateMorphTargets",value:function(){var n=this.geometry.morphAttributes,e=Object.keys(n);if(e.length>0){var t=n[e[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(var o=0,r=t.length;o<r;o++){var a=t[o].name||String(o);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=o}}}}}]),t}(Ar),Ps=new Oo,Fs=new Oo,js=function(n){U(t,n);var e=k(t);function t(n,o){var r;return g(this,t),(r=e.call(this,n,o)).isLineSegments=!0,r.type="LineSegments",r}return b(t,[{key:"computeLineDistances",value:function(){var n=this.geometry;if(null===n.index){for(var e=n.attributes.position,t=[],o=0,r=e.count;o<r;o+=2)Ps.fromBufferAttribute(e,o),Fs.fromBufferAttribute(e,o+1),t[o]=0===o?0:t[o-1],t[o+1]=t[o]+Ps.distanceTo(Fs);n.setAttribute("lineDistance",new la(t,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}]),t}(Ds),Is=function(n){U(t,n);var e=k(t);function t(n,o){var r;return g(this,t),(r=e.call(this,n,o)).isLineLoop=!0,r.type="LineLoop",r}return b(t)}(Ds),Es=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).isPointsMaterial=!0,o.type="PointsMaterial",o.color=new wo(16777215),o.map=null,o.alphaMap=null,o.size=1,o.sizeAttenuation=!0,o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.map=n.map,this.alphaMap=n.alphaMap,this.size=n.size,this.sizeAttenuation=n.sizeAttenuation,this.fog=n.fog,this}}]),t}(Jr),Os=new pr,As=new fr,Ls=new rr,Gs=new Oo,Ns=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ya,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Es;return g(this,t),(n=e.call(this)).isPoints=!0,n.type="Points",n.geometry=o,n.material=r,n.updateMorphTargets(),n}return b(t,[{key:"copy",value:function(n,e){return D(_(t.prototype),"copy",this).call(this,n,e),this.material=n.material,this.geometry=n.geometry,this}},{key:"raycast",value:function(n,e){var t=this.geometry,o=this.matrixWorld,r=n.params.Points.threshold,a=t.drawRange;if(null===t.boundingSphere&&t.computeBoundingSphere(),Ls.copy(t.boundingSphere),Ls.applyMatrix4(o),Ls.radius+=r,!1!==n.ray.intersectsSphere(Ls)){Os.copy(o).invert(),As.copy(n.ray).applyMatrix4(Os);var i=r/((this.scale.x+this.scale.y+this.scale.z)/3),v=i*i,c=t.index,s=t.attributes.position;if(null!==c)for(var l=Math.max(0,a.start),u=Math.min(c.count,a.start+a.count);l<u;l++){var f=c.getX(l);Gs.fromBufferAttribute(s,f),Bs(Gs,f,v,o,n,e,this)}else for(var p=Math.max(0,a.start),m=Math.min(s.count,a.start+a.count);p<m;p++)Gs.fromBufferAttribute(s,p),Bs(Gs,p,v,o,n,e,this)}}},{key:"updateMorphTargets",value:function(){var n=this.geometry.morphAttributes,e=Object.keys(n);if(e.length>0){var t=n[e[0]];if(void 0!==t){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(var o=0,r=t.length;o<r;o++){var a=t[o].name||String(o);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=o}}}}}]),t}(Ar);function Bs(n,e,t,o,r,a,i){var v=As.distanceSqToPoint(n);if(v<t){var c=new Oo;As.closestPointToPoint(n,c),c.applyMatrix4(o);var s=r.ray.origin.distanceTo(c);if(s<r.near||s>r.far)return;a.push({distance:s,distanceToRay:Math.sqrt(v),point:c,index:e,face:null,object:i})}}var qs=function(n){U(t,n);var e=k(t);function t(n,o,r,a,i,v,c,s,l){var u;g(this,t),(u=e.call(this,n,o,r,a,i,v,c,s,l)).isVideoTexture=!0,u.minFilter=void 0!==v?v:Xn,u.magFilter=void 0!==i?i:Xn,u.generateMipmaps=!1;var f=S(u);return"requestVideoFrameCallback"in n&&n.requestVideoFrameCallback((function e(){f.needsUpdate=!0,n.requestVideoFrameCallback(e)})),u}return b(t,[{key:"clone",value:function(){return new this.constructor(this.image).copy(this)}},{key:"update",value:function(){var n=this.image;!1==="requestVideoFrameCallback"in n&&n.readyState>=n.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}]),t}(Co),Vs=function(n){U(t,n);var e=k(t);function t(n,o,r){var a;return g(this,t),(a=e.call(this,{width:n,height:o})).isFramebufferTexture=!0,a.format=r,a.magFilter=Bn,a.minFilter=Bn,a.generateMipmaps=!1,a.needsUpdate=!0,a}return b(t)}(Co),Ws=function(n){U(t,n);var e=k(t);function t(n,o,r,a,i,v,c,s,l,u,f,p){var m;return g(this,t),(m=e.call(this,null,v,c,s,l,u,a,i,f,p)).isCompressedTexture=!0,m.image={width:o,height:r},m.mipmaps=n,m.flipY=!1,m.generateMipmaps=!1,m}return b(t)}(Co),Hs=function(n){U(t,n);var e=k(t);function t(n,o,r,a,i,v){var c;return g(this,t),(c=e.call(this,n,o,r,i,v)).isCompressedArrayTexture=!0,c.image.depth=a,c.wrapR=Gn,c}return b(t)}(Ws),Xs=function(n){U(t,n);var e=k(t);function t(n,o,r,a,i,v,c,s,l){var u;return g(this,t),(u=e.call(this,n,o,r,a,i,v,c,s,l)).isCanvasTexture=!0,u.needsUpdate=!0,u}return b(t)}(Co),Ys=function(){function n(){g(this,n),this.type="Curve",this.arcLengthDivisions=200}return b(n,[{key:"getPoint",value:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}},{key:"getPointAt",value:function(n,e){var t=this.getUtoTmapping(n);return this.getPoint(t,e)}},{key:"getPoints",value:function(){for(var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:5,e=[],t=0;t<=n;t++)e.push(this.getPoint(t/n));return e}},{key:"getSpacedPoints",value:function(){for(var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:5,e=[],t=0;t<=n;t++)e.push(this.getPointAt(t/n));return e}},{key:"getLength",value:function(){var n=this.getLengths();return n[n.length-1]}},{key:"getLengths",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.arcLengthDivisions;if(this.cacheArcLengths&&this.cacheArcLengths.length===n+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;var e,t=[],o=this.getPoint(0),r=0;t.push(0);for(var a=1;a<=n;a++)r+=(e=this.getPoint(a/n)).distanceTo(o),t.push(r),o=e;return this.cacheArcLengths=t,t}},{key:"updateArcLengths",value:function(){this.needsUpdate=!0,this.getLengths()}},{key:"getUtoTmapping",value:function(n,e){var t,o=this.getLengths(),r=0,a=o.length;t=e||n*o[a-1];for(var i,v=0,c=a-1;v<=c;)if((i=o[r=Math.floor(v+(c-v)/2)]-t)<0)v=r+1;else{if(!(i>0)){c=r;break}c=r-1}if(o[r=c]===t)return r/(a-1);var s=o[r];return(r+(t-s)/(o[r+1]-s))/(a-1)}},{key:"getTangent",value:function(n,e){var t=1e-4,o=n-t,r=n+t;o<0&&(o=0),r>1&&(r=1);var a=this.getPoint(o),i=this.getPoint(r),v=e||(a.isVector2?new ao:new Oo);return v.copy(i).sub(a).normalize(),v}},{key:"getTangentAt",value:function(n,e){var t=this.getUtoTmapping(n);return this.getTangent(t,e)}},{key:"computeFrenetFrames",value:function(n,e){for(var t=new Oo,o=[],r=[],a=[],i=new Oo,v=new pr,c=0;c<=n;c++){var s=c/n;o[c]=this.getTangentAt(s,new Oo)}r[0]=new Oo,a[0]=new Oo;var l=Number.MAX_VALUE,u=Math.abs(o[0].x),f=Math.abs(o[0].y),p=Math.abs(o[0].z);u<=l&&(l=u,t.set(1,0,0)),f<=l&&(l=f,t.set(0,1,0)),p<=l&&t.set(0,0,1),i.crossVectors(o[0],t).normalize(),r[0].crossVectors(o[0],i),a[0].crossVectors(o[0],r[0]);for(var m=1;m<=n;m++){if(r[m]=r[m-1].clone(),a[m]=a[m-1].clone(),i.crossVectors(o[m-1],o[m]),i.length()>Number.EPSILON){i.normalize();var d=Math.acos(Qt(o[m-1].dot(o[m]),-1,1));r[m].applyMatrix4(v.makeRotationAxis(i,d))}a[m].crossVectors(o[m],r[m])}if(!0===e){var h=Math.acos(Qt(r[0].dot(r[n]),-1,1));h/=n,o[0].dot(i.crossVectors(r[0],r[n]))>0&&(h=-h);for(var x=1;x<=n;x++)r[x].applyMatrix4(v.makeRotationAxis(o[x],h*x)),a[x].crossVectors(o[x],r[x])}return{tangents:o,normals:r,binormals:a}}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this}},{key:"toJSON",value:function(){var n={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return n.arcLengthDivisions=this.arcLengthDivisions,n.type=this.type,n}},{key:"fromJSON",value:function(n){return this.arcLengthDivisions=n.arcLengthDivisions,this}}]),n}(),Zs=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2*Math.PI,s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0;return g(this,t),(n=e.call(this)).isEllipseCurve=!0,n.type="EllipseCurve",n.aX=o,n.aY=r,n.xRadius=a,n.yRadius=i,n.aStartAngle=v,n.aEndAngle=c,n.aClockwise=s,n.aRotation=l,n}return b(t,[{key:"getPoint",value:function(n,e){for(var t=e||new ao,o=2*Math.PI,r=this.aEndAngle-this.aStartAngle,a=Math.abs(r)<Number.EPSILON;r<0;)r+=o;for(;r>o;)r-=o;r<Number.EPSILON&&(r=a?0:o),!0!==this.aClockwise||a||(r===o?r=-o:r-=o);var i=this.aStartAngle+n*r,v=this.aX+this.xRadius*Math.cos(i),c=this.aY+this.yRadius*Math.sin(i);if(0!==this.aRotation){var s=Math.cos(this.aRotation),l=Math.sin(this.aRotation),u=v-this.aX,f=c-this.aY;v=u*s-f*l+this.aX,c=u*l+f*s+this.aY}return t.set(v,c)}},{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this}},{key:"toJSON",value:function(){var n=D(_(t.prototype),"toJSON",this).call(this);return n.aX=this.aX,n.aY=this.aY,n.xRadius=this.xRadius,n.yRadius=this.yRadius,n.aStartAngle=this.aStartAngle,n.aEndAngle=this.aEndAngle,n.aClockwise=this.aClockwise,n.aRotation=this.aRotation,n}},{key:"fromJSON",value:function(n){return D(_(t.prototype),"fromJSON",this).call(this,n),this.aX=n.aX,this.aY=n.aY,this.xRadius=n.xRadius,this.yRadius=n.yRadius,this.aStartAngle=n.aStartAngle,this.aEndAngle=n.aEndAngle,this.aClockwise=n.aClockwise,this.aRotation=n.aRotation,this}}]),t}(Ys),Qs=function(n){U(t,n);var e=k(t);function t(n,o,r,a,i,v){var c;return g(this,t),(c=e.call(this,n,o,r,r,a,i,v)).isArcCurve=!0,c.type="ArcCurve",c}return b(t)}(Zs);function Js(){var n=0,e=0,t=0,o=0;function r(r,a,i,v){n=r,e=i,t=-3*r+3*a-2*i-v,o=2*r-2*a+i+v}return{initCatmullRom:function(n,e,t,o,a){r(e,t,a*(t-n),a*(o-e))},initNonuniformCatmullRom:function(n,e,t,o,a,i,v){var c=(e-n)/a-(t-n)/(a+i)+(t-e)/i,s=(t-e)/i-(o-e)/(i+v)+(o-t)/v;r(e,t,c*=i,s*=i)},calc:function(r){var a=r*r;return n+e*r+t*a+o*(a*r)}}}var Ks=new Oo,$s=new Js,nl=new Js,el=new Js,tl=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"centripetal",i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;return g(this,t),(n=e.call(this)).isCatmullRomCurve3=!0,n.type="CatmullRomCurve3",n.points=o,n.closed=r,n.curveType=a,n.tension=i,n}return b(t,[{key:"getPoint",value:function(n){var e,t,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo,r=o,a=this.points,i=a.length,v=(i-(this.closed?0:1))*n,c=Math.floor(v),s=v-c;this.closed?c+=c>0?0:(Math.floor(Math.abs(c)/i)+1)*i:0===s&&c===i-1&&(c=i-2,s=1),this.closed||c>0?e=a[(c-1)%i]:(Ks.subVectors(a[0],a[1]).add(a[0]),e=Ks);var l=a[c%i],u=a[(c+1)%i];if(this.closed||c+2<i?t=a[(c+2)%i]:(Ks.subVectors(a[i-1],a[i-2]).add(a[i-1]),t=Ks),"centripetal"===this.curveType||"chordal"===this.curveType){var f="chordal"===this.curveType?.5:.25,p=Math.pow(e.distanceToSquared(l),f),m=Math.pow(l.distanceToSquared(u),f),d=Math.pow(u.distanceToSquared(t),f);m<1e-4&&(m=1),p<1e-4&&(p=m),d<1e-4&&(d=m),$s.initNonuniformCatmullRom(e.x,l.x,u.x,t.x,p,m,d),nl.initNonuniformCatmullRom(e.y,l.y,u.y,t.y,p,m,d),el.initNonuniformCatmullRom(e.z,l.z,u.z,t.z,p,m,d)}else"catmullrom"===this.curveType&&($s.initCatmullRom(e.x,l.x,u.x,t.x,this.tension),nl.initCatmullRom(e.y,l.y,u.y,t.y,this.tension),el.initCatmullRom(e.z,l.z,u.z,t.z,this.tension));return r.set($s.calc(s),nl.calc(s),el.calc(s)),r}},{key:"copy",value:function(n){D(_(t.prototype),"copy",this).call(this,n),this.points=[];for(var e=0,o=n.points.length;e<o;e++){var r=n.points[e];this.points.push(r.clone())}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this}},{key:"toJSON",value:function(){var n=D(_(t.prototype),"toJSON",this).call(this);n.points=[];for(var e=0,o=this.points.length;e<o;e++){var r=this.points[e];n.points.push(r.toArray())}return n.closed=this.closed,n.curveType=this.curveType,n.tension=this.tension,n}},{key:"fromJSON",value:function(n){D(_(t.prototype),"fromJSON",this).call(this,n),this.points=[];for(var e=0,o=n.points.length;e<o;e++){var r=n.points[e];this.points.push((new Oo).fromArray(r))}return this.closed=n.closed,this.curveType=n.curveType,this.tension=n.tension,this}}]),t}(Ys);function ol(n,e,t,o,r){var a=.5*(o-e),i=.5*(r-t),v=n*n;return(2*t-2*o+a+i)*(n*v)+(-3*t+3*o-2*a-i)*v+a*n+t}function rl(n,e,t,o){return function(n,e){var t=1-n;return t*t*e}(n,e)+function(n,e){return 2*(1-n)*n*e}(n,t)+function(n,e){return n*n*e}(n,o)}function al(n,e,t,o,r){return function(n,e){var t=1-n;return t*t*t*e}(n,e)+function(n,e){var t=1-n;return 3*t*t*n*e}(n,t)+function(n,e){return 3*(1-n)*n*n*e}(n,o)+function(n,e){return n*n*n*e}(n,r)}var il=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ao,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ao,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new ao,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new ao;return g(this,t),(n=e.call(this)).isCubicBezierCurve=!0,n.type="CubicBezierCurve",n.v0=o,n.v1=r,n.v2=a,n.v3=i,n}return b(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ao,t=e,o=this.v0,r=this.v1,a=this.v2,i=this.v3;return t.set(al(n,o.x,r.x,a.x,i.x),al(n,o.y,r.y,a.y,i.y)),t}},{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this}},{key:"toJSON",value:function(){var n=D(_(t.prototype),"toJSON",this).call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n}},{key:"fromJSON",value:function(n){return D(_(t.prototype),"fromJSON",this).call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this}}]),t}(Ys),vl=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Oo,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Oo;return g(this,t),(n=e.call(this)).isCubicBezierCurve3=!0,n.type="CubicBezierCurve3",n.v0=o,n.v1=r,n.v2=a,n.v3=i,n}return b(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo,t=e,o=this.v0,r=this.v1,a=this.v2,i=this.v3;return t.set(al(n,o.x,r.x,a.x,i.x),al(n,o.y,r.y,a.y,i.y),al(n,o.z,r.z,a.z,i.z)),t}},{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this.v3.copy(n.v3),this}},{key:"toJSON",value:function(){var n=D(_(t.prototype),"toJSON",this).call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n.v3=this.v3.toArray(),n}},{key:"fromJSON",value:function(n){return D(_(t.prototype),"fromJSON",this).call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this.v3.fromArray(n.v3),this}}]),t}(Ys),cl=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ao,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ao;return g(this,t),(n=e.call(this)).isLineCurve=!0,n.type="LineCurve",n.v1=o,n.v2=r,n}return b(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ao,t=e;return 1===n?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(n).add(this.v1)),t}},{key:"getPointAt",value:function(n,e){return this.getPoint(n,e)}},{key:"getTangent",value:function(n,e){var t=e||new ao;return t.copy(this.v2).sub(this.v1).normalize(),t}},{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.v1.copy(n.v1),this.v2.copy(n.v2),this}},{key:"toJSON",value:function(){var n=D(_(t.prototype),"toJSON",this).call(this);return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n}},{key:"fromJSON",value:function(n){return D(_(t.prototype),"fromJSON",this).call(this,n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this}}]),t}(Ys),sl=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo;return g(this,t),(n=e.call(this)).isLineCurve3=!0,n.type="LineCurve3",n.v1=o,n.v2=r,n}return b(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo,t=e;return 1===n?t.copy(this.v2):(t.copy(this.v2).sub(this.v1),t.multiplyScalar(n).add(this.v1)),t}},{key:"getPointAt",value:function(n,e){return this.getPoint(n,e)}},{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.v1.copy(n.v1),this.v2.copy(n.v2),this}},{key:"toJSON",value:function(){var n=D(_(t.prototype),"toJSON",this).call(this);return n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n}},{key:"fromJSON",value:function(n){return D(_(t.prototype),"fromJSON",this).call(this,n),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this}}]),t}(Ys),ll=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ao,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ao,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new ao;return g(this,t),(n=e.call(this)).isQuadraticBezierCurve=!0,n.type="QuadraticBezierCurve",n.v0=o,n.v1=r,n.v2=a,n}return b(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ao,t=e,o=this.v0,r=this.v1,a=this.v2;return t.set(rl(n,o.x,r.x,a.x),rl(n,o.y,r.y,a.y)),t}},{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this}},{key:"toJSON",value:function(){var n=D(_(t.prototype),"toJSON",this).call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n}},{key:"fromJSON",value:function(n){return D(_(t.prototype),"fromJSON",this).call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this}}]),t}(Ys),ul=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Oo;return g(this,t),(n=e.call(this)).isQuadraticBezierCurve3=!0,n.type="QuadraticBezierCurve3",n.v0=o,n.v1=r,n.v2=a,n}return b(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo,t=e,o=this.v0,r=this.v1,a=this.v2;return t.set(rl(n,o.x,r.x,a.x),rl(n,o.y,r.y,a.y),rl(n,o.z,r.z,a.z)),t}},{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.v0.copy(n.v0),this.v1.copy(n.v1),this.v2.copy(n.v2),this}},{key:"toJSON",value:function(){var n=D(_(t.prototype),"toJSON",this).call(this);return n.v0=this.v0.toArray(),n.v1=this.v1.toArray(),n.v2=this.v2.toArray(),n}},{key:"fromJSON",value:function(n){return D(_(t.prototype),"fromJSON",this).call(this,n),this.v0.fromArray(n.v0),this.v1.fromArray(n.v1),this.v2.fromArray(n.v2),this}}]),t}(Ys),fl=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return g(this,t),(n=e.call(this)).isSplineCurve=!0,n.type="SplineCurve",n.points=o,n}return b(t,[{key:"getPoint",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ao,t=e,o=this.points,r=(o.length-1)*n,a=Math.floor(r),i=r-a,v=o[0===a?a:a-1],c=o[a],s=o[a>o.length-2?o.length-1:a+1],l=o[a>o.length-3?o.length-1:a+2];return t.set(ol(i,v.x,c.x,s.x,l.x),ol(i,v.y,c.y,s.y,l.y)),t}},{key:"copy",value:function(n){D(_(t.prototype),"copy",this).call(this,n),this.points=[];for(var e=0,o=n.points.length;e<o;e++){var r=n.points[e];this.points.push(r.clone())}return this}},{key:"toJSON",value:function(){var n=D(_(t.prototype),"toJSON",this).call(this);n.points=[];for(var e=0,o=this.points.length;e<o;e++){var r=this.points[e];n.points.push(r.toArray())}return n}},{key:"fromJSON",value:function(n){D(_(t.prototype),"fromJSON",this).call(this,n),this.points=[];for(var e=0,o=n.points.length;e<o;e++){var r=n.points[e];this.points.push((new ao).fromArray(r))}return this}}]),t}(Ys),pl=Object.freeze({__proto__:null,ArcCurve:Qs,CatmullRomCurve3:tl,CubicBezierCurve:il,CubicBezierCurve3:vl,EllipseCurve:Zs,LineCurve:cl,LineCurve3:sl,QuadraticBezierCurve:ll,QuadraticBezierCurve3:ul,SplineCurve:fl}),ml=function(n){U(t,n);var e=k(t);function t(){var n;return g(this,t),(n=e.call(this)).type="CurvePath",n.curves=[],n.autoClose=!1,n}return b(t,[{key:"add",value:function(n){this.curves.push(n)}},{key:"closePath",value:function(){var n=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);n.equals(e)||this.curves.push(new cl(e,n))}},{key:"getPoint",value:function(n,e){for(var t=n*this.getLength(),o=this.getCurveLengths(),r=0;r<o.length;){if(o[r]>=t){var a=o[r]-t,i=this.curves[r],v=i.getLength(),c=0===v?0:1-a/v;return i.getPointAt(c,e)}r++}return null}},{key:"getLength",value:function(){var n=this.getCurveLengths();return n[n.length-1]}},{key:"updateArcLengths",value:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}},{key:"getCurveLengths",value:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;for(var n=[],e=0,t=0,o=this.curves.length;t<o;t++)e+=this.curves[t].getLength(),n.push(e);return this.cacheLengths=n,n}},{key:"getSpacedPoints",value:function(){for(var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:40,e=[],t=0;t<=n;t++)e.push(this.getPoint(t/n));return this.autoClose&&e.push(e[0]),e}},{key:"getPoints",value:function(){for(var n,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:12,t=[],o=0,r=this.curves;o<r.length;o++)for(var a=r[o],i=a.isEllipseCurve?2*e:a.isLineCurve||a.isLineCurve3?1:a.isSplineCurve?e*a.points.length:e,v=a.getPoints(i),c=0;c<v.length;c++){var s=v[c];n&&n.equals(s)||(t.push(s),n=s)}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}},{key:"copy",value:function(n){D(_(t.prototype),"copy",this).call(this,n),this.curves=[];for(var e=0,o=n.curves.length;e<o;e++){var r=n.curves[e];this.curves.push(r.clone())}return this.autoClose=n.autoClose,this}},{key:"toJSON",value:function(){var n=D(_(t.prototype),"toJSON",this).call(this);n.autoClose=this.autoClose,n.curves=[];for(var e=0,o=this.curves.length;e<o;e++){var r=this.curves[e];n.curves.push(r.toJSON())}return n}},{key:"fromJSON",value:function(n){D(_(t.prototype),"fromJSON",this).call(this,n),this.autoClose=n.autoClose,this.curves=[];for(var e=0,o=n.curves.length;e<o;e++){var r=n.curves[e];this.curves.push((new pl[r.type]).fromJSON(r))}return this}}]),t}(Ys),dl=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).type="Path",o.currentPoint=new ao,n&&o.setFromPoints(n),o}return b(t,[{key:"setFromPoints",value:function(n){this.moveTo(n[0].x,n[0].y);for(var e=1,t=n.length;e<t;e++)this.lineTo(n[e].x,n[e].y);return this}},{key:"moveTo",value:function(n,e){return this.currentPoint.set(n,e),this}},{key:"lineTo",value:function(n,e){var t=new cl(this.currentPoint.clone(),new ao(n,e));return this.curves.push(t),this.currentPoint.set(n,e),this}},{key:"quadraticCurveTo",value:function(n,e,t,o){var r=new ll(this.currentPoint.clone(),new ao(n,e),new ao(t,o));return this.curves.push(r),this.currentPoint.set(t,o),this}},{key:"bezierCurveTo",value:function(n,e,t,o,r,a){var i=new il(this.currentPoint.clone(),new ao(n,e),new ao(t,o),new ao(r,a));return this.curves.push(i),this.currentPoint.set(r,a),this}},{key:"splineThru",value:function(n){var e=[this.currentPoint.clone()].concat(n),t=new fl(e);return this.curves.push(t),this.currentPoint.copy(n[n.length-1]),this}},{key:"arc",value:function(n,e,t,o,r,a){var i=this.currentPoint.x,v=this.currentPoint.y;return this.absarc(n+i,e+v,t,o,r,a),this}},{key:"absarc",value:function(n,e,t,o,r,a){return this.absellipse(n,e,t,t,o,r,a),this}},{key:"ellipse",value:function(n,e,t,o,r,a,i,v){var c=this.currentPoint.x,s=this.currentPoint.y;return this.absellipse(n+c,e+s,t,o,r,a,i,v),this}},{key:"absellipse",value:function(n,e,t,o,r,a,i,v){var c=new Zs(n,e,t,o,r,a,i,v);if(this.curves.length>0){var s=c.getPoint(0);s.equals(this.currentPoint)||this.lineTo(s.x,s.y)}this.curves.push(c);var l=c.getPoint(1);return this.currentPoint.copy(l),this}},{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.currentPoint.copy(n.currentPoint),this}},{key:"toJSON",value:function(){var n=D(_(t.prototype),"toJSON",this).call(this);return n.currentPoint=this.currentPoint.toArray(),n}},{key:"fromJSON",value:function(n){return D(_(t.prototype),"fromJSON",this).call(this,n),this.currentPoint.fromArray(n.currentPoint),this}}]),t}(ml),hl=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[new ao(0,-.5),new ao(.5,0),new ao(0,.5)],r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:12,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:2*Math.PI;g(this,t),(n=e.call(this)).type="LatheGeometry",n.parameters={points:o,segments:r,phiStart:a,phiLength:i},r=Math.floor(r),i=Qt(i,0,2*Math.PI);for(var v=[],c=[],s=[],l=[],u=[],f=1/r,p=new Oo,m=new ao,d=new Oo,h=new Oo,x=new Oo,y=0,b=0,U=0;U<=o.length-1;U++)switch(U){case 0:y=o[U+1].x-o[U].x,b=o[U+1].y-o[U].y,d.x=1*b,d.y=-y,d.z=0*b,x.copy(d),d.normalize(),l.push(d.x,d.y,d.z);break;case o.length-1:l.push(x.x,x.y,x.z);break;default:y=o[U+1].x-o[U].x,b=o[U+1].y-o[U].y,d.x=1*b,d.y=-y,d.z=0*b,h.copy(d),d.x+=x.x,d.y+=x.y,d.z+=x.z,d.normalize(),l.push(d.x,d.y,d.z),x.copy(h)}for(var _=0;_<=r;_++)for(var w=a+_*f*i,S=Math.sin(w),M=Math.cos(w),k=0;k<=o.length-1;k++){p.x=o[k].x*S,p.y=o[k].y,p.z=o[k].x*M,c.push(p.x,p.y,p.z),m.x=_/r,m.y=k/(o.length-1),s.push(m.x,m.y);var z=l[3*k+0]*S,C=l[3*k+1],T=l[3*k+0]*M;u.push(z,C,T)}for(var R=0;R<r;R++)for(var D=0;D<o.length-1;D++){var P=D+R*o.length,F=P,j=P+o.length,I=P+o.length+1,E=P+1;v.push(F,j,E),v.push(I,E,j)}return n.setIndex(v),n.setAttribute("position",new la(c,3)),n.setAttribute("uv",new la(s,2)),n.setAttribute("normal",new la(u,3)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.points,n.segments,n.phiStart,n.phiLength)}}]),t}(ya),xl=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:4,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:8;g(this,t);var v=new dl;return v.absarc(0,-r/2,o,1.5*Math.PI,0),v.absarc(0,r/2,o,0,.5*Math.PI),(n=e.call(this,v.getPoints(a),i)).type="CapsuleGeometry",n.parameters={radius:o,height:r,capSegments:a,radialSegments:i},n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.length,n.capSegments,n.radialSegments)}}]),t}(hl),gl=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:8,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:2*Math.PI;g(this,t),(n=e.call(this)).type="CircleGeometry",n.parameters={radius:o,segments:r,thetaStart:a,thetaLength:i},r=Math.max(3,r);var v=[],c=[],s=[],l=[],u=new Oo,f=new ao;c.push(0,0,0),s.push(0,0,1),l.push(.5,.5);for(var p=0,m=3;p<=r;p++,m+=3){var d=a+p/r*i;u.x=o*Math.cos(d),u.y=o*Math.sin(d),c.push(u.x,u.y,u.z),s.push(0,0,1),f.x=(c[m]/o+1)/2,f.y=(c[m+1]/o+1)/2,l.push(f.x,f.y)}for(var h=1;h<=r;h++)v.push(h,h+1,0);return n.setIndex(v),n.setAttribute("position",new la(c,3)),n.setAttribute("normal",new la(s,3)),n.setAttribute("uv",new la(l,2)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.segments,n.thetaStart,n.thetaLength)}}]),t}(ya),yl=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:8,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,c=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:2*Math.PI;g(this,t),(n=e.call(this)).type="CylinderGeometry",n.parameters={radiusTop:o,radiusBottom:r,height:a,radialSegments:i,heightSegments:v,openEnded:c,thetaStart:s,thetaLength:l};var u=S(n);i=Math.floor(i),v=Math.floor(v);var f=[],p=[],m=[],d=[],h=0,x=[],y=a/2,b=0;function U(){for(var n=new Oo,e=new Oo,t=0,c=(r-o)/a,g=0;g<=v;g++){for(var U=[],_=g/v,w=_*(r-o)+o,S=0;S<=i;S++){var M=S/i,k=M*l+s,z=Math.sin(k),C=Math.cos(k);e.x=w*z,e.y=-_*a+y,e.z=w*C,p.push(e.x,e.y,e.z),n.set(z,c,C).normalize(),m.push(n.x,n.y,n.z),d.push(M,1-_),U.push(h++)}x.push(U)}for(var T=0;T<i;T++)for(var R=0;R<v;R++){var D=x[R][T],P=x[R+1][T],F=x[R+1][T+1],j=x[R][T+1];f.push(D,P,j),f.push(P,F,j),t+=6}u.addGroup(b,t,0),b+=t}function _(n){for(var e=h,t=new ao,a=new Oo,v=0,c=!0===n?o:r,x=!0===n?1:-1,g=1;g<=i;g++)p.push(0,y*x,0),m.push(0,x,0),d.push(.5,.5),h++;for(var U=h,_=0;_<=i;_++){var w=_/i*l+s,S=Math.cos(w),M=Math.sin(w);a.x=c*M,a.y=y*x,a.z=c*S,p.push(a.x,a.y,a.z),m.push(0,x,0),t.x=.5*S+.5,t.y=.5*M*x+.5,d.push(t.x,t.y),h++}for(var k=0;k<i;k++){var z=e+k,C=U+k;!0===n?f.push(C,C+1,z):f.push(C+1,C,z),v+=3}u.addGroup(b,v,!0===n?1:2),b+=v}return U(),!1===c&&(o>0&&_(!0),r>0&&_(!1)),n.setIndex(f),n.setAttribute("position",new la(p,3)),n.setAttribute("normal",new la(m,3)),n.setAttribute("uv",new la(d,2)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radiusTop,n.radiusBottom,n.height,n.radialSegments,n.heightSegments,n.openEnded,n.thetaStart,n.thetaLength)}}]),t}(ya),bl=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:8,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,v=arguments.length>4&&void 0!==arguments[4]&&arguments[4],c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:2*Math.PI;return g(this,t),(n=e.call(this,0,o,r,a,i,v,c,s)).type="ConeGeometry",n.parameters={radius:o,height:r,radialSegments:a,heightSegments:i,openEnded:v,thetaStart:c,thetaLength:s},n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.height,n.radialSegments,n.heightSegments,n.openEnded,n.thetaStart,n.thetaLength)}}]),t}(yl),Ul=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;g(this,t),(n=e.call(this)).type="PolyhedronGeometry",n.parameters={vertices:o,indices:r,radius:a,detail:i};var v=[],c=[];function s(n){for(var e=new Oo,t=new Oo,o=new Oo,a=0;a<r.length;a+=3)d(r[a+0],e),d(r[a+1],t),d(r[a+2],o),l(e,t,o,n)}function l(n,e,t,o){for(var r=o+1,a=[],i=0;i<=r;i++){a[i]=[];for(var v=n.clone().lerp(t,i/r),c=e.clone().lerp(t,i/r),s=r-i,l=0;l<=s;l++)a[i][l]=0===l&&i===r?v:v.clone().lerp(c,l/s)}for(var u=0;u<r;u++)for(var f=0;f<2*(r-u)-1;f++){var p=Math.floor(f/2);f%2===0?(m(a[u][p+1]),m(a[u+1][p]),m(a[u][p])):(m(a[u][p+1]),m(a[u+1][p+1]),m(a[u+1][p]))}}function u(n){for(var e=new Oo,t=0;t<v.length;t+=3)e.x=v[t+0],e.y=v[t+1],e.z=v[t+2],e.normalize().multiplyScalar(n),v[t+0]=e.x,v[t+1]=e.y,v[t+2]=e.z}function f(){for(var n=new Oo,e=0;e<v.length;e+=3){n.x=v[e+0],n.y=v[e+1],n.z=v[e+2];var t=y(n)/2/Math.PI+.5,o=b(n)/Math.PI+.5;c.push(t,1-o)}h(),p()}function p(){for(var n=0;n<c.length;n+=6){var e=c[n+0],t=c[n+2],o=c[n+4],r=Math.max(e,t,o),a=Math.min(e,t,o);r>.9&&a<.1&&(e<.2&&(c[n+0]+=1),t<.2&&(c[n+2]+=1),o<.2&&(c[n+4]+=1))}}function m(n){v.push(n.x,n.y,n.z)}function d(n,e){var t=3*n;e.x=o[t+0],e.y=o[t+1],e.z=o[t+2]}function h(){for(var n=new Oo,e=new Oo,t=new Oo,o=new Oo,r=new ao,a=new ao,i=new ao,s=0,l=0;s<v.length;s+=9,l+=6){n.set(v[s+0],v[s+1],v[s+2]),e.set(v[s+3],v[s+4],v[s+5]),t.set(v[s+6],v[s+7],v[s+8]),r.set(c[l+0],c[l+1]),a.set(c[l+2],c[l+3]),i.set(c[l+4],c[l+5]),o.copy(n).add(e).add(t).divideScalar(3);var u=y(o);x(r,l+0,n,u),x(a,l+2,e,u),x(i,l+4,t,u)}}function x(n,e,t,o){o<0&&1===n.x&&(c[e]=n.x-1),0===t.x&&0===t.z&&(c[e]=o/2/Math.PI+.5)}function y(n){return Math.atan2(n.z,-n.x)}function b(n){return Math.atan2(-n.y,Math.sqrt(n.x*n.x+n.z*n.z))}return s(i),u(a),f(),n.setAttribute("position",new la(v,3)),n.setAttribute("normal",new la(v.slice(),3)),n.setAttribute("uv",new la(c,2)),0===i?n.computeVertexNormals():n.normalizeNormals(),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.vertices,n.indices,n.radius,n.details)}}]),t}(ya),_l=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;g(this,t);var a=(1+Math.sqrt(5))/2,i=1/a,v=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-a,0,-i,a,0,i,-a,0,i,a,-i,-a,0,-i,a,0,i,-a,0,i,a,0,-a,0,-i,a,0,-i,-a,0,i,a,0,i],c=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];return(n=e.call(this,v,c,o,r)).type="DodecahedronGeometry",n.parameters={radius:o,detail:r},n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.detail)}}]),t}(Ul),wl=new Oo,Sl=new Oo,Ml=new Oo,kl=new Zr,zl=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(g(this,t),(n=e.call(this)).type="EdgesGeometry",n.parameters={geometry:o,thresholdAngle:r},null!==o){for(var a=4,i=Math.pow(10,a),v=Math.cos(Xt*r),c=o.getIndex(),s=o.getAttribute("position"),l=c?c.count:s.count,u=[0,0,0],f=["a","b","c"],p=new Array(3),m={},d=[],h=0;h<l;h+=3){c?(u[0]=c.getX(h),u[1]=c.getX(h+1),u[2]=c.getX(h+2)):(u[0]=h,u[1]=h+1,u[2]=h+2);var x=kl.a,y=kl.b,b=kl.c;if(x.fromBufferAttribute(s,u[0]),y.fromBufferAttribute(s,u[1]),b.fromBufferAttribute(s,u[2]),kl.getNormal(Ml),p[0]="".concat(Math.round(x.x*i),",").concat(Math.round(x.y*i),",").concat(Math.round(x.z*i)),p[1]="".concat(Math.round(y.x*i),",").concat(Math.round(y.y*i),",").concat(Math.round(y.z*i)),p[2]="".concat(Math.round(b.x*i),",").concat(Math.round(b.y*i),",").concat(Math.round(b.z*i)),p[0]!==p[1]&&p[1]!==p[2]&&p[2]!==p[0])for(var U=0;U<3;U++){var _=(U+1)%3,w=p[U],S=p[_],M=kl[f[U]],k=kl[f[_]],z="".concat(w,"_").concat(S),C="".concat(S,"_").concat(w);C in m&&m[C]?(Ml.dot(m[C].normal)<=v&&(d.push(M.x,M.y,M.z),d.push(k.x,k.y,k.z)),m[C]=null):z in m||(m[z]={index0:u[U],index1:u[_],normal:Ml.clone()})}}for(var T in m)if(m[T]){var R=m[T],D=R.index0,P=R.index1;wl.fromBufferAttribute(s,D),Sl.fromBufferAttribute(s,P),d.push(wl.x,wl.y,wl.z),d.push(Sl.x,Sl.y,Sl.z)}n.setAttribute("position",new la(d,3))}return n}return b(t)}(ya),Cl=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this,n)).uuid=Zt(),o.type="Shape",o.holes=[],o}return b(t,[{key:"getPointsHoles",value:function(n){for(var e=[],t=0,o=this.holes.length;t<o;t++)e[t]=this.holes[t].getPoints(n);return e}},{key:"extractPoints",value:function(n){return{shape:this.getPoints(n),holes:this.getPointsHoles(n)}}},{key:"copy",value:function(n){D(_(t.prototype),"copy",this).call(this,n),this.holes=[];for(var e=0,o=n.holes.length;e<o;e++){var r=n.holes[e];this.holes.push(r.clone())}return this}},{key:"toJSON",value:function(){var n=D(_(t.prototype),"toJSON",this).call(this);n.uuid=this.uuid,n.holes=[];for(var e=0,o=this.holes.length;e<o;e++){var r=this.holes[e];n.holes.push(r.toJSON())}return n}},{key:"fromJSON",value:function(n){D(_(t.prototype),"fromJSON",this).call(this,n),this.uuid=n.uuid,this.holes=[];for(var e=0,o=n.holes.length;e<o;e++){var r=n.holes[e];this.holes.push((new dl).fromJSON(r))}return this}}]),t}(dl),Tl=function(n,e){var t,o,r,a,i,v,c,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2,l=e&&e.length,u=l?e[0]*s:n.length,f=Rl(n,0,u,s,!0),p=[];if(!f||f.next===f.prev)return p;if(l&&(f=Ol(n,e,f,s)),n.length>80*s){t=r=n[0],o=a=n[1];for(var m=s;m<u;m+=s)(i=n[m])<t&&(t=i),(v=n[m+1])<o&&(o=v),i>r&&(r=i),v>a&&(a=v);c=0!==(c=Math.max(r-t,a-o))?32767/c:0}return Pl(f,p,s,t,o,c,0),p};function Rl(n,e,t,o,r){var a,i;if(r===function(n,e,t,o){for(var r=0,a=e,i=t-o;a<t;a+=o)r+=(n[i]-n[a])*(n[a+1]+n[i+1]),i=a;return r}(n,e,t,o)>0)for(a=e;a<t;a+=o)i=Kl(a,n[a],n[a+1],i);else for(a=t-o;a>=e;a-=o)i=Kl(a,n[a],n[a+1],i);return i&&Hl(i,i.next)&&($l(i),i=i.next),i}function Dl(n,e){if(!n)return n;e||(e=n);var t,o=n;do{if(t=!1,o.steiner||!Hl(o,o.next)&&0!==Wl(o.prev,o,o.next))o=o.next;else{if($l(o),(o=e=o.prev)===o.next)break;t=!0}}while(t||o!==e);return e}function Pl(n,e,t,o,r,a,i){if(n){!i&&a&&function(n,e,t,o){var r=n;do{0===r.z&&(r.z=Nl(r.x,r.y,e,t,o)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next}while(r!==n);r.prevZ.nextZ=null,r.prevZ=null,function(n){var e,t,o,r,a,i,v,c,s=1;do{for(t=n,n=null,a=null,i=0;t;){for(i++,o=t,v=0,e=0;e<s&&(v++,o=o.nextZ);e++);for(c=s;v>0||c>0&&o;)0!==v&&(0===c||!o||t.z<=o.z)?(r=t,t=t.nextZ,v--):(r=o,o=o.nextZ,c--),a?a.nextZ=r:n=r,r.prevZ=a,a=r;t=o}a.nextZ=null,s*=2}while(i>1)}(r)}(n,o,r,a);for(var v,c,s=n;n.prev!==n.next;)if(v=n.prev,c=n.next,a?jl(n,o,r,a):Fl(n))e.push(v.i/t|0),e.push(n.i/t|0),e.push(c.i/t|0),$l(n),n=c.next,s=c.next;else if((n=c)===s){i?1===i?Pl(n=Il(Dl(n),e,t),e,t,o,r,a,2):2===i&&El(n,e,t,o,r,a):Pl(Dl(n),e,t,o,r,a,1);break}}}function Fl(n){var e=n.prev,t=n,o=n.next;if(Wl(e,t,o)>=0)return!1;for(var r=e.x,a=t.x,i=o.x,v=e.y,c=t.y,s=o.y,l=r<a?r<i?r:i:a<i?a:i,u=v<c?v<s?v:s:c<s?c:s,f=r>a?r>i?r:i:a>i?a:i,p=v>c?v>s?v:s:c>s?c:s,m=o.next;m!==e;){if(m.x>=l&&m.x<=f&&m.y>=u&&m.y<=p&&ql(r,v,a,c,i,s,m.x,m.y)&&Wl(m.prev,m,m.next)>=0)return!1;m=m.next}return!0}function jl(n,e,t,o){var r=n.prev,a=n,i=n.next;if(Wl(r,a,i)>=0)return!1;for(var v=r.x,c=a.x,s=i.x,l=r.y,u=a.y,f=i.y,p=v<c?v<s?v:s:c<s?c:s,m=l<u?l<f?l:f:u<f?u:f,d=v>c?v>s?v:s:c>s?c:s,h=l>u?l>f?l:f:u>f?u:f,x=Nl(p,m,e,t,o),g=Nl(d,h,e,t,o),y=n.prevZ,b=n.nextZ;y&&y.z>=x&&b&&b.z<=g;){if(y.x>=p&&y.x<=d&&y.y>=m&&y.y<=h&&y!==r&&y!==i&&ql(v,l,c,u,s,f,y.x,y.y)&&Wl(y.prev,y,y.next)>=0)return!1;if(y=y.prevZ,b.x>=p&&b.x<=d&&b.y>=m&&b.y<=h&&b!==r&&b!==i&&ql(v,l,c,u,s,f,b.x,b.y)&&Wl(b.prev,b,b.next)>=0)return!1;b=b.nextZ}for(;y&&y.z>=x;){if(y.x>=p&&y.x<=d&&y.y>=m&&y.y<=h&&y!==r&&y!==i&&ql(v,l,c,u,s,f,y.x,y.y)&&Wl(y.prev,y,y.next)>=0)return!1;y=y.prevZ}for(;b&&b.z<=g;){if(b.x>=p&&b.x<=d&&b.y>=m&&b.y<=h&&b!==r&&b!==i&&ql(v,l,c,u,s,f,b.x,b.y)&&Wl(b.prev,b,b.next)>=0)return!1;b=b.nextZ}return!0}function Il(n,e,t){var o=n;do{var r=o.prev,a=o.next.next;!Hl(r,a)&&Xl(r,o,o.next,a)&&Ql(r,a)&&Ql(a,r)&&(e.push(r.i/t|0),e.push(o.i/t|0),e.push(a.i/t|0),$l(o),$l(o.next),o=n=a),o=o.next}while(o!==n);return Dl(o)}function El(n,e,t,o,r,a){var i=n;do{for(var v=i.next.next;v!==i.prev;){if(i.i!==v.i&&Vl(i,v)){var c=Jl(i,v);return i=Dl(i,i.next),c=Dl(c,c.next),Pl(i,e,t,o,r,a,0),void Pl(c,e,t,o,r,a,0)}v=v.next}i=i.next}while(i!==n)}function Ol(n,e,t,o){var r,a,i,v=[];for(r=0,a=e.length;r<a;r++)(i=Rl(n,e[r]*o,r<a-1?e[r+1]*o:n.length,o,!1))===i.next&&(i.steiner=!0),v.push(Bl(i));for(v.sort(Al),r=0;r<v.length;r++)t=Ll(v[r],t);return t}function Al(n,e){return n.x-e.x}function Ll(n,e){var t=function(n,e){var t,o=e,r=-1/0,a=n.x,i=n.y;do{if(i<=o.y&&i>=o.next.y&&o.next.y!==o.y){var v=o.x+(i-o.y)*(o.next.x-o.x)/(o.next.y-o.y);if(v<=a&&v>r&&(r=v,t=o.x<o.next.x?o:o.next,v===a))return t}o=o.next}while(o!==e);if(!t)return null;var c,s=t,l=t.x,u=t.y,f=1/0;o=t;do{a>=o.x&&o.x>=l&&a!==o.x&&ql(i<u?a:r,i,l,u,i<u?r:a,i,o.x,o.y)&&(c=Math.abs(i-o.y)/(a-o.x),Ql(o,n)&&(c<f||c===f&&(o.x>t.x||o.x===t.x&&Gl(t,o)))&&(t=o,f=c)),o=o.next}while(o!==s);return t}(n,e);if(!t)return e;var o=Jl(t,n);return Dl(o,o.next),Dl(t,t.next)}function Gl(n,e){return Wl(n.prev,n,e.prev)<0&&Wl(e.next,n,n.next)<0}function Nl(n,e,t,o,r){return(n=1431655765&((n=858993459&((n=252645135&((n=16711935&((n=(n-t)*r|0)|n<<8))|n<<4))|n<<2))|n<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-o)*r|0)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function Bl(n){var e=n,t=n;do{(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next}while(e!==n);return t}function ql(n,e,t,o,r,a,i,v){return(r-i)*(e-v)>=(n-i)*(a-v)&&(n-i)*(o-v)>=(t-i)*(e-v)&&(t-i)*(a-v)>=(r-i)*(o-v)}function Vl(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!function(n,e){var t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&Xl(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}(n,e)&&(Ql(n,e)&&Ql(e,n)&&function(n,e){var t=n,o=!1,r=(n.x+e.x)/2,a=(n.y+e.y)/2;do{t.y>a!==t.next.y>a&&t.next.y!==t.y&&r<(t.next.x-t.x)*(a-t.y)/(t.next.y-t.y)+t.x&&(o=!o),t=t.next}while(t!==n);return o}(n,e)&&(Wl(n.prev,n,e.prev)||Wl(n,e.prev,e))||Hl(n,e)&&Wl(n.prev,n,n.next)>0&&Wl(e.prev,e,e.next)>0)}function Wl(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function Hl(n,e){return n.x===e.x&&n.y===e.y}function Xl(n,e,t,o){var r=Zl(Wl(n,e,t)),a=Zl(Wl(n,e,o)),i=Zl(Wl(t,o,n)),v=Zl(Wl(t,o,e));return r!==a&&i!==v||(!(0!==r||!Yl(n,t,e))||(!(0!==a||!Yl(n,o,e))||(!(0!==i||!Yl(t,n,o))||!(0!==v||!Yl(t,e,o)))))}function Yl(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function Zl(n){return n>0?1:n<0?-1:0}function Ql(n,e){return Wl(n.prev,n,n.next)<0?Wl(n,e,n.next)>=0&&Wl(n,n.prev,e)>=0:Wl(n,e,n.prev)<0||Wl(n,n.next,e)<0}function Jl(n,e){var t=new nu(n.i,n.x,n.y),o=new nu(e.i,e.x,e.y),r=n.next,a=e.prev;return n.next=e,e.prev=n,t.next=r,r.prev=t,o.next=t,t.prev=o,a.next=o,o.prev=a,o}function Kl(n,e,t,o){var r=new nu(n,e,t);return o?(r.next=o.next,r.prev=o,o.next.prev=r,o.next=r):(r.prev=r,r.next=r),r}function $l(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function nu(n,e,t){this.i=n,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}var eu=function(){function n(){g(this,n)}return b(n,null,[{key:"area",value:function(n){for(var e=n.length,t=0,o=e-1,r=0;r<e;o=r++)t+=n[o].x*n[r].y-n[r].x*n[o].y;return.5*t}},{key:"isClockWise",value:function(e){return n.area(e)<0}},{key:"triangulateShape",value:function(n,e){var t=[],o=[],r=[];tu(n),ou(t,n);var a=n.length;e.forEach(tu);for(var i=0;i<e.length;i++)o.push(a),a+=e[i].length,ou(t,e[i]);for(var v=Tl(t,o),c=0;c<v.length;c+=3)r.push(v.slice(c,c+3));return r}}]),n}();function tu(n){var e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function ou(n,e){for(var t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}var ru=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Cl([new ao(.5,.5),new ao(-.5,.5),new ao(-.5,-.5),new ao(.5,-.5)]),r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};g(this,t),(n=e.call(this)).type="ExtrudeGeometry",n.parameters={shapes:o,options:r},o=Array.isArray(o)?o:[o];for(var a=S(n),i=[],v=[],c=0,s=o.length;c<s;c++){var l=o[c];u(l)}function u(n){var e,t,o,c,s,l=[],u=void 0!==r.curveSegments?r.curveSegments:12,f=void 0!==r.steps?r.steps:1,p=void 0!==r.depth?r.depth:1,m=void 0===r.bevelEnabled||r.bevelEnabled,d=void 0!==r.bevelThickness?r.bevelThickness:.2,h=void 0!==r.bevelSize?r.bevelSize:d-.1,x=void 0!==r.bevelOffset?r.bevelOffset:0,g=void 0!==r.bevelSegments?r.bevelSegments:3,y=r.extrudePath,b=void 0!==r.UVGenerator?r.UVGenerator:au,U=!1;y&&(e=y.getSpacedPoints(f),U=!0,m=!1,t=y.computeFrenetFrames(f,!1),o=new Oo,c=new Oo,s=new Oo),m||(g=0,d=0,h=0,x=0);var _=n.extractPoints(u),w=_.shape,S=_.holes;if(!eu.isClockWise(w)){w=w.reverse();for(var M=0,k=S.length;M<k;M++){var z=S[M];eu.isClockWise(z)&&(S[M]=z.reverse())}}for(var C=eu.triangulateShape(w,S),T=w,R=0,D=S.length;R<D;R++){var P=S[R];w=w.concat(P)}function F(n,e,t){return e||console.error("THREE.ExtrudeGeometry: vec does not exist"),e.clone().multiplyScalar(t).add(n)}var j=w.length,I=C.length;function E(n,e,t){var o,r,a,i=n.x-e.x,v=n.y-e.y,c=t.x-n.x,s=t.y-n.y,l=i*i+v*v,u=i*s-v*c;if(Math.abs(u)>Number.EPSILON){var f=Math.sqrt(l),p=Math.sqrt(c*c+s*s),m=e.x-v/f,d=e.y+i/f,h=((t.x-s/p-m)*s-(t.y+c/p-d)*c)/(i*s-v*c),x=(o=m+i*h-n.x)*o+(r=d+v*h-n.y)*r;if(x<=2)return new ao(o,r);a=Math.sqrt(x/2)}else{var g=!1;i>Number.EPSILON?c>Number.EPSILON&&(g=!0):i<-Number.EPSILON?c<-Number.EPSILON&&(g=!0):Math.sign(v)===Math.sign(s)&&(g=!0),g?(o=-v,r=i,a=Math.sqrt(l)):(o=i,r=v,a=Math.sqrt(l/2))}return new ao(o/a,r/a)}for(var O=[],A=0,L=T.length,G=L-1,N=A+1;A<L;A++,G++,N++)G===L&&(G=0),N===L&&(N=0),O[A]=E(T[A],T[G],T[N]);for(var B,q=[],V=O.concat(),W=0,H=S.length;W<H;W++){var X=S[W];B=[];for(var Y=0,Z=X.length,Q=Z-1,J=Y+1;Y<Z;Y++,Q++,J++)Q===Z&&(Q=0),J===Z&&(J=0),B[Y]=E(X[Y],X[Q],X[J]);q.push(B),V=V.concat(B)}for(var K=0;K<g;K++){for(var $=K/g,nn=d*Math.cos($*Math.PI/2),en=h*Math.sin($*Math.PI/2)+x,tn=0,on=T.length;tn<on;tn++){var rn=F(T[tn],O[tn],en);Pn(rn.x,rn.y,-nn)}for(var an=0,vn=S.length;an<vn;an++){var cn=S[an];B=q[an];for(var sn=0,ln=cn.length;sn<ln;sn++){var un=F(cn[sn],B[sn],en);Pn(un.x,un.y,-nn)}}}for(var fn=h+x,pn=0;pn<j;pn++){var mn=m?F(w[pn],V[pn],fn):w[pn];U?(c.copy(t.normals[0]).multiplyScalar(mn.x),o.copy(t.binormals[0]).multiplyScalar(mn.y),s.copy(e[0]).add(c).add(o),Pn(s.x,s.y,s.z)):Pn(mn.x,mn.y,0)}for(var dn=1;dn<=f;dn++)for(var hn=0;hn<j;hn++){var xn=m?F(w[hn],V[hn],fn):w[hn];U?(c.copy(t.normals[dn]).multiplyScalar(xn.x),o.copy(t.binormals[dn]).multiplyScalar(xn.y),s.copy(e[dn]).add(c).add(o),Pn(s.x,s.y,s.z)):Pn(xn.x,xn.y,p/f*dn)}for(var gn=g-1;gn>=0;gn--){for(var yn=gn/g,bn=d*Math.cos(yn*Math.PI/2),Un=h*Math.sin(yn*Math.PI/2)+x,_n=0,wn=T.length;_n<wn;_n++){var Sn=F(T[_n],O[_n],Un);Pn(Sn.x,Sn.y,p+bn)}for(var Mn=0,kn=S.length;Mn<kn;Mn++){var zn=S[Mn];B=q[Mn];for(var Cn=0,Tn=zn.length;Cn<Tn;Cn++){var Rn=F(zn[Cn],B[Cn],Un);U?Pn(Rn.x,Rn.y+e[f-1].y,e[f-1].x+bn):Pn(Rn.x,Rn.y,p+bn)}}}function Dn(n,e){for(var t=n.length;--t>=0;){var o=t,r=t-1;r<0&&(r=n.length-1);for(var a=0,i=f+2*g;a<i;a++){var v=j*a,c=j*(a+1);jn(e+o+v,e+r+v,e+r+c,e+o+c)}}}function Pn(n,e,t){l.push(n),l.push(e),l.push(t)}function Fn(n,e,t){In(n),In(e),In(t);var o=i.length/3,r=b.generateTopUV(a,i,o-3,o-2,o-1);En(r[0]),En(r[1]),En(r[2])}function jn(n,e,t,o){In(n),In(e),In(o),In(e),In(t),In(o);var r=i.length/3,v=b.generateSideWallUV(a,i,r-6,r-3,r-2,r-1);En(v[0]),En(v[1]),En(v[3]),En(v[1]),En(v[2]),En(v[3])}function In(n){i.push(l[3*n+0]),i.push(l[3*n+1]),i.push(l[3*n+2])}function En(n){v.push(n.x),v.push(n.y)}!function(){var n=i.length/3;if(m){for(var e=0,t=j*e,o=0;o<I;o++){var r=C[o];Fn(r[2]+t,r[1]+t,r[0]+t)}t=j*(e=f+2*g);for(var v=0;v<I;v++){var c=C[v];Fn(c[0]+t,c[1]+t,c[2]+t)}}else{for(var s=0;s<I;s++){var l=C[s];Fn(l[2],l[1],l[0])}for(var u=0;u<I;u++){var p=C[u];Fn(p[0]+j*f,p[1]+j*f,p[2]+j*f)}}a.addGroup(n,i.length/3-n,0)}(),function(){var n=i.length/3,e=0;Dn(T,e),e+=T.length;for(var t=0,o=S.length;t<o;t++){var r=S[t];Dn(r,e),e+=r.length}a.addGroup(n,i.length/3-n,1)}()}return n.setAttribute("position",new la(i,3)),n.setAttribute("uv",new la(v,2)),n.computeVertexNormals(),n}return b(t,[{key:"toJSON",value:function(){var n=D(_(t.prototype),"toJSON",this).call(this);return function(n,e,t){if(t.shapes=[],Array.isArray(n))for(var o=0,r=n.length;o<r;o++){var a=n[o];t.shapes.push(a.uuid)}else t.shapes.push(n.uuid);t.options=Object.assign({},e),void 0!==e.extrudePath&&(t.options.extrudePath=e.extrudePath.toJSON());return t}(this.parameters.shapes,this.parameters.options,n)}}],[{key:"fromJSON",value:function(n,e){for(var o=[],r=0,a=n.shapes.length;r<a;r++){var i=e[n.shapes[r]];o.push(i)}var v=n.options.extrudePath;return void 0!==v&&(n.options.extrudePath=(new pl[v.type]).fromJSON(v)),new t(o,n.options)}}]),t}(ya),au={generateTopUV:function(n,e,t,o,r){var a=e[3*t],i=e[3*t+1],v=e[3*o],c=e[3*o+1],s=e[3*r],l=e[3*r+1];return[new ao(a,i),new ao(v,c),new ao(s,l)]},generateSideWallUV:function(n,e,t,o,r,a){var i=e[3*t],v=e[3*t+1],c=e[3*t+2],s=e[3*o],l=e[3*o+1],u=e[3*o+2],f=e[3*r],p=e[3*r+1],m=e[3*r+2],d=e[3*a],h=e[3*a+1],x=e[3*a+2];return Math.abs(v-l)<Math.abs(i-s)?[new ao(i,1-c),new ao(s,1-u),new ao(f,1-m),new ao(d,1-x)]:[new ao(v,1-c),new ao(l,1-u),new ao(p,1-m),new ao(h,1-x)]}};var iu=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;g(this,t);var a=(1+Math.sqrt(5))/2,i=[-1,a,0,1,a,0,-1,-a,0,1,-a,0,0,-1,a,0,1,a,0,-1,-a,0,1,-a,a,0,-1,a,0,1,-a,0,-1,-a,0,1],v=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];return(n=e.call(this,i,v,o,r)).type="IcosahedronGeometry",n.parameters={radius:o,detail:r},n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.detail)}}]),t}(Ul),vu=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;g(this,t);var a=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];return(n=e.call(this,a,i,o,r)).type="OctahedronGeometry",n.parameters={radius:o,detail:r},n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.detail)}}]),t}(Ul),cu=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:.5,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:8,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2*Math.PI;g(this,t),(n=e.call(this)).type="RingGeometry",n.parameters={innerRadius:o,outerRadius:r,thetaSegments:a,phiSegments:i,thetaStart:v,thetaLength:c},a=Math.max(3,a);for(var s=[],l=[],u=[],f=[],p=o,m=(r-o)/(i=Math.max(1,i)),d=new Oo,h=new ao,x=0;x<=i;x++){for(var y=0;y<=a;y++){var b=v+y/a*c;d.x=p*Math.cos(b),d.y=p*Math.sin(b),l.push(d.x,d.y,d.z),u.push(0,0,1),h.x=(d.x/r+1)/2,h.y=(d.y/r+1)/2,f.push(h.x,h.y)}p+=m}for(var U=0;U<i;U++)for(var _=U*(a+1),w=0;w<a;w++){var S=w+_,M=S,k=S+a+1,z=S+a+2,C=S+1;s.push(M,k,C),s.push(k,z,C)}return n.setIndex(s),n.setAttribute("position",new la(l,3)),n.setAttribute("normal",new la(u,3)),n.setAttribute("uv",new la(f,2)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.innerRadius,n.outerRadius,n.thetaSegments,n.phiSegments,n.thetaStart,n.thetaLength)}}]),t}(ya),su=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Cl([new ao(0,.5),new ao(-.5,-.5),new ao(.5,-.5)]),r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:12;g(this,t),(n=e.call(this)).type="ShapeGeometry",n.parameters={shapes:o,curveSegments:r};var a=[],i=[],v=[],c=[],s=0,l=0;if(!1===Array.isArray(o))f(o);else for(var u=0;u<o.length;u++)f(o[u]),n.addGroup(s,l,u),s+=l,l=0;function f(n){var e=i.length/3,t=n.extractPoints(r),o=t.shape,s=t.holes;!1===eu.isClockWise(o)&&(o=o.reverse());for(var u=0,f=s.length;u<f;u++){var p=s[u];!0===eu.isClockWise(p)&&(s[u]=p.reverse())}for(var m=eu.triangulateShape(o,s),d=0,h=s.length;d<h;d++){var x=s[d];o=o.concat(x)}for(var g=0,y=o.length;g<y;g++){var b=o[g];i.push(b.x,b.y,0),v.push(0,0,1),c.push(b.x,b.y)}for(var U=0,_=m.length;U<_;U++){var w=m[U],S=w[0]+e,M=w[1]+e,k=w[2]+e;a.push(S,M,k),l+=3}}return n.setIndex(a),n.setAttribute("position",new la(i,3)),n.setAttribute("normal",new la(v,3)),n.setAttribute("uv",new la(c,2)),n}return b(t,[{key:"toJSON",value:function(){var n=D(_(t.prototype),"toJSON",this).call(this);return function(n,e){if(e.shapes=[],Array.isArray(n))for(var t=0,o=n.length;t<o;t++){var r=n[t];e.shapes.push(r.uuid)}else e.shapes.push(n.uuid);return e}(this.parameters.shapes,n)}}],[{key:"fromJSON",value:function(n,e){for(var o=[],r=0,a=n.shapes.length;r<a;r++){var i=e[n.shapes[r]];o.push(i)}return new t(o,n.curveSegments)}}]),t}(ya);var lu=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:16,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:Math.PI;g(this,t),(n=e.call(this)).type="SphereGeometry",n.parameters={radius:o,widthSegments:r,heightSegments:a,phiStart:i,phiLength:v,thetaStart:c,thetaLength:s},r=Math.max(3,Math.floor(r)),a=Math.max(2,Math.floor(a));for(var l=Math.min(c+s,Math.PI),u=0,f=[],p=new Oo,m=new Oo,d=[],h=[],x=[],y=[],b=0;b<=a;b++){var U=[],_=b/a,w=0;0==b&&0==c?w=.5/r:b==a&&l==Math.PI&&(w=-.5/r);for(var S=0;S<=r;S++){var M=S/r;p.x=-o*Math.cos(i+M*v)*Math.sin(c+_*s),p.y=o*Math.cos(c+_*s),p.z=o*Math.sin(i+M*v)*Math.sin(c+_*s),h.push(p.x,p.y,p.z),m.copy(p).normalize(),x.push(m.x,m.y,m.z),y.push(M+w,1-_),U.push(u++)}f.push(U)}for(var k=0;k<a;k++)for(var z=0;z<r;z++){var C=f[k][z+1],T=f[k][z],R=f[k+1][z],D=f[k+1][z+1];(0!==k||c>0)&&d.push(C,T,D),(k!==a-1||l<Math.PI)&&d.push(T,R,D)}return n.setIndex(d),n.setAttribute("position",new la(h,3)),n.setAttribute("normal",new la(x,3)),n.setAttribute("uv",new la(y,2)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.widthSegments,n.heightSegments,n.phiStart,n.phiLength,n.thetaStart,n.thetaLength)}}]),t}(ya),uu=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;g(this,t);var a=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];return(n=e.call(this,a,i,o,r)).type="TetrahedronGeometry",n.parameters={radius:o,detail:r},n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.detail)}}]),t}(Ul),fu=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.4,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:8,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:6,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI;g(this,t),(n=e.call(this)).type="TorusGeometry",n.parameters={radius:o,tube:r,radialSegments:a,tubularSegments:i,arc:v},a=Math.floor(a),i=Math.floor(i);for(var c=[],s=[],l=[],u=[],f=new Oo,p=new Oo,m=new Oo,d=0;d<=a;d++)for(var h=0;h<=i;h++){var x=h/i*v,y=d/a*Math.PI*2;p.x=(o+r*Math.cos(y))*Math.cos(x),p.y=(o+r*Math.cos(y))*Math.sin(x),p.z=r*Math.sin(y),s.push(p.x,p.y,p.z),f.x=o*Math.cos(x),f.y=o*Math.sin(x),m.subVectors(p,f).normalize(),l.push(m.x,m.y,m.z),u.push(h/i),u.push(d/a)}for(var b=1;b<=a;b++)for(var U=1;U<=i;U++){var _=(i+1)*b+U-1,w=(i+1)*(b-1)+U-1,S=(i+1)*(b-1)+U,M=(i+1)*b+U;c.push(_,w,M),c.push(w,S,M)}return n.setIndex(c),n.setAttribute("position",new la(s,3)),n.setAttribute("normal",new la(l,3)),n.setAttribute("uv",new la(u,2)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.tube,n.radialSegments,n.tubularSegments,n.arc)}}]),t}(ya),pu=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.4,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:64,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:8,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:3;g(this,t),(n=e.call(this)).type="TorusKnotGeometry",n.parameters={radius:o,tube:r,tubularSegments:a,radialSegments:i,p:v,q:c},a=Math.floor(a),i=Math.floor(i);for(var s=[],l=[],u=[],f=[],p=new Oo,m=new Oo,d=new Oo,h=new Oo,x=new Oo,y=new Oo,b=new Oo,U=0;U<=a;++U){var _=U/a*v*Math.PI*2;F(_,v,c,o,d),F(_+.01,v,c,o,h),y.subVectors(h,d),b.addVectors(h,d),x.crossVectors(y,b),b.crossVectors(x,y),x.normalize(),b.normalize();for(var w=0;w<=i;++w){var S=w/i*Math.PI*2,M=-r*Math.cos(S),k=r*Math.sin(S);p.x=d.x+(M*b.x+k*x.x),p.y=d.y+(M*b.y+k*x.y),p.z=d.z+(M*b.z+k*x.z),l.push(p.x,p.y,p.z),m.subVectors(p,d).normalize(),u.push(m.x,m.y,m.z),f.push(U/a),f.push(w/i)}}for(var z=1;z<=a;z++)for(var C=1;C<=i;C++){var T=(i+1)*(z-1)+(C-1),R=(i+1)*z+(C-1),D=(i+1)*z+C,P=(i+1)*(z-1)+C;s.push(T,R,P),s.push(R,D,P)}function F(n,e,t,o,r){var a=Math.cos(n),i=Math.sin(n),v=t/e*n,c=Math.cos(v);r.x=o*(2+c)*.5*a,r.y=o*(2+c)*i*.5,r.z=o*Math.sin(v)*.5}return n.setIndex(s),n.setAttribute("position",new la(l,3)),n.setAttribute("normal",new la(u,3)),n.setAttribute("uv",new la(f,2)),n}return b(t,null,[{key:"fromJSON",value:function(n){return new t(n.radius,n.tube,n.tubularSegments,n.radialSegments,n.p,n.q)}}]),t}(ya),mu=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ul(new Oo(-1,-1,0),new Oo(-1,1,0),new Oo(1,1,0)),r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:64,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:8,v=arguments.length>4&&void 0!==arguments[4]&&arguments[4];g(this,t),(n=e.call(this)).type="TubeGeometry",n.parameters={path:o,tubularSegments:r,radius:a,radialSegments:i,closed:v};var c=o.computeFrenetFrames(r,v);n.tangents=c.tangents,n.normals=c.normals,n.binormals=c.binormals;var s=new Oo,l=new Oo,u=new ao,f=new Oo,p=[],m=[],d=[],h=[];function x(){for(var n=0;n<r;n++)y(n);y(!1===v?r:0),U(),b()}function y(n){f=o.getPointAt(n/r,f);for(var e=c.normals[n],t=c.binormals[n],v=0;v<=i;v++){var u=v/i*Math.PI*2,d=Math.sin(u),h=-Math.cos(u);l.x=h*e.x+d*t.x,l.y=h*e.y+d*t.y,l.z=h*e.z+d*t.z,l.normalize(),m.push(l.x,l.y,l.z),s.x=f.x+a*l.x,s.y=f.y+a*l.y,s.z=f.z+a*l.z,p.push(s.x,s.y,s.z)}}function b(){for(var n=1;n<=r;n++)for(var e=1;e<=i;e++){var t=(i+1)*(n-1)+(e-1),o=(i+1)*n+(e-1),a=(i+1)*n+e,v=(i+1)*(n-1)+e;h.push(t,o,v),h.push(o,a,v)}}function U(){for(var n=0;n<=r;n++)for(var e=0;e<=i;e++)u.x=n/r,u.y=e/i,d.push(u.x,u.y)}return x(),n.setIndex(h),n.setAttribute("position",new la(p,3)),n.setAttribute("normal",new la(m,3)),n.setAttribute("uv",new la(d,2)),n}return b(t,[{key:"toJSON",value:function(){var n=D(_(t.prototype),"toJSON",this).call(this);return n.path=this.parameters.path.toJSON(),n}}],[{key:"fromJSON",value:function(n){return new t((new pl[n.path.type]).fromJSON(n.path),n.tubularSegments,n.radius,n.radialSegments,n.closed)}}]),t}(ya),du=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(g(this,t),(n=e.call(this)).type="WireframeGeometry",n.parameters={geometry:o},null!==o){var r=[],a=new Set,i=new Oo,v=new Oo;if(null!==o.index){var c=o.attributes.position,s=o.index,l=o.groups;0===l.length&&(l=[{start:0,count:s.count,materialIndex:0}]);for(var u=0,f=l.length;u<f;++u)for(var p=l[u],m=p.start,d=p.count,h=m,x=m+d;h<x;h+=3)for(var y=0;y<3;y++){var b=s.getX(h+y),U=s.getX(h+(y+1)%3);i.fromBufferAttribute(c,b),v.fromBufferAttribute(c,U),!0===hu(i,v,a)&&(r.push(i.x,i.y,i.z),r.push(v.x,v.y,v.z))}}else for(var _=o.attributes.position,w=0,S=_.count/3;w<S;w++)for(var M=0;M<3;M++){var k=3*w+M,z=3*w+(M+1)%3;i.fromBufferAttribute(_,k),v.fromBufferAttribute(_,z),!0===hu(i,v,a)&&(r.push(i.x,i.y,i.z),r.push(v.x,v.y,v.z))}n.setAttribute("position",new la(r,3))}return n}return b(t)}(ya);function hu(n,e,t){var o="".concat(n.x,",").concat(n.y,",").concat(n.z,"-").concat(e.x,",").concat(e.y,",").concat(e.z),r="".concat(e.x,",").concat(e.y,",").concat(e.z,"-").concat(n.x,",").concat(n.y,",").concat(n.z);return!0!==t.has(o)&&!0!==t.has(r)&&(t.add(o),t.add(r),!0)}var xu=Object.freeze({__proto__:null,BoxGeometry:La,CapsuleGeometry:xl,CircleGeometry:gl,ConeGeometry:bl,CylinderGeometry:yl,DodecahedronGeometry:_l,EdgesGeometry:zl,ExtrudeGeometry:ru,IcosahedronGeometry:iu,LatheGeometry:hl,OctahedronGeometry:vu,PlaneGeometry:ai,PolyhedronGeometry:Ul,RingGeometry:cu,ShapeGeometry:su,SphereGeometry:lu,TetrahedronGeometry:uu,TorusGeometry:fu,TorusKnotGeometry:pu,TubeGeometry:mu,WireframeGeometry:du}),gu=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).isShadowMaterial=!0,o.type="ShadowMaterial",o.color=new wo(0),o.transparent=!0,o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.fog=n.fog,this}}]),t}(Jr),yu=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this,n)).isRawShaderMaterial=!0,o.type="RawShaderMaterial",o}return b(t)}(qa),bu=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).isMeshStandardMaterial=!0,o.defines={STANDARD:""},o.type="MeshStandardMaterial",o.color=new wo(16777215),o.roughness=1,o.metalness=0,o.map=null,o.lightMap=null,o.lightMapIntensity=1,o.aoMap=null,o.aoMapIntensity=1,o.emissive=new wo(0),o.emissiveIntensity=1,o.emissiveMap=null,o.bumpMap=null,o.bumpScale=1,o.normalMap=null,o.normalMapType=ut,o.normalScale=new ao(1,1),o.displacementMap=null,o.displacementScale=1,o.displacementBias=0,o.roughnessMap=null,o.metalnessMap=null,o.alphaMap=null,o.envMap=null,o.envMapIntensity=1,o.wireframe=!1,o.wireframeLinewidth=1,o.wireframeLinecap="round",o.wireframeLinejoin="round",o.flatShading=!1,o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.defines={STANDARD:""},this.color.copy(n.color),this.roughness=n.roughness,this.metalness=n.metalness,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.roughnessMap=n.roughnessMap,this.metalnessMap=n.metalnessMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.envMapIntensity=n.envMapIntensity,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.flatShading=n.flatShading,this.fog=n.fog,this}}]),t}(Jr),Uu=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).isMeshPhysicalMaterial=!0,o.defines={STANDARD:"",PHYSICAL:""},o.type="MeshPhysicalMaterial",o.clearcoatMap=null,o.clearcoatRoughness=0,o.clearcoatRoughnessMap=null,o.clearcoatNormalScale=new ao(1,1),o.clearcoatNormalMap=null,o.ior=1.5,Object.defineProperty(S(o),"reflectivity",{get:function(){return Qt(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(n){this.ior=(1+.4*n)/(1-.4*n)}}),o.iridescenceMap=null,o.iridescenceIOR=1.3,o.iridescenceThicknessRange=[100,400],o.iridescenceThicknessMap=null,o.sheenColor=new wo(0),o.sheenColorMap=null,o.sheenRoughness=1,o.sheenRoughnessMap=null,o.transmissionMap=null,o.thickness=0,o.thicknessMap=null,o.attenuationDistance=1/0,o.attenuationColor=new wo(1,1,1),o.specularIntensity=1,o.specularIntensityMap=null,o.specularColor=new wo(1,1,1),o.specularColorMap=null,o._sheen=0,o._clearcoat=0,o._iridescence=0,o._transmission=0,o.setValues(n),o}return b(t,[{key:"sheen",get:function(){return this._sheen},set:function(n){this._sheen>0!==n>0&&this.version++,this._sheen=n}},{key:"clearcoat",get:function(){return this._clearcoat},set:function(n){this._clearcoat>0!==n>0&&this.version++,this._clearcoat=n}},{key:"iridescence",get:function(){return this._iridescence},set:function(n){this._iridescence>0!==n>0&&this.version++,this._iridescence=n}},{key:"transmission",get:function(){return this._transmission},set:function(n){this._transmission>0!==n>0&&this.version++,this._transmission=n}},{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=n.clearcoat,this.clearcoatMap=n.clearcoatMap,this.clearcoatRoughness=n.clearcoatRoughness,this.clearcoatRoughnessMap=n.clearcoatRoughnessMap,this.clearcoatNormalMap=n.clearcoatNormalMap,this.clearcoatNormalScale.copy(n.clearcoatNormalScale),this.ior=n.ior,this.iridescence=n.iridescence,this.iridescenceMap=n.iridescenceMap,this.iridescenceIOR=n.iridescenceIOR,this.iridescenceThicknessRange=x(n.iridescenceThicknessRange),this.iridescenceThicknessMap=n.iridescenceThicknessMap,this.sheen=n.sheen,this.sheenColor.copy(n.sheenColor),this.sheenColorMap=n.sheenColorMap,this.sheenRoughness=n.sheenRoughness,this.sheenRoughnessMap=n.sheenRoughnessMap,this.transmission=n.transmission,this.transmissionMap=n.transmissionMap,this.thickness=n.thickness,this.thicknessMap=n.thicknessMap,this.attenuationDistance=n.attenuationDistance,this.attenuationColor.copy(n.attenuationColor),this.specularIntensity=n.specularIntensity,this.specularIntensityMap=n.specularIntensityMap,this.specularColor.copy(n.specularColor),this.specularColorMap=n.specularColorMap,this}}]),t}(bu),_u=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).isMeshPhongMaterial=!0,o.type="MeshPhongMaterial",o.color=new wo(16777215),o.specular=new wo(1118481),o.shininess=30,o.map=null,o.lightMap=null,o.lightMapIntensity=1,o.aoMap=null,o.aoMapIntensity=1,o.emissive=new wo(0),o.emissiveIntensity=1,o.emissiveMap=null,o.bumpMap=null,o.bumpScale=1,o.normalMap=null,o.normalMapType=ut,o.normalScale=new ao(1,1),o.displacementMap=null,o.displacementScale=1,o.displacementBias=0,o.specularMap=null,o.alphaMap=null,o.envMap=null,o.combine=Sn,o.reflectivity=1,o.refractionRatio=.98,o.wireframe=!1,o.wireframeLinewidth=1,o.wireframeLinecap="round",o.wireframeLinejoin="round",o.flatShading=!1,o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.specular.copy(n.specular),this.shininess=n.shininess,this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.flatShading=n.flatShading,this.fog=n.fog,this}}]),t}(Jr),wu=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).isMeshToonMaterial=!0,o.defines={TOON:""},o.type="MeshToonMaterial",o.color=new wo(16777215),o.map=null,o.gradientMap=null,o.lightMap=null,o.lightMapIntensity=1,o.aoMap=null,o.aoMapIntensity=1,o.emissive=new wo(0),o.emissiveIntensity=1,o.emissiveMap=null,o.bumpMap=null,o.bumpScale=1,o.normalMap=null,o.normalMapType=ut,o.normalScale=new ao(1,1),o.displacementMap=null,o.displacementScale=1,o.displacementBias=0,o.alphaMap=null,o.wireframe=!1,o.wireframeLinewidth=1,o.wireframeLinecap="round",o.wireframeLinejoin="round",o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.map=n.map,this.gradientMap=n.gradientMap,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.fog=n.fog,this}}]),t}(Jr),Su=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).isMeshNormalMaterial=!0,o.type="MeshNormalMaterial",o.bumpMap=null,o.bumpScale=1,o.normalMap=null,o.normalMapType=ut,o.normalScale=new ao(1,1),o.displacementMap=null,o.displacementScale=1,o.displacementBias=0,o.wireframe=!1,o.wireframeLinewidth=1,o.flatShading=!1,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.flatShading=n.flatShading,this}}]),t}(Jr),Mu=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).isMeshLambertMaterial=!0,o.type="MeshLambertMaterial",o.color=new wo(16777215),o.map=null,o.lightMap=null,o.lightMapIntensity=1,o.aoMap=null,o.aoMapIntensity=1,o.emissive=new wo(0),o.emissiveIntensity=1,o.emissiveMap=null,o.bumpMap=null,o.bumpScale=1,o.normalMap=null,o.normalMapType=ut,o.normalScale=new ao(1,1),o.displacementMap=null,o.displacementScale=1,o.displacementBias=0,o.specularMap=null,o.alphaMap=null,o.envMap=null,o.combine=Sn,o.reflectivity=1,o.refractionRatio=.98,o.wireframe=!1,o.wireframeLinewidth=1,o.wireframeLinecap="round",o.wireframeLinejoin="round",o.flatShading=!1,o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.color.copy(n.color),this.map=n.map,this.lightMap=n.lightMap,this.lightMapIntensity=n.lightMapIntensity,this.aoMap=n.aoMap,this.aoMapIntensity=n.aoMapIntensity,this.emissive.copy(n.emissive),this.emissiveMap=n.emissiveMap,this.emissiveIntensity=n.emissiveIntensity,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.specularMap=n.specularMap,this.alphaMap=n.alphaMap,this.envMap=n.envMap,this.combine=n.combine,this.reflectivity=n.reflectivity,this.refractionRatio=n.refractionRatio,this.wireframe=n.wireframe,this.wireframeLinewidth=n.wireframeLinewidth,this.wireframeLinecap=n.wireframeLinecap,this.wireframeLinejoin=n.wireframeLinejoin,this.flatShading=n.flatShading,this.fog=n.fog,this}}]),t}(Jr),ku=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).isMeshMatcapMaterial=!0,o.defines={MATCAP:""},o.type="MeshMatcapMaterial",o.color=new wo(16777215),o.matcap=null,o.map=null,o.bumpMap=null,o.bumpScale=1,o.normalMap=null,o.normalMapType=ut,o.normalScale=new ao(1,1),o.displacementMap=null,o.displacementScale=1,o.displacementBias=0,o.alphaMap=null,o.flatShading=!1,o.fog=!0,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.defines={MATCAP:""},this.color.copy(n.color),this.matcap=n.matcap,this.map=n.map,this.bumpMap=n.bumpMap,this.bumpScale=n.bumpScale,this.normalMap=n.normalMap,this.normalMapType=n.normalMapType,this.normalScale.copy(n.normalScale),this.displacementMap=n.displacementMap,this.displacementScale=n.displacementScale,this.displacementBias=n.displacementBias,this.alphaMap=n.alphaMap,this.flatShading=n.flatShading,this.fog=n.fog,this}}]),t}(Jr),zu=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).isLineDashedMaterial=!0,o.type="LineDashedMaterial",o.scale=1,o.dashSize=3,o.gapSize=1,o.setValues(n),o}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.scale=n.scale,this.dashSize=n.dashSize,this.gapSize=n.gapSize,this}}]),t}(Ms);function Cu(n,e,t){return Ru(n)?new n.constructor(n.subarray(e,void 0!==t?t:n.length)):n.slice(e,t)}function Tu(n,e,t){return!n||!t&&n.constructor===e?n:"number"===typeof e.BYTES_PER_ELEMENT?new e(n):Array.prototype.slice.call(n)}function Ru(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)}function Du(n){for(var e=n.length,t=new Array(e),o=0;o!==e;++o)t[o]=o;return t.sort((function(e,t){return n[e]-n[t]})),t}function Pu(n,e,t){for(var o=n.length,r=new n.constructor(o),a=0,i=0;i!==o;++a)for(var v=t[a]*e,c=0;c!==e;++c)r[i++]=n[v+c];return r}function Fu(n,e,t,o){for(var r=1,a=n[0];void 0!==a&&void 0===a[o];)a=n[r++];if(void 0!==a){var i=a[o];if(void 0!==i)if(Array.isArray(i))do{void 0!==(i=a[o])&&(e.push(a.time),t.push.apply(t,i)),a=n[r++]}while(void 0!==a);else if(void 0!==i.toArray)do{void 0!==(i=a[o])&&(e.push(a.time),i.toArray(t,t.length)),a=n[r++]}while(void 0!==a);else do{void 0!==(i=a[o])&&(e.push(a.time),t.push(i)),a=n[r++]}while(void 0!==a)}}var ju=Object.freeze({__proto__:null,arraySlice:Cu,convertArray:Tu,isTypedArray:Ru,getKeyframeOrder:Du,sortedArray:Pu,flattenJSON:Fu,subclip:function(n,e,t,o){var r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:30,a=n.clone();a.name=e;for(var i=[],v=0;v<a.tracks.length;++v){for(var c=a.tracks[v],s=c.getValueSize(),l=[],u=[],f=0;f<c.times.length;++f){var p=c.times[f]*r;if(!(p<t||p>=o)){l.push(c.times[f]);for(var m=0;m<s;++m)u.push(c.values[f*s+m])}}0!==l.length&&(c.times=Tu(l,c.times.constructor),c.values=Tu(u,c.values.constructor),i.push(c))}a.tracks=i;for(var d=1/0,h=0;h<a.tracks.length;++h)d>a.tracks[h].times[0]&&(d=a.tracks[h].times[0]);for(var x=0;x<a.tracks.length;++x)a.tracks[x].shift(-1*d);return a.resetDuration(),a},makeClipAdditive:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:n,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:30;o<=0&&(o=30);for(var r=t.tracks.length,a=e/o,i=function(e){var o=t.tracks[e],r=o.ValueTypeName;if("bool"===r||"string"===r)return"continue";var i=n.tracks.find((function(n){return n.name===o.name&&n.ValueTypeName===r}));if(void 0===i)return"continue";var v=0,c=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(v=c/3);var s=0,l=i.getValueSize();i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(s=l/3);var u=o.times.length-1,f=void 0;if(a<=o.times[0]){var p=v,m=c-v;f=Cu(o.values,p,m)}else if(a>=o.times[u]){var d=u*c+v,h=d+c-v;f=Cu(o.values,d,h)}else{var x=o.createInterpolant(),g=v,y=c-v;x.evaluate(a),f=Cu(x.resultBuffer,g,y)}"quaternion"===r&&(new Eo).fromArray(f).normalize().conjugate().toArray(f);for(var b=i.times.length,U=0;U<b;++U){var _=U*l+s;if("quaternion"===r)Eo.multiplyQuaternionsFlat(i.values,_,f,0,i.values,_);else for(var w=l-2*s,S=0;S<w;++S)i.values[_+S]-=f[S]}},v=0;v<r;++v)i(v);return n.blendMode=ot,n}}),Iu=function(){function n(e,t,o,r){g(this,n),this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=void 0!==r?r:new t.constructor(o),this.sampleValues=t,this.valueSize=o,this.settings=null,this.DefaultSettings_={}}return b(n,[{key:"evaluate",value:function(n){var e=this.parameterPositions,t=this._cachedIndex,o=e[t],r=e[t-1];n:{e:{var a;t:{o:if(!(n<o)){for(var i=t+2;;){if(void 0===o){if(n<r)break o;return t=e.length,this._cachedIndex=t,this.copySampleValue_(t-1)}if(t===i)break;if(r=o,n<(o=e[++t]))break e}a=e.length;break t}if(n>=r)break n;var v=e[1];n<v&&(t=2,r=v);for(var c=t-2;;){if(void 0===r)return this._cachedIndex=0,this.copySampleValue_(0);if(t===c)break;if(o=r,n>=(r=e[--t-1]))break e}a=t,t=0}for(;t<a;){var s=t+a>>>1;n<e[s]?a=s:t=s+1}if(o=e[t],void 0===(r=e[t-1]))return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===o)return t=e.length,this._cachedIndex=t,this.copySampleValue_(t-1)}this._cachedIndex=t,this.intervalChanged_(t,r,o)}return this.interpolate_(t,r,n,o)}},{key:"getSettings_",value:function(){return this.settings||this.DefaultSettings_}},{key:"copySampleValue_",value:function(n){for(var e=this.resultBuffer,t=this.sampleValues,o=this.valueSize,r=n*o,a=0;a!==o;++a)e[a]=t[r+a];return e}},{key:"interpolate_",value:function(){throw new Error("call to abstract method")}},{key:"intervalChanged_",value:function(){}}]),n}(),Eu=function(n){U(t,n);var e=k(t);function t(n,o,r,a){var i;return g(this,t),(i=e.call(this,n,o,r,a))._weightPrev=-0,i._offsetPrev=-0,i._weightNext=-0,i._offsetNext=-0,i.DefaultSettings_={endingStart:$e,endingEnd:$e},i}return b(t,[{key:"intervalChanged_",value:function(n,e,t){var o=this.parameterPositions,r=n-2,a=n+1,i=o[r],v=o[a];if(void 0===i)switch(this.getSettings_().endingStart){case nt:r=n,i=2*e-t;break;case et:i=e+o[r=o.length-2]-o[r+1];break;default:r=n,i=t}if(void 0===v)switch(this.getSettings_().endingEnd){case nt:a=n,v=2*t-e;break;case et:a=1,v=t+o[1]-o[0];break;default:a=n-1,v=e}var c=.5*(t-e),s=this.valueSize;this._weightPrev=c/(e-i),this._weightNext=c/(v-t),this._offsetPrev=r*s,this._offsetNext=a*s}},{key:"interpolate_",value:function(n,e,t,o){for(var r=this.resultBuffer,a=this.sampleValues,i=this.valueSize,v=n*i,c=v-i,s=this._offsetPrev,l=this._offsetNext,u=this._weightPrev,f=this._weightNext,p=(t-e)/(o-e),m=p*p,d=m*p,h=-u*d+2*u*m-u*p,x=(1+u)*d+(-1.5-2*u)*m+(-.5+u)*p+1,g=(-1-f)*d+(1.5+f)*m+.5*p,y=f*d-f*m,b=0;b!==i;++b)r[b]=h*a[s+b]+x*a[c+b]+g*a[v+b]+y*a[l+b];return r}}]),t}(Iu),Ou=function(n){U(t,n);var e=k(t);function t(n,o,r,a){return g(this,t),e.call(this,n,o,r,a)}return b(t,[{key:"interpolate_",value:function(n,e,t,o){for(var r=this.resultBuffer,a=this.sampleValues,i=this.valueSize,v=n*i,c=v-i,s=(t-e)/(o-e),l=1-s,u=0;u!==i;++u)r[u]=a[c+u]*l+a[v+u]*s;return r}}]),t}(Iu),Au=function(n){U(t,n);var e=k(t);function t(n,o,r,a){return g(this,t),e.call(this,n,o,r,a)}return b(t,[{key:"interpolate_",value:function(n){return this.copySampleValue_(n-1)}}]),t}(Iu),Lu=function(){function n(e,t,o,r){if(g(this,n),void 0===e)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===t||0===t.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Tu(t,this.TimeBufferType),this.values=Tu(o,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}return b(n,[{key:"InterpolantFactoryMethodDiscrete",value:function(n){return new Au(this.times,this.values,this.getValueSize(),n)}},{key:"InterpolantFactoryMethodLinear",value:function(n){return new Ou(this.times,this.values,this.getValueSize(),n)}},{key:"InterpolantFactoryMethodSmooth",value:function(n){return new Eu(this.times,this.values,this.getValueSize(),n)}},{key:"setInterpolation",value:function(n){var e;switch(n){case Qe:e=this.InterpolantFactoryMethodDiscrete;break;case Je:e=this.InterpolantFactoryMethodLinear;break;case Ke:e=this.InterpolantFactoryMethodSmooth}if(void 0===e){var t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(n===this.DefaultInterpolation)throw new Error(t);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=e,this}},{key:"getInterpolation",value:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Qe;case this.InterpolantFactoryMethodLinear:return Je;case this.InterpolantFactoryMethodSmooth:return Ke}}},{key:"getValueSize",value:function(){return this.values.length/this.times.length}},{key:"shift",value:function(n){if(0!==n)for(var e=this.times,t=0,o=e.length;t!==o;++t)e[t]+=n;return this}},{key:"scale",value:function(n){if(1!==n)for(var e=this.times,t=0,o=e.length;t!==o;++t)e[t]*=n;return this}},{key:"trim",value:function(n,e){for(var t=this.times,o=t.length,r=0,a=o-1;r!==o&&t[r]<n;)++r;for(;-1!==a&&t[a]>e;)--a;if(++a,0!==r||a!==o){r>=a&&(r=(a=Math.max(a,1))-1);var i=this.getValueSize();this.times=Cu(t,r,a),this.values=Cu(this.values,r*i,a*i)}return this}},{key:"validate",value:function(){var n=!0,e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),n=!1);var t=this.times,o=this.values,r=t.length;0===r&&(console.error("THREE.KeyframeTrack: Track is empty.",this),n=!1);for(var a=null,i=0;i!==r;i++){var v=t[i];if("number"===typeof v&&isNaN(v)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,i,v),n=!1;break}if(null!==a&&a>v){console.error("THREE.KeyframeTrack: Out of order keys.",this,i,v,a),n=!1;break}a=v}if(void 0!==o&&Ru(o))for(var c=0,s=o.length;c!==s;++c){var l=o[c];if(isNaN(l)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,c,l),n=!1;break}}return n}},{key:"optimize",value:function(){for(var n=Cu(this.times),e=Cu(this.values),t=this.getValueSize(),o=this.getInterpolation()===Ke,r=n.length-1,a=1,i=1;i<r;++i){var v=!1,c=n[i];if(c!==n[i+1]&&(1!==i||c!==n[0]))if(o)v=!0;else for(var s=i*t,l=s-t,u=s+t,f=0;f!==t;++f){var p=e[s+f];if(p!==e[l+f]||p!==e[u+f]){v=!0;break}}if(v){if(i!==a){n[a]=n[i];for(var m=i*t,d=a*t,h=0;h!==t;++h)e[d+h]=e[m+h]}++a}}if(r>0){n[a]=n[r];for(var x=r*t,g=a*t,y=0;y!==t;++y)e[g+y]=e[x+y];++a}return a!==n.length?(this.times=Cu(n,0,a),this.values=Cu(e,0,a*t)):(this.times=n,this.values=e),this}},{key:"clone",value:function(){var n=Cu(this.times,0),e=Cu(this.values,0),t=new(0,this.constructor)(this.name,n,e);return t.createInterpolant=this.createInterpolant,t}}],[{key:"toJSON",value:function(n){var e,t=n.constructor;if(t.toJSON!==this.toJSON)e=t.toJSON(n);else{e={name:n.name,times:Tu(n.times,Array),values:Tu(n.values,Array)};var o=n.getInterpolation();o!==n.DefaultInterpolation&&(e.interpolation=o)}return e.type=n.ValueTypeName,e}}]),n}();Lu.prototype.TimeBufferType=Float32Array,Lu.prototype.ValueBufferType=Float32Array,Lu.prototype.DefaultInterpolation=Je;var Gu=function(n){U(t,n);var e=k(t);function t(){return g(this,t),e.apply(this,arguments)}return b(t)}(Lu);Gu.prototype.ValueTypeName="bool",Gu.prototype.ValueBufferType=Array,Gu.prototype.DefaultInterpolation=Qe,Gu.prototype.InterpolantFactoryMethodLinear=void 0,Gu.prototype.InterpolantFactoryMethodSmooth=void 0;var Nu=function(n){U(t,n);var e=k(t);function t(){return g(this,t),e.apply(this,arguments)}return b(t)}(Lu);Nu.prototype.ValueTypeName="color";var Bu=function(n){U(t,n);var e=k(t);function t(){return g(this,t),e.apply(this,arguments)}return b(t)}(Lu);Bu.prototype.ValueTypeName="number";var qu=function(n){U(t,n);var e=k(t);function t(n,o,r,a){return g(this,t),e.call(this,n,o,r,a)}return b(t,[{key:"interpolate_",value:function(n,e,t,o){for(var r=this.resultBuffer,a=this.sampleValues,i=this.valueSize,v=(t-e)/(o-e),c=n*i,s=c+i;c!==s;c+=4)Eo.slerpFlat(r,0,a,c-i,a,c,v);return r}}]),t}(Iu),Vu=function(n){U(t,n);var e=k(t);function t(){return g(this,t),e.apply(this,arguments)}return b(t,[{key:"InterpolantFactoryMethodLinear",value:function(n){return new qu(this.times,this.values,this.getValueSize(),n)}}]),t}(Lu);Vu.prototype.ValueTypeName="quaternion",Vu.prototype.DefaultInterpolation=Je,Vu.prototype.InterpolantFactoryMethodSmooth=void 0;var Wu=function(n){U(t,n);var e=k(t);function t(){return g(this,t),e.apply(this,arguments)}return b(t)}(Lu);Wu.prototype.ValueTypeName="string",Wu.prototype.ValueBufferType=Array,Wu.prototype.DefaultInterpolation=Qe,Wu.prototype.InterpolantFactoryMethodLinear=void 0,Wu.prototype.InterpolantFactoryMethodSmooth=void 0;var Hu=function(n){U(t,n);var e=k(t);function t(){return g(this,t),e.apply(this,arguments)}return b(t)}(Lu);Hu.prototype.ValueTypeName="vector";var Xu=function(){function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2?arguments[2]:void 0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:tt;g(this,n),this.name=e,this.tracks=o,this.duration=t,this.blendMode=r,this.uuid=Zt(),this.duration<0&&this.resetDuration()}return b(n,[{key:"resetDuration",value:function(){for(var n=0,e=0,t=this.tracks.length;e!==t;++e){var o=this.tracks[e];n=Math.max(n,o.times[o.times.length-1])}return this.duration=n,this}},{key:"trim",value:function(){for(var n=0;n<this.tracks.length;n++)this.tracks[n].trim(0,this.duration);return this}},{key:"validate",value:function(){for(var n=!0,e=0;e<this.tracks.length;e++)n=n&&this.tracks[e].validate();return n}},{key:"optimize",value:function(){for(var n=0;n<this.tracks.length;n++)this.tracks[n].optimize();return this}},{key:"clone",value:function(){for(var n=[],e=0;e<this.tracks.length;e++)n.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,n,this.blendMode)}},{key:"toJSON",value:function(){return this.constructor.toJSON(this)}}],[{key:"parse",value:function(n){for(var e=[],t=n.tracks,o=1/(n.fps||1),r=0,a=t.length;r!==a;++r)e.push(Yu(t[r]).scale(o));var i=new this(n.name,n.duration,e,n.blendMode);return i.uuid=n.uuid,i}},{key:"toJSON",value:function(n){for(var e=[],t=n.tracks,o={name:n.name,duration:n.duration,tracks:e,uuid:n.uuid,blendMode:n.blendMode},r=0,a=t.length;r!==a;++r)e.push(Lu.toJSON(t[r]));return o}},{key:"CreateFromMorphTargetSequence",value:function(n,e,t,o){for(var r=e.length,a=[],i=0;i<r;i++){var v=[],c=[];v.push((i+r-1)%r,i,(i+1)%r),c.push(0,1,0);var s=Du(v);v=Pu(v,1,s),c=Pu(c,1,s),o||0!==v[0]||(v.push(r),c.push(c[0])),a.push(new Bu(".morphTargetInfluences["+e[i].name+"]",v,c).scale(1/t))}return new this(n,-1,a)}},{key:"findByName",value:function(n,e){var t=n;if(!Array.isArray(n)){var o=n;t=o.geometry&&o.geometry.animations||o.animations}for(var r=0;r<t.length;r++)if(t[r].name===e)return t[r];return null}},{key:"CreateClipsFromMorphTargetSequences",value:function(n,e,t){for(var o={},r=/^([\w-]*?)([\d]+)$/,a=0,i=n.length;a<i;a++){var v=n[a],c=v.name.match(r);if(c&&c.length>1){var s=c[1],l=o[s];l||(o[s]=l=[]),l.push(v)}}var u=[];for(var f in o)u.push(this.CreateFromMorphTargetSequence(f,o[f],e,t));return u}},{key:"parseAnimation",value:function(n,e){if(!n)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;for(var t=function(n,e,t,o,r){if(0!==t.length){var a=[],i=[];Fu(t,a,i,o),0!==a.length&&r.push(new n(e,a,i))}},o=[],r=n.name||"default",a=n.fps||30,i=n.blendMode,v=n.length||-1,c=n.hierarchy||[],s=0;s<c.length;s++){var l=c[s].keys;if(l&&0!==l.length)if(l[0].morphTargets){var u={},f=void 0;for(f=0;f<l.length;f++)if(l[f].morphTargets)for(var p=0;p<l[f].morphTargets.length;p++)u[l[f].morphTargets[p]]=-1;for(var m in u){for(var d=[],h=[],x=0;x!==l[f].morphTargets.length;++x){var g=l[f];d.push(g.time),h.push(g.morphTarget===m?1:0)}o.push(new Bu(".morphTargetInfluence["+m+"]",d,h))}v=u.length*a}else{var y=".bones["+e[s].name+"]";t(Hu,y+".position",l,"pos",o),t(Vu,y+".quaternion",l,"rot",o),t(Hu,y+".scale",l,"scl",o)}}return 0===o.length?null:new this(r,v,o,i)}}]),n}();function Yu(n){if(void 0===n.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");var e=function(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Bu;case"vector":case"vector2":case"vector3":case"vector4":return Hu;case"color":return Nu;case"quaternion":return Vu;case"bool":case"boolean":return Gu;case"string":return Wu}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}(n.type);if(void 0===n.times){var t=[],o=[];Fu(n.keys,t,o,"value"),n.times=t,n.values=o}return void 0!==e.parse?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}var Zu,Qu={enabled:!1,files:{},add:function(n,e){!1!==this.enabled&&(this.files[n]=e)},get:function(n){if(!1!==this.enabled)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}},Ju=b((function n(e,t,o){g(this,n);var r=this,a=!1,i=0,v=0,c=void 0,s=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=o,this.itemStart=function(n){v++,!1===a&&void 0!==r.onStart&&r.onStart(n,i,v),a=!0},this.itemEnd=function(n){i++,void 0!==r.onProgress&&r.onProgress(n,i,v),i===v&&(a=!1,void 0!==r.onLoad&&r.onLoad())},this.itemError=function(n){void 0!==r.onError&&r.onError(n)},this.resolveURL=function(n){return c?c(n):n},this.setURLModifier=function(n){return c=n,this},this.addHandler=function(n,e){return s.push(n,e),this},this.removeHandler=function(n){var e=s.indexOf(n);return-1!==e&&s.splice(e,2),this},this.getHandler=function(n){for(var e=0,t=s.length;e<t;e+=2){var o=s[e],r=s[e+1];if(o.global&&(o.lastIndex=0),o.test(n))return r}return null}})),Ku=new Ju,$u=function(){function n(e){g(this,n),this.manager=void 0!==e?e:Ku,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}return b(n,[{key:"load",value:function(){}},{key:"loadAsync",value:function(n,e){var t=this;return new Promise((function(o,r){t.load(n,o,e,r)}))}},{key:"parse",value:function(){}},{key:"setCrossOrigin",value:function(n){return this.crossOrigin=n,this}},{key:"setWithCredentials",value:function(n){return this.withCredentials=n,this}},{key:"setPath",value:function(n){return this.path=n,this}},{key:"setResourcePath",value:function(n){return this.resourcePath=n,this}},{key:"setRequestHeader",value:function(n){return this.requestHeader=n,this}}]),n}(),nf={},ef=function(n){U(t,n);var e=k(t);function t(n,o){var r;return g(this,t),(r=e.call(this,n)).response=o,r}return b(t)}(z(Error)),tf=function(n){U(t,n);var e=k(t);function t(n){return g(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=this;void 0===n&&(n=""),void 0!==this.path&&(n=this.path+n),n=this.manager.resolveURL(n);var a=Qu.get(n);if(void 0!==a)return this.manager.itemStart(n),setTimeout((function(){e&&e(a),r.manager.itemEnd(n)}),0),a;if(void 0===nf[n]){nf[n]=[],nf[n].push({onLoad:e,onProgress:t,onError:o});var i=new Request(n,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),v=this.mimeType,c=this.responseType;fetch(i).then((function(e){if(200===e.status||0===e.status){if(0===e.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),"undefined"===typeof ReadableStream||void 0===e.body||void 0===e.body.getReader)return e;var t=nf[n],o=e.body.getReader(),r=e.headers.get("Content-Length"),a=r?parseInt(r):0,i=0!==a,v=0,c=new ReadableStream({start:function(n){!function e(){o.read().then((function(o){var r=o.done,c=o.value;if(r)n.close();else{v+=c.byteLength;for(var s=new ProgressEvent("progress",{lengthComputable:i,loaded:v,total:a}),l=0,u=t.length;l<u;l++){var f=t[l];f.onProgress&&f.onProgress(s)}n.enqueue(c),e()}}))}()}});return new Response(c)}throw new ef('fetch for "'.concat(e.url,'" responded with ').concat(e.status,": ").concat(e.statusText),e)})).then((function(n){switch(c){case"arraybuffer":return n.arrayBuffer();case"blob":return n.blob();case"document":return n.text().then((function(n){return(new DOMParser).parseFromString(n,v)}));case"json":return n.json();default:if(void 0===v)return n.text();var e=/charset="?([^;"\s]*)"?/i.exec(v),t=e&&e[1]?e[1].toLowerCase():void 0,o=new TextDecoder(t);return n.arrayBuffer().then((function(n){return o.decode(n)}))}})).then((function(e){Qu.add(n,e);var t=nf[n];delete nf[n];for(var o=0,r=t.length;o<r;o++){var a=t[o];a.onLoad&&a.onLoad(e)}})).catch((function(e){var t=nf[n];if(void 0===t)throw r.manager.itemError(n),e;delete nf[n];for(var o=0,a=t.length;o<a;o++){var i=t[o];i.onError&&i.onError(e)}r.manager.itemError(n)})).finally((function(){r.manager.itemEnd(n)})),this.manager.itemStart(n)}else nf[n].push({onLoad:e,onProgress:t,onError:o})}},{key:"setResponseType",value:function(n){return this.responseType=n,this}},{key:"setMimeType",value:function(n){return this.mimeType=n,this}}]),t}($u),of=function(n){U(t,n);var e=k(t);function t(n){return g(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=this,a=new tf(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(n,(function(t){try{e(r.parse(JSON.parse(t)))}catch(a){o?o(a):console.error(a),r.manager.itemError(n)}}),t,o)}},{key:"parse",value:function(n){for(var e=[],t=0;t<n.length;t++){var o=Xu.parse(n[t]);e.push(o)}return e}}]),t}($u),rf=function(n){U(t,n);var e=k(t);function t(n){return g(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=this,a=[],i=new Ws,v=new tf(this.manager);v.setPath(this.path),v.setResponseType("arraybuffer"),v.setRequestHeader(this.requestHeader),v.setWithCredentials(r.withCredentials);var c=0;function s(s){v.load(n[s],(function(n){var t=r.parse(n,!0);a[s]={width:t.width,height:t.height,format:t.format,mipmaps:t.mipmaps},6===(c+=1)&&(1===t.mipmapCount&&(i.minFilter=Xn),i.image=a,i.format=t.format,i.needsUpdate=!0,e&&e(i))}),t,o)}if(Array.isArray(n))for(var l=0,u=n.length;l<u;++l)s(l);else v.load(n,(function(n){var t=r.parse(n,!0);if(t.isCubemap){for(var o=t.mipmaps.length/t.mipmapCount,v=0;v<o;v++){a[v]={mipmaps:[]};for(var c=0;c<t.mipmapCount;c++)a[v].mipmaps.push(t.mipmaps[v*t.mipmapCount+c]),a[v].format=t.format,a[v].width=t.width,a[v].height=t.height}i.image=a}else i.image.width=t.width,i.image.height=t.height,i.mipmaps=t.mipmaps;1===t.mipmapCount&&(i.minFilter=Xn),i.format=t.format,i.needsUpdate=!0,e&&e(i)}),t,o);return i}}]),t}($u),af=function(n){U(t,n);var e=k(t);function t(n){return g(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){void 0!==this.path&&(n=this.path+n),n=this.manager.resolveURL(n);var r=this,a=Qu.get(n);if(void 0!==a)return r.manager.itemStart(n),setTimeout((function(){e&&e(a),r.manager.itemEnd(n)}),0),a;var i=lo("img");function v(){s(),Qu.add(n,this),e&&e(this),r.manager.itemEnd(n)}function c(e){s(),o&&o(e),r.manager.itemError(n),r.manager.itemEnd(n)}function s(){i.removeEventListener("load",v,!1),i.removeEventListener("error",c,!1)}return i.addEventListener("load",v,!1),i.addEventListener("error",c,!1),"data:"!==n.slice(0,5)&&void 0!==this.crossOrigin&&(i.crossOrigin=this.crossOrigin),r.manager.itemStart(n),i.src=n,i}}]),t}($u),vf=function(n){U(t,n);var e=k(t);function t(n){return g(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=new Ya,a=new af(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);var i=0;function v(t){a.load(n[t],(function(n){r.images[t]=n,6===++i&&(r.needsUpdate=!0,e&&e(r))}),void 0,o)}for(var c=0;c<n.length;++c)v(c);return r}}]),t}($u),cf=function(n){U(t,n);var e=k(t);function t(n){return g(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=this,a=new ms,i=new tf(this.manager);return i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setPath(this.path),i.setWithCredentials(r.withCredentials),i.load(n,(function(n){var t=r.parse(n);t&&(void 0!==t.image?a.image=t.image:void 0!==t.data&&(a.image.width=t.width,a.image.height=t.height,a.image.data=t.data),a.wrapS=void 0!==t.wrapS?t.wrapS:Gn,a.wrapT=void 0!==t.wrapT?t.wrapT:Gn,a.magFilter=void 0!==t.magFilter?t.magFilter:Xn,a.minFilter=void 0!==t.minFilter?t.minFilter:Xn,a.anisotropy=void 0!==t.anisotropy?t.anisotropy:1,void 0!==t.encoding&&(a.encoding=t.encoding),void 0!==t.flipY&&(a.flipY=t.flipY),void 0!==t.format&&(a.format=t.format),void 0!==t.type&&(a.type=t.type),void 0!==t.mipmaps&&(a.mipmaps=t.mipmaps,a.minFilter=Qn),1===t.mipmapCount&&(a.minFilter=Xn),void 0!==t.generateMipmaps&&(a.generateMipmaps=t.generateMipmaps),a.needsUpdate=!0,e&&e(a,t))}),t,o),a}}]),t}($u),sf=function(n){U(t,n);var e=k(t);function t(n){return g(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=new Co,a=new af(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(n,(function(n){r.image=n,r.needsUpdate=!0,void 0!==e&&e(r)}),t,o),r}}]),t}($u),lf=function(n){U(t,n);var e=k(t);function t(n){var o,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return g(this,t),(o=e.call(this)).isLight=!0,o.type="Light",o.color=new wo(n),o.intensity=r,o}return b(t,[{key:"dispose",value:function(){}},{key:"copy",value:function(n,e){return D(_(t.prototype),"copy",this).call(this,n,e),this.color.copy(n.color),this.intensity=n.intensity,this}},{key:"toJSON",value:function(n){var e=D(_(t.prototype),"toJSON",this).call(this,n);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,void 0!==this.groundColor&&(e.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(e.object.distance=this.distance),void 0!==this.angle&&(e.object.angle=this.angle),void 0!==this.decay&&(e.object.decay=this.decay),void 0!==this.penumbra&&(e.object.penumbra=this.penumbra),void 0!==this.shadow&&(e.object.shadow=this.shadow.toJSON()),e}}]),t}(Ar),uf=function(n){U(t,n);var e=k(t);function t(n,o,r){var a;return g(this,t),(a=e.call(this,n,r)).isHemisphereLight=!0,a.type="HemisphereLight",a.position.copy(Ar.DefaultUp),a.updateMatrix(),a.groundColor=new wo(o),a}return b(t,[{key:"copy",value:function(n,e){return D(_(t.prototype),"copy",this).call(this,n,e),this.groundColor.copy(n.groundColor),this}}]),t}(lf),ff=new pr,pf=new Oo,mf=new Oo,df=function(){function n(e){g(this,n),this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new ao(512,512),this.map=null,this.mapPass=null,this.matrix=new pr,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new ti,this._frameExtents=new ao(1,1),this._viewportCount=1,this._viewports=[new To(0,0,1,1)]}return b(n,[{key:"getViewportCount",value:function(){return this._viewportCount}},{key:"getFrustum",value:function(){return this._frustum}},{key:"updateMatrices",value:function(n){var e=this.camera,t=this.matrix;pf.setFromMatrixPosition(n.matrixWorld),e.position.copy(pf),mf.setFromMatrixPosition(n.target.matrixWorld),e.lookAt(mf),e.updateMatrixWorld(),ff.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(ff),t.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),t.multiply(ff)}},{key:"getViewport",value:function(n){return this._viewports[n]}},{key:"getFrameExtents",value:function(){return this._frameExtents}},{key:"dispose",value:function(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}},{key:"copy",value:function(n){return this.camera=n.camera.clone(),this.bias=n.bias,this.radius=n.radius,this.mapSize.copy(n.mapSize),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"toJSON",value:function(){var n={};return 0!==this.bias&&(n.bias=this.bias),0!==this.normalBias&&(n.normalBias=this.normalBias),1!==this.radius&&(n.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(n.mapSize=this.mapSize.toArray()),n.camera=this.camera.toJSON(!1).object,delete n.camera.matrix,n}}]),n}(),hf=function(n){U(t,n);var e=k(t);function t(){var n;return g(this,t),(n=e.call(this,new Wa(50,1,.5,500))).isSpotLightShadow=!0,n.focus=1,n}return b(t,[{key:"updateMatrices",value:function(n){var e=this.camera,o=2*Yt*n.angle*this.focus,r=this.mapSize.width/this.mapSize.height,a=n.distance||e.far;o===e.fov&&r===e.aspect&&a===e.far||(e.fov=o,e.aspect=r,e.far=a,e.updateProjectionMatrix()),D(_(t.prototype),"updateMatrices",this).call(this,n)}},{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.focus=n.focus,this}}]),t}(df),xf=function(n){U(t,n);var e=k(t);function t(n,o){var r,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Math.PI/3,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;return g(this,t),(r=e.call(this,n,o)).isSpotLight=!0,r.type="SpotLight",r.position.copy(Ar.DefaultUp),r.updateMatrix(),r.target=new Ar,r.distance=a,r.angle=i,r.penumbra=v,r.decay=c,r.map=null,r.shadow=new hf,r}return b(t,[{key:"power",get:function(){return this.intensity*Math.PI},set:function(n){this.intensity=n/Math.PI}},{key:"dispose",value:function(){this.shadow.dispose()}},{key:"copy",value:function(n,e){return D(_(t.prototype),"copy",this).call(this,n,e),this.distance=n.distance,this.angle=n.angle,this.penumbra=n.penumbra,this.decay=n.decay,this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}}]),t}(lf),gf=new pr,yf=new Oo,bf=new Oo,Uf=function(n){U(t,n);var e=k(t);function t(){var n;return g(this,t),(n=e.call(this,new Wa(90,1,.5,500))).isPointLightShadow=!0,n._frameExtents=new ao(4,2),n._viewportCount=6,n._viewports=[new To(2,1,1,1),new To(0,1,1,1),new To(3,1,1,1),new To(1,1,1,1),new To(3,0,1,1),new To(1,0,1,1)],n._cubeDirections=[new Oo(1,0,0),new Oo(-1,0,0),new Oo(0,0,1),new Oo(0,0,-1),new Oo(0,1,0),new Oo(0,-1,0)],n._cubeUps=[new Oo(0,1,0),new Oo(0,1,0),new Oo(0,1,0),new Oo(0,1,0),new Oo(0,0,1),new Oo(0,0,-1)],n}return b(t,[{key:"updateMatrices",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=this.camera,o=this.matrix,r=n.distance||t.far;r!==t.far&&(t.far=r,t.updateProjectionMatrix()),yf.setFromMatrixPosition(n.matrixWorld),t.position.copy(yf),bf.copy(t.position),bf.add(this._cubeDirections[e]),t.up.copy(this._cubeUps[e]),t.lookAt(bf),t.updateMatrixWorld(),o.makeTranslation(-yf.x,-yf.y,-yf.z),gf.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(gf)}}]),t}(df),_f=function(n){U(t,n);var e=k(t);function t(n,o){var r,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;return g(this,t),(r=e.call(this,n,o)).isPointLight=!0,r.type="PointLight",r.distance=a,r.decay=i,r.shadow=new Uf,r}return b(t,[{key:"power",get:function(){return 4*this.intensity*Math.PI},set:function(n){this.intensity=n/(4*Math.PI)}},{key:"dispose",value:function(){this.shadow.dispose()}},{key:"copy",value:function(n,e){return D(_(t.prototype),"copy",this).call(this,n,e),this.distance=n.distance,this.decay=n.decay,this.shadow=n.shadow.clone(),this}}]),t}(lf),wf=function(n){U(t,n);var e=k(t);function t(){var n;return g(this,t),(n=e.call(this,new di(-5,5,5,-5,.5,500))).isDirectionalLightShadow=!0,n}return b(t)}(df),Sf=function(n){U(t,n);var e=k(t);function t(n,o){var r;return g(this,t),(r=e.call(this,n,o)).isDirectionalLight=!0,r.type="DirectionalLight",r.position.copy(Ar.DefaultUp),r.updateMatrix(),r.target=new Ar,r.shadow=new wf,r}return b(t,[{key:"dispose",value:function(){this.shadow.dispose()}},{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.target=n.target.clone(),this.shadow=n.shadow.clone(),this}}]),t}(lf),Mf=function(n){U(t,n);var e=k(t);function t(n,o){var r;return g(this,t),(r=e.call(this,n,o)).isAmbientLight=!0,r.type="AmbientLight",r}return b(t)}(lf),kf=function(n){U(t,n);var e=k(t);function t(n,o){var r,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:10,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:10;return g(this,t),(r=e.call(this,n,o)).isRectAreaLight=!0,r.type="RectAreaLight",r.width=a,r.height=i,r}return b(t,[{key:"power",get:function(){return this.intensity*this.width*this.height*Math.PI},set:function(n){this.intensity=n/(this.width*this.height*Math.PI)}},{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.width=n.width,this.height=n.height,this}},{key:"toJSON",value:function(n){var e=D(_(t.prototype),"toJSON",this).call(this,n);return e.object.width=this.width,e.object.height=this.height,e}}]),t}(lf),zf=function(){function n(){g(this,n),this.isSphericalHarmonics3=!0,this.coefficients=[];for(var e=0;e<9;e++)this.coefficients.push(new Oo)}return b(n,[{key:"set",value:function(n){for(var e=0;e<9;e++)this.coefficients[e].copy(n[e]);return this}},{key:"zero",value:function(){for(var n=0;n<9;n++)this.coefficients[n].set(0,0,0);return this}},{key:"getAt",value:function(n,e){var t=n.x,o=n.y,r=n.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.282095),e.addScaledVector(a[1],.488603*o),e.addScaledVector(a[2],.488603*r),e.addScaledVector(a[3],.488603*t),e.addScaledVector(a[4],t*o*1.092548),e.addScaledVector(a[5],o*r*1.092548),e.addScaledVector(a[6],.315392*(3*r*r-1)),e.addScaledVector(a[7],t*r*1.092548),e.addScaledVector(a[8],.546274*(t*t-o*o)),e}},{key:"getIrradianceAt",value:function(n,e){var t=n.x,o=n.y,r=n.z,a=this.coefficients;return e.copy(a[0]).multiplyScalar(.886227),e.addScaledVector(a[1],1.023328*o),e.addScaledVector(a[2],1.023328*r),e.addScaledVector(a[3],1.023328*t),e.addScaledVector(a[4],.858086*t*o),e.addScaledVector(a[5],.858086*o*r),e.addScaledVector(a[6],.743125*r*r-.247708),e.addScaledVector(a[7],.858086*t*r),e.addScaledVector(a[8],.429043*(t*t-o*o)),e}},{key:"add",value:function(n){for(var e=0;e<9;e++)this.coefficients[e].add(n.coefficients[e]);return this}},{key:"addScaledSH",value:function(n,e){for(var t=0;t<9;t++)this.coefficients[t].addScaledVector(n.coefficients[t],e);return this}},{key:"scale",value:function(n){for(var e=0;e<9;e++)this.coefficients[e].multiplyScalar(n);return this}},{key:"lerp",value:function(n,e){for(var t=0;t<9;t++)this.coefficients[t].lerp(n.coefficients[t],e);return this}},{key:"equals",value:function(n){for(var e=0;e<9;e++)if(!this.coefficients[e].equals(n.coefficients[e]))return!1;return!0}},{key:"copy",value:function(n){return this.set(n.coefficients)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"fromArray",value:function(n){for(var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=this.coefficients,o=0;o<9;o++)t[o].fromArray(n,e+3*o);return this}},{key:"toArray",value:function(){for(var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=this.coefficients,o=0;o<9;o++)t[o].toArray(n,e+3*o);return n}}],[{key:"getBasisAt",value:function(n,e){var t=n.x,o=n.y,r=n.z;e[0]=.282095,e[1]=.488603*o,e[2]=.488603*r,e[3]=.488603*t,e[4]=1.092548*t*o,e[5]=1.092548*o*r,e[6]=.315392*(3*r*r-1),e[7]=1.092548*t*r,e[8]=.546274*(t*t-o*o)}}]),n}(),Cf=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new zf,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return g(this,t),(n=e.call(this,void 0,r)).isLightProbe=!0,n.sh=o,n}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.sh.copy(n.sh),this}},{key:"fromJSON",value:function(n){return this.intensity=n.intensity,this.sh.fromArray(n.sh),this}},{key:"toJSON",value:function(n){var e=D(_(t.prototype),"toJSON",this).call(this,n);return e.object.sh=this.sh.toArray(),e}}]),t}(lf),Tf=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this,n)).textures={},o}return b(t,[{key:"load",value:function(n,e,t,o){var r=this,a=new tf(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(n,(function(t){try{e(r.parse(JSON.parse(t)))}catch(a){o?o(a):console.error(a),r.manager.itemError(n)}}),t,o)}},{key:"parse",value:function(n){var e=this.textures;function o(n){return void 0===e[n]&&console.warn("THREE.MaterialLoader: Undefined texture",n),e[n]}var r=t.createMaterialFromType(n.type);if(void 0!==n.uuid&&(r.uuid=n.uuid),void 0!==n.name&&(r.name=n.name),void 0!==n.color&&void 0!==r.color&&r.color.setHex(n.color),void 0!==n.roughness&&(r.roughness=n.roughness),void 0!==n.metalness&&(r.metalness=n.metalness),void 0!==n.sheen&&(r.sheen=n.sheen),void 0!==n.sheenColor&&(r.sheenColor=(new wo).setHex(n.sheenColor)),void 0!==n.sheenRoughness&&(r.sheenRoughness=n.sheenRoughness),void 0!==n.emissive&&void 0!==r.emissive&&r.emissive.setHex(n.emissive),void 0!==n.specular&&void 0!==r.specular&&r.specular.setHex(n.specular),void 0!==n.specularIntensity&&(r.specularIntensity=n.specularIntensity),void 0!==n.specularColor&&void 0!==r.specularColor&&r.specularColor.setHex(n.specularColor),void 0!==n.shininess&&(r.shininess=n.shininess),void 0!==n.clearcoat&&(r.clearcoat=n.clearcoat),void 0!==n.clearcoatRoughness&&(r.clearcoatRoughness=n.clearcoatRoughness),void 0!==n.iridescence&&(r.iridescence=n.iridescence),void 0!==n.iridescenceIOR&&(r.iridescenceIOR=n.iridescenceIOR),void 0!==n.iridescenceThicknessRange&&(r.iridescenceThicknessRange=n.iridescenceThicknessRange),void 0!==n.transmission&&(r.transmission=n.transmission),void 0!==n.thickness&&(r.thickness=n.thickness),void 0!==n.attenuationDistance&&(r.attenuationDistance=n.attenuationDistance),void 0!==n.attenuationColor&&void 0!==r.attenuationColor&&r.attenuationColor.setHex(n.attenuationColor),void 0!==n.fog&&(r.fog=n.fog),void 0!==n.flatShading&&(r.flatShading=n.flatShading),void 0!==n.blending&&(r.blending=n.blending),void 0!==n.combine&&(r.combine=n.combine),void 0!==n.side&&(r.side=n.side),void 0!==n.shadowSide&&(r.shadowSide=n.shadowSide),void 0!==n.opacity&&(r.opacity=n.opacity),void 0!==n.transparent&&(r.transparent=n.transparent),void 0!==n.alphaTest&&(r.alphaTest=n.alphaTest),void 0!==n.depthTest&&(r.depthTest=n.depthTest),void 0!==n.depthWrite&&(r.depthWrite=n.depthWrite),void 0!==n.colorWrite&&(r.colorWrite=n.colorWrite),void 0!==n.stencilWrite&&(r.stencilWrite=n.stencilWrite),void 0!==n.stencilWriteMask&&(r.stencilWriteMask=n.stencilWriteMask),void 0!==n.stencilFunc&&(r.stencilFunc=n.stencilFunc),void 0!==n.stencilRef&&(r.stencilRef=n.stencilRef),void 0!==n.stencilFuncMask&&(r.stencilFuncMask=n.stencilFuncMask),void 0!==n.stencilFail&&(r.stencilFail=n.stencilFail),void 0!==n.stencilZFail&&(r.stencilZFail=n.stencilZFail),void 0!==n.stencilZPass&&(r.stencilZPass=n.stencilZPass),void 0!==n.wireframe&&(r.wireframe=n.wireframe),void 0!==n.wireframeLinewidth&&(r.wireframeLinewidth=n.wireframeLinewidth),void 0!==n.wireframeLinecap&&(r.wireframeLinecap=n.wireframeLinecap),void 0!==n.wireframeLinejoin&&(r.wireframeLinejoin=n.wireframeLinejoin),void 0!==n.rotation&&(r.rotation=n.rotation),1!==n.linewidth&&(r.linewidth=n.linewidth),void 0!==n.dashSize&&(r.dashSize=n.dashSize),void 0!==n.gapSize&&(r.gapSize=n.gapSize),void 0!==n.scale&&(r.scale=n.scale),void 0!==n.polygonOffset&&(r.polygonOffset=n.polygonOffset),void 0!==n.polygonOffsetFactor&&(r.polygonOffsetFactor=n.polygonOffsetFactor),void 0!==n.polygonOffsetUnits&&(r.polygonOffsetUnits=n.polygonOffsetUnits),void 0!==n.dithering&&(r.dithering=n.dithering),void 0!==n.alphaToCoverage&&(r.alphaToCoverage=n.alphaToCoverage),void 0!==n.premultipliedAlpha&&(r.premultipliedAlpha=n.premultipliedAlpha),void 0!==n.visible&&(r.visible=n.visible),void 0!==n.toneMapped&&(r.toneMapped=n.toneMapped),void 0!==n.userData&&(r.userData=n.userData),void 0!==n.vertexColors&&("number"===typeof n.vertexColors?r.vertexColors=n.vertexColors>0:r.vertexColors=n.vertexColors),void 0!==n.uniforms)for(var a in n.uniforms){var i=n.uniforms[a];switch(r.uniforms[a]={},i.type){case"t":r.uniforms[a].value=o(i.value);break;case"c":r.uniforms[a].value=(new wo).setHex(i.value);break;case"v2":r.uniforms[a].value=(new ao).fromArray(i.value);break;case"v3":r.uniforms[a].value=(new Oo).fromArray(i.value);break;case"v4":r.uniforms[a].value=(new To).fromArray(i.value);break;case"m3":r.uniforms[a].value=(new io).fromArray(i.value);break;case"m4":r.uniforms[a].value=(new pr).fromArray(i.value);break;default:r.uniforms[a].value=i.value}}if(void 0!==n.defines&&(r.defines=n.defines),void 0!==n.vertexShader&&(r.vertexShader=n.vertexShader),void 0!==n.fragmentShader&&(r.fragmentShader=n.fragmentShader),void 0!==n.glslVersion&&(r.glslVersion=n.glslVersion),void 0!==n.extensions)for(var v in n.extensions)r.extensions[v]=n.extensions[v];if(void 0!==n.size&&(r.size=n.size),void 0!==n.sizeAttenuation&&(r.sizeAttenuation=n.sizeAttenuation),void 0!==n.map&&(r.map=o(n.map)),void 0!==n.matcap&&(r.matcap=o(n.matcap)),void 0!==n.alphaMap&&(r.alphaMap=o(n.alphaMap)),void 0!==n.bumpMap&&(r.bumpMap=o(n.bumpMap)),void 0!==n.bumpScale&&(r.bumpScale=n.bumpScale),void 0!==n.normalMap&&(r.normalMap=o(n.normalMap)),void 0!==n.normalMapType&&(r.normalMapType=n.normalMapType),void 0!==n.normalScale){var c=n.normalScale;!1===Array.isArray(c)&&(c=[c,c]),r.normalScale=(new ao).fromArray(c)}return void 0!==n.displacementMap&&(r.displacementMap=o(n.displacementMap)),void 0!==n.displacementScale&&(r.displacementScale=n.displacementScale),void 0!==n.displacementBias&&(r.displacementBias=n.displacementBias),void 0!==n.roughnessMap&&(r.roughnessMap=o(n.roughnessMap)),void 0!==n.metalnessMap&&(r.metalnessMap=o(n.metalnessMap)),void 0!==n.emissiveMap&&(r.emissiveMap=o(n.emissiveMap)),void 0!==n.emissiveIntensity&&(r.emissiveIntensity=n.emissiveIntensity),void 0!==n.specularMap&&(r.specularMap=o(n.specularMap)),void 0!==n.specularIntensityMap&&(r.specularIntensityMap=o(n.specularIntensityMap)),void 0!==n.specularColorMap&&(r.specularColorMap=o(n.specularColorMap)),void 0!==n.envMap&&(r.envMap=o(n.envMap)),void 0!==n.envMapIntensity&&(r.envMapIntensity=n.envMapIntensity),void 0!==n.reflectivity&&(r.reflectivity=n.reflectivity),void 0!==n.refractionRatio&&(r.refractionRatio=n.refractionRatio),void 0!==n.lightMap&&(r.lightMap=o(n.lightMap)),void 0!==n.lightMapIntensity&&(r.lightMapIntensity=n.lightMapIntensity),void 0!==n.aoMap&&(r.aoMap=o(n.aoMap)),void 0!==n.aoMapIntensity&&(r.aoMapIntensity=n.aoMapIntensity),void 0!==n.gradientMap&&(r.gradientMap=o(n.gradientMap)),void 0!==n.clearcoatMap&&(r.clearcoatMap=o(n.clearcoatMap)),void 0!==n.clearcoatRoughnessMap&&(r.clearcoatRoughnessMap=o(n.clearcoatRoughnessMap)),void 0!==n.clearcoatNormalMap&&(r.clearcoatNormalMap=o(n.clearcoatNormalMap)),void 0!==n.clearcoatNormalScale&&(r.clearcoatNormalScale=(new ao).fromArray(n.clearcoatNormalScale)),void 0!==n.iridescenceMap&&(r.iridescenceMap=o(n.iridescenceMap)),void 0!==n.iridescenceThicknessMap&&(r.iridescenceThicknessMap=o(n.iridescenceThicknessMap)),void 0!==n.transmissionMap&&(r.transmissionMap=o(n.transmissionMap)),void 0!==n.thicknessMap&&(r.thicknessMap=o(n.thicknessMap)),void 0!==n.sheenColorMap&&(r.sheenColorMap=o(n.sheenColorMap)),void 0!==n.sheenRoughnessMap&&(r.sheenRoughnessMap=o(n.sheenRoughnessMap)),r}},{key:"setTextures",value:function(n){return this.textures=n,this}}],[{key:"createMaterialFromType",value:function(n){return new{ShadowMaterial:gu,SpriteMaterial:qc,RawShaderMaterial:yu,ShaderMaterial:qa,PointsMaterial:Es,MeshPhysicalMaterial:Uu,MeshStandardMaterial:bu,MeshPhongMaterial:_u,MeshToonMaterial:wu,MeshNormalMaterial:Su,MeshLambertMaterial:Mu,MeshDepthMaterial:yc,MeshDistanceMaterial:bc,MeshBasicMaterial:Kr,MeshMatcapMaterial:ku,LineDashedMaterial:zu,LineBasicMaterial:Ms,Material:Jr}[n]}}]),t}($u),Rf=function(){function n(){g(this,n)}return b(n,null,[{key:"decodeText",value:function(n){if("undefined"!==typeof TextDecoder)return(new TextDecoder).decode(n);for(var e="",t=0,o=n.length;t<o;t++)e+=String.fromCharCode(n[t]);try{return decodeURIComponent(escape(e))}catch(r){return e}}},{key:"extractUrlBase",value:function(n){var e=n.lastIndexOf("/");return-1===e?"./":n.slice(0,e+1)}},{key:"resolveURL",value:function(n,e){return"string"!==typeof n||""===n?"":(/^https?:\/\//i.test(e)&&/^\//.test(n)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(n)||/^data:.*,.*$/i.test(n)||/^blob:.*$/i.test(n)?n:e+n)}}]),n}(),Df=function(n){U(t,n);var e=k(t);function t(){var n;return g(this,t),(n=e.call(this)).isInstancedBufferGeometry=!0,n.type="InstancedBufferGeometry",n.instanceCount=1/0,n}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.instanceCount=n.instanceCount,this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"toJSON",value:function(){var n=D(_(t.prototype),"toJSON",this).call(this,this);return n.instanceCount=this.instanceCount,n.isInstancedBufferGeometry=!0,n}}]),t}(ya),Pf=function(n){U(t,n);var e=k(t);function t(n){return g(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=this,a=new tf(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(n,(function(t){try{e(r.parse(JSON.parse(t)))}catch(a){o?o(a):console.error(a),r.manager.itemError(n)}}),t,o)}},{key:"parse",value:function(n){var e={},t={};function o(n,o){if(void 0!==e[o])return e[o];var r=n.interleavedBuffers[o],a=function(n,e){if(void 0!==t[e])return t[e];var o=n.arrayBuffers[e],r=new Uint32Array(o).buffer;return t[e]=r,r}(n,r.buffer),i=so(r.type,a),v=new Gc(i,r.stride);return v.uuid=r.uuid,e[o]=v,v}var r=n.isInstancedBufferGeometry?new Df:new ya,a=n.data.index;if(void 0!==a){var i=so(a.type,a.array);r.setIndex(new ea(i,1))}var v=n.data.attributes;for(var c in v){var s=v[c],l=void 0;if(s.isInterleavedBufferAttribute){var u=o(n.data,s.data);l=new Bc(u,s.itemSize,s.offset,s.normalized)}else{var f=so(s.type,s.array);l=new(s.isInstancedBufferAttribute?gs:ea)(f,s.itemSize,s.normalized)}void 0!==s.name&&(l.name=s.name),void 0!==s.usage&&l.setUsage(s.usage),void 0!==s.updateRange&&(l.updateRange.offset=s.updateRange.offset,l.updateRange.count=s.updateRange.count),r.setAttribute(c,l)}var p=n.data.morphAttributes;if(p)for(var m in p){for(var d=p[m],h=[],x=0,g=d.length;x<g;x++){var y=d[x],b=void 0;if(y.isInterleavedBufferAttribute){var U=o(n.data,y.data);b=new Bc(U,y.itemSize,y.offset,y.normalized)}else{var _=so(y.type,y.array);b=new ea(_,y.itemSize,y.normalized)}void 0!==y.name&&(b.name=y.name),h.push(b)}r.morphAttributes[m]=h}n.data.morphTargetsRelative&&(r.morphTargetsRelative=!0);var w=n.data.groups||n.data.drawcalls||n.data.offsets;if(void 0!==w)for(var S=0,M=w.length;S!==M;++S){var k=w[S];r.addGroup(k.start,k.count,k.materialIndex)}var z=n.data.boundingSphere;if(void 0!==z){var C=new Oo;void 0!==z.center&&C.fromArray(z.center),r.boundingSphere=new rr(C,z.radius)}return n.name&&(r.name=n.name),n.userData&&(r.userData=n.userData),r}}]),t}($u),Ff=function(n){U(t,n);var e=k(t);function t(n){return g(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=this,a=""===this.path?Rf.extractUrlBase(n):this.path;this.resourcePath=this.resourcePath||a;var i=new tf(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(n,(function(t){var a=null;try{a=JSON.parse(t)}catch(v){return void 0!==o&&o(v),void console.error("THREE:ObjectLoader: Can't parse "+n+".",v.message)}var i=a.metadata;void 0!==i&&void 0!==i.type&&"geometry"!==i.type.toLowerCase()?r.parse(a,e):console.error("THREE.ObjectLoader: Can't load "+n)}),t,o)}},{key:"loadAsync",value:function(){var n=T(P().mark((function n(e,t){var o,r,a,i,v,c;return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return o=this,r=""===this.path?Rf.extractUrlBase(e):this.path,this.resourcePath=this.resourcePath||r,(a=new tf(this.manager)).setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),n.next=9,a.loadAsync(e,t);case 9:if(i=n.sent,v=JSON.parse(i),void 0!==(c=v.metadata)&&void 0!==c.type&&"geometry"!==c.type.toLowerCase()){n.next=14;break}throw new Error("THREE.ObjectLoader: Can't load "+e);case 14:return n.next=16,o.parseAsync(v);case 16:return n.abrupt("return",n.sent);case 17:case"end":return n.stop()}}),n,this)})));return function(e,t){return n.apply(this,arguments)}}()},{key:"parse",value:function(n,e){var t=this.parseAnimations(n.animations),o=this.parseShapes(n.shapes),r=this.parseGeometries(n.geometries,o),a=this.parseImages(n.images,(function(){void 0!==e&&e(c)})),i=this.parseTextures(n.textures,a),v=this.parseMaterials(n.materials,i),c=this.parseObject(n.object,r,v,i,t),s=this.parseSkeletons(n.skeletons,c);if(this.bindSkeletons(c,s),void 0!==e){var l=!1;for(var u in a)if(a[u].data instanceof HTMLImageElement){l=!0;break}!1===l&&e(c)}return c}},{key:"parseAsync",value:function(){var n=T(P().mark((function n(e){var t,o,r,a,i,v,c,s;return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t=this.parseAnimations(e.animations),o=this.parseShapes(e.shapes),r=this.parseGeometries(e.geometries,o),n.next=5,this.parseImagesAsync(e.images);case 5:return a=n.sent,i=this.parseTextures(e.textures,a),v=this.parseMaterials(e.materials,i),c=this.parseObject(e.object,r,v,i,t),s=this.parseSkeletons(e.skeletons,c),this.bindSkeletons(c,s),n.abrupt("return",c);case 12:case"end":return n.stop()}}),n,this)})));return function(e){return n.apply(this,arguments)}}()},{key:"parseShapes",value:function(n){var e={};if(void 0!==n)for(var t=0,o=n.length;t<o;t++){var r=(new Cl).fromJSON(n[t]);e[r.uuid]=r}return e}},{key:"parseSkeletons",value:function(n,e){var t={},o={};if(e.traverse((function(n){n.isBone&&(o[n.uuid]=n)})),void 0!==n)for(var r=0,a=n.length;r<a;r++){var i=(new xs).fromJSON(n[r],o);t[i.uuid]=i}return t}},{key:"parseGeometries",value:function(n,e){var t={};if(void 0!==n)for(var o=new Pf,r=0,a=n.length;r<a;r++){var i=void 0,v=n[r];switch(v.type){case"BufferGeometry":case"InstancedBufferGeometry":i=o.parse(v);break;default:v.type in xu?i=xu[v.type].fromJSON(v,e):console.warn('THREE.ObjectLoader: Unsupported geometry type "'.concat(v.type,'"'))}i.uuid=v.uuid,void 0!==v.name&&(i.name=v.name),!0===i.isBufferGeometry&&void 0!==v.userData&&(i.userData=v.userData),t[v.uuid]=i}return t}},{key:"parseMaterials",value:function(n,e){var t={},o={};if(void 0!==n){var r=new Tf;r.setTextures(e);for(var a=0,i=n.length;a<i;a++){var v=n[a];void 0===t[v.uuid]&&(t[v.uuid]=r.parse(v)),o[v.uuid]=t[v.uuid]}}return o}},{key:"parseAnimations",value:function(n){var e={};if(void 0!==n)for(var t=0;t<n.length;t++){var o=n[t],r=Xu.parse(o);e[r.uuid]=r}return e}},{key:"parseImages",value:function(n,e){var t,o=this,r={};function a(n){if("string"===typeof n){var e=n;return function(n){return o.manager.itemStart(n),t.load(n,(function(){o.manager.itemEnd(n)}),void 0,(function(){o.manager.itemError(n),o.manager.itemEnd(n)}))}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e)?e:o.resourcePath+e)}return n.data?{data:so(n.type,n.data),width:n.width,height:n.height}:null}if(void 0!==n&&n.length>0){var i=new Ju(e);(t=new af(i)).setCrossOrigin(this.crossOrigin);for(var v=0,c=n.length;v<c;v++){var s=n[v],l=s.url;if(Array.isArray(l)){for(var u=[],f=0,p=l.length;f<p;f++){var m=a(l[f]);null!==m&&(m instanceof HTMLImageElement?u.push(m):u.push(new ms(m.data,m.width,m.height)))}r[s.uuid]=new Mo(u)}else{var d=a(s.url);r[s.uuid]=new Mo(d)}}}return r}},{key:"parseImagesAsync",value:function(){var n=T(P().mark((function n(e){var t,o,r,a,i,v,c,s,l,u,f,p,m,d,h;return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(i=function(){return i=T(P().mark((function n(e){var o,a;return P().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if("string"!==typeof e){n.next=8;break}return a=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(o=e)?o:t.resourcePath+o,n.next=5,r.loadAsync(a);case 5:return n.abrupt("return",n.sent);case 8:if(!e.data){n.next=12;break}return n.abrupt("return",{data:so(e.type,e.data),width:e.width,height:e.height});case 12:return n.abrupt("return",null);case 13:case"end":return n.stop()}}),n)}))),i.apply(this,arguments)},a=function(n){return i.apply(this,arguments)},t=this,o={},!(void 0!==e&&e.length>0)){n.next=33;break}(r=new af(this.manager)).setCrossOrigin(this.crossOrigin),v=0,c=e.length;case 8:if(!(v<c)){n.next=33;break}if(s=e[v],l=s.url,!Array.isArray(l)){n.next=26;break}u=[],f=0,p=l.length;case 14:if(!(f<p)){n.next=23;break}return m=l[f],n.next=18,a(m);case 18:null!==(d=n.sent)&&(d instanceof HTMLImageElement?u.push(d):u.push(new ms(d.data,d.width,d.height)));case 20:f++,n.next=14;break;case 23:o[s.uuid]=new Mo(u),n.next=30;break;case 26:return n.next=28,a(s.url);case 28:h=n.sent,o[s.uuid]=new Mo(h);case 30:v++,n.next=8;break;case 33:return n.abrupt("return",o);case 34:case"end":return n.stop()}}),n,this)})));return function(e){return n.apply(this,arguments)}}()},{key:"parseTextures",value:function(n,e){function t(n,e){return"number"===typeof n?n:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",n),e[n])}var o={};if(void 0!==n)for(var r=0,a=n.length;r<a;r++){var i=n[r];void 0===i.image&&console.warn('THREE.ObjectLoader: No "image" specified for',i.uuid),void 0===e[i.image]&&console.warn("THREE.ObjectLoader: Undefined image",i.image);var v=e[i.image],c=v.data,s=void 0;Array.isArray(c)?(s=new Ya,6===c.length&&(s.needsUpdate=!0)):(s=c&&c.data?new ms:new Co,c&&(s.needsUpdate=!0)),s.source=v,s.uuid=i.uuid,void 0!==i.name&&(s.name=i.name),void 0!==i.mapping&&(s.mapping=t(i.mapping,jf)),void 0!==i.offset&&s.offset.fromArray(i.offset),void 0!==i.repeat&&s.repeat.fromArray(i.repeat),void 0!==i.center&&s.center.fromArray(i.center),void 0!==i.rotation&&(s.rotation=i.rotation),void 0!==i.wrap&&(s.wrapS=t(i.wrap[0],If),s.wrapT=t(i.wrap[1],If)),void 0!==i.format&&(s.format=i.format),void 0!==i.type&&(s.type=i.type),void 0!==i.encoding&&(s.encoding=i.encoding),void 0!==i.minFilter&&(s.minFilter=t(i.minFilter,Ef)),void 0!==i.magFilter&&(s.magFilter=t(i.magFilter,Ef)),void 0!==i.anisotropy&&(s.anisotropy=i.anisotropy),void 0!==i.flipY&&(s.flipY=i.flipY),void 0!==i.premultiplyAlpha&&(s.premultiplyAlpha=i.premultiplyAlpha),void 0!==i.unpackAlignment&&(s.unpackAlignment=i.unpackAlignment),void 0!==i.userData&&(s.userData=i.userData),o[i.uuid]=s}return o}},{key:"parseObject",value:function(n,e,t,o,r){var a,i,v;function c(n){return void 0===e[n]&&console.warn("THREE.ObjectLoader: Undefined geometry",n),e[n]}function s(n){if(void 0!==n){if(Array.isArray(n)){for(var e=[],o=0,r=n.length;o<r;o++){var a=n[o];void 0===t[a]&&console.warn("THREE.ObjectLoader: Undefined material",a),e.push(t[a])}return e}return void 0===t[n]&&console.warn("THREE.ObjectLoader: Undefined material",n),t[n]}}function l(n){return void 0===o[n]&&console.warn("THREE.ObjectLoader: Undefined texture",n),o[n]}switch(n.type){case"Scene":a=new Lc,void 0!==n.background&&(Number.isInteger(n.background)?a.background=new wo(n.background):a.background=l(n.background)),void 0!==n.environment&&(a.environment=l(n.environment)),void 0!==n.fog&&("Fog"===n.fog.type?a.fog=new Ac(n.fog.color,n.fog.near,n.fog.far):"FogExp2"===n.fog.type&&(a.fog=new Oc(n.fog.color,n.fog.density))),void 0!==n.backgroundBlurriness&&(a.backgroundBlurriness=n.backgroundBlurriness);break;case"PerspectiveCamera":a=new Wa(n.fov,n.aspect,n.near,n.far),void 0!==n.focus&&(a.focus=n.focus),void 0!==n.zoom&&(a.zoom=n.zoom),void 0!==n.filmGauge&&(a.filmGauge=n.filmGauge),void 0!==n.filmOffset&&(a.filmOffset=n.filmOffset),void 0!==n.view&&(a.view=Object.assign({},n.view));break;case"OrthographicCamera":a=new di(n.left,n.right,n.top,n.bottom,n.near,n.far),void 0!==n.zoom&&(a.zoom=n.zoom),void 0!==n.view&&(a.view=Object.assign({},n.view));break;case"AmbientLight":a=new Mf(n.color,n.intensity);break;case"DirectionalLight":a=new Sf(n.color,n.intensity);break;case"PointLight":a=new _f(n.color,n.intensity,n.distance,n.decay);break;case"RectAreaLight":a=new kf(n.color,n.intensity,n.width,n.height);break;case"SpotLight":a=new xf(n.color,n.intensity,n.distance,n.angle,n.penumbra,n.decay);break;case"HemisphereLight":a=new uf(n.color,n.groundColor,n.intensity);break;case"LightProbe":a=(new Cf).fromJSON(n);break;case"SkinnedMesh":i=c(n.geometry),v=s(n.material),a=new fs(i,v),void 0!==n.bindMode&&(a.bindMode=n.bindMode),void 0!==n.bindMatrix&&a.bindMatrix.fromArray(n.bindMatrix),void 0!==n.skeleton&&(a.skeleton=n.skeleton);break;case"Mesh":i=c(n.geometry),v=s(n.material),a=new Oa(i,v);break;case"InstancedMesh":i=c(n.geometry),v=s(n.material);var u=n.count,f=n.instanceMatrix,p=n.instanceColor;(a=new Ss(i,v,u)).instanceMatrix=new gs(new Float32Array(f.array),16),void 0!==p&&(a.instanceColor=new gs(new Float32Array(p.array),p.itemSize));break;case"LOD":a=new is;break;case"Line":a=new Ds(c(n.geometry),s(n.material));break;case"LineLoop":a=new Is(c(n.geometry),s(n.material));break;case"LineSegments":a=new js(c(n.geometry),s(n.material));break;case"PointCloud":case"Points":a=new Ns(c(n.geometry),s(n.material));break;case"Sprite":a=new ts(s(n.material));break;case"Group":a=new kc;break;case"Bone":a=new ps;break;default:a=new Ar}if(a.uuid=n.uuid,void 0!==n.name&&(a.name=n.name),void 0!==n.matrix?(a.matrix.fromArray(n.matrix),void 0!==n.matrixAutoUpdate&&(a.matrixAutoUpdate=n.matrixAutoUpdate),a.matrixAutoUpdate&&a.matrix.decompose(a.position,a.quaternion,a.scale)):(void 0!==n.position&&a.position.fromArray(n.position),void 0!==n.rotation&&a.rotation.fromArray(n.rotation),void 0!==n.quaternion&&a.quaternion.fromArray(n.quaternion),void 0!==n.scale&&a.scale.fromArray(n.scale)),void 0!==n.castShadow&&(a.castShadow=n.castShadow),void 0!==n.receiveShadow&&(a.receiveShadow=n.receiveShadow),n.shadow&&(void 0!==n.shadow.bias&&(a.shadow.bias=n.shadow.bias),void 0!==n.shadow.normalBias&&(a.shadow.normalBias=n.shadow.normalBias),void 0!==n.shadow.radius&&(a.shadow.radius=n.shadow.radius),void 0!==n.shadow.mapSize&&a.shadow.mapSize.fromArray(n.shadow.mapSize),void 0!==n.shadow.camera&&(a.shadow.camera=this.parseObject(n.shadow.camera))),void 0!==n.visible&&(a.visible=n.visible),void 0!==n.frustumCulled&&(a.frustumCulled=n.frustumCulled),void 0!==n.renderOrder&&(a.renderOrder=n.renderOrder),void 0!==n.userData&&(a.userData=n.userData),void 0!==n.layers&&(a.layers.mask=n.layers),void 0!==n.children)for(var m=n.children,d=0;d<m.length;d++)a.add(this.parseObject(m[d],e,t,o,r));if(void 0!==n.animations)for(var h=n.animations,x=0;x<h.length;x++){var g=h[x];a.animations.push(r[g])}if("LOD"===n.type){void 0!==n.autoUpdate&&(a.autoUpdate=n.autoUpdate);for(var y=n.levels,b=0;b<y.length;b++){var U=y[b],_=a.getObjectByProperty("uuid",U.object);void 0!==_&&a.addLevel(_,U.distance)}}return a}},{key:"bindSkeletons",value:function(n,e){0!==Object.keys(e).length&&n.traverse((function(n){if(!0===n.isSkinnedMesh&&void 0!==n.skeleton){var t=e[n.skeleton];void 0===t?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",n.skeleton):n.bind(t,n.bindMatrix)}}))}}]),t}($u),jf={UVMapping:Fn,CubeReflectionMapping:jn,CubeRefractionMapping:In,EquirectangularReflectionMapping:En,EquirectangularRefractionMapping:On,CubeUVReflectionMapping:An},If={RepeatWrapping:Ln,ClampToEdgeWrapping:Gn,MirroredRepeatWrapping:Nn},Ef={NearestFilter:Bn,NearestMipmapNearestFilter:qn,NearestMipmapLinearFilter:Wn,LinearFilter:Xn,LinearMipmapNearestFilter:Yn,LinearMipmapLinearFilter:Qn},Of=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this,n)).isImageBitmapLoader=!0,"undefined"===typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"===typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),o.options={premultiplyAlpha:"none"},o}return b(t,[{key:"setOptions",value:function(n){return this.options=n,this}},{key:"load",value:function(n,e,t,o){void 0===n&&(n=""),void 0!==this.path&&(n=this.path+n),n=this.manager.resolveURL(n);var r=this,a=Qu.get(n);if(void 0!==a)return r.manager.itemStart(n),setTimeout((function(){e&&e(a),r.manager.itemEnd(n)}),0),a;var i={};i.credentials="anonymous"===this.crossOrigin?"same-origin":"include",i.headers=this.requestHeader,fetch(n,i).then((function(n){return n.blob()})).then((function(n){return createImageBitmap(n,Object.assign(r.options,{colorSpaceConversion:"none"}))})).then((function(t){Qu.add(n,t),e&&e(t),r.manager.itemEnd(n)})).catch((function(e){o&&o(e),r.manager.itemError(n),r.manager.itemEnd(n)})),r.manager.itemStart(n)}}]),t}($u),Af=function(){function n(){g(this,n)}return b(n,null,[{key:"getContext",value:function(){return void 0===Zu&&(Zu=new(window.AudioContext||window.webkitAudioContext)),Zu}},{key:"setContext",value:function(n){Zu=n}}]),n}(),Lf=function(n){U(t,n);var e=k(t);function t(n){return g(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=this,a=new tf(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(n,(function(t){try{var a=t.slice(0);Af.getContext().decodeAudioData(a,(function(n){e(n)}))}catch(i){o?o(i):console.error(i),r.manager.itemError(n)}}),t,o)}}]),t}($u),Gf=function(n){U(t,n);var e=k(t);function t(n,o){var r,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;g(this,t),(r=e.call(this,void 0,a)).isHemisphereLightProbe=!0;var i=(new wo).set(n),v=(new wo).set(o),c=new Oo(i.r,i.g,i.b),s=new Oo(v.r,v.g,v.b),l=Math.sqrt(Math.PI),u=l*Math.sqrt(.75);return r.sh.coefficients[0].copy(c).add(s).multiplyScalar(l),r.sh.coefficients[1].copy(c).sub(s).multiplyScalar(u),r}return b(t)}(Cf),Nf=function(n){U(t,n);var e=k(t);function t(n){var o,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;g(this,t),(o=e.call(this,void 0,r)).isAmbientLightProbe=!0;var a=(new wo).set(n);return o.sh.coefficients[0].set(a.r,a.g,a.b).multiplyScalar(2*Math.sqrt(Math.PI)),o}return b(t)}(Cf),Bf=new pr,qf=new pr,Vf=new pr,Wf=function(){function n(){g(this,n),this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Wa,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Wa,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}return b(n,[{key:"update",value:function(n){var e=this._cache;if(e.focus!==n.focus||e.fov!==n.fov||e.aspect!==n.aspect*this.aspect||e.near!==n.near||e.far!==n.far||e.zoom!==n.zoom||e.eyeSep!==this.eyeSep){e.focus=n.focus,e.fov=n.fov,e.aspect=n.aspect*this.aspect,e.near=n.near,e.far=n.far,e.zoom=n.zoom,e.eyeSep=this.eyeSep,Vf.copy(n.projectionMatrix);var t,o,r=e.eyeSep/2,a=r*e.near/e.focus,i=e.near*Math.tan(Xt*e.fov*.5)/e.zoom;qf.elements[12]=-r,Bf.elements[12]=r,t=-i*e.aspect+a,o=i*e.aspect+a,Vf.elements[0]=2*e.near/(o-t),Vf.elements[8]=(o+t)/(o-t),this.cameraL.projectionMatrix.copy(Vf),t=-i*e.aspect-a,o=i*e.aspect-a,Vf.elements[0]=2*e.near/(o-t),Vf.elements[8]=(o+t)/(o-t),this.cameraR.projectionMatrix.copy(Vf)}this.cameraL.matrixWorld.copy(n.matrixWorld).multiply(qf),this.cameraR.matrixWorld.copy(n.matrixWorld).multiply(Bf)}}]),n}(),Hf=function(){function n(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];g(this,n),this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}return b(n,[{key:"start",value:function(){this.startTime=Xf(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}},{key:"stop",value:function(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}},{key:"getElapsedTime",value:function(){return this.getDelta(),this.elapsedTime}},{key:"getDelta",value:function(){var n=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){var e=Xf();n=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=n}return n}}]),n}();function Xf(){return("undefined"===typeof performance?Date:performance).now()}var Yf=new Oo,Zf=new Eo,Qf=new Oo,Jf=new Oo,Kf=function(n){U(t,n);var e=k(t);function t(){var n;return g(this,t),(n=e.call(this)).type="AudioListener",n.context=Af.getContext(),n.gain=n.context.createGain(),n.gain.connect(n.context.destination),n.filter=null,n.timeDelta=0,n._clock=new Hf,n}return b(t,[{key:"getInput",value:function(){return this.gain}},{key:"removeFilter",value:function(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}},{key:"getFilter",value:function(){return this.filter}},{key:"setFilter",value:function(n){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=n,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}},{key:"getMasterVolume",value:function(){return this.gain.gain.value}},{key:"setMasterVolume",value:function(n){return this.gain.gain.setTargetAtTime(n,this.context.currentTime,.01),this}},{key:"updateMatrixWorld",value:function(n){D(_(t.prototype),"updateMatrixWorld",this).call(this,n);var e=this.context.listener,o=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Yf,Zf,Qf),Jf.set(0,0,-1).applyQuaternion(Zf),e.positionX){var r=this.context.currentTime+this.timeDelta;e.positionX.linearRampToValueAtTime(Yf.x,r),e.positionY.linearRampToValueAtTime(Yf.y,r),e.positionZ.linearRampToValueAtTime(Yf.z,r),e.forwardX.linearRampToValueAtTime(Jf.x,r),e.forwardY.linearRampToValueAtTime(Jf.y,r),e.forwardZ.linearRampToValueAtTime(Jf.z,r),e.upX.linearRampToValueAtTime(o.x,r),e.upY.linearRampToValueAtTime(o.y,r),e.upZ.linearRampToValueAtTime(o.z,r)}else e.setPosition(Yf.x,Yf.y,Yf.z),e.setOrientation(Jf.x,Jf.y,Jf.z,o.x,o.y,o.z)}}]),t}(Ar),$f=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this)).type="Audio",o.listener=n,o.context=n.context,o.gain=o.context.createGain(),o.gain.connect(n.getInput()),o.autoplay=!1,o.buffer=null,o.detune=0,o.loop=!1,o.loopStart=0,o.loopEnd=0,o.offset=0,o.duration=void 0,o.playbackRate=1,o.isPlaying=!1,o.hasPlaybackControl=!0,o.source=null,o.sourceType="empty",o._startedAt=0,o._progress=0,o._connected=!1,o.filters=[],o}return b(t,[{key:"getOutput",value:function(){return this.gain}},{key:"setNodeSource",value:function(n){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=n,this.connect(),this}},{key:"setMediaElementSource",value:function(n){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(n),this.connect(),this}},{key:"setMediaStreamSource",value:function(n){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(n),this.connect(),this}},{key:"setBuffer",value:function(n){return this.buffer=n,this.sourceType="buffer",this.autoplay&&this.play(),this}},{key:"play",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;if(!0!==this.isPlaying){if(!1!==this.hasPlaybackControl){this._startedAt=this.context.currentTime+n;var e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}console.warn("THREE.Audio: this Audio has no playback control.")}else console.warn("THREE.Audio: Audio is already playing.")}},{key:"pause",value:function(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}},{key:"stop",value:function(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}},{key:"connect",value:function(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(var n=1,e=this.filters.length;n<e;n++)this.filters[n-1].connect(this.filters[n]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}},{key:"disconnect",value:function(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(var n=1,e=this.filters.length;n<e;n++)this.filters[n-1].disconnect(this.filters[n]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}},{key:"getFilters",value:function(){return this.filters}},{key:"setFilters",value:function(n){return n||(n=[]),!0===this._connected?(this.disconnect(),this.filters=n.slice(),this.connect()):this.filters=n.slice(),this}},{key:"setDetune",value:function(n){if(this.detune=n,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}},{key:"getDetune",value:function(){return this.detune}},{key:"getFilter",value:function(){return this.getFilters()[0]}},{key:"setFilter",value:function(n){return this.setFilters(n?[n]:[])}},{key:"setPlaybackRate",value:function(n){if(!1!==this.hasPlaybackControl)return this.playbackRate=n,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}},{key:"getPlaybackRate",value:function(){return this.playbackRate}},{key:"onEnded",value:function(){this.isPlaying=!1}},{key:"getLoop",value:function(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}},{key:"setLoop",value:function(n){if(!1!==this.hasPlaybackControl)return this.loop=n,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}},{key:"setLoopStart",value:function(n){return this.loopStart=n,this}},{key:"setLoopEnd",value:function(n){return this.loopEnd=n,this}},{key:"getVolume",value:function(){return this.gain.gain.value}},{key:"setVolume",value:function(n){return this.gain.gain.setTargetAtTime(n,this.context.currentTime,.01),this}}]),t}(Ar),np=new Oo,ep=new Eo,tp=new Oo,op=new Oo,rp=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this,n)).panner=o.context.createPanner(),o.panner.panningModel="HRTF",o.panner.connect(o.gain),o}return b(t,[{key:"disconnect",value:function(){D(_(t.prototype),"disconnect",this).call(this),this.panner.disconnect(this.gain)}},{key:"getOutput",value:function(){return this.panner}},{key:"getRefDistance",value:function(){return this.panner.refDistance}},{key:"setRefDistance",value:function(n){return this.panner.refDistance=n,this}},{key:"getRolloffFactor",value:function(){return this.panner.rolloffFactor}},{key:"setRolloffFactor",value:function(n){return this.panner.rolloffFactor=n,this}},{key:"getDistanceModel",value:function(){return this.panner.distanceModel}},{key:"setDistanceModel",value:function(n){return this.panner.distanceModel=n,this}},{key:"getMaxDistance",value:function(){return this.panner.maxDistance}},{key:"setMaxDistance",value:function(n){return this.panner.maxDistance=n,this}},{key:"setDirectionalCone",value:function(n,e,t){return this.panner.coneInnerAngle=n,this.panner.coneOuterAngle=e,this.panner.coneOuterGain=t,this}},{key:"updateMatrixWorld",value:function(n){if(D(_(t.prototype),"updateMatrixWorld",this).call(this,n),!0!==this.hasPlaybackControl||!1!==this.isPlaying){this.matrixWorld.decompose(np,ep,tp),op.set(0,0,1).applyQuaternion(ep);var e=this.panner;if(e.positionX){var o=this.context.currentTime+this.listener.timeDelta;e.positionX.linearRampToValueAtTime(np.x,o),e.positionY.linearRampToValueAtTime(np.y,o),e.positionZ.linearRampToValueAtTime(np.z,o),e.orientationX.linearRampToValueAtTime(op.x,o),e.orientationY.linearRampToValueAtTime(op.y,o),e.orientationZ.linearRampToValueAtTime(op.z,o)}else e.setPosition(np.x,np.y,np.z),e.setOrientation(op.x,op.y,op.z)}}}]),t}($f),ap=function(){function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2048;g(this,n),this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}return b(n,[{key:"getFrequencyData",value:function(){return this.analyser.getByteFrequencyData(this.data),this.data}},{key:"getAverageFrequency",value:function(){for(var n=0,e=this.getFrequencyData(),t=0;t<e.length;t++)n+=e[t];return n/e.length}}]),n}(),ip=function(){function n(e,t,o){var r,a,i;switch(g(this,n),this.binding=e,this.valueSize=o,t){case"quaternion":r=this._slerp,a=this._slerpAdditive,i=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*o),this._workIndex=5;break;case"string":case"bool":r=this._select,a=this._select,i=this._setAdditiveIdentityOther,this.buffer=new Array(5*o);break;default:r=this._lerp,a=this._lerpAdditive,i=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*o)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=a,this._setIdentity=i,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}return b(n,[{key:"accumulate",value:function(n,e){var t=this.buffer,o=this.valueSize,r=n*o+o,a=this.cumulativeWeight;if(0===a){for(var i=0;i!==o;++i)t[r+i]=t[i];a=e}else{var v=e/(a+=e);this._mixBufferRegion(t,r,0,v,o)}this.cumulativeWeight=a}},{key:"accumulateAdditive",value:function(n){var e=this.buffer,t=this.valueSize,o=t*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(e,o,0,n,t),this.cumulativeWeightAdditive+=n}},{key:"apply",value:function(n){var e=this.valueSize,t=this.buffer,o=n*e+e,r=this.cumulativeWeight,a=this.cumulativeWeightAdditive,i=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){var v=e*this._origIndex;this._mixBufferRegion(t,o,v,1-r,e)}a>0&&this._mixBufferRegionAdditive(t,o,this._addIndex*e,1,e);for(var c=e,s=e+e;c!==s;++c)if(t[c]!==t[c+e]){i.setValue(t,o);break}}},{key:"saveOriginalState",value:function(){var n=this.binding,e=this.buffer,t=this.valueSize,o=t*this._origIndex;n.getValue(e,o);for(var r=t,a=o;r!==a;++r)e[r]=e[o+r%t];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}},{key:"restoreOriginalState",value:function(){var n=3*this.valueSize;this.binding.setValue(this.buffer,n)}},{key:"_setAdditiveIdentityNumeric",value:function(){for(var n=this._addIndex*this.valueSize,e=n+this.valueSize,t=n;t<e;t++)this.buffer[t]=0}},{key:"_setAdditiveIdentityQuaternion",value:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}},{key:"_setAdditiveIdentityOther",value:function(){for(var n=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize,t=0;t<this.valueSize;t++)this.buffer[e+t]=this.buffer[n+t]}},{key:"_select",value:function(n,e,t,o,r){if(o>=.5)for(var a=0;a!==r;++a)n[e+a]=n[t+a]}},{key:"_slerp",value:function(n,e,t,o){Eo.slerpFlat(n,e,n,e,n,t,o)}},{key:"_slerpAdditive",value:function(n,e,t,o,r){var a=this._workIndex*r;Eo.multiplyQuaternionsFlat(n,a,n,e,n,t),Eo.slerpFlat(n,e,n,e,n,a,o)}},{key:"_lerp",value:function(n,e,t,o,r){for(var a=1-o,i=0;i!==r;++i){var v=e+i;n[v]=n[v]*a+n[t+i]*o}}},{key:"_lerpAdditive",value:function(n,e,t,o,r){for(var a=0;a!==r;++a){var i=e+a;n[i]=n[i]+n[t+a]*o}}}]),n}(),vp="\\[\\]\\.:\\/",cp=new RegExp("[\\[\\]\\.:\\/]","g"),sp="[^\\[\\]\\.:\\/]",lp="[^"+vp.replace("\\.","")+"]",up=new RegExp("^"+/((?:WC+[\/:])*)/.source.replace("WC",sp)+/(WCOD+)?/.source.replace("WCOD",lp)+/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",sp)+/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",sp)+"$"),fp=["material","materials","bones","map"],pp=function(){function n(e,t,o){g(this,n);var r=o||mp.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,r)}return b(n,[{key:"getValue",value:function(n,e){this.bind();var t=this._targetGroup.nCachedObjects_,o=this._bindings[t];void 0!==o&&o.getValue(n,e)}},{key:"setValue",value:function(n,e){for(var t=this._bindings,o=this._targetGroup.nCachedObjects_,r=t.length;o!==r;++o)t[o].setValue(n,e)}},{key:"bind",value:function(){for(var n=this._bindings,e=this._targetGroup.nCachedObjects_,t=n.length;e!==t;++e)n[e].bind()}},{key:"unbind",value:function(){for(var n=this._bindings,e=this._targetGroup.nCachedObjects_,t=n.length;e!==t;++e)n[e].unbind()}}]),n}(),mp=function(){function n(e,t,o){g(this,n),this.path=t,this.parsedPath=o||n.parseTrackName(t),this.node=n.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}return b(n,[{key:"_getValue_unavailable",value:function(){}},{key:"_setValue_unavailable",value:function(){}},{key:"_getValue_direct",value:function(n,e){n[e]=this.targetObject[this.propertyName]}},{key:"_getValue_array",value:function(n,e){for(var t=this.resolvedProperty,o=0,r=t.length;o!==r;++o)n[e++]=t[o]}},{key:"_getValue_arrayElement",value:function(n,e){n[e]=this.resolvedProperty[this.propertyIndex]}},{key:"_getValue_toArray",value:function(n,e){this.resolvedProperty.toArray(n,e)}},{key:"_setValue_direct",value:function(n,e){this.targetObject[this.propertyName]=n[e]}},{key:"_setValue_direct_setNeedsUpdate",value:function(n,e){this.targetObject[this.propertyName]=n[e],this.targetObject.needsUpdate=!0}},{key:"_setValue_direct_setMatrixWorldNeedsUpdate",value:function(n,e){this.targetObject[this.propertyName]=n[e],this.targetObject.matrixWorldNeedsUpdate=!0}},{key:"_setValue_array",value:function(n,e){for(var t=this.resolvedProperty,o=0,r=t.length;o!==r;++o)t[o]=n[e++]}},{key:"_setValue_array_setNeedsUpdate",value:function(n,e){for(var t=this.resolvedProperty,o=0,r=t.length;o!==r;++o)t[o]=n[e++];this.targetObject.needsUpdate=!0}},{key:"_setValue_array_setMatrixWorldNeedsUpdate",value:function(n,e){for(var t=this.resolvedProperty,o=0,r=t.length;o!==r;++o)t[o]=n[e++];this.targetObject.matrixWorldNeedsUpdate=!0}},{key:"_setValue_arrayElement",value:function(n,e){this.resolvedProperty[this.propertyIndex]=n[e]}},{key:"_setValue_arrayElement_setNeedsUpdate",value:function(n,e){this.resolvedProperty[this.propertyIndex]=n[e],this.targetObject.needsUpdate=!0}},{key:"_setValue_arrayElement_setMatrixWorldNeedsUpdate",value:function(n,e){this.resolvedProperty[this.propertyIndex]=n[e],this.targetObject.matrixWorldNeedsUpdate=!0}},{key:"_setValue_fromArray",value:function(n,e){this.resolvedProperty.fromArray(n,e)}},{key:"_setValue_fromArray_setNeedsUpdate",value:function(n,e){this.resolvedProperty.fromArray(n,e),this.targetObject.needsUpdate=!0}},{key:"_setValue_fromArray_setMatrixWorldNeedsUpdate",value:function(n,e){this.resolvedProperty.fromArray(n,e),this.targetObject.matrixWorldNeedsUpdate=!0}},{key:"_getValue_unbound",value:function(n,e){this.bind(),this.getValue(n,e)}},{key:"_setValue_unbound",value:function(n,e){this.bind(),this.setValue(n,e)}},{key:"bind",value:function(){var e=this.node,t=this.parsedPath,o=t.objectName,r=t.propertyName,a=t.propertyIndex;if(e||(e=n.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,e){if(o){var i=t.objectIndex;switch(o){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(var v=0;v<e.length;v++)if(e[v].name===i){i=v;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.map)return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);e=e.material.map;break;default:if(void 0===e[o])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[o]}if(void 0!==i){if(void 0===e[i])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[i]}}var c=e[r];if(void 0!==c){var s=this.Versioning.None;this.targetObject=e,void 0!==e.needsUpdate?s=this.Versioning.NeedsUpdate:void 0!==e.matrixWorldNeedsUpdate&&(s=this.Versioning.MatrixWorldNeedsUpdate);var l=this.BindingType.Direct;if(void 0!==a){if("morphTargetInfluences"===r){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==e.morphTargetDictionary[a]&&(a=e.morphTargetDictionary[a])}l=this.BindingType.ArrayElement,this.resolvedProperty=c,this.propertyIndex=a}else void 0!==c.fromArray&&void 0!==c.toArray?(l=this.BindingType.HasFromToArray,this.resolvedProperty=c):Array.isArray(c)?(l=this.BindingType.EntireArray,this.resolvedProperty=c):this.propertyName=r;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][s]}else{var u=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+u+"."+r+" but it wasn't found.",e)}}else console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.")}},{key:"unbind",value:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}],[{key:"create",value:function(e,t,o){return e&&e.isAnimationObjectGroup?new n.Composite(e,t,o):new n(e,t,o)}},{key:"sanitizeNodeName",value:function(n){return n.replace(/\s/g,"_").replace(cp,"")}},{key:"parseTrackName",value:function(n){var e=up.exec(n);if(null===e)throw new Error("PropertyBinding: Cannot parse trackName: "+n);var t={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},o=t.nodeName&&t.nodeName.lastIndexOf(".");if(void 0!==o&&-1!==o){var r=t.nodeName.substring(o+1);-1!==fp.indexOf(r)&&(t.nodeName=t.nodeName.substring(0,o),t.objectName=r)}if(null===t.propertyName||0===t.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+n);return t}},{key:"findNode",value:function(n,e){if(void 0===e||""===e||"."===e||-1===e||e===n.name||e===n.uuid)return n;if(n.skeleton){var t=n.skeleton.getBoneByName(e);if(void 0!==t)return t}if(n.children){var o=function n(t){for(var o=0;o<t.length;o++){var r=t[o];if(r.name===e||r.uuid===e)return r;var a=n(r.children);if(a)return a}return null}(n.children);if(o)return o}return null}}]),n}();mp.Composite=pp,mp.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},mp.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},mp.prototype.GetterByBindingType=[mp.prototype._getValue_direct,mp.prototype._getValue_array,mp.prototype._getValue_arrayElement,mp.prototype._getValue_toArray],mp.prototype.SetterByBindingTypeAndVersioning=[[mp.prototype._setValue_direct,mp.prototype._setValue_direct_setNeedsUpdate,mp.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[mp.prototype._setValue_array,mp.prototype._setValue_array_setNeedsUpdate,mp.prototype._setValue_array_setMatrixWorldNeedsUpdate],[mp.prototype._setValue_arrayElement,mp.prototype._setValue_arrayElement_setNeedsUpdate,mp.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[mp.prototype._setValue_fromArray,mp.prototype._setValue_fromArray_setNeedsUpdate,mp.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];var dp=function(){function n(){g(this,n),this.isAnimationObjectGroup=!0,this.uuid=Zt(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;var e={};this._indicesByUUID=e;for(var t=0,o=arguments.length;t!==o;++t)e[arguments[t].uuid]=t;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};var r=this;this.stats={objects:{get total(){return r._objects.length},get inUse(){return this.total-r.nCachedObjects_}},get bindingsPerObject(){return r._bindings.length}}}return b(n,[{key:"add",value:function(){for(var n=this._objects,e=this._indicesByUUID,t=this._paths,o=this._parsedPaths,r=this._bindings,a=r.length,i=void 0,v=n.length,c=this.nCachedObjects_,s=0,l=arguments.length;s!==l;++s){var u=arguments[s],f=u.uuid,p=e[f];if(void 0===p){p=v++,e[f]=p,n.push(u);for(var m=0,d=a;m!==d;++m)r[m].push(new mp(u,t[m],o[m]))}else if(p<c){i=n[p];var h=--c,x=n[h];e[x.uuid]=p,n[p]=x,e[f]=h,n[h]=u;for(var g=0,y=a;g!==y;++g){var b=r[g],U=b[h],_=b[p];b[p]=U,void 0===_&&(_=new mp(u,t[g],o[g])),b[h]=_}}else n[p]!==i&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c}},{key:"remove",value:function(){for(var n=this._objects,e=this._indicesByUUID,t=this._bindings,o=t.length,r=this.nCachedObjects_,a=0,i=arguments.length;a!==i;++a){var v=arguments[a],c=v.uuid,s=e[c];if(void 0!==s&&s>=r){var l=r++,u=n[l];e[u.uuid]=s,n[s]=u,e[c]=l,n[l]=v;for(var f=0,p=o;f!==p;++f){var m=t[f],d=m[l],h=m[s];m[s]=d,m[l]=h}}}this.nCachedObjects_=r}},{key:"uncache",value:function(){for(var n=this._objects,e=this._indicesByUUID,t=this._bindings,o=t.length,r=this.nCachedObjects_,a=n.length,i=0,v=arguments.length;i!==v;++i){var c=arguments[i],s=c.uuid,l=e[s];if(void 0!==l)if(delete e[s],l<r){var u=--r,f=n[u],p=--a,m=n[p];e[f.uuid]=l,n[l]=f,e[m.uuid]=u,n[u]=m,n.pop();for(var d=0,h=o;d!==h;++d){var x=t[d],g=x[u],y=x[p];x[l]=g,x[u]=y,x.pop()}}else{var b=--a,U=n[b];b>0&&(e[U.uuid]=l),n[l]=U,n.pop();for(var _=0,w=o;_!==w;++_){var S=t[_];S[l]=S[b],S.pop()}}}this.nCachedObjects_=r}},{key:"subscribe_",value:function(n,e){var t=this._bindingsIndicesByPath,o=t[n],r=this._bindings;if(void 0!==o)return r[o];var a=this._paths,i=this._parsedPaths,v=this._objects,c=v.length,s=this.nCachedObjects_,l=new Array(c);o=r.length,t[n]=o,a.push(n),i.push(e),r.push(l);for(var u=s,f=v.length;u!==f;++u){var p=v[u];l[u]=new mp(p,n,e)}return l}},{key:"unsubscribe_",value:function(n){var e=this._bindingsIndicesByPath,t=e[n];if(void 0!==t){var o=this._paths,r=this._parsedPaths,a=this._bindings,i=a.length-1,v=a[i];e[n[i]]=t,a[t]=v,a.pop(),r[t]=r[i],r.pop(),o[t]=o[i],o.pop()}}}]),n}(),hp=function(){function n(e,t){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t.blendMode;g(this,n),this._mixer=e,this._clip=t,this._localRoot=o,this.blendMode=r;for(var a=t.tracks,i=a.length,v=new Array(i),c={endingStart:$e,endingEnd:$e},s=0;s!==i;++s){var l=a[s].createInterpolant(null);v[s]=l,l.settings=c}this._interpolantSettings=c,this._interpolants=v,this._propertyBindings=new Array(i),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Ye,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}return b(n,[{key:"play",value:function(){return this._mixer._activateAction(this),this}},{key:"stop",value:function(){return this._mixer._deactivateAction(this),this.reset()}},{key:"reset",value:function(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}},{key:"isRunning",value:function(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}},{key:"isScheduled",value:function(){return this._mixer._isActiveAction(this)}},{key:"startAt",value:function(n){return this._startTime=n,this}},{key:"setLoop",value:function(n,e){return this.loop=n,this.repetitions=e,this}},{key:"setEffectiveWeight",value:function(n){return this.weight=n,this._effectiveWeight=this.enabled?n:0,this.stopFading()}},{key:"getEffectiveWeight",value:function(){return this._effectiveWeight}},{key:"fadeIn",value:function(n){return this._scheduleFading(n,0,1)}},{key:"fadeOut",value:function(n){return this._scheduleFading(n,1,0)}},{key:"crossFadeFrom",value:function(n,e,t){if(n.fadeOut(e),this.fadeIn(e),t){var o=this._clip.duration,r=n._clip.duration,a=r/o,i=o/r;n.warp(1,a,e),this.warp(i,1,e)}return this}},{key:"crossFadeTo",value:function(n,e,t){return n.crossFadeFrom(this,e,t)}},{key:"stopFading",value:function(){var n=this._weightInterpolant;return null!==n&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(n)),this}},{key:"setEffectiveTimeScale",value:function(n){return this.timeScale=n,this._effectiveTimeScale=this.paused?0:n,this.stopWarping()}},{key:"getEffectiveTimeScale",value:function(){return this._effectiveTimeScale}},{key:"setDuration",value:function(n){return this.timeScale=this._clip.duration/n,this.stopWarping()}},{key:"syncWith",value:function(n){return this.time=n.time,this.timeScale=n.timeScale,this.stopWarping()}},{key:"halt",value:function(n){return this.warp(this._effectiveTimeScale,0,n)}},{key:"warp",value:function(n,e,t){var o=this._mixer,r=o.time,a=this.timeScale,i=this._timeScaleInterpolant;null===i&&(i=o._lendControlInterpolant(),this._timeScaleInterpolant=i);var v=i.parameterPositions,c=i.sampleValues;return v[0]=r,v[1]=r+t,c[0]=n/a,c[1]=e/a,this}},{key:"stopWarping",value:function(){var n=this._timeScaleInterpolant;return null!==n&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(n)),this}},{key:"getMixer",value:function(){return this._mixer}},{key:"getClip",value:function(){return this._clip}},{key:"getRoot",value:function(){return this._localRoot||this._mixer._root}},{key:"_update",value:function(n,e,t,o){if(this.enabled){var r=this._startTime;if(null!==r){var a=(n-r)*t;a<0||0===t?e=0:(this._startTime=null,e=t*a)}e*=this._updateTimeScale(n);var i=this._updateTime(e),v=this._updateWeight(n);if(v>0){var c=this._interpolants,s=this._propertyBindings;if(this.blendMode===ot)for(var l=0,u=c.length;l!==u;++l)c[l].evaluate(i),s[l].accumulateAdditive(v);else for(var f=0,p=c.length;f!==p;++f)c[f].evaluate(i),s[f].accumulate(o,v)}}else this._updateWeight(n)}},{key:"_updateWeight",value:function(n){var e=0;if(this.enabled){e=this.weight;var t=this._weightInterpolant;if(null!==t){var o=t.evaluate(n)[0];e*=o,n>t.parameterPositions[1]&&(this.stopFading(),0===o&&(this.enabled=!1))}}return this._effectiveWeight=e,e}},{key:"_updateTimeScale",value:function(n){var e=0;if(!this.paused){e=this.timeScale;var t=this._timeScaleInterpolant;if(null!==t)e*=t.evaluate(n)[0],n>t.parameterPositions[1]&&(this.stopWarping(),0===e?this.paused=!0:this.timeScale=e)}return this._effectiveTimeScale=e,e}},{key:"_updateTime",value:function(n){var e=this._clip.duration,t=this.loop,o=this.time+n,r=this._loopCount,a=t===Ze;if(0===n)return-1===r?o:a&&1===(1&r)?e-o:o;if(t===Xe){-1===r&&(this._loopCount=0,this._setEndings(!0,!0,!1));n:{if(o>=e)o=e;else{if(!(o<0)){this.time=o;break n}o=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=o,this._mixer.dispatchEvent({type:"finished",action:this,direction:n<0?-1:1})}}else{if(-1===r&&(n>=0?(r=0,this._setEndings(!0,0===this.repetitions,a)):this._setEndings(0===this.repetitions,!0,a)),o>=e||o<0){var i=Math.floor(o/e);o-=e*i,r+=Math.abs(i);var v=this.repetitions-r;if(v<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,o=n>0?e:0,this.time=o,this._mixer.dispatchEvent({type:"finished",action:this,direction:n>0?1:-1});else{if(1===v){var c=n<0;this._setEndings(c,!c,a)}else this._setEndings(!1,!1,a);this._loopCount=r,this.time=o,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:i})}}else this.time=o;if(a&&1===(1&r))return e-o}return o}},{key:"_setEndings",value:function(n,e,t){var o=this._interpolantSettings;t?(o.endingStart=nt,o.endingEnd=nt):(o.endingStart=n?this.zeroSlopeAtStart?nt:$e:et,o.endingEnd=e?this.zeroSlopeAtEnd?nt:$e:et)}},{key:"_scheduleFading",value:function(n,e,t){var o=this._mixer,r=o.time,a=this._weightInterpolant;null===a&&(a=o._lendControlInterpolant(),this._weightInterpolant=a);var i=a.parameterPositions,v=a.sampleValues;return i[0]=r,v[0]=e,i[1]=r+n,v[1]=t,this}}]),n}(),xp=new Float32Array(1),gp=function(n){U(t,n);var e=k(t);function t(n){var o;return g(this,t),(o=e.call(this))._root=n,o._initMemoryManager(),o._accuIndex=0,o.time=0,o.timeScale=1,o}return b(t,[{key:"_bindAction",value:function(n,e){var t=n._localRoot||this._root,o=n._clip.tracks,r=o.length,a=n._propertyBindings,i=n._interpolants,v=t.uuid,c=this._bindingsByRootAndName,s=c[v];void 0===s&&(s={},c[v]=s);for(var l=0;l!==r;++l){var u=o[l],f=u.name,p=s[f];if(void 0!==p)++p.referenceCount,a[l]=p;else{if(void 0!==(p=a[l])){null===p._cacheIndex&&(++p.referenceCount,this._addInactiveBinding(p,v,f));continue}var m=e&&e._propertyBindings[l].binding.parsedPath;++(p=new ip(mp.create(t,f,m),u.ValueTypeName,u.getValueSize())).referenceCount,this._addInactiveBinding(p,v,f),a[l]=p}i[l].resultBuffer=p.buffer}}},{key:"_activateAction",value:function(n){if(!this._isActiveAction(n)){if(null===n._cacheIndex){var e=(n._localRoot||this._root).uuid,t=n._clip.uuid,o=this._actionsByClip[t];this._bindAction(n,o&&o.knownActions[0]),this._addInactiveAction(n,t,e)}for(var r=n._propertyBindings,a=0,i=r.length;a!==i;++a){var v=r[a];0===v.useCount++&&(this._lendBinding(v),v.saveOriginalState())}this._lendAction(n)}}},{key:"_deactivateAction",value:function(n){if(this._isActiveAction(n)){for(var e=n._propertyBindings,t=0,o=e.length;t!==o;++t){var r=e[t];0===--r.useCount&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(n)}}},{key:"_initMemoryManager",value:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;var n=this;this.stats={actions:{get total(){return n._actions.length},get inUse(){return n._nActiveActions}},bindings:{get total(){return n._bindings.length},get inUse(){return n._nActiveBindings}},controlInterpolants:{get total(){return n._controlInterpolants.length},get inUse(){return n._nActiveControlInterpolants}}}}},{key:"_isActiveAction",value:function(n){var e=n._cacheIndex;return null!==e&&e<this._nActiveActions}},{key:"_addInactiveAction",value:function(n,e,t){var o=this._actions,r=this._actionsByClip,a=r[e];if(void 0===a)a={knownActions:[n],actionByRoot:{}},n._byClipCacheIndex=0,r[e]=a;else{var i=a.knownActions;n._byClipCacheIndex=i.length,i.push(n)}n._cacheIndex=o.length,o.push(n),a.actionByRoot[t]=n}},{key:"_removeInactiveAction",value:function(n){var e=this._actions,t=e[e.length-1],o=n._cacheIndex;t._cacheIndex=o,e[o]=t,e.pop(),n._cacheIndex=null;var r=n._clip.uuid,a=this._actionsByClip,i=a[r],v=i.knownActions,c=v[v.length-1],s=n._byClipCacheIndex;c._byClipCacheIndex=s,v[s]=c,v.pop(),n._byClipCacheIndex=null,delete i.actionByRoot[(n._localRoot||this._root).uuid],0===v.length&&delete a[r],this._removeInactiveBindingsForAction(n)}},{key:"_removeInactiveBindingsForAction",value:function(n){for(var e=n._propertyBindings,t=0,o=e.length;t!==o;++t){var r=e[t];0===--r.referenceCount&&this._removeInactiveBinding(r)}}},{key:"_lendAction",value:function(n){var e=this._actions,t=n._cacheIndex,o=this._nActiveActions++,r=e[o];n._cacheIndex=o,e[o]=n,r._cacheIndex=t,e[t]=r}},{key:"_takeBackAction",value:function(n){var e=this._actions,t=n._cacheIndex,o=--this._nActiveActions,r=e[o];n._cacheIndex=o,e[o]=n,r._cacheIndex=t,e[t]=r}},{key:"_addInactiveBinding",value:function(n,e,t){var o=this._bindingsByRootAndName,r=this._bindings,a=o[e];void 0===a&&(a={},o[e]=a),a[t]=n,n._cacheIndex=r.length,r.push(n)}},{key:"_removeInactiveBinding",value:function(n){var e=this._bindings,t=n.binding,o=t.rootNode.uuid,r=t.path,a=this._bindingsByRootAndName,i=a[o],v=e[e.length-1],c=n._cacheIndex;v._cacheIndex=c,e[c]=v,e.pop(),delete i[r],0===Object.keys(i).length&&delete a[o]}},{key:"_lendBinding",value:function(n){var e=this._bindings,t=n._cacheIndex,o=this._nActiveBindings++,r=e[o];n._cacheIndex=o,e[o]=n,r._cacheIndex=t,e[t]=r}},{key:"_takeBackBinding",value:function(n){var e=this._bindings,t=n._cacheIndex,o=--this._nActiveBindings,r=e[o];n._cacheIndex=o,e[o]=n,r._cacheIndex=t,e[t]=r}},{key:"_lendControlInterpolant",value:function(){var n=this._controlInterpolants,e=this._nActiveControlInterpolants++,t=n[e];return void 0===t&&((t=new Ou(new Float32Array(2),new Float32Array(2),1,xp)).__cacheIndex=e,n[e]=t),t}},{key:"_takeBackControlInterpolant",value:function(n){var e=this._controlInterpolants,t=n.__cacheIndex,o=--this._nActiveControlInterpolants,r=e[o];n.__cacheIndex=o,e[o]=n,r.__cacheIndex=t,e[t]=r}},{key:"clipAction",value:function(n,e,t){var o=e||this._root,r=o.uuid,a="string"===typeof n?Xu.findByName(o,n):n,i=null!==a?a.uuid:n,v=this._actionsByClip[i],c=null;if(void 0===t&&(t=null!==a?a.blendMode:tt),void 0!==v){var s=v.actionByRoot[r];if(void 0!==s&&s.blendMode===t)return s;c=v.knownActions[0],null===a&&(a=c._clip)}if(null===a)return null;var l=new hp(this,a,e,t);return this._bindAction(l,c),this._addInactiveAction(l,i,r),l}},{key:"existingAction",value:function(n,e){var t=e||this._root,o=t.uuid,r="string"===typeof n?Xu.findByName(t,n):n,a=r?r.uuid:n,i=this._actionsByClip[a];return void 0!==i&&i.actionByRoot[o]||null}},{key:"stopAllAction",value:function(){for(var n=this._actions,e=this._nActiveActions-1;e>=0;--e)n[e].stop();return this}},{key:"update",value:function(n){n*=this.timeScale;for(var e=this._actions,t=this._nActiveActions,o=this.time+=n,r=Math.sign(n),a=this._accuIndex^=1,i=0;i!==t;++i){e[i]._update(o,n,r,a)}for(var v=this._bindings,c=this._nActiveBindings,s=0;s!==c;++s)v[s].apply(a);return this}},{key:"setTime",value:function(n){this.time=0;for(var e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(n)}},{key:"getRoot",value:function(){return this._root}},{key:"uncacheClip",value:function(n){var e=this._actions,t=n.uuid,o=this._actionsByClip,r=o[t];if(void 0!==r){for(var a=r.knownActions,i=0,v=a.length;i!==v;++i){var c=a[i];this._deactivateAction(c);var s=c._cacheIndex,l=e[e.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,l._cacheIndex=s,e[s]=l,e.pop(),this._removeInactiveBindingsForAction(c)}delete o[t]}}},{key:"uncacheRoot",value:function(n){var e=n.uuid,t=this._actionsByClip;for(var o in t){var r=t[o].actionByRoot[e];void 0!==r&&(this._deactivateAction(r),this._removeInactiveAction(r))}var a=this._bindingsByRootAndName[e];if(void 0!==a)for(var i in a){var v=a[i];v.restoreOriginalState(),this._removeInactiveBinding(v)}}},{key:"uncacheAction",value:function(n,e){var t=this.existingAction(n,e);null!==t&&(this._deactivateAction(t),this._removeInactiveAction(t))}}]),t}(Vt),yp=function(){function n(e){g(this,n),this.value=e}return b(n,[{key:"clone",value:function(){return new n(void 0===this.value.clone?this.value:this.value.clone())}}]),n}(),bp=0,Up=function(n){U(t,n);var e=k(t);function t(){var n;return g(this,t),(n=e.call(this)).isUniformsGroup=!0,Object.defineProperty(S(n),"id",{value:bp++}),n.name="",n.usage=Pt,n.uniforms=[],n}return b(t,[{key:"add",value:function(n){return this.uniforms.push(n),this}},{key:"remove",value:function(n){var e=this.uniforms.indexOf(n);return-1!==e&&this.uniforms.splice(e,1),this}},{key:"setName",value:function(n){return this.name=n,this}},{key:"setUsage",value:function(n){return this.usage=n,this}},{key:"dispose",value:function(){return this.dispatchEvent({type:"dispose"}),this}},{key:"copy",value:function(n){this.name=n.name,this.usage=n.usage;var e=n.uniforms;this.uniforms.length=0;for(var t=0,o=e.length;t<o;t++)this.uniforms.push(e[t].clone());return this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),t}(Vt),_p=function(n){U(t,n);var e=k(t);function t(n,o){var r,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return g(this,t),(r=e.call(this,n,o)).isInstancedInterleavedBuffer=!0,r.meshPerAttribute=a,r}return b(t,[{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n),this.meshPerAttribute=n.meshPerAttribute,this}},{key:"clone",value:function(n){var e=D(_(t.prototype),"clone",this).call(this,n);return e.meshPerAttribute=this.meshPerAttribute,e}},{key:"toJSON",value:function(n){var e=D(_(t.prototype),"toJSON",this).call(this,n);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}]),t}(Gc),wp=function(){function n(e,t,o,r,a){g(this,n),this.isGLBufferAttribute=!0,this.buffer=e,this.type=t,this.itemSize=o,this.elementSize=r,this.count=a,this.version=0}return b(n,[{key:"needsUpdate",set:function(n){!0===n&&this.version++}},{key:"setBuffer",value:function(n){return this.buffer=n,this}},{key:"setType",value:function(n,e){return this.type=n,this.elementSize=e,this}},{key:"setItemSize",value:function(n){return this.itemSize=n,this}},{key:"setCount",value:function(n){return this.count=n,this}}]),n}(),Sp=function(){function n(e,t){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;g(this,n),this.ray=new fr(e,t),this.near=o,this.far=r,this.camera=null,this.layers=new Sr,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}return b(n,[{key:"set",value:function(n,e){this.ray.set(n,e)}},{key:"setFromCamera",value:function(n,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(n.x,n.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(n.x,n.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}},{key:"intersectObject",value:function(n){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return kp(n,this,t,e),t.sort(Mp),t}},{key:"intersectObjects",value:function(n){for(var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],o=0,r=n.length;o<r;o++)kp(n[o],this,t,e);return t.sort(Mp),t}}]),n}();function Mp(n,e){return n.distance-e.distance}function kp(n,e,t,o){if(n.layers.test(e.layers)&&n.raycast(e,t),!0===o)for(var r=n.children,a=0,i=r.length;a<i;a++)kp(r[a],e,t,!0)}var zp=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return g(this,n),this.radius=e,this.phi=t,this.theta=o,this}return b(n,[{key:"set",value:function(n,e,t){return this.radius=n,this.phi=e,this.theta=t,this}},{key:"copy",value:function(n){return this.radius=n.radius,this.phi=n.phi,this.theta=n.theta,this}},{key:"makeSafe",value:function(){var n=1e-6;return this.phi=Math.max(n,Math.min(Math.PI-n,this.phi)),this}},{key:"setFromVector3",value:function(n){return this.setFromCartesianCoords(n.x,n.y,n.z)}},{key:"setFromCartesianCoords",value:function(n,e,t){return this.radius=Math.sqrt(n*n+e*e+t*t),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(n,t),this.phi=Math.acos(Qt(e/this.radius,-1,1))),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),Cp=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return g(this,n),this.radius=e,this.theta=t,this.y=o,this}return b(n,[{key:"set",value:function(n,e,t){return this.radius=n,this.theta=e,this.y=t,this}},{key:"copy",value:function(n){return this.radius=n.radius,this.theta=n.theta,this.y=n.y,this}},{key:"setFromVector3",value:function(n){return this.setFromCartesianCoords(n.x,n.y,n.z)}},{key:"setFromCartesianCoords",value:function(n,e,t){return this.radius=Math.sqrt(n*n+t*t),this.theta=Math.atan2(n,t),this.y=e,this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),Tp=new ao,Rp=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new ao(1/0,1/0),t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new ao(-1/0,-1/0);g(this,n),this.isBox2=!0,this.min=e,this.max=t}return b(n,[{key:"set",value:function(n,e){return this.min.copy(n),this.max.copy(e),this}},{key:"setFromPoints",value:function(n){this.makeEmpty();for(var e=0,t=n.length;e<t;e++)this.expandByPoint(n[e]);return this}},{key:"setFromCenterAndSize",value:function(n,e){var t=Tp.copy(e).multiplyScalar(.5);return this.min.copy(n).sub(t),this.max.copy(n).add(t),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"copy",value:function(n){return this.min.copy(n.min),this.max.copy(n.max),this}},{key:"makeEmpty",value:function(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}},{key:"isEmpty",value:function(){return this.max.x<this.min.x||this.max.y<this.min.y}},{key:"getCenter",value:function(n){return this.isEmpty()?n.set(0,0):n.addVectors(this.min,this.max).multiplyScalar(.5)}},{key:"getSize",value:function(n){return this.isEmpty()?n.set(0,0):n.subVectors(this.max,this.min)}},{key:"expandByPoint",value:function(n){return this.min.min(n),this.max.max(n),this}},{key:"expandByVector",value:function(n){return this.min.sub(n),this.max.add(n),this}},{key:"expandByScalar",value:function(n){return this.min.addScalar(-n),this.max.addScalar(n),this}},{key:"containsPoint",value:function(n){return!(n.x<this.min.x||n.x>this.max.x||n.y<this.min.y||n.y>this.max.y)}},{key:"containsBox",value:function(n){return this.min.x<=n.min.x&&n.max.x<=this.max.x&&this.min.y<=n.min.y&&n.max.y<=this.max.y}},{key:"getParameter",value:function(n,e){return e.set((n.x-this.min.x)/(this.max.x-this.min.x),(n.y-this.min.y)/(this.max.y-this.min.y))}},{key:"intersectsBox",value:function(n){return!(n.max.x<this.min.x||n.min.x>this.max.x||n.max.y<this.min.y||n.min.y>this.max.y)}},{key:"clampPoint",value:function(n,e){return e.copy(n).clamp(this.min,this.max)}},{key:"distanceToPoint",value:function(n){return Tp.copy(n).clamp(this.min,this.max).sub(n).length()}},{key:"intersect",value:function(n){return this.min.max(n.min),this.max.min(n.max),this}},{key:"union",value:function(n){return this.min.min(n.min),this.max.max(n.max),this}},{key:"translate",value:function(n){return this.min.add(n),this.max.add(n),this}},{key:"equals",value:function(n){return n.min.equals(this.min)&&n.max.equals(this.max)}}]),n}(),Dp=new Oo,Pp=new Oo,Fp=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo;g(this,n),this.start=e,this.end=t}return b(n,[{key:"set",value:function(n,e){return this.start.copy(n),this.end.copy(e),this}},{key:"copy",value:function(n){return this.start.copy(n.start),this.end.copy(n.end),this}},{key:"getCenter",value:function(n){return n.addVectors(this.start,this.end).multiplyScalar(.5)}},{key:"delta",value:function(n){return n.subVectors(this.end,this.start)}},{key:"distanceSq",value:function(){return this.start.distanceToSquared(this.end)}},{key:"distance",value:function(){return this.start.distanceTo(this.end)}},{key:"at",value:function(n,e){return this.delta(e).multiplyScalar(n).add(this.start)}},{key:"closestPointToPointParameter",value:function(n,e){Dp.subVectors(n,this.start),Pp.subVectors(this.end,this.start);var t=Pp.dot(Pp),o=Pp.dot(Dp)/t;return e&&(o=Qt(o,0,1)),o}},{key:"closestPointToPoint",value:function(n,e,t){var o=this.closestPointToPointParameter(n,e);return this.delta(t).multiplyScalar(o).add(this.start)}},{key:"applyMatrix4",value:function(n){return this.start.applyMatrix4(n),this.end.applyMatrix4(n),this}},{key:"equals",value:function(n){return n.start.equals(this.start)&&n.end.equals(this.end)}},{key:"clone",value:function(){return(new this.constructor).copy(this)}}]),n}(),jp=new Oo,Ip=function(n){U(t,n);var e=k(t);function t(n,o){var r;g(this,t),(r=e.call(this)).light=n,r.light.updateMatrixWorld(),r.matrix=n.matrixWorld,r.matrixAutoUpdate=!1,r.color=o;for(var a=new ya,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1],v=0,c=1;v<32;v++,c++){var s=v/32*Math.PI*2,l=c/32*Math.PI*2;i.push(Math.cos(s),Math.sin(s),1,Math.cos(l),Math.sin(l),1)}a.setAttribute("position",new la(i,3));var u=new Ms({fog:!1,toneMapped:!1});return r.cone=new js(a,u),r.add(r.cone),r.update(),r}return b(t,[{key:"dispose",value:function(){this.cone.geometry.dispose(),this.cone.material.dispose()}},{key:"update",value:function(){this.light.updateMatrixWorld();var n=this.light.distance?this.light.distance:1e3,e=n*Math.tan(this.light.angle);this.cone.scale.set(e,e,n),jp.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(jp),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}]),t}(Ar),Ep=new Oo,Op=new pr,Ap=new pr,Lp=function(n){U(t,n);var e=k(t);function t(n){var o;g(this,t);for(var r=Gp(n),a=new ya,i=[],v=[],c=new wo(0,0,1),s=new wo(0,1,0),l=0;l<r.length;l++){var u=r[l];u.parent&&u.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),v.push(c.r,c.g,c.b),v.push(s.r,s.g,s.b))}a.setAttribute("position",new la(i,3)),a.setAttribute("color",new la(v,3));var f=new Ms({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});return(o=e.call(this,a,f)).isSkeletonHelper=!0,o.type="SkeletonHelper",o.root=n,o.bones=r,o.matrix=n.matrixWorld,o.matrixAutoUpdate=!1,o}return b(t,[{key:"updateMatrixWorld",value:function(n){var e=this.bones,o=this.geometry,r=o.getAttribute("position");Ap.copy(this.root.matrixWorld).invert();for(var a=0,i=0;a<e.length;a++){var v=e[a];v.parent&&v.parent.isBone&&(Op.multiplyMatrices(Ap,v.matrixWorld),Ep.setFromMatrixPosition(Op),r.setXYZ(i,Ep.x,Ep.y,Ep.z),Op.multiplyMatrices(Ap,v.parent.matrixWorld),Ep.setFromMatrixPosition(Op),r.setXYZ(i+1,Ep.x,Ep.y,Ep.z),i+=2)}o.getAttribute("position").needsUpdate=!0,D(_(t.prototype),"updateMatrixWorld",this).call(this,n)}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(js);function Gp(n){var e=[];!0===n.isBone&&e.push(n);for(var t=0;t<n.children.length;t++)e.push.apply(e,Gp(n.children[t]));return e}var Np=function(n){U(t,n);var e=k(t);function t(n,o,r){var a;g(this,t);var i=new lu(o,4,2),v=new Kr({wireframe:!0,fog:!1,toneMapped:!1});return(a=e.call(this,i,v)).light=n,a.light.updateMatrixWorld(),a.color=r,a.type="PointLightHelper",a.matrix=a.light.matrixWorld,a.matrixAutoUpdate=!1,a.update(),a}return b(t,[{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}},{key:"update",value:function(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}]),t}(Oa),Bp=new Oo,qp=new wo,Vp=new wo,Wp=function(n){U(t,n);var e=k(t);function t(n,o,r){var a;g(this,t),(a=e.call(this)).light=n,a.light.updateMatrixWorld(),a.matrix=n.matrixWorld,a.matrixAutoUpdate=!1,a.color=r;var i=new vu(o);i.rotateY(.5*Math.PI),a.material=new Kr({wireframe:!0,fog:!1,toneMapped:!1}),void 0===a.color&&(a.material.vertexColors=!0);var v=i.getAttribute("position"),c=new Float32Array(3*v.count);return i.setAttribute("color",new ea(c,3)),a.add(new Oa(i,a.material)),a.update(),a}return b(t,[{key:"dispose",value:function(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}},{key:"update",value:function(){var n=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{var e=n.geometry.getAttribute("color");qp.copy(this.light.color),Vp.copy(this.light.groundColor);for(var t=0,o=e.count;t<o;t++){var r=t<o/2?qp:Vp;e.setXYZ(t,r.r,r.g,r.b)}e.needsUpdate=!0}n.lookAt(Bp.setFromMatrixPosition(this.light.matrixWorld).negate())}}]),t}(Ar),Hp=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:10,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:4473924,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:8947848;g(this,t),a=new wo(a),i=new wo(i);for(var v=r/2,c=o/r,s=o/2,l=[],u=[],f=0,p=0,m=-s;f<=r;f++,m+=c){l.push(-s,0,m,s,0,m),l.push(m,0,-s,m,0,s);var d=f===v?a:i;d.toArray(u,p),p+=3,d.toArray(u,p),p+=3,d.toArray(u,p),p+=3,d.toArray(u,p),p+=3}var h=new ya;h.setAttribute("position",new la(l,3)),h.setAttribute("color",new la(u,3));var x=new Ms({vertexColors:!0,toneMapped:!1});return(n=e.call(this,h,x)).type="GridHelper",n}return b(t,[{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(js),Xp=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:10,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:16,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:8,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:64,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4473924,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:8947848;g(this,t),v=new wo(v),c=new wo(c);var s=[],l=[];if(r>1)for(var u=0;u<r;u++){var f=u/r*(2*Math.PI),p=Math.sin(f)*o,m=Math.cos(f)*o;s.push(0,0,0),s.push(p,0,m);var d=1&u?v:c;l.push(d.r,d.g,d.b),l.push(d.r,d.g,d.b)}for(var h=0;h<a;h++)for(var x=1&h?v:c,y=o-o/a*h,b=0;b<i;b++){var U=b/i*(2*Math.PI),_=Math.sin(U)*y,w=Math.cos(U)*y;s.push(_,0,w),l.push(x.r,x.g,x.b),U=(b+1)/i*(2*Math.PI),_=Math.sin(U)*y,w=Math.cos(U)*y,s.push(_,0,w),l.push(x.r,x.g,x.b)}var S=new ya;S.setAttribute("position",new la(s,3)),S.setAttribute("color",new la(l,3));var M=new Ms({vertexColors:!0,toneMapped:!1});return(n=e.call(this,S,M)).type="PolarGridHelper",n}return b(t,[{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(js),Yp=new Oo,Zp=new Oo,Qp=new Oo,Jp=function(n){U(t,n);var e=k(t);function t(n,o,r){var a;g(this,t),(a=e.call(this)).light=n,a.light.updateMatrixWorld(),a.matrix=n.matrixWorld,a.matrixAutoUpdate=!1,a.color=r,void 0===o&&(o=1);var i=new ya;i.setAttribute("position",new la([-o,o,0,o,o,0,o,-o,0,-o,-o,0,-o,o,0],3));var v=new Ms({fog:!1,toneMapped:!1});return a.lightPlane=new Ds(i,v),a.add(a.lightPlane),(i=new ya).setAttribute("position",new la([0,0,0,0,0,1],3)),a.targetLine=new Ds(i,v),a.add(a.targetLine),a.update(),a}return b(t,[{key:"dispose",value:function(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}},{key:"update",value:function(){Yp.setFromMatrixPosition(this.light.matrixWorld),Zp.setFromMatrixPosition(this.light.target.matrixWorld),Qp.subVectors(Zp,Yp),this.lightPlane.lookAt(Zp),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Zp),this.targetLine.scale.z=Qp.length()}}]),t}(Ar),Kp=new Oo,$p=new Va,nm=function(n){U(t,n);var e=k(t);function t(n){var o;g(this,t);var r=new ya,a=new Ms({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],v=[],c={};function s(n,e){l(n),l(e)}function l(n){i.push(0,0,0),v.push(0,0,0),void 0===c[n]&&(c[n]=[]),c[n].push(i.length/3-1)}s("n1","n2"),s("n2","n4"),s("n4","n3"),s("n3","n1"),s("f1","f2"),s("f2","f4"),s("f4","f3"),s("f3","f1"),s("n1","f1"),s("n2","f2"),s("n3","f3"),s("n4","f4"),s("p","n1"),s("p","n2"),s("p","n3"),s("p","n4"),s("u1","u2"),s("u2","u3"),s("u3","u1"),s("c","t"),s("p","c"),s("cn1","cn2"),s("cn3","cn4"),s("cf1","cf2"),s("cf3","cf4"),r.setAttribute("position",new la(i,3)),r.setAttribute("color",new la(v,3)),(o=e.call(this,r,a)).type="CameraHelper",o.camera=n,o.camera.updateProjectionMatrix&&o.camera.updateProjectionMatrix(),o.matrix=n.matrixWorld,o.matrixAutoUpdate=!1,o.pointMap=c,o.update();var u=new wo(16755200),f=new wo(16711680),p=new wo(43775),m=new wo(16777215),d=new wo(3355443);return o.setColors(u,f,p,m,d),o}return b(t,[{key:"setColors",value:function(n,e,t,o,r){var a=this.geometry.getAttribute("color");a.setXYZ(0,n.r,n.g,n.b),a.setXYZ(1,n.r,n.g,n.b),a.setXYZ(2,n.r,n.g,n.b),a.setXYZ(3,n.r,n.g,n.b),a.setXYZ(4,n.r,n.g,n.b),a.setXYZ(5,n.r,n.g,n.b),a.setXYZ(6,n.r,n.g,n.b),a.setXYZ(7,n.r,n.g,n.b),a.setXYZ(8,n.r,n.g,n.b),a.setXYZ(9,n.r,n.g,n.b),a.setXYZ(10,n.r,n.g,n.b),a.setXYZ(11,n.r,n.g,n.b),a.setXYZ(12,n.r,n.g,n.b),a.setXYZ(13,n.r,n.g,n.b),a.setXYZ(14,n.r,n.g,n.b),a.setXYZ(15,n.r,n.g,n.b),a.setXYZ(16,n.r,n.g,n.b),a.setXYZ(17,n.r,n.g,n.b),a.setXYZ(18,n.r,n.g,n.b),a.setXYZ(19,n.r,n.g,n.b),a.setXYZ(20,n.r,n.g,n.b),a.setXYZ(21,n.r,n.g,n.b),a.setXYZ(22,n.r,n.g,n.b),a.setXYZ(23,n.r,n.g,n.b),a.setXYZ(24,e.r,e.g,e.b),a.setXYZ(25,e.r,e.g,e.b),a.setXYZ(26,e.r,e.g,e.b),a.setXYZ(27,e.r,e.g,e.b),a.setXYZ(28,e.r,e.g,e.b),a.setXYZ(29,e.r,e.g,e.b),a.setXYZ(30,e.r,e.g,e.b),a.setXYZ(31,e.r,e.g,e.b),a.setXYZ(32,t.r,t.g,t.b),a.setXYZ(33,t.r,t.g,t.b),a.setXYZ(34,t.r,t.g,t.b),a.setXYZ(35,t.r,t.g,t.b),a.setXYZ(36,t.r,t.g,t.b),a.setXYZ(37,t.r,t.g,t.b),a.setXYZ(38,o.r,o.g,o.b),a.setXYZ(39,o.r,o.g,o.b),a.setXYZ(40,r.r,r.g,r.b),a.setXYZ(41,r.r,r.g,r.b),a.setXYZ(42,r.r,r.g,r.b),a.setXYZ(43,r.r,r.g,r.b),a.setXYZ(44,r.r,r.g,r.b),a.setXYZ(45,r.r,r.g,r.b),a.setXYZ(46,r.r,r.g,r.b),a.setXYZ(47,r.r,r.g,r.b),a.setXYZ(48,r.r,r.g,r.b),a.setXYZ(49,r.r,r.g,r.b),a.needsUpdate=!0}},{key:"update",value:function(){var n=this.geometry,e=this.pointMap;$p.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),em("c",e,n,$p,0,0,-1),em("t",e,n,$p,0,0,1),em("n1",e,n,$p,-1,-1,-1),em("n2",e,n,$p,1,-1,-1),em("n3",e,n,$p,-1,1,-1),em("n4",e,n,$p,1,1,-1),em("f1",e,n,$p,-1,-1,1),em("f2",e,n,$p,1,-1,1),em("f3",e,n,$p,-1,1,1),em("f4",e,n,$p,1,1,1),em("u1",e,n,$p,.7,1.1,-1),em("u2",e,n,$p,-.7,1.1,-1),em("u3",e,n,$p,0,2,-1),em("cf1",e,n,$p,-1,0,1),em("cf2",e,n,$p,1,0,1),em("cf3",e,n,$p,0,-1,1),em("cf4",e,n,$p,0,1,1),em("cn1",e,n,$p,-1,0,-1),em("cn2",e,n,$p,1,0,-1),em("cn3",e,n,$p,0,-1,-1),em("cn4",e,n,$p,0,1,-1),n.getAttribute("position").needsUpdate=!0}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(js);function em(n,e,t,o,r,a,i){Kp.set(r,a,i).unproject(o);var v=e[n];if(void 0!==v)for(var c=t.getAttribute("position"),s=0,l=v.length;s<l;s++)c.setXYZ(v[s],Kp.x,Kp.y,Kp.z)}var tm,om,rm=new Go,am=function(n){U(t,n);var e=k(t);function t(n){var o,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:16776960;g(this,t);var a=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),v=new ya;return v.setIndex(new ea(a,1)),v.setAttribute("position",new ea(i,3)),(o=e.call(this,v,new Ms({color:r,toneMapped:!1}))).object=n,o.type="BoxHelper",o.matrixAutoUpdate=!1,o.update(),o}return b(t,[{key:"update",value:function(n){if(void 0!==n&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&rm.setFromObject(this.object),!rm.isEmpty()){var e=rm.min,t=rm.max,o=this.geometry.attributes.position,r=o.array;r[0]=t.x,r[1]=t.y,r[2]=t.z,r[3]=e.x,r[4]=t.y,r[5]=t.z,r[6]=e.x,r[7]=e.y,r[8]=t.z,r[9]=t.x,r[10]=e.y,r[11]=t.z,r[12]=t.x,r[13]=t.y,r[14]=e.z,r[15]=e.x,r[16]=t.y,r[17]=e.z,r[18]=e.x,r[19]=e.y,r[20]=e.z,r[21]=t.x,r[22]=e.y,r[23]=e.z,o.needsUpdate=!0,this.geometry.computeBoundingSphere()}}},{key:"setFromObject",value:function(n){return this.object=n,this.update(),this}},{key:"copy",value:function(n,e){return D(_(t.prototype),"copy",this).call(this,n,e),this.object=n.object,this}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(js),im=function(n){U(t,n);var e=k(t);function t(n){var o,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:16776960;g(this,t);var a=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],v=new ya;return v.setIndex(new ea(a,1)),v.setAttribute("position",new la(i,3)),(o=e.call(this,v,new Ms({color:r,toneMapped:!1}))).box=n,o.type="Box3Helper",o.geometry.computeBoundingSphere(),o}return b(t,[{key:"updateMatrixWorld",value:function(n){var e=this.box;e.isEmpty()||(e.getCenter(this.position),e.getSize(this.scale),this.scale.multiplyScalar(.5),D(_(t.prototype),"updateMatrixWorld",this).call(this,n))}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(js),vm=function(n){U(t,n);var e=k(t);function t(n){var o,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:16776960;g(this,t);var i=a,v=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],c=new ya;c.setAttribute("position",new la(v,3)),c.computeBoundingSphere(),(o=e.call(this,c,new Ms({color:i,toneMapped:!1}))).type="PlaneHelper",o.plane=n,o.size=r;var s=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],l=new ya;return l.setAttribute("position",new la(s,3)),l.computeBoundingSphere(),o.add(new Oa(l,new Kr({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1}))),o}return b(t,[{key:"updateMatrixWorld",value:function(n){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),D(_(t.prototype),"updateMatrixWorld",this).call(this,n)}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}]),t}(Ds),cm=new Oo,sm=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new Oo(0,0,1),r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Oo(0,0,0),a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:16776960,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.2*a,c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.2*v;return g(this,t),(n=e.call(this)).type="ArrowHelper",void 0===tm&&((tm=new ya).setAttribute("position",new la([0,0,0,0,1,0],3)),(om=new yl(0,.5,1,5,1)).translate(0,-.5,0)),n.position.copy(r),n.line=new Ds(tm,new Ms({color:i,toneMapped:!1})),n.line.matrixAutoUpdate=!1,n.add(n.line),n.cone=new Oa(om,new Kr({color:i,toneMapped:!1})),n.cone.matrixAutoUpdate=!1,n.add(n.cone),n.setDirection(o),n.setLength(a,v,c),n}return b(t,[{key:"setDirection",value:function(n){if(n.y>.99999)this.quaternion.set(0,0,0,1);else if(n.y<-.99999)this.quaternion.set(1,0,0,0);else{cm.set(n.z,0,-n.x).normalize();var e=Math.acos(n.y);this.quaternion.setFromAxisAngle(cm,e)}}},{key:"setLength",value:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2*n,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.2*e;this.line.scale.set(1,Math.max(1e-4,n-e),1),this.line.updateMatrix(),this.cone.scale.set(t,e,t),this.cone.position.y=n,this.cone.updateMatrix()}},{key:"setColor",value:function(n){this.line.material.color.set(n),this.cone.material.color.set(n)}},{key:"copy",value:function(n){return D(_(t.prototype),"copy",this).call(this,n,!1),this.line.copy(n.line),this.cone.copy(n.cone),this}},{key:"dispose",value:function(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}]),t}(Ar),lm=function(n){U(t,n);var e=k(t);function t(){var n,o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;g(this,t);var r=[0,0,0,o,0,0,0,0,0,0,o,0,0,0,0,0,0,o],a=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new ya;i.setAttribute("position",new la(r,3)),i.setAttribute("color",new la(a,3));var v=new Ms({vertexColors:!0,toneMapped:!1});return(n=e.call(this,i,v)).type="AxesHelper",n}return b(t,[{key:"setColors",value:function(n,e,t){var o=new wo,r=this.geometry.attributes.color.array;return o.set(n),o.toArray(r,0),o.toArray(r,3),o.set(e),o.toArray(r,6),o.toArray(r,9),o.set(t),o.toArray(r,12),o.toArray(r,15),this.geometry.attributes.color.needsUpdate=!0,this}},{key:"dispose",value:function(){this.geometry.dispose(),this.material.dispose()}}]),t}(js),um=function(){function n(){g(this,n),this.type="ShapePath",this.color=new wo,this.subPaths=[],this.currentPath=null}return b(n,[{key:"moveTo",value:function(n,e){return this.currentPath=new dl,this.subPaths.push(this.currentPath),this.currentPath.moveTo(n,e),this}},{key:"lineTo",value:function(n,e){return this.currentPath.lineTo(n,e),this}},{key:"quadraticCurveTo",value:function(n,e,t,o){return this.currentPath.quadraticCurveTo(n,e,t,o),this}},{key:"bezierCurveTo",value:function(n,e,t,o,r,a){return this.currentPath.bezierCurveTo(n,e,t,o,r,a),this}},{key:"splineThru",value:function(n){return this.currentPath.splineThru(n),this}},{key:"toShapes",value:function(n){function e(n,e){for(var t=e.length,o=!1,r=t-1,a=0;a<t;r=a++){var i=e[r],v=e[a],c=v.x-i.x,s=v.y-i.y;if(Math.abs(s)>Number.EPSILON){if(s<0&&(i=e[a],c=-c,v=e[r],s=-s),n.y<i.y||n.y>v.y)continue;if(n.y===i.y){if(n.x===i.x)return!0}else{var l=s*(n.x-i.x)-c*(n.y-i.y);if(0===l)return!0;if(l<0)continue;o=!o}}else{if(n.y!==i.y)continue;if(v.x<=n.x&&n.x<=i.x||i.x<=n.x&&n.x<=v.x)return!0}}return o}var t,o,r,a=eu.isClockWise,i=this.subPaths;if(0===i.length)return[];var v=[];if(1===i.length)return o=i[0],(r=new Cl).curves=o.curves,v.push(r),v;var c=!a(i[0].getPoints());c=n?!c:c;var s,l,u=[],f=[],p=[],m=0;f[m]=void 0,p[m]=[];for(var d=0,h=i.length;d<h;d++)t=a(s=(o=i[d]).getPoints()),(t=n?!t:t)?(!c&&f[m]&&m++,f[m]={s:new Cl,p:s},f[m].s.curves=o.curves,c&&m++,p[m]=[]):p[m].push({h:o,p:s[0]});if(!f[0])return function(n){for(var e=[],t=0,o=n.length;t<o;t++){var r=n[t],a=new Cl;a.curves=r.curves,e.push(a)}return e}(i);if(f.length>1){for(var x=!1,g=0,y=0,b=f.length;y<b;y++)u[y]=[];for(var U=0,_=f.length;U<_;U++)for(var w=p[U],S=0;S<w.length;S++){for(var M=w[S],k=!0,z=0;z<f.length;z++)e(M.p,f[z].p)&&(U!==z&&g++,k?(k=!1,u[z].push(M)):x=!0);k&&u[U].push(M)}g>0&&!1===x&&(p=u)}for(var C=0,T=f.length;C<T;C++){r=f[C].s,v.push(r);for(var R=0,D=(l=p[C]).length;R<D;R++)r.holes.push(l[R].h)}return v}}]),n}(),fm=pm();function pm(){for(var n=new ArrayBuffer(4),e=new Float32Array(n),t=new Uint32Array(n),o=new Uint32Array(512),r=new Uint32Array(512),a=0;a<256;++a){var i=a-127;i<-27?(o[a]=0,o[256|a]=32768,r[a]=24,r[256|a]=24):i<-14?(o[a]=1024>>-i-14,o[256|a]=1024>>-i-14|32768,r[a]=-i-1,r[256|a]=-i-1):i<=15?(o[a]=i+15<<10,o[256|a]=i+15<<10|32768,r[a]=13,r[256|a]=13):i<128?(o[a]=31744,o[256|a]=64512,r[a]=24,r[256|a]=24):(o[a]=31744,o[256|a]=64512,r[a]=13,r[256|a]=13)}for(var v=new Uint32Array(2048),c=new Uint32Array(64),s=new Uint32Array(64),l=1;l<1024;++l){for(var u=l<<13,f=0;0===(8388608&u);)u<<=1,f-=8388608;u&=-8388609,f+=947912704,v[l]=u|f}for(var p=1024;p<2048;++p)v[p]=939524096+(p-1024<<13);for(var m=1;m<31;++m)c[m]=m<<23;c[31]=1199570944,c[32]=2147483648;for(var d=33;d<63;++d)c[d]=2147483648+(d-32<<23);c[63]=3347054592;for(var h=1;h<64;++h)32!==h&&(s[h]=1024);return{floatView:e,uint32View:t,baseTable:o,shiftTable:r,mantissaTable:v,exponentTable:c,offsetTable:s}}var mm=Object.freeze({__proto__:null,toHalfFloat:function(n){Math.abs(n)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),n=Qt(n,-65504,65504),fm.floatView[0]=n;var e=fm.uint32View[0],t=e>>23&511;return fm.baseTable[t]+((8388607&e)>>fm.shiftTable[t])},fromHalfFloat:function(n){var e=n>>10;return fm.uint32View[0]=fm.mantissaTable[fm.offsetTable[e]+(1023&n)]+fm.exponentTable[e],fm.floatView[0]}});function dm(){console.error("THREE.ImmediateRenderObject has been removed.")}var hm=function(n){U(t,n);var e=k(t);function t(n,o,r){var a;return g(this,t),console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'),(a=e.call(this,n,o,r)).samples=4,a}return b(t)}(Ro),xm=function(n){U(t,n);var e=k(t);function t(n,o,r,a){return g(this,t),console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."),e.call(this,n,o,r,a)}return b(t)}(Do),gm=function(n){U(t,n);var e=k(t);function t(n,o,r,a){return g(this,t),console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."),e.call(this,n,o,r,a)}return b(t)}(Fo),ym=function(n){U(t,n);var e=k(t);function t(n,o,r,a,i,v){return g(this,t),console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."),e.call(this,n,o,r,a,i,v)}return b(t)}(La),bm=function(n){U(t,n);var e=k(t);function t(n,o,r,a){return g(this,t),console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."),e.call(this,n,o,r,a)}return b(t)}(xl),Um=function(n){U(t,n);var e=k(t);function t(n,o,r,a){return g(this,t),console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."),e.call(this,n,o,r,a)}return b(t)}(gl),_m=function(n){U(t,n);var e=k(t);function t(n,o,r,a,i,v,c){return g(this,t),console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."),e.call(this,n,o,r,a,i,v,c)}return b(t)}(bl),wm=function(n){U(t,n);var e=k(t);function t(n,o,r,a,i,v,c,s){return g(this,t),console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."),e.call(this,n,o,r,a,i,v,c,s)}return b(t)}(yl),Sm=function(n){U(t,n);var e=k(t);function t(n,o){return g(this,t),console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."),e.call(this,n,o)}return b(t)}(_l),Mm=function(n){U(t,n);var e=k(t);function t(n,o){return g(this,t),console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."),e.call(this,n,o)}return b(t)}(ru),km=function(n){U(t,n);var e=k(t);function t(n,o){return g(this,t),console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."),e.call(this,n,o)}return b(t)}(iu),zm=function(n){U(t,n);var e=k(t);function t(n,o,r,a){return g(this,t),console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."),e.call(this,n,o,r,a)}return b(t)}(hl),Cm=function(n){U(t,n);var e=k(t);function t(n,o){return g(this,t),console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."),e.call(this,n,o)}return b(t)}(vu),Tm=function(n){U(t,n);var e=k(t);function t(n,o,r,a){return g(this,t),console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."),e.call(this,n,o,r,a)}return b(t)}(ai),Rm=function(n){U(t,n);var e=k(t);function t(n,o,r,a){return g(this,t),console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."),e.call(this,n,o,r,a)}return b(t)}(Ul),Dm=function(n){U(t,n);var e=k(t);function t(n,o,r,a,i,v){return g(this,t),console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."),e.call(this,n,o,r,a,i,v)}return b(t)}(cu),Pm=function(n){U(t,n);var e=k(t);function t(n,o){return g(this,t),console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."),e.call(this,n,o)}return b(t)}(su),Fm=function(n){U(t,n);var e=k(t);function t(n,o,r,a,i,v,c){return g(this,t),console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."),e.call(this,n,o,r,a,i,v,c)}return b(t)}(lu),jm=function(n){U(t,n);var e=k(t);function t(n,o){return g(this,t),console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."),e.call(this,n,o)}return b(t)}(uu),Im=function(n){U(t,n);var e=k(t);function t(n,o,r,a,i){return g(this,t),console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."),e.call(this,n,o,r,a,i)}return b(t)}(fu),Em=function(n){U(t,n);var e=k(t);function t(n,o,r,a,i,v){return g(this,t),console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."),e.call(this,n,o,r,a,i,v)}return b(t)}(pu),Om=function(n){U(t,n);var e=k(t);function t(n,o,r,a,i){return g(this,t),console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."),e.call(this,n,o,r,a,i)}return b(t)}(mu);"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:F}})),"undefined"!==typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=F);var Am=t(791),Lm=t(585);function Gm(n){var e,t=new Set,o=function(n,o){var r="function"===typeof n?n(e):n;if(r!==e){var a=e;e=o?r:Object.assign({},e,r),t.forEach((function(n){return n(e,a)}))}},r=function(){return e},a={setState:o,getState:r,subscribe:function(n,o,a){return o||a?function(n){var o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:r,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Object.is;console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");var i=o(e);function v(){var t=o(e);if(!a(i,t)){var r=i;n(i=t,r)}}return t.add(v),function(){return t.delete(v)}}(n,o,a):(t.add(n),function(){return t.delete(n)})},destroy:function(){return t.clear()}};return e=n(o,r,a),a}var Nm="undefined"===typeof window||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent)?Am.useEffect:Am.useLayoutEffect;var Bm=t(258),qm=t.n(Bm),Vm=t(545);function Wm(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(n,e){return n===e};if(n===e)return!0;if(!n||!e)return!1;var o=n.length;if(e.length!==o)return!1;for(var r=0;r<o;r++)if(!t(n[r],e[r]))return!1;return!0}var Hm=[];function Xm(n,e){var t,o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a=f(Hm);try{for(a.s();!(t=a.n()).done;){var i=t.value;if(Wm(e,i.keys,i.equal)){if(o)return;if(Object.prototype.hasOwnProperty.call(i,"error"))throw i.error;if(Object.prototype.hasOwnProperty.call(i,"response"))return i.response;if(!o)throw i.promise}}}catch(c){a.e(c)}finally{a.f()}var v={keys:e,equal:r.equal,promise:n.apply(void 0,x(e)).then((function(n){return v.response=n})).then((function(){r.lifespan&&r.lifespan>0&&setTimeout((function(){var n=Hm.indexOf(v);-1!==n&&Hm.splice(n,1)}),r.lifespan)})).catch((function(n){return v.error=n}))};if(Hm.push(v),!o)throw v.promise}var Ym,Zm,Qm=["children","key","ref"],Jm=["children","key","ref"],Km=["args","attach"],$m=["args","children"],nd=["args","children"],ed=["params"],td=function(n){return n&&n.isOrthographicCamera},od="undefined"!==typeof window&&(null!=(Ym=window.document)&&Ym.createElement||"ReactNative"===(null==(Zm=window.navigator)?void 0:Zm.product))?Am.useLayoutEffect:Am.useEffect;function rd(n){var e=Am.useRef(n);return od((function(){e.current=n}),[n]),e}function ad(n){var e=n.set;return od((function(){return e(new Promise((function(){return null}))),function(){return e(!1)}}),[e]),null}var id=function(n){U(t,n);var e=k(t);function t(){var n;g(this,t);for(var o=arguments.length,r=new Array(o),a=0;a<o;a++)r[a]=arguments[a];return(n=e.call.apply(e,[this].concat(r))).state={error:!1},n}return b(t,[{key:"componentDidCatch",value:function(n){this.props.set(n)}},{key:"render",value:function(){return this.state.error?null:this.props.children}}]),t}(Am.Component);id.getDerivedStateFromError=function(){return{error:!0}};var vd="__default";function cd(n){var e="undefined"!==typeof window?window.devicePixelRatio:1;return Array.isArray(n)?Math.min(Math.max(n[0],e),n[1]):n}var sd=function(n){var e;return null==(e=n.__r3f)?void 0:e.root.getState()},ld={obj:function(n){return n===Object(n)&&!ld.arr(n)&&"function"!==typeof n},fun:function(n){return"function"===typeof n},str:function(n){return"string"===typeof n},num:function(n){return"number"===typeof n},boo:function(n){return"boolean"===typeof n},und:function(n){return void 0===n},arr:function(n){return Array.isArray(n)},equ:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=t.arrays,r=void 0===o?"shallow":o,a=t.objects,i=void 0===a?"reference":a,v=t.strict,c=void 0===v||v;if(typeof n!==typeof e||!!n!==!!e)return!1;if(ld.str(n)||ld.num(n))return n===e;var s=ld.obj(n);if(s&&"reference"===i)return n===e;var l,u=ld.arr(n);if(u&&"reference"===r)return n===e;if((u||s)&&n===e)return!0;for(l in n)if(!(l in e))return!1;for(l in c?e:n)if(n[l]!==e[l])return!1;if(ld.und(l)){if(u&&0===n.length&&0===e.length)return!0;if(s&&0===Object.keys(n).length&&0===Object.keys(e).length)return!0;if(n!==e)return!1}return!0}};function ud(n){var e={nodes:{},materials:{}};return n&&n.traverse((function(n){n.name&&(e.nodes[n.name]=n),n.material&&!e.materials[n.material.name]&&(e.materials[n.material.name]=n.material)})),e}function fd(n,e){var t=n;return(null!=e&&e.primitive||!t.__r3f)&&(t.__r3f=u({type:"",root:null,previousAttach:null,memoizedProps:{},eventCount:0,handlers:{},objects:[],parent:null},e)),n}function pd(n,e){var t=n;if(e.includes("-")){var o=e.split("-"),r=o.pop();return t=o.reduce((function(n,e){return n[e]}),n),{target:t,key:r}}return{target:t,key:e}}var md=/-\d+$/;function dd(n,e,t){if(ld.str(t)){if(md.test(t)){var o=pd(n,t.replace(md,"")),r=o.target,a=o.key;Array.isArray(r[a])||(r[a]=[])}var i=pd(n,t),v=i.target,c=i.key;e.__r3f.previousAttach=v[c],v[c]=e}else e.__r3f.previousAttach=t(n,e)}function hd(n,e,t){var o,r;if(ld.str(t)){var a=pd(n,t),i=a.target,v=a.key,c=e.__r3f.previousAttach;void 0===c?delete i[v]:i[v]=c}else null==(o=e.__r3f)||null==o.previousAttach||o.previousAttach(n,e);null==(r=e.__r3f)||delete r.previousAttach}function xd(n,e){e.children,e.key,e.ref;var t,r=o(e,Qm),a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=(a.children,a.key,a.ref,o(a,Jm)),v=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=null!=(t=null==n?void 0:n.__r3f)?t:{},l=Object.entries(r),f=[];if(v)for(var p=Object.keys(i),m=0;m<p.length;m++)r.hasOwnProperty(p[m])||l.unshift([p[m],vd+"remove"]);l.forEach((function(e){var t,o=c(e,2),a=o[0],v=o[1];if((null==(t=n.__r3f)||!t.primitive||"object"!==a)&&!ld.equ(v,i[a])){if(/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(a))return f.push([a,v,!0,[]]);var s=[];for(var l in a.includes("-")&&(s=a.split("-")),f.push([a,v,!1,s]),r){var u=r[l];l.startsWith("".concat(a,"-"))&&f.push([l,u,!1,l.split("-")])}}}));var d=u({},r);return s.memoizedProps&&s.memoizedProps.args&&(d.args=s.memoizedProps.args),s.memoizedProps&&s.memoizedProps.attach&&(d.attach=s.memoizedProps.attach),{memoized:d,changes:f}}function gd(n,e){var t,o,a,s,l,u=null!=(t=n.__r3f)?t:{},f=u.root,p=null!=(o=null==f||null==f.getState?void 0:f.getState())?o:{},m=(s=e)&&s.memoized&&s.changes?e:xd(n,e),g=m.memoized,y=m.changes,b=u.eventCount;n.__r3f&&(n.__r3f.memoizedProps=g);for(var U=0;U<y.length;U++){var _,w=c(y[U],4),S=w[0],M=w[1],k=w[2],z=w[3],C=n,T=C[S];if(z.length&&(T=z.reduce((function(n,e){return n[e]}),n),!T||!T.set)){var R=z.reverse(),D=r(l=R)||h(l)||i(l)||v(),P=D[0];C=D.slice(1).reverse().reduce((function(n,e){return n[e]}),n),S=P}if(M===vd+"remove")if(T&&T.constructor)M=d(T.constructor,x(null!=(_=g.args)?_:[]));else if(C.constructor){var F,j=d(C.constructor,x(null!=(F=C.__r3f.memoizedProps.args)?F:[]));M=j[T],j.dispose&&j.dispose()}else M=0;if(k)M?u.handlers[S]=M:delete u.handlers[S],u.eventCount=Object.keys(u.handlers).length;else if(T&&T.set&&(T.copy||T instanceof Sr)){var I;if(Array.isArray(M))T.fromArray?T.fromArray(M):(I=T).set.apply(I,x(M));else if(T.copy&&M&&M.constructor&&T.constructor.name===M.constructor.name)T.copy(M);else if(void 0!==M){var E=T instanceof wo;!E&&T.setScalar?T.setScalar(M):T instanceof Sr&&M instanceof Sr?T.mask=M.mask:T.set(M);0}}else C[S]=M,!p.linear&&C[S]instanceof Co&&(C[S].encoding=ct);yd(n)}if(u.parent&&p.internal&&n.raycast&&b!==u.eventCount){var O=p.internal.interaction.indexOf(n);O>-1&&p.internal.interaction.splice(O,1),u.eventCount&&p.internal.interaction.push(n)}return y.length&&null!=(a=n.__r3f)&&a.parent&&bd(n),n}function yd(n){var e,t,o=null==(e=n.__r3f)||null==(t=e.root)||null==t.getState?void 0:t.getState();o&&0===o.internal.frames&&o.invalidate()}function bd(n){null==n.onUpdate||n.onUpdate(n)}function Ud(n,e){n.manual||(td(n)?(n.left=e.width/-2,n.right=e.width/2,n.top=e.height/2,n.bottom=e.height/-2):n.aspect=e.width/e.height,n.updateProjectionMatrix(),n.updateMatrixWorld())}function _d(n,e,t){var o=t.pop(),r=t.reduce((function(n,e){return n[e]}),n);return r[o]=e}function wd(n){return(n.eventObject||n.object).uuid+"/"+n.index+n.instanceId}function Sd(n,e,t,o){var r=t.get(e);r&&(t.delete(e),0===t.size&&(n.delete(o),r.target.releasePointerCapture(o)))}function Md(n){function e(n){return n.filter((function(n){return["Move","Over","Enter","Out","Leave"].some((function(e){var t;return null==(t=n.__r3f)?void 0:t.handlers["onPointer"+e]}))}))}function t(e){var t,o=n.getState().internal,r=f(o.hovered.values());try{var a=function(){var n=t.value;if(!e.length||!e.find((function(e){return e.object===n.object&&e.index===n.index&&e.instanceId===n.instanceId}))){var r=n.eventObject.__r3f,a=null==r?void 0:r.handlers;if(o.hovered.delete(wd(n)),null!=r&&r.eventCount){var i=u(u({},n),{},{intersections:e});null==a.onPointerOut||a.onPointerOut(i),null==a.onPointerLeave||a.onPointerLeave(i)}}};for(r.s();!(t=r.n()).done;)a()}catch(i){r.e(i)}finally{r.f()}}function o(n,e){for(var t=0;t<e.length;t++){var o=e[t].__r3f;null==o||null==o.handlers.onPointerMissed||o.handlers.onPointerMissed(n)}}return{handlePointer:function(r){switch(r){case"onPointerLeave":case"onPointerCancel":return function(){return t([])};case"onLostPointerCapture":return function(e){var o=n.getState().internal;"pointerId"in e&&o.capturedMap.has(e.pointerId)&&(o.capturedMap.delete(e.pointerId),t([]))}}return function(a){var i=n.getState(),v=i.onPointerMissed,c=i.internal;c.lastEvent.current=a;var s="onPointerMove"===r,l="onClick"===r||"onContextMenu"===r||"onDoubleClick"===r,p=function(e,t){for(var o=n.getState(),r=new Set,a=[],i=t?t(o.internal.interaction):o.internal.interaction,v=0;v<i.length;v++){var c=sd(i[v]);c&&(c.raycaster.camera=void 0)}o.previousRoot||null==o.events.compute||o.events.compute(e,o);var s=i.flatMap((function(n){var t,o=sd(n);return o&&o.events.enabled&&null!==o.raycaster.camera?(void 0===o.raycaster.camera&&(null==o.events.compute||o.events.compute(e,o,null==(t=o.previousRoot)?void 0:t.getState()),void 0===o.raycaster.camera&&(o.raycaster.camera=null)),o.raycaster.camera?o.raycaster.intersectObject(n,!0):[]):[]})).sort((function(n,e){var t=sd(n.object),o=sd(e.object);return t&&o&&o.events.priority-t.events.priority||n.distance-e.distance})).filter((function(n){var e=wd(n);return!r.has(e)&&(r.add(e),!0)}));o.events.filter&&(s=o.events.filter(s,o));var l,p=f(s);try{for(p.s();!(l=p.n()).done;)for(var m=l.value,d=m.object;d;){var h;null!=(h=d.__r3f)&&h.eventCount&&a.push(u(u({},m),{},{eventObject:d})),d=d.parent}}catch(b){p.e(b)}finally{p.f()}if("pointerId"in e&&o.internal.capturedMap.has(e.pointerId)){var x,g=f(o.internal.capturedMap.get(e.pointerId).values());try{for(g.s();!(x=g.n()).done;){var y=x.value;r.has(wd(y.intersection))||a.push(y.intersection)}}catch(b){g.e(b)}finally{g.f()}}return a}(a,s?e:void 0),m=l?function(e){var t=n.getState().internal,o=e.offsetX-t.initialClick[0],r=e.offsetY-t.initialClick[1];return Math.round(Math.sqrt(o*o+r*r))}(a):0;"onPointerDown"===r&&(c.initialClick=[a.offsetX,a.offsetY],c.initialHits=p.map((function(n){return n.eventObject}))),l&&!p.length&&m<=2&&(o(a,c.interaction),v&&v(a)),s&&t(p),function(e,o,r,a){var i=n.getState();e.length&&function(){var n,v={stopped:!1},c=f(e);try{var s=function(){var c=n.value,s=sd(c.object)||i,l=s.raycaster,f=s.pointer,p=s.camera,m=s.internal,d=new Oo(f.x,f.y,0).unproject(p),h=function(n){var e,t;return null!=(e=null==(t=m.capturedMap.get(n))?void 0:t.has(c.eventObject))&&e},g=function(n){var e={intersection:c,target:o.target};m.capturedMap.has(n)?m.capturedMap.get(n).set(c.eventObject,e):m.capturedMap.set(n,new Map([[c.eventObject,e]])),o.target.setPointerCapture(n)},y=function(n){var e=m.capturedMap.get(n);e&&Sd(m.capturedMap,c.eventObject,e,n)},b={};for(var U in o){var _=o[U];"function"!==typeof _&&(b[U]=_)}var w=u(u(u({},c),b),{},{pointer:f,intersections:e,stopped:v.stopped,delta:r,unprojectedPoint:d,ray:l.ray,camera:p,stopPropagation:function(){var n="pointerId"in o&&m.capturedMap.get(o.pointerId);if((!n||n.has(c.eventObject))&&(w.stopped=v.stopped=!0,m.hovered.size&&Array.from(m.hovered.values()).find((function(n){return n.eventObject===c.eventObject})))){var r=e.slice(0,e.indexOf(c));t([].concat(x(r),[c]))}},target:{hasPointerCapture:h,setPointerCapture:g,releasePointerCapture:y},currentTarget:{hasPointerCapture:h,setPointerCapture:g,releasePointerCapture:y},nativeEvent:o});if(a(w),!0===v.stopped)return"break"};for(c.s();!(n=c.n()).done&&"break"!==s(););}catch(l){c.e(l)}finally{c.f()}}()}(p,a,m,(function(n){var e=n.eventObject,t=e.__r3f,i=null==t?void 0:t.handlers;if(null!=t&&t.eventCount)if(s){if(i.onPointerOver||i.onPointerEnter||i.onPointerOut||i.onPointerLeave){var v=wd(n),u=c.hovered.get(v);u?u.stopped&&n.stopPropagation():(c.hovered.set(v,n),null==i.onPointerOver||i.onPointerOver(n),null==i.onPointerEnter||i.onPointerEnter(n))}null==i.onPointerMove||i.onPointerMove(n)}else{var f=i[r];f?l&&!c.initialHits.includes(e)||(o(a,c.interaction.filter((function(n){return!c.initialHits.includes(n)}))),f(n)):l&&c.initialHits.includes(e)&&o(a,c.interaction.filter((function(n){return!c.initialHits.includes(n)})))}}))}}}}var kd={};var zd,Cd=function(n){return!(null==n||!n.render)},Td=Am.createContext(null);function Rd(n,e){var t={callback:n};return e.add(t),function(){e.delete(t)}}var Dd,Pd,Fd=new Set,jd=new Set,Id=new Set;function Ed(n,e){if(n.size){var t,o=f(n.values());try{for(o.s();!(t=o.n()).done;){(0,t.value.callback)(e)}}catch(r){o.e(r)}finally{o.f()}}}function Od(n,e){switch(n){case"before":return Ed(Fd,e);case"after":return Ed(jd,e);case"tail":return Ed(Id,e)}}function Ad(n,e,t){var o=e.clock.getDelta();for("never"===e.frameloop&&"number"===typeof n&&(o=n-e.clock.elapsedTime,e.clock.oldTime=e.clock.elapsedTime,e.clock.elapsedTime=n),Dd=e.internal.subscribers,zd=0;zd<Dd.length;zd++)(Pd=Dd[zd]).ref.current(Pd.store.getState(),o,t);return!e.internal.priority&&e.gl.render&&e.gl.render(e.scene,e.camera),e.internal.frames=Math.max(0,e.internal.frames-1),"always"===e.frameloop?1:e.internal.frames}function Ld(){var n=Am.useContext(Td);if(!n)throw new Error("R3F: Hooks can only be used within the Canvas component!");return n}function Gd(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:function(n){return n},e=arguments.length>1?arguments[1]:void 0;return Ld()(n,e)}function Nd(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=Ld(),o=t.getState().internal.subscribe,r=rd(n);return od((function(){return o(r,e,t)}),[e,o,t]),null}function Bd(n,e){return function(t){var o=new t;n&&n(o);for(var r=arguments.length,a=new Array(r>1?r-1:0),i=1;i<r;i++)a[i-1]=arguments[i];return Promise.all(a.map((function(n){return new Promise((function(t,r){return o.load(n,(function(n){n.scene&&Object.assign(n,ud(n.scene)),t(n)}),e,(function(e){return r(new Error("Could not load ".concat(n,": ").concat(e.message,")")))}))}))})))}}function qd(n,e,t,o){var r=Array.isArray(e)?e:[e],a=function(n,e,t){return Xm(n,e,!1,t)}(Bd(t,o),[n].concat(x(r)),{equal:ld.equ});return Array.isArray(e)?a:a[0]}qd.preload=function(n,e,t){var o=Array.isArray(e)?e:[e];return function(n,e,t){Xm(n,e,!0,t)}(Bd(t),[n].concat(x(o)))},qd.clear=function(n,e){var t=Array.isArray(e)?e:[e];return function(n){if(void 0===n||0===n.length)Hm.splice(0,Hm.length);else{var e=Hm.find((function(e){return Wm(n,e.keys,e.equal)}));if(e){var t=Hm.indexOf(e);-1!==t&&Hm.splice(t,1)}}}([n].concat(x(t)))};var Vd=new Map,Wd=function(n){var e,t,o,r=!1;function a(i){t=requestAnimationFrame(a),r=!0,e=0,Od("before",i);var v,c=f(n.values());try{for(c.s();!(v=c.n()).done;){var s,l=v.value;!(o=l.store.getState()).internal.active||!("always"===o.frameloop||o.internal.frames>0)||null!=(s=o.gl.xr)&&s.isPresenting||(e+=Ad(i,o))}}catch(u){c.e(u)}finally{c.f()}if(Od("after",i),0===e)return Od("tail",i),r=!1,cancelAnimationFrame(t)}return{loop:a,invalidate:function e(t){var o,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(!t)return n.forEach((function(n){return e(n.store.getState())}),i);null!=(o=t.gl.xr)&&o.isPresenting||!t.internal.active||"never"===t.frameloop||(t.internal.frames=Math.min(60,t.internal.frames+i),r||(r=!0,requestAnimationFrame(a)))},advance:function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],o=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(t&&Od("before",e),o)Ad(e,o,r);else{var a,i=f(n.values());try{for(i.s();!(a=i.n()).done;){var v=a.value;Ad(e,v.store.getState())}}catch(c){i.e(c)}finally{i.f()}}t&&Od("after",e)}}}(Vd),Hd=Wd.invalidate,Xd=Wd.advance,Yd=function(n,e){function t(n,e,t){var r,a=e.args,i=void 0===a?[]:a,v=e.attach,c=o(e,Km),s="".concat(n[0].toUpperCase()).concat(n.slice(1));if("primitive"===n){if(void 0===c.object)throw new Error("R3F: Primitives without 'object' are invalid!");r=fd(c.object,{type:n,root:t,attach:v,primitive:!0})}else{var l=kd[s];if(!l)throw new Error("R3F: ".concat(s," is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively"));if(!Array.isArray(i))throw new Error("R3F: The args prop must be an array!");r=fd(d(l,x(i)),{type:n,root:t,attach:v,memoizedProps:{args:i}})}return void 0===r.__r3f.attach&&(r instanceof ya?r.__r3f.attach="geometry":r instanceof Jr&&(r.__r3f.attach="material")),"inject"!==s&&gd(r,c),r}function r(n,e){var t,o,r=!1;e&&(null!=(t=e.__r3f)&&t.attach?dd(n,e,e.__r3f.attach):e.isObject3D&&n.isObject3D&&(n.add(e),r=!0),r||null==(o=n.__r3f)||o.objects.push(e),e.__r3f||fd(e,{}),e.__r3f.parent=n,bd(e),yd(e))}function a(n,e,t){var o=!1;if(e){var r,a;if(null!=(r=e.__r3f)&&r.attach)dd(n,e,e.__r3f.attach);else if(e.isObject3D&&n.isObject3D){e.parent=n,e.dispatchEvent({type:"added"});var i=n.children.filter((function(n){return n!==e})),v=i.indexOf(t);n.children=[].concat(x(i.slice(0,v)),[e],x(i.slice(v))),o=!0}o||null==(a=n.__r3f)||a.objects.push(e),e.__r3f||fd(e,{}),e.__r3f.parent=n,bd(e),yd(e)}}function i(n,e){var t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];n&&x(n).forEach((function(n){return v(e,n,t)}))}function v(n,e,t){if(e){var o,r,a;if(e.__r3f&&(e.__r3f.parent=null),null!=(o=n.__r3f)&&o.objects&&(n.__r3f.objects=n.__r3f.objects.filter((function(n){return n!==e}))),null!=(r=e.__r3f)&&r.attach)hd(n,e,e.__r3f.attach);else if(e.isObject3D&&n.isObject3D){var v;n.remove(e),null!=(v=e.__r3f)&&v.root&&function(n,e){var t=n.getState().internal;t.interaction=t.interaction.filter((function(n){return n!==e})),t.initialHits=t.initialHits.filter((function(n){return n!==e})),t.hovered.forEach((function(n,o){n.eventObject!==e&&n.object!==e||t.hovered.delete(o)})),t.capturedMap.forEach((function(n,o){Sd(t.capturedMap,e,n,o)}))}(e.__r3f.root,e)}var c,s=null==(a=e.__r3f)?void 0:a.primitive,l=void 0===t?null!==e.dispose&&!s:t;if(!s)i(null==(c=e.__r3f)?void 0:c.objects,e,l),i(e.children,e,l);e.__r3f&&(delete e.__r3f.root,delete e.__r3f.objects,delete e.__r3f.handlers,delete e.__r3f.memoizedProps,s||delete e.__r3f),l&&e.dispose&&"Scene"!==e.type&&(0,Vm.unstable_scheduleCallback)(Vm.unstable_IdlePriority,(function(){try{e.dispose()}catch(n){}})),yd(n)}}var s=function(){return console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.")};return{reconciler:qm()({createInstance:t,removeChild:v,appendChild:r,appendInitialChild:r,insertBefore:a,supportsMutation:!0,isPrimaryRenderer:!1,supportsPersistence:!1,supportsHydration:!1,noTimeout:-1,appendChildToContainer:function(n,e){if(e){var t=n.getState().scene;t.__r3f&&(t.__r3f.root=n,r(t,e))}},removeChildFromContainer:function(n,e){e&&v(n.getState().scene,e)},insertInContainerBefore:function(n,e,t){if(e&&t){var o=n.getState().scene;o.__r3f&&a(o,e,t)}},getRootHostContext:function(){return null},getChildHostContext:function(n){return n},finalizeInitialChildren:function(n){var e,t=null!=(e=null==n?void 0:n.__r3f)?e:{};return Boolean(t.handlers)},prepareUpdate:function(n,e,t,r){if(n.__r3f.primitive&&r.object&&r.object!==n)return[!0];var a=r.args,i=void 0===a?[]:a,v=(r.children,o(r,$m)),c=t.args,s=void 0===c?[]:c,l=(t.children,o(t,nd));if(!Array.isArray(i))throw new Error("R3F: the args prop must be an array!");if(i.some((function(n,e){return n!==s[e]})))return[!0];var u=xd(n,v,l,!0);return u.changes.length?[!1,u]:null},commitUpdate:function(n,e,o,a,i,s){var l=c(e,2),u=l[0],p=l[1];u?function(n,e,o,a){var i,c=null==(i=n.__r3f)?void 0:i.parent;if(c){var s=t(e,o,n.__r3f.root);if(n.children){var l,u=f(n.children);try{for(u.s();!(l=u.n()).done;){var p=l.value;p.__r3f&&r(s,p)}}catch(m){u.e(m)}finally{u.f()}n.children=n.children.filter((function(n){return!n.__r3f}))}n.__r3f.objects.forEach((function(n){return r(s,n)})),n.__r3f.objects=[],v(c,n),r(c,s),s.raycast&&s.__r3f.eventCount&&s.__r3f.root.getState().internal.interaction.push(s),[a,a.alternate].forEach((function(n){null!==n&&(n.stateNode=s,n.ref&&("function"===typeof n.ref?n.ref(s):n.ref.current=s))}))}}(n,o,i,s):gd(n,p)},commitMount:function(n,e,t,o){var r,a=null!=(r=n.__r3f)?r:{};n.raycast&&a.handlers&&a.eventCount&&n.__r3f.root.getState().internal.interaction.push(n)},getPublicInstance:function(n){return n},prepareForCommit:function(){return null},preparePortalMount:function(n){return fd(n.getState().scene)},resetAfterCommit:function(){},shouldSetTextContent:function(){return!1},clearContainer:function(){return!1},hideInstance:function(n){var e,t=null!=(e=n.__r3f)?e:{},o=t.attach,r=t.parent;o&&r&&hd(r,n,o),n.isObject3D&&(n.visible=!1),yd(n)},unhideInstance:function(n,e){var t,o=null!=(t=n.__r3f)?t:{},r=o.attach,a=o.parent;r&&a&&dd(a,n,r),(n.isObject3D&&null==e.visible||e.visible)&&(n.visible=!0),yd(n)},createTextInstance:s,hideTextInstance:s,unhideTextInstance:s,getCurrentEventPriority:function(){return e?e():Lm.DefaultEventPriority},beforeActiveInstanceBlur:function(){},afterActiveInstanceBlur:function(){},detachDeletedInstance:function(){},now:"undefined"!==typeof performance&&ld.fun(performance.now)?performance.now:ld.fun(Date.now)?Date.now:function(){return 0},scheduleTimeout:ld.fun(setTimeout)?setTimeout:void 0,cancelTimeout:ld.fun(clearTimeout)?clearTimeout:void 0}),applyProps:gd}}(0,(function(){var n,e="undefined"!==typeof self&&self||"undefined"!==typeof window&&window;if(!e)return Lm.DefaultEventPriority;switch(null==(n=e.event)?void 0:n.type){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return Lm.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return Lm.ContinuousEventPriority;default:return Lm.DefaultEventPriority}})),Zd=Yd.reconciler,Qd=Yd.applyProps,Jd={objects:"shallow",strict:!1},Kd=function(n,e){var t="function"===typeof n?n(e):n;return Cd(t)?t:new jc(u({powerPreference:"high-performance",canvas:e,antialias:!0,alpha:!0},n))};function $d(n,e){if(e)return e;if(n instanceof HTMLCanvasElement&&n.parentElement){var t=n.parentElement.getBoundingClientRect();return{width:t.width,height:t.height,top:t.top,left:t.left}}return{width:0,height:0,top:0,left:0}}function nh(n){var t=Vd.get(n),r=null==t?void 0:t.fiber,a=null==t?void 0:t.store;t&&console.warn("R3F.createRoot should only be called once!");var i,v="function"===typeof reportError?reportError:console.error,s=a||function(n,e){var t=function(n){var e="function"===typeof n?Gm(n):n,t=function(){var n,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:e.getState,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Object.is,r=c((0,Am.useReducer)((function(n){return n+1}),0),2)[1],a=e.getState(),i=(0,Am.useRef)(a),v=(0,Am.useRef)(t),s=(0,Am.useRef)(o),l=(0,Am.useRef)(!1),u=(0,Am.useRef)();void 0===u.current&&(u.current=t(a));var f=!1;(i.current!==a||v.current!==t||s.current!==o||l.current)&&(n=t(a),f=!o(u.current,n)),Nm((function(){f&&(u.current=n),i.current=a,v.current=t,s.current=o,l.current=!1}));var p=(0,Am.useRef)(a);Nm((function(){var n=function(){try{var n=e.getState(),t=v.current(n);s.current(u.current,t)||(i.current=n,u.current=t,r())}catch(o){l.current=!0,r()}},t=e.subscribe(n);return e.getState()!==p.current&&n(),t}),[]);var m=f?n:u.current;return(0,Am.useDebugValue)(m),m};return Object.assign(t,e),t[Symbol.iterator]=function(){console.warn("[useStore, api] = create() is deprecated and will be removed in v4");var n=[t,e];return{next:function(){var e=n.length<=0;return{value:n.shift(),done:e}}}},t}((function(t,o){var r=new Oo,a=new Oo,i=new Oo;function v(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:o().camera,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:a,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:o().size,v=t.width,c=t.height,s=t.top,l=t.left,u=v/c;e instanceof Oo?i.copy(e):i.set.apply(i,x(e));var f=n.getWorldPosition(r).distanceTo(i);if(td(n))return{width:v/n.zoom,height:c/n.zoom,top:s,left:l,factor:1,distance:f,aspect:u};var p=n.fov*Math.PI/180,m=2*Math.tan(p/2)*f,d=m*(v/c);return{width:d,height:m,top:s,left:l,factor:v/d,distance:f,aspect:u}}var c=void 0,s=function(n){return t((function(e){return{performance:u(u({},e.performance),{},{current:n})}}))},l=new ao,f={set:t,get:o,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},xr:null,invalidate:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return n(o(),e)},advance:function(n,t){return e(n,t,o())},legacy:!1,linear:!1,flat:!1,scene:fd(new Lc),controls:null,clock:new Hf,pointer:l,mouse:l,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:function(){var n=o();c&&clearTimeout(c),n.performance.current!==n.performance.min&&s(n.performance.min),c=setTimeout((function(){return s(o().performance.max)}),n.performance.debounce)}},size:{width:0,height:0,top:0,left:0,updateStyle:!1},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:v},setEvents:function(n){return t((function(e){return u(u({},e),{},{events:u(u({},e.events),n)})}))},setSize:function(n,e,r,i,c){var s=o().camera,l={width:n,height:e,top:i||0,left:c||0,updateStyle:r};t((function(n){return{size:l,viewport:u(u({},n.viewport),v(s,a,l))}}))},setDpr:function(n){return t((function(e){var t=cd(n);return{viewport:u(u({},e.viewport),{},{dpr:t,initialDpr:e.viewport.initialDpr||t})}}))},setFrameloop:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"always",e=o().clock;e.stop(),e.elapsedTime=0,"never"!==n&&(e.start(),e.elapsedTime=0),t((function(){return{frameloop:n}}))},previousRoot:void 0,internal:{active:!1,priority:0,frames:0,lastEvent:Am.createRef(),interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,subscribe:function(n,e,t){var r=o().internal;return r.priority=r.priority+(e>0?1:0),r.subscribers.push({ref:n,priority:e,store:t}),r.subscribers=r.subscribers.sort((function(n,e){return n.priority-e.priority})),function(){var t=o().internal;null!=t&&t.subscribers&&(t.priority=t.priority-(e>0?1:0),t.subscribers=t.subscribers.filter((function(e){return e.ref!==n})))}}}};return f})),o=t.getState(),r=o.size,a=o.viewport.dpr,i=o.camera;return t.subscribe((function(){var n=t.getState(),e=n.camera,o=n.size,v=n.viewport,c=n.gl,s=n.set;o===r&&v.dpr===a||(r=o,a=v.dpr,Ud(e,o),c.setPixelRatio(v.dpr),c.setSize(o.width,o.height,o.updateStyle)),e!==i&&(i=e,s((function(n){return{viewport:u(u({},n.viewport),n.viewport.getCurrentViewport(e))}})))})),t.subscribe((function(e){return n(e)})),t}(Hd,Xd),l=r||Zd.createContainer(s,Lm.ConcurrentRoot,null,!1,null,"",v,null);t||Vd.set(n,{fiber:l,store:s});var f=!1;return{configure:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=t.gl,a=t.size,v=t.events,c=t.onCreated,l=t.shadows,p=void 0!==l&&l,m=t.linear,d=void 0!==m&&m,h=t.flat,x=void 0!==h&&h,g=t.legacy,y=void 0!==g&&g,b=t.orthographic,U=void 0!==b&&b,_=t.frameloop,w=void 0===_?"always":_,S=t.dpr,M=void 0===S?[1,2]:S,k=t.performance,z=t.raycaster,C=t.camera,T=t.onPointerMissed,R=s.getState(),D=R.gl;R.gl||R.set({gl:D=Kd(r,n)});var P=R.raycaster;P||R.set({raycaster:P=new Sp});var F=z||{},j=F.params,I=o(F,ed);if(ld.equ(I,P,Jd)||Qd(P,u({},I)),ld.equ(j,P.params,Jd)||Qd(P,{params:u(u({},P.params),j)}),!R.camera){var E=C instanceof Va,O=E?C:U?new di(0,0,0,0,.1,1e3):new Wa(75,0,.1,1e3);E||(O.position.z=5,C&&Qd(O,C),null!=C&&C.rotation||O.lookAt(0,0,0)),R.set({camera:O})}if(!R.xr){var A=function(n,e){var t=s.getState();"never"!==t.frameloop&&Xd(n,!0,t,e)},L=function(){var n=s.getState();n.gl.xr.enabled=n.gl.xr.isPresenting,n.gl.xr.setAnimationLoop(n.gl.xr.isPresenting?A:null),n.gl.xr.isPresenting||Hd(n)},G={connect:function(){var n=s.getState().gl;n.xr.addEventListener("sessionstart",L),n.xr.addEventListener("sessionend",L)},disconnect:function(){var n=s.getState().gl;n.xr.removeEventListener("sessionstart",L),n.xr.removeEventListener("sessionend",L)}};D.xr&&G.connect(),R.set({xr:G})}if(D.shadowMap){var N=ld.boo(p);if(N&&D.shadowMap.enabled!==p||!ld.equ(p,D.shadowMap,Jd)){var q=D.shadowMap.enabled;D.shadowMap.enabled=!!p,N?D.shadowMap.type=B:Object.assign(D.shadowMap,p),q!==D.shadowMap.enabled&&(D.shadowMap.needsUpdate=!0)}}_d(e,y,["ColorManagement","legacyMode"]);var V=d?vt:ct,W=x?zn:Dn;D.outputEncoding!==V&&(D.outputEncoding=V),D.toneMapping!==W&&(D.toneMapping=W),R.legacy!==y&&R.set((function(){return{legacy:y}})),R.linear!==d&&R.set((function(){return{linear:d}})),R.flat!==x&&R.set((function(){return{flat:x}})),!r||ld.fun(r)||Cd(r)||ld.equ(r,D,Jd)||Qd(D,r),v&&!R.events.handlers&&R.set({events:v(s)}),M&&R.viewport.dpr!==cd(M)&&R.setDpr(M);var H=$d(n,a);return ld.equ(H,R.size,Jd)||R.setSize(H.width,H.height,H.updateStyle,H.top,H.left),R.frameloop!==w&&R.setFrameloop(w),R.onPointerMissed||R.set({onPointerMissed:T}),k&&!ld.equ(k,R.performance,Jd)&&R.set((function(n){return{performance:u(u({},n.performance),k)}})),i=c,f=!0,this},render:function(e){return f||this.configure(),Zd.updateContainer(Am.createElement(eh,{store:s,children:e,onCreated:i,rootElement:n}),l,null,(function(){})),s},unmount:function(){th(n)}}}function eh(n){var e=n.store,t=n.children,o=n.onCreated,r=n.rootElement;return od((function(){var n=e.getState();n.set((function(n){return{internal:u(u({},n.internal),{},{active:!0})}})),o&&o(n),e.getState().events.connected||null==n.events.connect||n.events.connect(r)}),[]),Am.createElement(Td.Provider,{value:e},t)}function th(n,e){var t=Vd.get(n),o=null==t?void 0:t.fiber;if(o){var r=null==t?void 0:t.store.getState();r&&(r.internal.active=!1),Zd.updateContainer(null,o,null,(function(){r&&setTimeout((function(){try{var t,o,a,i;null==r.events.disconnect||r.events.disconnect(),null==(t=r.gl)||null==(o=t.renderLists)||null==o.dispose||o.dispose(),null==(a=r.gl)||null==a.forceContextLoss||a.forceContextLoss(),null!=(i=r.gl)&&i.xr&&r.xr.disconnect(),function(n){for(var e in n.dispose&&"Scene"!==n.type&&n.dispose(),n)null==e.dispose||e.dispose(),delete n[e]}(r),Vd.delete(n),e&&e(n)}catch(v){}}),500)}))}}Zd.injectIntoDevTools({bundleType:0,rendererPackageName:"@react-three/fiber",version:Am.version});Am.unstable_act;function oh(){return oh=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(n[o]=t[o])}return n},oh.apply(this,arguments)}var rh=t(494),ah=t.n(rh);function ih(n){var e=void 0===n?{debounce:0,scroll:!1,offsetSize:!1}:n,t=e.debounce,o=e.scroll,r=e.polyfill,a=e.offsetSize,i=r||("undefined"===typeof window?b((function n(){g(this,n)})):window.ResizeObserver);if(!i)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");var v=c((0,Am.useState)({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),2),s=v[0],l=v[1],u=(0,Am.useRef)({element:null,scrollContainers:null,resizeObserver:null,lastBounds:s}),f=t?"number"===typeof t?t:t.scroll:null,p=t?"number"===typeof t?t:t.resize:null,m=(0,Am.useRef)(!1);(0,Am.useEffect)((function(){return m.current=!0,function(){m.current=!1}}));var d=c((0,Am.useMemo)((function(){var n=function(){if(u.current.element){var n=u.current.element.getBoundingClientRect(),e={left:n.left,top:n.top,width:n.width,height:n.height,bottom:n.bottom,right:n.right,x:n.x,y:n.y};u.current.element instanceof HTMLElement&&a&&(e.height=u.current.element.offsetHeight,e.width=u.current.element.offsetWidth),Object.freeze(e),m.current&&!sh(u.current.lastBounds,e)&&l(u.current.lastBounds=e)}};return[n,p?ah()(n,p):n,f?ah()(n,f):n]}),[l,a,f,p]),3),h=d[0],x=d[1],y=d[2];function U(){u.current.scrollContainers&&(u.current.scrollContainers.forEach((function(n){return n.removeEventListener("scroll",y,!0)})),u.current.scrollContainers=null),u.current.resizeObserver&&(u.current.resizeObserver.disconnect(),u.current.resizeObserver=null)}function _(){u.current.element&&(u.current.resizeObserver=new i(y),u.current.resizeObserver.observe(u.current.element),o&&u.current.scrollContainers&&u.current.scrollContainers.forEach((function(n){return n.addEventListener("scroll",y,{capture:!0,passive:!0})})))}var w,S,M;return w=y,S=Boolean(o),(0,Am.useEffect)((function(){if(S){var n=w;return window.addEventListener("scroll",n,{capture:!0,passive:!0}),function(){window.removeEventListener("scroll",n,!0)}}}),[w,S]),M=x,(0,Am.useEffect)((function(){var n=M;return window.addEventListener("resize",n),function(){window.removeEventListener("resize",n)}}),[M]),(0,Am.useEffect)((function(){U(),_()}),[o,y,x]),(0,Am.useEffect)((function(){return U}),[]),[function(n){n&&n!==u.current.element&&(U(),u.current.element=n,u.current.scrollContainers=vh(n),_())},s,h]}function vh(n){var e=[];if(!n||n===document.body)return e;var t=window.getComputedStyle(n);return[t.overflow,t.overflowX,t.overflowY].some((function(n){return"auto"===n||"scroll"===n}))&&e.push(n),[].concat(e,x(vh(n.parentElement)))}var ch=["x","y","top","bottom","left","right","width","height"],sh=function(n,e){return ch.every((function(t){return n[t]===e[t]}))},lh=Object.defineProperty,uh=Object.defineProperties,fh=Object.getOwnPropertyDescriptors,ph=Object.getOwnPropertySymbols,mh=Object.prototype.hasOwnProperty,dh=Object.prototype.propertyIsEnumerable,hh=function(n,e,t){return e in n?lh(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t},xh=function(n,e){for(var t in e||(e={}))mh.call(e,t)&&hh(n,t,e[t]);if(ph){var o,r=f(ph(e));try{for(r.s();!(o=r.n()).done;){t=o.value;dh.call(e,t)&&hh(n,t,e[t])}}catch(a){r.e(a)}finally{r.f()}}return n};function gh(n,e,t){if(n){if(!0===t(n))return n;for(var o=e?n.return:n.child;o;){var r=gh(o,e,t);if(r)return r;o=e?null:o.sibling}}}function yh(n){try{return Object.defineProperties(n,{_currentRenderer:{get:function(){return null},set:function(){}},_currentRenderer2:{get:function(){return null},set:function(){}}})}catch(e){return n}}var bh=yh(Am.createContext(null)),Uh=function(n){U(t,n);var e=k(t);function t(){return g(this,t),e.apply(this,arguments)}return b(t,[{key:"render",value:function(){return Am.createElement(bh.Provider,{value:this._reactInternals},this.props.children)}}]),t}(Am.Component),_h=Am.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,wh=_h.ReactCurrentOwner,Sh=_h.ReactCurrentDispatcher;function Mh(){var n=Am.useContext(bh);if(!n)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");var e=Am.useId(),t=Am.useMemo((function(){var t;return null!=(t=wh.current)?t:gh(n,!1,(function(n){for(var t=n.memoizedState;t;){if(t.memoizedState===e)return!0;t=t.next}}))}),[n,e]);return t}var kh=[],zh=new WeakMap;function Ch(){var n,e=Mh();kh.splice(0,kh.length),gh(e,!0,(function(n){var e,t=null==(e=n.type)?void 0:e._context;t&&t!==bh&&kh.push(yh(t))}));var t,o=f(kh);try{for(o.s();!(t=o.n()).done;){var r=t.value,a=null==(n=Sh.current)?void 0:n.readContext(r);zh.set(r,a)}}catch(i){o.e(i)}finally{o.f()}return Am.useMemo((function(){return kh.reduce((function(n,e){return function(t){return Am.createElement(n,null,Am.createElement(e.Provider,(o=xh({},t),r={value:zh.get(e)},uh(o,fh(r)))));var o,r}}),(function(n){return Am.createElement(Uh,xh({},n))}))}),[])}var Th=["children","fallback","resize","style","gl","events","eventSource","eventPrefix","shadows","linear","flat","legacy","orthographic","frameloop","dpr","performance","raycaster","camera","onPointerMissed","onCreated"],Rh={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function Dh(n){var e=Md(n).handlePointer;return{priority:1,enabled:!0,compute:function(n,e,t){e.pointer.set(n.offsetX/e.size.width*2-1,-n.offsetY/e.size.height*2+1),e.raycaster.setFromCamera(e.pointer,e.camera)},connected:void 0,handlers:Object.keys(Rh).reduce((function(n,t){return u(u({},n),{},s({},t,e(t)))}),{}),connect:function(e){var t,o=n.getState(),r=o.set,a=o.events;null==a.disconnect||a.disconnect(),r((function(n){return{events:u(u({},n.events),{},{connected:e})}})),Object.entries(null!=(t=a.handlers)?t:[]).forEach((function(n){var t=c(n,2),o=t[0],r=t[1],a=c(Rh[o],2),i=a[0],v=a[1];e.addEventListener(i,r,{passive:v})}))},disconnect:function(){var e,t=n.getState(),o=t.set,r=t.events;r.connected&&(Object.entries(null!=(e=r.handlers)?e:[]).forEach((function(n){var e=c(n,2),t=e[0],o=e[1];if(r&&r.connected instanceof HTMLElement){var a=c(Rh[t],1)[0];r.connected.removeEventListener(a,o)}})),o((function(n){return{events:u(u({},n.events),{},{connected:void 0})}})))}}}var Ph=Am.forwardRef((function(n,t){var r=n.children,a=n.fallback,i=n.resize,v=n.style,s=n.gl,l=n.events,f=void 0===l?Dh:l,p=n.eventSource,m=n.eventPrefix,d=n.shadows,h=n.linear,x=n.flat,g=n.legacy,y=n.orthographic,b=n.frameloop,U=n.dpr,_=n.performance,w=n.raycaster,S=n.camera,M=n.onPointerMissed,k=n.onCreated,z=o(n,Th);Am.useMemo((function(){return n=e,void(kd=u(u({},kd),n));var n}),[]);var C=Ch(),T=c(ih(u({scroll:!0,debounce:{scroll:50,resize:0}},i)),2),R=T[0],D=T[1],P=Am.useRef(null),F=Am.useRef(null),j=c(Am.useState(null),2),I=j[0],E=j[1];Am.useImperativeHandle(t,(function(){return P.current}));var O=rd(M),A=c(Am.useState(!1),2),L=A[0],G=A[1],N=c(Am.useState(!1),2),B=N[0],q=N[1];if(L)throw L;if(B)throw B;var V=Am.useRef(null);D.width>0&&D.height>0&&I&&(V.current||(V.current=nh(I)),V.current.configure({gl:s,events:f,shadows:d,linear:h,flat:x,legacy:g,orthographic:y,frameloop:b,dpr:U,performance:_,raycaster:w,camera:S,size:D,onPointerMissed:function(){return null==O.current?void 0:O.current.apply(O,arguments)},onCreated:function(n){var e;null==n.events.connect||n.events.connect(p?(e=p)&&e.hasOwnProperty("current")?p.current:p:F.current),m&&n.setEvents({compute:function(n,e){var t=n[m+"X"],o=n[m+"Y"];e.pointer.set(t/e.size.width*2-1,-o/e.size.height*2+1),e.raycaster.setFromCamera(e.pointer,e.camera)}}),null==k||k(n)}}),V.current.render(Am.createElement(C,null,Am.createElement(id,{set:q},Am.createElement(Am.Suspense,{fallback:Am.createElement(ad,{set:G})},r))))),od((function(){E(P.current)}),[]),Am.useEffect((function(){if(I)return function(){return th(I)}}),[I]);var W=p?"none":"auto";return Am.createElement("div",oh({ref:F,style:u({position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:W},v)},z),Am.createElement("div",{ref:R,style:{width:"100%",height:"100%"}},Am.createElement("canvas",{ref:P,style:{display:"block"}},a)))})),Fh=Am.forwardRef((function(n,e){return Am.createElement(Uh,null,Am.createElement(Ph,oh({},n,{ref:e})))})),jh=t(250),Ih=function(n){var e,t=new Set,o=function(n,o){var r="function"===typeof n?n(e):n;if(!Object.is(r,e)){var a=e;e=(null!=o?o:"object"!==typeof r)?r:Object.assign({},e,r),t.forEach((function(n){return n(e,a)}))}},r=function(){return e},a={setState:o,getState:r,subscribe:function(n){return t.add(n),function(){return t.delete(n)}},destroy:function(){console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),t.clear()}};return e=n(o,r,a),a},Eh=function(n){return n?Ih(n):Ih},Oh=t(327).useSyncExternalStoreWithSelector,Ah=!1;var Lh=function(n){"function"!==typeof n&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");var e="function"===typeof n?Eh(n):n,t=function(n,t){return function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.getState,t=arguments.length>2?arguments[2]:void 0;t&&!Ah&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),Ah=!0);var o=Oh(n.subscribe,n.getState,n.getServerState||n.getState,e,t);return(0,Am.useDebugValue)(o),o}(e,n,t)};return Object.assign(t,e),t},Gh=function(n){return n?Lh(n):Lh},Nh=Gh((function(n,e){return{currentShader:Math.floor(600*Math.random())+1,information:!1,total:0,songPlaying:!1,songStartTime:0,songStatus:"off",startSong:function(){return n((function(n){return{songStatus:"playing"}})),n((function(n){return{songStartTime:Date.now()}})),n((function(n){return{songPlaying:!0}})),e().songStartTime},getSongTime:function(){return e().songStartTime},setSongOn:function(){},setSongOff:function(){n((function(n){return{songStartTime:0}}))},setCurrentShader:function(e){n((function(n){return{currentShader:e}}))},activateInformation:function(){n((function(n){return{information:!0}}))},deactivateInformation:function(){n((function(n){return{information:!1}}))},setTotal:function(e){n((function(n){return{total:e}}))}}})),Bh="\n\n    float sdNumHorizontal(vec2 p)\n    {\n        vec2 newUv = p;\n        newUv.x += 0.125;\n        newUv.y -= 0.25;\n        vec2 uv1 = newUv;\n        vec2 uv2 = newUv;\n        uv1 = Rot(uv1, PI * 0.5);\n        uv1 /= .5;\n        uv1 -= 1.;\n\n        uv2 = Rot(uv2, -PI* .5);\n        uv2 /= .5;\n        uv2 -= 1.;\n        float shape1 = sdEqTriangle(uv1, 0.15);\n        shape1 = 1. - smoothstep(0.1, 0.11, shape1);\n\n        float shape2 = sdBox(vec2(uv1.x + 0.5, uv1.y+0.75), vec2(0.33, 0.2815));\n        shape2 = 1. - smoothstep(0.1, 0.11, shape2);\n\n        float shape3 = sdEqTriangle(vec2(uv2.x, uv2.y-0.5), 0.15);\n        shape3 = 1. - smoothstep(0.1, 0.11, shape3);\n\n        return shape1 + shape2 + shape3;\n    }\n\n    float sdNumVertical(vec2 p){\n        vec2 newUv = p;\n        newUv.x += 0.125;\n        newUv.y -= 0.25;\n        vec2 uv1 = newUv;\n        vec2 uv3 = newUv;\n        vec2 uv4 = newUv;\n        uv1 = Rot(uv1, PI * 0.5);\n        uv1 /= .5;\n        uv1 -= 1.;\n\n        uv3 = Rot(uv3, PI * 1.5);\n        uv3 /= .5;\n        uv3 -= 1.;\n        uv3.x -= 0.2;\n        uv3.y += 0.1;\n\n        uv4 = Rot(uv4, PI * 1.5);\n        uv4 /= .5;\n        uv4 -= 1.;\n        uv4.y += 0.1;\n        uv4.x -= 0.52;\n\n        float shape1 = sdEqTriangle(vec2(uv1.x + 0.36125, uv1.y-0.01), 0.125);\n        shape1 = 1. - smoothstep(0.1, 0.11, shape1);\n\n        float shape4 = sdEqTriangle(vec2(uv3.x, uv3.y), 0.14);\n        shape4 = 1. - smoothstep(0.1, 0.11, shape4);\n\n        float shape5 = sdBox(vec2(uv1.x + 0.859, uv1.y+0.442), vec2(0.35, 0.325));\n        shape5 = 1. - smoothstep(0.1, 0.11, shape5);\n\n        float shape6 = sdEqTriangle(vec2(uv4), 0.14);\n        shape6 = 1. - smoothstep(0.1, 0.11, shape6);\n\n        float tri = ((shape4 + shape6 + shape1 ) );\n        float sq = sdBox(vec2(uv1.x + 0.859, uv1.y +0.442), vec2(0.3));\n        sq = 1. - smoothstep(0.1, 0.11, sq);\n        float shape7 = sdBox(vec2(uv1.x + 0.859, uv1.y+0.442), vec2(0.3));\n        shape7 = 1. - smoothstep(0.1, 0.11, shape7);\n\n        return tri ;\n    }\n\n    float numNine(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float triRB = sdEqTriangle(vec2(p3.x - 0.635, p3.y-0.265), 0.14);\n        triRB = 1. - smoothstep(0.1, 0.11, triRB);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeNine = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4 + triRB;\n\n        return shapeNine;\n    }\n\n    float numEight(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float triRB = sdEqTriangle(vec2(p3.x - 0.635, p3.y-0.265), 0.14);\n        triRB = 1. - smoothstep(0.1, 0.11, triRB);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        // shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeEight = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4;\n\n        return shapeEight;\n    }\n\n    float numSeven(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float triRB = sdEqTriangle(vec2(p3.x - 0.635, p3.y-0.265), 0.14);\n        triRB = 1. - smoothstep(0.1, 0.11, triRB);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeSeven = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4 + triR + triRB;\n\n        return shapeSeven;\n    }\n\n    float numSix(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        // shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeSix = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4;\n\n        return shapeSix;\n    }\n\n    float numFive(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeFive = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4;\n\n        return shapeFive;\n    }\n\n    float numFour(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float triRT = sdEqTriangle(vec2(p3.x + 0.79, p3.y-0.265), 0.14);\n        triRT = 1. - smoothstep(0.1, 0.11, triRT);\n\n        float triRB = sdEqTriangle(vec2(p3.x - 0.635, p3.y-0.265), 0.14);\n        triRB = 1. - smoothstep(0.1, 0.11, triRB);\n\n        float triLT = sdEqTriangle(vec2(p4.x - 0.79, p4.y-0.265), 0.14);\n        triLT = 1. - smoothstep(0.1, 0.11, triLT);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeFour = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4 + triRT + triRB + triLT;\n\n        return shapeFour;\n    }\n\n    float numThree(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        // shapevertical4 *= 0.1;\n        \n        float shapeThree = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4;\n\n        return shapeThree;\n    }\n\n    float numTwo(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        // shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        // shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n        // shapevertical3 *= 0.1;\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        shapevertical4 *= 0.1;\n        \n        float shapeTwo = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4;\n\n        return shapeTwo;\n    }\n\n    float numOne(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float triRT = sdEqTriangle(vec2(p3.x + 0.79, p3.y-0.265), 0.14);\n        triRT = 1. - smoothstep(0.1, 0.11, triRT);\n\n        float triRB = sdEqTriangle(vec2(p3.x - 0.635, p3.y-0.265), 0.14);\n        triRB = 1. - smoothstep(0.1, 0.11, triRB);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        \n        float shapeOne = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4 + triR + triRT + triRB;\n\n        return shapeOne;\n    }\n\n    float numZero(vec2 p){\n\n        vec2 p2 = p;\n        vec2 p3 = p;\n        vec2 p4 = p;\n        p = p * 1.5 - 0.25;\n        p.y -= 0.15;\n\n        p2 = Rot(p2, PI);\n        p2 = p2 * 1.5 - 0.25;\n\n        p3 = Rot(p3, -PI* .5);\n        p3 = p3 * 1.5 - 0.25;\n        p3 /= .5;\n        p3 -= 1.;\n\n        p4 = Rot(p4, PI* .5);\n        p4 = p4 * 1.5 - 0.25;\n        p4 /= .5;\n        p4 -= 1.;\n\n        float triR = sdEqTriangle(vec2(p3.x + 0.079, p3.y-0.265), 0.14);\n        triR = 1. - smoothstep(0.1, 0.11, triR);\n\n        float triL = sdEqTriangle(vec2(p4.x - 0.081, p4.y-0.265), 0.14);\n        triL = 1. - smoothstep(0.1, 0.11, triL);\n\n        float shapehorizontal = sdNumHorizontal(p);\n        // shapehorizontal *= 0.1;\n\n        float shapehorizontal2 = sdNumHorizontal(vec2(p.x, p.y + 0.36));\n        shapehorizontal2 *= 0.1;\n\n        float shapehorizontal3 = sdNumHorizontal(vec2(p.x, p.y + 0.72));\n        // shapehorizontal3 *= 0.1;\n\n        float shapevertical = sdNumVertical(p);\n        // shapevertical *= 0.1;\n\n        float shapevertical2 = sdNumVertical(vec2(p.x, p.y + 0.36));\n        // shapevertical2 *= 0.1;\n\n        float shapevertical3 = sdNumVertical(vec2(p2.x, p2.y + 0.29));\n\n        float shapevertical4 = sdNumVertical(vec2(p2.x, p2.y - 0.07));\n        \n        float shapeZero = shapehorizontal + shapehorizontal2 + shapehorizontal3 + shapevertical + shapevertical2 + shapevertical3 + shapevertical4 + triR + triL;\n\n        return shapeZero;\n    }\n\n    float sdZero(vec2 p)\n    {\n        vec2 p2 = p;\n        p2 *= 4.;\n        vec2 p3 = p2;\n        p3 = Rot(p3, PI);\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        float z1 = sdArc(vec2(p2.x - 2., p2.y - 2.4), vec2(a * 0.7, a * 0.7), .36, b * 0.85 );\n        float z2 = sdArc(vec2(p3.x+1., p3.y+0.61), vec2(a * 0.7, a * 0.7), .36, b * 0.85 );\n        z1 = 1. - smoothstep(0.01, 0.02, z1);\n        z2 = 1. - smoothstep(0.01, 0.02, z2);\n        float z3=sdRoundedBox((vec2(p.x+0.088, p.y)), vec2(0.082, 0.275), vec4(0.075));\n        float z4=sdRoundedBox((vec2(p.x-0.088, p.y)), vec2(0.082, 0.275), vec4(0.075));\n        return z1 + z2 + z3 + z4;\n    }\n\n    float sdOne(vec2 p)\n    {\n        p.x -= 0.15;\n        vec2 vUv2 = p;\n        p = p * 2. - 0.5;\n        vUv2 = Rot(vUv2, PI * -0.25);\n        float x1 = sdRoundedBox(vec2(p.x + 0.275, p.y), vec2(0.17, 0.85), vec4(0.1, 0.1, 0.1, 0.1));\n        float x2 = sdRoundedBox(vec2(vUv2.x + 0.24, vUv2.y + 0.05), vec2(0.07, 0.2), vec4(0.1, 0.075, 0.1, 0.075));\n        return x1 + x2;\n    }\n\n    float sdTwo(vec2 p)\n    {\n        p.x += 0.1;\n        vec2 p2 = p;\n        p = p * 2. - 0.5;\n        vec2 p3 = p;\n        p3 = p3 * 2. - 1.;\n        p3.x -= 0.5;\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        p3 = Rot(p3, PI * 1.85);\n        float x1 = sdArc(vec2(p3.x - 0.1, p3.y - 0.15), vec2(a * 0.8, a * 0.8), .35, b * 0.84 );\n        x1 = smoothstep(0.01, 0.02, x1);\n        p2 = Rot(p2, PI * -0.22);\n        float x2 = sdRoundedBox(vec2(p2.x - 0.122, p2.y - 0.05), vec2(0.075, 0.35), vec4(0.2, 0.1, 0.1, 0.1));\n        float x3 = sdRoundedBox(vec2(p.x - 0.25, p.y + 0.335), vec2(0.5, 0.155), vec4(0.1, 0.1, 0.1, 0.1));\n        return 1. - x1 + x2 + x3;\n    }\n\n    float sdThree(vec2 p)\n    {\n        p = p * 2. - 0.5;\n        p *= 1.2;\n        p.y += 0.125;\n        p = Rot(p, PI * -0.5);\n        p = p * 2. - 1.;\n        vec2 p2 = p;\n        vec2 p3 = p;\n        p2 = Rot(p2, PI * -0.7);\n        p3 = Rot(p3, PI * -0.7 * 2.);\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n\n        float x1 = sdArc(vec2(p.x, p.y), vec2(a * 0.8, a * 0.8), .45, b * 0.85 );\n        float x2 = sdArc(vec2(p.x + 0.9, p.y), vec2(a * 0.8, a * 0.8), .45, b * 0.85 );\n        float x3 = sdArc(vec2(p2.x - 1.2, p2.y - 0.39), vec2(a * 0.1, a * 0.1), .45, b * 0.85 );\n        float x4 = sdArc(vec2(p3.x - 0.43, p3.y - 1.99), vec2(a * 0.1, a * 0.1), .45, b * 0.85 );\n\n        x1 = 1. - smoothstep(0.01, 0.02, x1);\n        x2 = 1. - smoothstep(0.01, 0.02, x2);\n        x3 = 1. - smoothstep(0.01, 0.02, x3);\n        x4 = 1. - smoothstep(0.01, 0.02, x4);\n\n        return x1 + x2 + x3 + x4;\n    }\n\n    float sdFour(vec2 p)\n    {\n        float f1 = sdRoundedBox(vec2(p.x + 0.125, p.y - 0.09), vec2(0.07, 0.25), vec4(0.075));\n        float f2 = sdRoundedBox(vec2(p.x - 0.05, p.y + 0.), vec2(0.07, 0.425), vec4(0.075));\n        float f3 = sdRoundedBox(vec2(p.x + 0.00125, p.y - 0.0), vec2(0.3, 0.07), vec4(0.075));\n        return f1 + f2 + f3;\n    }\n\n    float sdFive(vec2 p)\n    {\n        p = p * 1.05;\n        p.x -= 0.05;\n        p.y -= 0.02;\n        float f1=sdRoundedBox((vec2(p.x+0.01, p.y-0.17)), vec2(0.275, 0.08), vec4(0.075));\n        float f2=sdRoundedBox((vec2(p.x + 0.03, p.y+0.17)), vec2(0.225, 0.08), vec4(0.075));\n        float f3=sdRoundedBox((vec2(p.x + 0.03, p.y+0.005)), vec2(0.245, 0.08), vec4(0.075));\n        float f4=sdRoundedBox((vec2(p.x+0.112, p.y-0.09)), vec2(0.08, 0.225), vec4(0.075));\n        vec2 p2 = p;\n        p2 = Rot(p2, PI * -0.5);\n        p2 *=4.;\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        float f5 = sdArc(vec2(p2.x - 2.35, p2.y - 2.09), vec2(a * 0.5, a * 0.5), .36, b * 0.85 );\n        f5 = 1. - smoothstep(0.0, 0.02, f5);\n        return f1 + f2 + f3 + f4 + f5;\n    }\n\n    float sdSix(vec2 p)\n    {\n        vec2 p2 = p;\n        vec2 p4 = p2;\n        p2 *= 4.;\n        vec2 p3 = p2;\n        p3 = Rot(p3, PI);\n        // p4 = Rot(p4, PI * 0.125);\n        p4 *= 4.;\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        float s1 = sdArc(vec2(p2.x - 2., p2.y - 1.7), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float s2 = sdArc(vec2(p3.x+1., p3.y+0.65), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float s3 = sdArc(vec2(p4.x - 1.945, p4.y - 2.35), vec2(a * 0.4, a * 0.4), .36, b * 0.82 );\n        s1 = 1. - smoothstep(0.01, 0.02, s1);\n        s2 = 1. - smoothstep(0.01, 0.02, s2);\n        s3 = 1. - smoothstep(0.01, 0.02, s3);\n        float s4=sdRoundedBox((vec2(p.x+0.092, p.y-0.035)), vec2(0.0725, 0.275), vec4(0.075));\n        return s1 + s2 + s3 + s4;\n    }\n\n    float sdSeven(vec2 p)\n    {\n        vec2 p2 = p;\n        float s1 = sdRoundedBox((vec2(p.x+0.01, p.y-0.17)), vec2(0.275, 0.08), vec4(0.075));\n        p2 = Rot(p2, PI * -0.127);\n        float s2 = sdRoundedBox((vec2(p2.x-0.016, p2.y+0.001)), vec2(0.08, 0.44), vec4(0.075));\n        return s1 + s2;\n    }\n\n    float sdEight(vec2 p)\n    {\n        p *= 4.;\n        vec2 p2 = p;\n        p2 = Rot(p2, PI);\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        float e1 = sdArc(vec2(p.x - 2., p.y - 1.7), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float e2 = sdArc(vec2(p2.x+1., p2.y+0.65), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float e3 = sdArc(vec2(p.x - 2., p.y - 2.45), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float e4 = sdArc(vec2(p2.x+1., p2.y+1.5 * 0.95), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        e1 = 1. - smoothstep(0.01, 0.02, e1);\n        e2 = 1. - smoothstep(0.01, 0.02, e2);\n        e3 = 1. - smoothstep(0.01, 0.02, e3);\n        e4 = 1. - smoothstep(0.01, 0.02, e4);\n        return e1 + e2 + e3 + e4;\n    }\n\n    float sdNine(vec2 p)\n    {\n        p = Rot(p, PI);\n        vec2 p2 = p;\n        vec2 p4 = p2;\n        p2 *= 4.;\n        vec2 p3 = p2;\n        p3 = Rot(p3, PI);\n        // p4 = Rot(p4, PI * 0.125);\n        p4 *= 4.;\n        float a = PI * (0.5 + 0.25);\n        float b = 0.2 *(0.5 + 0.5);\n        float n1 = sdArc(vec2(p2.x - 2., p2.y - 1.7), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float n2 = sdArc(vec2(p3.x+1., p3.y+0.65), vec2(a * 0.72, a * 0.72), .36, b * 0.82 );\n        float n3 = sdArc(vec2(p4.x - 1.945, p4.y - 2.35), vec2(a * 0.4, a * 0.4), .36, b * 0.82 );\n        n1 = 1. - smoothstep(0.01, 0.02, n1);\n        n2 = 1. - smoothstep(0.01, 0.02, n2);\n        n3 = 1. - smoothstep(0.01, 0.02, n3);\n        float n4=sdRoundedBox((vec2(p.x+0.092, p.y-0.035)), vec2(0.0725, 0.275), vec4(0.075));\n        return n1 + n2 + n3 + n4;\n    }\n",qh="\n    // #ifdef GL_ES\n    // precision highp float;\n    // #endif\n\n    precision highp float;\n\n    varying vec2 vUv;\n    #define PI 3.14159265359\n    #define TWO_PI 6.28318530718\n    uniform float u_time;\n    uniform vec2 u_resolution;\n    uniform vec2 u_mouse;\n",Vh="\n//iquilezles.org/articls/distfunctions2d\nfloat sdRoundedBox(vec2 p, vec2 b, vec4 r)\n{\n    //p - point\n    //b - size of box\n    //r - round box - top right, bottom right, top left, bottom left\n    p = p * 2.0 - 1.;\n    r.xy = (p.x > 0.0) ? r.xy : r.zw;\n    r.x = (p.y > 0.0) ? r.x : r.y;\n    vec2 q = abs(p)-b+r.x;\n    float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n    return 1. - smoothstep(0.01, 0.015, v);\n}\n\nfloat sdSpiral(vec2 p, float w, float k)\n{\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float n = floor(0.5/w + (log2(r/w)*k-a)/TWO_PI);\n    float ra = w * exp2((a+TWO_PI * (min(n+0., 0.) - 0.5))/k);\n    float rb = w * exp2((a+TWO_PI * (min(n+1., 0.) - 0.5))/k);\n    float d = min(abs(r-ra), abs(r-rb));\n    float spiral = min(d, length(p + vec2(w, 0.0)));\n    return 1. - smoothstep(0.01, 0.011, spiral);\n}\n\nfloat sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n{\n    //x - thickness\n    float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n    float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n    return (c - a);\n    \n}\n\nfloat sdBoxOutline(vec2 p, vec2 b)\n{\n    //p - point \n    //b -\n    p = p * 2.0 - 1.; \n    vec2 d = abs(p) - b;\n    float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n    float y = length(max(d, 0.0)) + min(max(d.x + 0.05, d.y + 0.05), 0.0);\n    // x = 1. - smoothstep(0.01, 0.02, x);\n    // y = 1. - smoothstep(0.01, 0.02, y);\n    return 1.  - smoothstep(0.01, 0.2, y / x);\n}\n\nfloat rect( vec2 vUv, float height, float width)\n{\n    float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.001, vUv.x);\n    float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.001, 1. - vUv.x);\n    float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.001, 1. - vUv.y);\n    float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.001, vUv.y);\n    // return left * right * top * bottom;\n    float x = left * right * top * bottom;\n    // float y = x ;\n    return x;\n}\n\nfloat rectOutline(vec2 vUv, float height, float width)\n{\n    float y = rect(vUv, height, width);\n    float x = rect(vUv, height + 0.01, width + 0.01);\n    return x - y;\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    //p - point \n    //b -\n    p = p * 2.0 - 1.; \n    vec2 d = abs(p) - b;\n    float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n    return smoothstep(0.01, 0.012, x);\n}\n\nfloat quadraticBezier (float x, vec2 a){\n    // adapted from BEZMATH.PS (1993)\n    // by Don Lancaster, SYNERGETICS Inc. \n    // http://www.tinaja.com/text/bezmath.html\n  \n    float epsilon = 0.00001;\n    a.x = clamp(a.x,0.0,1.0); \n    a.y = clamp(a.y,0.0,1.0); \n    if (a.x == 0.5){\n      a += epsilon;\n    }\n    \n    // solve t from x (an inverse operation)\n    float om2a = 1.0 - 2.0 * a.x;\n    float t = (sqrt(a.x*a.x + om2a*x) - a.x)/om2a;\n    float y = (1.0-2.0*a.y)*(t*t) + (2.0*a.y)*t;\n    return y;\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise2D(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nfloat IterateMandelbrot( in vec2 c )\n{\n    const float B = 256.0;\n\n    float n = 0.0;\n    vec2 z  = vec2(0.);\n    for( int i=0; i<120; i++ )\n    {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c; // z = z\xb2 + c\n        if( dot(z,z)>(B*B) ) break;\n        n += 1.0 * u_time;\n    }\n\n    // float sn = n - log(log(length(z))/log(B))/log(2.0); // smooth iteration count\n    float sn = n - log2(log2(dot(z,z))) + 4.0;  // equivalent optimized smooth iteration count\n    \n    return sn;\n}\n\nfloat plot(vec2 p, float line, float thickness)\n{\n    return smoothstep(line - thickness, line, p.y) -\n           smoothstep(line, line + thickness, p.y);\n}\n\nfloat sdCircle(vec2 p, float r)\n{\n    p = p * 2.0 - 1.;\n    float x = length(p) - r;\n    return 1. - smoothstep(0.01, 0.03, x);\n}\n\nfloat sdCircleOutline(vec2 p, float r)\n{\n    p = p * 2.0 - 1.;\n    float x = length(p) - r;\n    float y = length(p) - r + 0.05;\n    float x1 = 1. - smoothstep(0.01, 0.03, x);\n    float y1 = 1. - smoothstep(0.01, 0.03, y);\n    return x1 - y1;\n}\n\nfloat circle(vec2 vUv, float radius)\n{\n    vec2 dist = vUv - vec2(0.5);\n    return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n}\n\nfloat cirOutline(vec2 vUv, float r)\n{\n    vec2 dist = vUv - vec2(0.5);\n    float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n    // float b = 1. - smoothstep(r + 0.01 - ((r + 0.01)), r + 0.01 + ((r + 0.02)), dot(dist, dist) * 4.);\n    float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.01), r + 0.01 + ((r + 0.011) * 0.012), dot(dist, dist) * 4.);\n    return b - a;\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n    float v = length(pa - ba * h);\n    return 1. - smoothstep(0.01, 0.015, v);\n}\n\nvec2 Rot(vec2 vUv, float a){\n    vUv -= 0.5;\n    vUv = mat2(cos(a), -sin(a),\n            sin(a), cos(a)) * vUv;\n    vUv += 0.5;\n    return vUv;\n}\n\nfloat ndot(vec2 a, vec2 b)\n{\n    return a.x * b.x - a.y * b.y;\n}\n\nfloat sdRhombus(vec2 p, vec2 b)\n{\n    p = abs(p);\n    float h = clamp(ndot(b-2. *p, b) / dot(b, b), -1., 1.);\n    float d = length(p - 0.5* b*vec2(1.0-h, 1.0+h));\n    return d * sign(p.x * b.y + p.y * b.x - b.x*b.y);\n}\n\nfloat dot2(vec2 a)\n{\n    return dot(a.x, a.y);\n}\n\nfloat trapezoid(vec2 p, float r1, float r2, float he)\n{\n    vec2 k1 = vec2(r2, he);\n    vec2 k2 = vec2(r2-r1, 2.0 * he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x, (p.y<0.)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2 * clamp(dot(k1-p,k2)/dot2(k2), 0., 1.);\n    float s = (cb.x < 0. && ca.y<0.)? -1.: 1.;\n    return s*sqrt(min(dot(ca, ca),dot(cb, cb)));\n}\n\nfloat sdEqTriangle(vec2 p, float size)\n{\n    p = p / size;\n    float k = sqrt(3.);\n    p.x = abs(p.x) - 1.;\n    p.y = p.y + 1.0/k;\n    if(p.x+k*p.y > 0.)\n    {\n        p = vec2(p.x-k*p.y, -k*p.x-p.y)/2.0; \n    }\n    p.x -= clamp(p.x, -2., 0.);\n    return -length(p) * sign(p.y);\n}\n\nfloat sdEqTriangleOutline(vec2 p, float size)\n{\n    float x = 1. - sdEqTriangle(p, size);\n    float y = 1. - sdEqTriangle(p, size + 0.025);\n    x = smoothstep(0.01, 0.021, x);\n    y = smoothstep(0.01, 0.021, y);\n    return y - x;\n}\n\nfloat sdArc(vec2 p, vec2 sc, float ra, float rb){\n    //sc is arc's aperture\n    p.x = abs(p.x);\n    sc = vec2(sin(sc.x), cos(sc.y));\n    if (sc.y * p.x > sc.x * p.y){\n        return length(p - sc*ra) - rb;\n    }\n    else {\n        return abs(length(p) - ra) - rb;\n    }\n}\n\nfloat sdTriIsosceles(vec2 p, vec2 q)\n{\n    p = Rot(p, PI);\n    p.x = abs(p.x);\n    vec2 a = p - q * clamp(dot(p,q)/dot(q,q), 0.0, 1.0);\n    vec2 b = p - q * vec2( clamp(p.x/q.x, 0., 1.), 1.);\n    float s = -sign(q.y);\n    vec2 d = min(vec2(dot(a,a), s*(p.x*q.y-p.y*q.x)), \n                vec2(dot(b,b), s*(p.y-q.y)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdHexagram(vec2 p, float r)\n{\n    vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy, p), 0.0) * k.xy;\n    p -= 2.0 * min(dot(k.yx, p), 0.0) * k.yx;\n    p -= vec2(clamp(p.x, r*k.z, r*k.w), r);\n    return length(p) * sign(p.y);\n}\n\nfloat sdEgg(vec2 p, float ra, float rb)\n{\n    float k = sqrt(3.);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y < 0.0) ? length(vec2(p.x, p.y)) - r :\n            (k * (p.x + r) < p.y) ? length(vec2(p.x, p.y - k * r)) :\n            length(vec2(p.x + r, p.y)) -2.0 * r) - rb;\n}\n\nfloat sdPolygon(vec2 p, int sides, float scale)\n{\n    p = p * 2. - 1.;\n    float angle = atan(p.x, p.y) + PI;\n    float radius = TWO_PI/float(sides);\n    float d = cos(floor(.5 + angle/ radius) * radius - angle) * length(p);\n    return 1. - smoothstep(scale, scale + 0.01, d); \n}\n\nfloat sdPolygonOutline(vec2 p, int sides, float scale)\n{\n    float x = sdPolygon(p, sides, scale);\n    float y = sdPolygon(p, sides, scale + 0.05);\n    return y - x;\n}\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\nfloat cnoise(vec3 P){\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod(Pi0, 289.0);\n    Pi1 = mod(Pi1, 289.0);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 / 7.0;\n    vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 / 7.0;\n    vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n    return 2.2 * n_xyz;\n}\n\n",Wh=t(184),Hh=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Xh(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Hh,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Yh=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Zh(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Yh,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qh=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Jh(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Qh,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Kh=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $h(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Kh,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ex(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ox(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ax(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ix=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:ix,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ux(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function px(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ux(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _x=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //uniform float u_time;\n\n    //varying vec2 vUv;\n\n    void main(){\n        vec3 color = vec3(0.);\n        color = vec3(vUv.x, vUv.y, 0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_x,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Sx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float circleSDF(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float circleSDF2(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float circleSDF3(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float circleSDF4(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float circleSDF5(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float circleSDF6(vec2 vUv){\n        return length(vUv - .5) * 2.;\n    }\n    \n    float stroke(float x, float s, float w){\n        float d = step(s, x+w*.5) -\n                  step(s, x-w*.5);\n        return clamp(d, 0., 1.);\n    }\n    \n    \n    \n    void main(){\n        vec3 color = vec3(0.);\n    \n        color.rg += stroke(circleSDF(vec2(vUv.x + .125, vUv.y - 0.08)), 0.2, 0.03);\n        color.b += stroke(circleSDF2(vec2(vUv.x + .3 - .05, vUv.y - .2)), 0.2, 0.03);\n        color += stroke(circleSDF(vec2(vUv.x , vUv.y - .2)), 0.2, 0.03);\n        color.g += stroke(circleSDF(vec2(vUv.x - .124, vUv.y - .08)), 0.2, 0.03);\n        color.r += stroke(circleSDF(vec2(vUv.x  - .4 + .15, vUv.y - .2)), 0.2, 0.03);;\n        //color += stroke(circleSDF6(vec2(vUv)), 0.5, 0.02);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Mx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Sx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    void main(){\n        vec3 color = vec3(0.);\n        color.gb += vUv.x - (sin(u_time) ) * 0.35;\n        color.gb *= vUv.y - (sin(u_time) ) * 0.35;\n        color.gb -= 0.1;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Cx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n\n// 2D Random\nfloat random(in vec2 st){\n    return fract(sin(dot(st.xy,\n                vec2(12.9898,78.233)))\n            *43758.5453123);\n        }\n\nfloat noise(in vec2 st){\n    vec2 i=floor(st);\n    vec2 f=fract(st);\n    \n    // Four corners in 2D of a tile\n    float a=random(i);\n    float b=random(i+vec2(1.,0.));\n    float c=random(i+vec2(0.,1.));\n    float d=random(i+vec2(1.,1.));\n    \n    // Smooth Interpolation\n    \n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u=f*f*(3.-2.*f);\n    // u = smoothstep(0.,1.,f);\n    \n    // Mix 4 coorners percentages\n    return mix(a,b,u.x)+\n    (c-a)*u.y*(1.-u.x)+\n    (d-b)*u.x*u.y;\n}\n\nvoid main(){\n    vec3 color = vec3(0.);\n    vec2 pos = vec2(vUv * 5.);\n    float n = step(noise(pos + u_time), vUv.x);\n    float x = cnoise(vec3(n * vUv.y * u_time));\n    color += x * n - abs(sin(u_time));\n    color *= x + n + abs(sin(u_time));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Tx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Cx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Rx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float plot(vec2 vUv){\n        return smoothstep(0.02, 0.0, abs(vUv.y - vUv.x));\n    }\n    \n    float plot2(vec2 vUv){\n        return smoothstep(.02,0.,abs(1. - vUv.y-vUv.x));\n    }\n    \n    \n    void main(){\n        float y = (sin(vUv.x) + abs(cos(u_time)) - 0.5);\n        vec3 color = vec3(y);\n        float pct = plot(vUv);\n        float pct2=plot2(vUv);\n        color = (0.5 - pct) * color + pct* vec3(1., 0., 0.);\n        color+=(0.5 - pct2)*color+pct2*vec3(1.,0.,0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Dx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Rx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Px=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // float plot(vec2 st){\n//     return smoothstep(0.02, 0.0, abs(st.y - st.x));\n// }\n\nfloat plot2(vec2 st, float pct){\n    return smoothstep(pct - 0.02, pct, st.y) - \n            smoothstep(pct, pct + 0.02, st.y);\n}\n\n// float plot(vec2 vUv, float pct){\n//     return smoothstep(pct-0.02, pct, vUv.y) - \n//            smoothstep(pct, pct+0.02, vUv.y);\n// }\n\nvoid main(){\n    //float y = vUv.x;\n    //float y2 = pow(vUv.x, 20.0);\n    //float y2 = sqrt(vUv.x * PI);\n    //float y = smoothstep(vUv, y);\n    float y2 = smoothstep(0.01, 0.9, abs(vUv.x * sin(u_time)));\n\n    vec3 color = vec3(y2);\n\n    float pct2 = plot2(vUv, y2);\n    color = (1.0 - pct2) * color + pct2 * vec3(1., 0., 0.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Fx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Px,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float plot( vec2 st, float pct){\n        return smoothstep(pct - 0.02, pct, st.y) - \n               smoothstep(pct, pct + 0.02, st.y);\n    }\n    \n    void main(){\n        float y = abs(sin((vUv.x * PI) + u_time) * 0.5) ;\n        y /= abs(cos((vUv.y * PI) + u_time) * 0.5);\n        vec3 color = vec3(tan(y + u_time));\n        gl_FragColor = vec4(color, 0.2);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ix(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ex=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    void main(){\n        float y = smoothstep(0.2, 0.5, vUv.x) - smoothstep(0.5, 0.8, vUv.x);\n        y+= smoothstep(0.2, 0.5, vUv.y) - smoothstep(0.5, 0.8, vUv.y);\n        y -= abs(cos(u_time * 0.5));\n        vec3 color = vec3(abs(sin(y + u_time)));\n        color.x = sin(u_time);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ox(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Ex,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ax=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    void main(){\n        float y = step(distance(abs(sin(u_time)), abs(sin(PI))), vUv.x);\n        float x = step(distance(abs(sin(u_time)), abs(cos(PI))), vUv.y);\n        vec3 color = vec3(y * x);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Lx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Ax,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Gx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    void main(){\n        //float y=step(.5,vUv.x);\n        float y = step(abs(sin(u_time * 0.2)),vUv.y);\n        float x =step(abs(cos(u_time * 0.8)),vUv.x);\n        float z =step(abs(sin(u_time * 0.5)),vUv.y);\n    \n    \n        vec3 color=vec3(y, x, z);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Nx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Gx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Bx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float plot(vec2 st,float pct){\n        return abs(smoothstep(pct-.1,pct,st.y)-\n        smoothstep(pct,pct+.1,st.y));\n    }\n    \n    void main(){\n        float y = smoothstep(0.01, 0.99, vUv.x);\n        float x=smoothstep(.01,.99,vUv.y);\n        vec3 color = vec3(0.);\n    \n        float pct = plot(sin(vUv * u_time * PI),sin(y * u_time * 0.5 * PI));\n        float pct2 =plot(cos(vUv * u_time),cos(x * u_time * 0.5));\n    \n        color = (1. - pct) * color + pct * vec3(0., 1., 0.);\n        color *=(1.-pct2)*color+pct2*vec3(0.,1.,0.);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Bx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Vx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float plot(vec2 vUv, float pct){\n        return smoothstep(pct-0.01, pct, vUv.y) - \n                smoothstep(pct, pct + 0.1, vUv.y);\n    }\n    \n    \n    void main(){\n        float y = smoothstep(0.1 + abs(atan(u_time)), 0.9 - abs(atan(u_time)) , 0.5 + abs(tan(vUv.x * 20. * abs(cos(u_time * 0.25)))));\n        float x = smoothstep(0.9 - abs(atan(u_time)), 0.1 + abs(atan(u_time)),0.5 +  abs(tan(vUv.y * 20. *abs(cos(u_time * 0.25)))));\n        vec3 color = vec3(y * x);\n    \n        float pct = plot(vUv, (y * x) );\n        color = (1.0 - pct) * color + pct * vec3(0., 1., 0.);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Wx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Vx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Hx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    void main(){\n        float y = step(vUv.x, abs(cos((vUv.y + u_time))) * abs(cos((vUv.y + u_time) * 1.)) * abs(sin(vUv.y + u_time)) * abs(sin((vUv.y + u_time) * 2.)));\n        vec3  color = vec3(y);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Xx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Hx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Yx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    void main(){\n        float y = mod(cos(vUv.y * u_time) + 1., cos(PI +PI +sin(u_time)));\n        float x = mod(cos(vUv.x * u_time) + 1., cos(PI + PI +sin(u_time)));\n        vec3 color = vec3(y-x, x/y, x*y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Zx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Yx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 getRadialUv(vec2 vUv){\n        float angle = atan(vUv.x, vUv.y);\n        vec2 radialUv = vec2(0.);\n        radialUv.x = angle/(PI * 2. ) + .9 *abs(cos(u_time));\n        radialUv.y = 1. - pow(1. - length(vUv), 4.);\n        return radialUv;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv -= 0.5;\n        vec2 radialUv = getRadialUv(vUv);\n        vec2 color = vec2(radialUv);\n        gl_FragColor = vec4(color, 1., 0.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Jx(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Qx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Kx=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Exponential impulse iquilezles.org\nfloat expImpulse(float x, float k){\n    float h = k*x;\n    return h* exp(1.-h);\n}\n\n//sinc curve original iquilezles.org\n// float sinc(float x,float k)\n// {\n//     float a=PI*((k*x-1.);\n//     return sin(a)/a;\n// }\n\n//Sinc curve  - modified\nfloat sinc(float x, float k){\n    float a = PI * ((k*x - 0.5));\n    return abs(sin(a))/ abs(cos(a));\n}\n\nvoid main(){\n    // float y = expImpulse(vUv.x, vUv.y / sin(u_time * 0.02) * 10.0);\n    float y=sinc(sin(vUv.y * 20.), sin(u_time * 0.25));\n    float x=sinc(sin(vUv.x * 20.), sin(u_time * 0.25));\n    vec3 color = vec3(cos(y) + sin(x));\n    gl_FragColor = vec4(y * x + vUv.x, vUv.y, 0.5, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $x(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Kx,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ng=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float plot(vec2 st, float pct){\n        return  smoothstep( pct-0.02, pct, st.y) -\n                smoothstep( pct, pct+0.02, st.y);\n      }\n      \n      void main(){\n          float y = 0.1 * cos((10.0 * vUv.x) + (5. *  u_time));\n          float line = smoothstep(1. - clamp(distance(y + (sin(vUv.y)), 0.5) * 1., 0., 1.), 1., 0.99);\n          float line2 = smoothstep(1. - clamp(distance(y + (cos(vUv.y)), 0.5) * 1., 0., 1.), 1., 0.99);\n          vec3 color = vec3(line + line2);\n      \n          float pct = plot(vUv, sin(line));\n          color = (1. - line) * color + sin(pct) * vec3(0., 0., 0.);\n      \n          gl_FragColor = vec4(color, 1.);\n      }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function eg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:ng,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float sinc(float x, float k){\n        float a = PI * ((k * x) - 1.);\n        return sin(a)/a;\n    }\n    \n    //plot function from bookofshaders.com\n    float plot(vec2 vUv, float pct){\n        return smoothstep(pct - 0.01, pct, vUv.y) -\n               smoothstep(pct, pct + 0.1, vUv.y);\n    }\n    \n    \n    void main(){\n        float y = sinc(u_time, vUv.x);\n        vec3 color = vec3(y);\n        float pct = plot(vUv * 1.75 -0.5, y);\n        color = vec3(1. - pct);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function og(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float sinc(float x,float k){\n        float a=PI*((k*x)-1.);\n        return sin(a)/a;\n    }\n    \n    //exponential impulse iquilezles.org\n    float expImpulse(float x,float k)\n    {\n        float h=k*x;\n        return h*exp(1.-h);\n    }\n    float expImpulse2(float x,float k)\n    {\n        float h=(k + 0.25)*x;\n        return h*exp(1.-h);\n    }\n    float expImpulse3(float x,float k)\n    {\n        float h=(k + 0.5)*x;\n        return h*exp(1.-h);\n    }\n    \n    //plot function from bookofshaders.com\n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-.01,pct,vUv.y)-\n        smoothstep(pct,pct+.1,vUv.y);\n    }\n    \n    void main(){\n        float y=expImpulse(u_time,clamp(vUv.x, 0.0, 1.0));\n        float x=expImpulse2(u_time,clamp(vUv.x, 0.0, 1.0));\n        float z=expImpulse3(u_time,clamp(vUv.x,0.,1.));\n    \n        vec3 color=vec3(y);\n        float pct=plot(vUv*1.75-.5,y);\n        float pct2=plot(vUv*1.75-.5,x);\n        float pct3=plot(vUv*1.75-.5,z);\n        color=vec3(1.-pct);\n        color*=vec3(1.-pct2);\n        color*=vec3(1.-pct3);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ag(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ig=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float plot(vec2 st, float pct){\n        return  smoothstep( pct-0.02, pct, st.y) -\n                smoothstep( pct, pct+0.02, st.y);\n      }\n      \n      void main(){\n          float a = sin(vUv.x * u_time) * 0.25 + 0.5;//sin\n          float b = cos(vUv.x * u_time) * 0.25 + 0.5;//cos\n      \n          vec3 color = vec3(1.0);\n      \n          float pct = plot(vUv, a);\n          float pct2 = plot(vUv, b);\n      \n          color *= (1.0 - pct) * color + pct * vec3(1.0, 0.0, 0.0);\n          color *= (1.0 - pct2) * color + pct2 * vec3(0.0, 0.0, 1.0);\n          \n          gl_FragColor = vec4(color, 1.);\n      }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:ig,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float plot(vec2 st, float pct){\n        return  smoothstep( pct-0.02, pct, st.y) -\n                smoothstep( pct, pct+0.02, st.y);\n      }\n      \n      //parabola iquilezles.org\n      float parabola( float x, float k ){\n          return pow(4.0 * x * (1.0 - x), k);\n      }\n      \n      \n      void main(){\n          float y = parabola(vUv.x, 2. + (sin(u_time)));\n          float x = parabola(vUv.x, 4. + (sin(u_time)));\n          float z = parabola(vUv.x, 8. + (sin(u_time)));\n          vec3 color = vec3(0.);\n      \n          float pct = plot(vUv, y);\n          float pct2 = plot(vUv, x);\n          float pct3 = plot(vUv, z);\n      \n          color = (1.0-pct)*color+pct*vec3(0.0,1.0,0.0);\n          color += (1.0-pct2)*color+pct2*vec3(1.0,0.0,0.0);\n          color += (1.0-pct3)*color+pct3*vec3(0.0,0.0,1.0);\n      \n          gl_FragColor = vec4(color, 1.);\n      }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //plot function bookofshaders\n    float plot(vec2 st, float pct){\n        return  smoothstep( pct-0.02, pct, st.y) -\n                smoothstep( pct, pct+0.02, st.y);\n    }\n    \n    //easing functions easings.net/#easeInElastic\n    float easeInElastic(float x){\n        float y = (2.0 * PI) / 3.;\n        return (1.0 - pow(2., 10. * x - 10.) * sin((x * 10. - 10.75) * y - (u_time * u_time * (0.25)))) ;\n    }\n    \n    void main(){\n        float y = easeInElastic(vUv.x) - 0.5;\n    \n        vec3 color = vec3(y);\n    \n        float pct = plot(vUv, y);\n        color = pct * vec3(0., 1., 0.);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ug(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //plot function bookofshaders\nfloat plotY(vec2 st, float pct){\n    return  smoothstep( pct-0.2, pct, st.y + 0.5) -\n            smoothstep( pct, pct+0.2, st.y + 0.5);\n  }\n  \n  float plotX(vec2 st, float pct){\n    return  smoothstep( pct-0.2, pct, st.x + 0.5) -\n            smoothstep( pct, pct+0.2, st.x + 0.5);\n  }\n  \n  //easing functions easings.net/#easeInElastic\n  float easeInElastic(float x){\n      float y = (2.0 * PI) / 3.;\n      return (1.0 - pow(2., 10. * x - 10.) * sin((x * 10. - 10.75) * y - (u_time * 2.0 ))) ;\n  }\n  \n  void main(){\n      float y =  easeInElastic(vUv.x) - 0.25;\n      float x =  easeInElastic(vUv.y) - 0.25;\n      float z = easeInElastic(1. - vUv.x) - 0.5;\n      float a = easeInElastic(1. - vUv.y) - 0.5;\n  \n      vec3 color = vec3(y);\n  \n      float pct = plotY(vUv, y + 0.25);\n      float pct2 = plotX(vUv, x + 0.25);\n      float pct3 = plotY(vUv, z);\n      float pct4 = plotX(vUv, a);\n  \n      color = pct * vec3(1., 0., 0.);\n      color *= pct2 * vec3(1., 1., 0.);\n      //color *= pct3 * vec3(0., 1., 0.);\n      //color += pct4 * vec3(1., 0., 0.);\n  \n      gl_FragColor = vec4(color, 1.);\n  }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders plot function\nfloat plot(vec2 st,float pct){\n    return smoothstep(pct-.8,pct,st.y)-\n    smoothstep(pct,pct+.8,st.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(atan(vUv.x - 0.5, vUv.y - 0.5) * u_time * sin(u_time * 0.5));\n    float x = sin(vUv.x);\n    float y = sin(vUv.y);\n    vec3 color = vec3(x);\n    color += vec3(y);\n\n    //float pct = plot(vUv, y);\n    //color += pct * vec3(0.0, 1.0, 1.0);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //sinc curve iquilezles.org\nfloat sinc(float x,float k){\n    float a=PI*((k*x)-1.);\n    return sin(a)/a ;\n}\n\n//plot function bookofshaders\nfloat plot(vec2 st, float pct){\n  \n  return  smoothstep( pct-0.02, pct, st.x + 0.5) -\n          smoothstep( pct, pct+0.2, st.x + 0.5);\n}\n\nfloat plot2(vec2 st, float pct){\n  \n  return  smoothstep( pct-0.02, pct, st.y + 0.5) -\n          smoothstep( pct, pct+0.2, st.y + 0.5);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vUv -= 0.5; \n    float y = sinc((vUv.y - 0.5 * PI), u_time  * 0.5);\n    float x = sinc((vUv.x - 0.5 * PI), u_time  * 0.5);\n    \n    vec3 color = vec3(0.);\n\n    float pct = plot(vUv - 0.5, y);\n    float pct2 = plot2(vUv - 0.5, x);\n\n    color += pct * vec3(1., 0., 0.);\n    color *= pct2 * vec3(1., 0., 0.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //plot function bookofshaders\nfloat plotY(vec2 st, float pct){\n    return  smoothstep( pct-0.02, pct, st.y +2.5) -\n            smoothstep( pct, pct+0.25, st.y + 2.5);\n  }\n  \n  //easing functions easings.net/#easeInElastic\n  float easeInElastic(float x){\n      float y = (2.0 * PI) / 3.;\n      return (1.0 - pow(2., 10. * x - 10.) * sin((x * 10. - 10.75) * y - (u_time * 1.5 ))) ;\n  }\n  \n  void main(){\n      vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.7);\n      vUv *= 2.75;\n      float y = easeInElastic(abs(sin(vUv.x)) * 1.25);\n      float x = easeInElastic(abs(cos(vUv.y)) * 1.25);\n  \n      vec3 color = vec3(0.);\n  \n      float pct = plotY(vUv, y * x);\n      color += pct  * vec3(0., 1., 1.);\n  \n      gl_FragColor = vec4(color, 1.);\n  }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //plot function bookofshaders\nfloat plotY(vec2 st, float pct){\n    return  smoothstep( pct-.02, pct, st.y + 0.5) -\n            smoothstep( pct, pct+.25, st.y + 0.5);\n  }\n  \n  float plotX(vec2 st, float pct){\n    return  smoothstep( pct-.02, pct, st.x + 0.5) -\n            smoothstep( pct, pct+.25, st.x + 0.5);\n  }\n  \n  \n  //easing functions easings.net/#easeInElastic\n  float easeInElastic(float x){\n      float y = (2.0 * PI) / 3.;\n      return (1.0 - pow(2., 10. * x - 10.) * cos((x * 10. - 10.75) * y - (u_time * 2.0 ))) ;\n  }\n  \n  float easeInElastic2(float x){\n      float y = (2.0 * PI) / 3.;\n      return (1.0 - pow(2., 10. * x - 10.) * sin((x * 10. - 10.75) * y - (u_time * 2.0 ))) ;\n  }\n  \n  void main(){\n      vec2 vUv = vec2(vUv.x, vUv.y);\n      vUv *= 0.5;\n      vUv += 0.3;\n  \n      float y =  easeInElastic(vUv.x);\n      float x =  easeInElastic2(vUv.y);\n  \n      vec3 color = vec3(y);\n  \n      float pct = 1. -plotY(vUv, y);\n      float pct2 = 1. - plotX(vUv, x);\n    \n      color = pct * vec3(1., 0., 0.);\n      color += pct2 * vec3(1., 0., 0.);\n  \n      gl_FragColor = vec4(color, 1.);\n  }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ug(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _g=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec3 colorA = vec3(0.788, 0.262, 0.250);\nvec3 colorB = vec3(0.250, 0.474, 0.788);\n\nfloat easeInQuad(float x){\n    return x * x;\n}\n\nvoid main(){\n    vec3 color = vec3(0.);\n    float pct = easeInQuad(vUv.x);\n    pct += sin(u_time);\n    color = mix(colorA, colorB, pct);\n    color -= mix(colorB, colorA, pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_g,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Sg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec3 colorA = vec3(0.149,0.141,0.912);\nvec3 colorB = vec3(1.000,0.833,0.224);\n\nfloat plot (vec2 st, float pct){\n  return  smoothstep( pct-0.01, pct, st.y) -\n          smoothstep( pct, pct+0.01, st.y);\n}\n\n//bookofshaders\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 3.0;\n    vec3 color = vec3(0.0);\n    color = rgb2hsb(vec3(vUv.x, vUv.y, abs(sin(u_time * 0.5))));\n    color -= rgb2hsb(vec3(vUv.x, vUv.y, abs(cos(u_time * 0.5))));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Mg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Sg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 centeredUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    centeredUv *= 10.0;\n    float t = u_time * .05;\n    //vUv += M;\n    centeredUv *= Rot(t * 10.0);\n    vec3 color = vec3(0.);\n    float angle = dot(sin(centeredUv.y), sin(centeredUv.x));\n    float radius = length(centeredUv) * 200.0;\n    color = 1. - hsb2rgb(vec3((angle * abs(tan(sin(u_time * 0.25)))) - 0.25, radius, 1.));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Cg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb(in vec3 c){\n    vec3 rgb=clamp(abs(mod(c.x*6.+vec3(3.8,1.,7.),\n6.)-3.)-1.,\n0.,\n1.);\nrgb=rgb*rgb*(3.-2.*rgb);\nreturn c.z*mix(vec3(1.),rgb,c.y);\n}\n\nmat2 Rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid main(){\n    vec2 centeredUv=vec2(vUv.x-.5,vUv.y-.5);\n    centeredUv*=10.;\n    float t=u_time*.05;\n    centeredUv*=Rot(t*10.);\n    vec3 color=vec3(0.);\n    float angle=abs(tan(dot(abs(cos(centeredUv.x)), abs(sin(centeredUv.y)))) * abs(cos(u_time * 0.5)));\n    float radius=length(centeredUv)*2000.;\n    color=1. - hsb2rgb(vec3((angle/(TWO_PI /3.))+.5,radius, 1.));\n    gl_FragColor=vec4(color.x , color.y, color.z ,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Tg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Cg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Rg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    mat2 Rot(float a){\n        float s=sin(a);\n        float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n    void main(){\n        vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n        vUv *= 25.0;\n        float t = u_time * 0.25;\n        vUv*=Rot(t*1.);\n        vec3 color=vec3(0.);\n        float angle=abs(tan(dot(abs(cos(vUv.x)),abs(sin(vUv.y))))*abs(cos(u_time*.25)));\n        float radius=length(vUv) * 0.5;\n        color = vec3(((angle * radius)/ PI) + (cos(u_time)), tan(radius * angle) , tan(radius * angle));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Dg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Rg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Pg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 10.0;\n    float t = u_time * .05;\n    vUv *= Rot(t * 10.0);\n    vec3 color = vec3(0.);\n    float angle = dot(sin(vUv.y), sin(vUv.x));\n    float radius = length(vUv) * 2.0;\n    color = 1. - hsb2rgb(vec3((angle * abs(tan(sin(u_time * 0.5)))), abs(tan(angle + u_time)) , u_time * 0.5));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Fg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Pg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv -= 0.5;\n        vUv *= 10.0;\n        float t = u_time * .05;\n        vUv *= Rot(t * 5.0);\n        vec3 color = vec3(0.);\n        float radius = length(tan(vUv + (sin(vUv.y))) * 0.08);\n        color = vec3(tan(vUv.x + cos(vUv.y + u_time)), tan(1. - vUv.x + cos(vUv.y + u_time)), tan(vUv.x + cos(vUv.y + u_time)));\n        vec3 newColor = vec3(color.x * radius, color.y * radius, color.z * radius);\n        gl_FragColor = vec4(newColor, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ig(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Eg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 10.0;\n    float t = u_time * .05;\n    vUv *= Rot(t * 10.0);\n    vec3 color = vec3(0.);\n    float angle = dot(cos(vUv.y), cos(vUv.x));\n    float radius = length(vUv) * 200.0;\n    color = vec3(vUv.x * angle, vUv.y * angle, 1.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Og(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Eg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ag=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //plot function bookofshaders\nfloat plotY(vec2 st, float pct){\n    return  smoothstep( pct-.5, pct, st.y + 0.5) -\n            smoothstep( pct, pct+.5, st.y + 0.5);\n  }\n  \n  //  Function from I\xf1igo Quiles\n  //  https://www.shadertoy.com/view/MsS3Wc\n  vec3 hsb2rgb( in vec3 c ){\n      vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                               6.0)-3.0)-1.0,\n                       0.0,\n                       1.0 );\n      rgb = rgb*rgb*(3.0-2.0*rgb);\n      return c.z * mix(vec3(1.0), rgb, c.y);\n  }\n  \n  \n  \n  //easing functions easings.net/#easeInElastic\n  float easeInElastic(float x){\n      float y = (sin( - u_time * 0.25)) / 3.;\n      return pow(2., 10. * x - 10.) * cos((x * 10. - 10.75) * y - (u_time * 0.5)) ;\n  }\n  \n  \n  void main(){\n      vec2 vUv = vec2(vUv.x - 1.5 , vUv.y - 1.5 );\n      vUv *= 1.0;\n      //vec3 color = vec3(0.);\n      float angle = dot(sin(vUv.y), cos(vUv.x));\n      float radius = length(vUv) * 2.0;\n  \n      float y =  easeInElastic(vUv.x * angle * radius);\n  \n      vec3 color = vec3(y);\n  \n      float pct =plotY(vUv, y * radius * angle);\n    \n      color = hsb2rgb(vec3(y + cos(u_time), y + cos(u_time), y * pct));\n  \n      gl_FragColor = vec4(color, 1.);\n  }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Lg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Ag,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Gg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv -= 0.5;\n        vUv *= 5.0;\n        float t = u_time * .05;\n        vUv *= Rot(t * 5.0);\n        vUv *= length(vUv * sin(t));\n        vec3 color = vec3(0.);\n        float radius = length(cos((vUv * sin(u_time)) + (cos(vUv.y))) * 0.08);\n        color = vec3(tan(vUv.x + cos(vUv.y + u_time)), tan(1. - vUv.x + cos(vUv.y + u_time)), tan(vUv.x + cos(vUv.y + u_time)));\n        vec3 newColor = vec3(color.x * radius * abs(cos(u_time)), color.y * radius * abs(sin(u_time)), color.z * radius );\n        gl_FragColor = vec4(newColor, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ng(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Gg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Bg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //plot function from book of shaders\nfloat plot(vec2 st, float pct){\n    return  smoothstep( pct-1.5, pct, st.y) -\n            smoothstep( pct, pct+1.5, st.y);\n  }\n  \n  float plot2(vec2 st, float pct){\n    return  smoothstep( pct-1., pct, st.x) -\n            smoothstep( pct, pct+1., st.x);\n  }\n  \n  mat2 Rot(float a){\n      float s = sin(a);\n      float c = cos(a);\n      return mat2(c, -s, s, c);\n  }\n  \n  void main(){\n      vec2 vUv = vec2(vUv.x -0.5, vUv.y - 0.5);\n      vUv *= 10.0;\n      float t = u_time * .05;\n      vUv *= Rot(t * 5.0);\n      float a = sin(vUv.x + u_time * (atan(sin(u_time + vUv.x), vUv.y)));//sin\n      //float b = cos(vUv.y * (dot(cos(u_time * vUv.y), vUv.y)));//cos\n  \n      vec3 color = vec3(0.);\n  \n      float pct = plot(vUv, a);\n      //float pct2 = plot2(vUv, b);\n      float radius = length(cos((vUv * sin(u_time)) + (cos(vUv.y))) * 0.08);\n      color = (1.0 - pct) * color + pct * vec3(vUv.x, vUv.y, 1.);\n      \n      // vec3 newColor = vec3(color.x * radius * abs(cos(u_time)), color.y * radius * abs(sin(u_time)), color.z * radius );\n      //gl_FragColor = vec4(newColor, 1.);\n  \n      //color = (1.0 - pct) * color + pct * vec3(1.0, 0.0, 0.0);\n      //color *= (1.0 - pct2) * color + pct2 * vec3(0.0, 0.0, 1.0);\n      \n      gl_FragColor = vec4(color, 1.);\n  }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Bg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Vg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    mat2 Rot(float a){\n        float s=sin(a);\n        float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n    \n    //  Function from I\xf1igo Quiles\n    //  https://www.shadertoy.com/view/MsS3Wc\n    vec3 hsb2rgb(in vec3 c){\n        vec3 rgb=clamp(abs(mod(c.x*6.+vec3(3.8,1.,7.),\n    6.)-3.)-1.,\n    0.,\n    1.);\n    rgb=rgb*rgb*(3.-2.*rgb);\n    return c.z*mix(vec3(1.),rgb,c.y);\n    }\n    \n    //pixel deck\n    vec2 rotate(vec2 vUv, float a){\n        vUv = mat2(cos(a), - sin(a), sin(a), cos(a)) * vUv * 0.5;\n        return vUv;\n    }\n    float stroke(float x, float s, float w){\n        float d = step(s, x + w * 0.5) - \n                    step(s, x -w * 0.5);\n        return clamp(d, 0., 1.);\n    }\n    float fill(float x, float size){\n        return 1. - step(size, x);\n    }\n    float rectSDF(vec2 vUv, vec2 s){\n        vUv = vUv * 2. - 1.;\n        return max(abs(vUv.x/s.x), abs(vUv.y/s.y));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x , vUv.y );\n        vUv -= 0.5;\n        vUv *= 6.25;\n        vUv = rotate(vUv, radians(180. * (u_time * u_time) ));\n        float y = 0.;\n        vec3 color = vec3(y);\n        y = fill(rectSDF(vUv, vec2(1.5)), 1.5);\n        y -= 1. - stroke(vUv.x, 0.9, 0.1);\n        y -= 1. - stroke(vUv.y,0.9, 0.1);\n        color = vec3(y);\n        gl_FragColor = vec4(color.x + (sin(u_time * 0.1)), color.y + (sin(u_time * 0.2)), color.z + (cos(u_time * 0.1)), 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Wg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Vg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Hg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 5.0;\n    float t = u_time * .05;\n    vUv *= Rot(t * 10.0);\n    vec3 color = vec3(0.);\n    float angle = dot(cos(vUv.y * sin(u_time * 0.25)), cos(vUv.x * sin(u_time * 0.25)));\n    float radius = length(vUv);\n    color = 1. - hsb2rgb(vec3((angle * abs(tan(sin(u_time * 0.5)))) * radius, abs(tan(angle + u_time)) , radius * angle * u_time - 0.5));\n    gl_FragColor = vec4(1. - color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Xg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Hg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Yg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //pixeldeck\nfloat starSDF(vec2 vUv, int V, float s){\n    //vUv = vUv * 5. - 2.5;\n    float a  = atan(vUv.y, vUv.x)/TWO_PI;\n    float seg = a * float(V);\n    a = ((floor(seg) + 0.5)/ float(V) + mix(s, -s, step(.5, fract(seg)))) * TWO_PI;\n    return abs(dot(vec2(cos(a), sin(a)), vUv));\n}\n\n//  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y-0.5);\n    vUv *= 5.;\n    vec3 color = vec3(0.);\n    float t = u_time * .1;\n    vUv *= Rot(t * 10.0);\n    float s = starSDF(vUv.yx, 5, .1);\n    color += 1. - step(.7, s);\n    //color *= 1. - step(.7, s);\n    float angle = dot(cos(vUv.y * sin(u_time * 0.25)), cos(vUv.x * sin(u_time * 0.25)));\n    float radius = length(vUv);\n    color *= 1. - hsb2rgb(vec3((angle * abs(tan(sin(u_time * 0.25)))), abs(tan(angle + u_time)) , (u_time) * 0.25));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Zg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Yg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// //Rectangle function\nfloat createRect(in vec2 vUv, in vec2 start, in vec2 dim){\n    vec2 bottomLeft = step(start, vUv);\n    vec2 topRight = step(1. - start -dim, 1.0 - vUv);\n    float pct = bottomLeft.x * bottomLeft.y * topRight.x * topRight.y;\n    return pct;\n}\n\nfloat circleSDF(vec2 vUv){\n    return length(vUv - 0.5) * 2.;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x + 0.48, vUv.y + 0.48);\n    vUv *= 10.;\n    float angle = dot(sin(vUv.y - 0.5), sin(vUv.x - 0.5));\n    // float radius = length((vUv * 2.0 - 0.5) );\n    float barX = step(0.4, mod(vUv.x * 10.0 - 0.2, 1.0)) * step(0.8, mod(vUv.y * 10.0, 1.0));\n    float barY = step(0.8, mod(vUv.x * 10.0, 1.0)) * step(0.4, mod(vUv.y * 10.0 - 0.2, 1.0));\n    float strength = barX + barY;\n    float circle = step(circleSDF(vUv), 1.0);\n    vec3 color = vec3(strength);\n    float radius = length(cos((vUv * sin(u_time)) + (cos(vUv.y))) * 0.08);\n    color *= vec3(tan(vUv.x + cos(vUv.y + u_time)), tan(1. - vUv.x + cos(vUv.y + u_time)), tan(vUv.x + cos(vUv.y + u_time)));\n    vec3 newColor = vec3(color.x + atan(0.5 * u_time) * radius * (sin(u_time )), color.y + atan(0.5 * u_time) * radius * (cos(u_time)), color.z * radius );\n    newColor -= strength;\n    gl_FragColor = vec4(newColor, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Jg(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Qg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Kg=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Rectangle function\nfloat createRect(in vec2 vUv, in vec2 start, in vec2 dim){\n    vec2 bottomLeft = step(start, vUv);\n    vec2 topRight = step(1. - start -dim, 1.0 - vUv);\n    float pct = bottomLeft.x * bottomLeft.y * topRight.x * topRight.y;\n    return pct;\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 3.0;\n    float t = u_time * .75;\n    vUv *= Rot(t);\n    float y = createRect(vUv, vec2(-0.62, 0.0), vec2(1.5, 0.25));\n    float x = createRect(vUv, vec2(0.0, -0.62), vec2(0.25, 1.5));\n    float shape = x - y;\n    vec3 color = vec3(shape);\n    float angle = dot(atan(vUv.y * sin(u_time * 0.25)), atan(vUv.x * sin(u_time * 0.25)));\n    float radius = length(vUv - 0.5) * 20.;\n    color *= vec3(sin(color.x * (sin(u_time * sin(radius)))), sin(color.y * (cos(u_time * sin(radius)))), sin(color.z * (sin(u_time * sin(radius)))));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $g(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Kg,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ny=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n//pixel deck\nfloat circleSDF(vec2 vUv){\n    return length(vUv - 0.5) * 2.;\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 2.0;\n    float t = u_time * .75;\n    vUv *= Rot(t);\n    float circle = circleSDF(vUv + 0.5);\n    float angle = dot(vUv.y, vUv.x);\n    float radius = length(vUv) * 100.0;\n    vec3 color = vec3(0.);\n    color = hsb2rgb(vec3((angle/TWO_PI * (u_time)) , sin(radius * sin(u_time * 0.25)), 1.0));\n    color -=  tan(circle);\n    gl_FragColor = vec4(color.x, color.y, color.z, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ey(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:ny,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ty=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n//pixel deck\nfloat circleSDF(vec2 vUv){\n    return length(vUv - 0.5) * 2.;\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 2.0;\n    float t = u_time * .75;\n    vUv *= Rot(t);\n    float circle = circleSDF(vUv + 0.5);\n    float angle = dot(vUv.y, vUv.x);\n    float radius = length(vUv) * 1000.0;\n    //vec3 color = vec3(0.);\n    \n    vec3 color =  vec3(tan(circle));\n    color += hsb2rgb(vec3(atan(circle,angle * radius/TWO_PI) *1. -  abs(cos(u_time * 0.25))));\n    gl_FragColor = vec4(color.x + sin(u_time), color.y - sin(u_time), color.z + cos(u_time), 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function oy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:ty,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ry=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb(in vec3 c){\n    vec3 rgb=clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),\n            6.)-3.)-1.,\n            0.,\n            1.);\n    rgb=rgb*rgb*(3.-2.*rgb);\n    return c.z*mix(vec3(1.),rgb,c.y);\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\n//pixel deck\nfloat circleSDF(vec2 vUv){\n    return length(vUv-.5)*2.;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv - 0.5);\n    vUv *= 3.0;\n    float angle=atan(vUv.y,vUv.x);\n    float radius=length(vUv)*5.;\n    float circle=circleSDF(vUv+.5);\n    vec3 color=vec3(tan(circle + u_time));\n    color += 1. - hsb2rgb(vec3(atan(radius, angle)  + sin(u_time), atan(radius,angle)+cos(u_time), atan(radius,angle) +cos(u_time)));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ay(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:ry,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //pixel deck\nfloat circleSDF(vec2 vUv){\n    return length(vUv - 0.5) * 2.;\n}\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv-0.25);\n    vUv *= 2.0;\n    float angle = dot(vUv.y , vUv.x);\n    float radius = length(vUv- 0.5) * 10.0;\n    vec3 color = vec3 (cos(vUv.x), sin(vUv.y + u_time* 0.2), 0.);\n    color *= vec3(step(circleSDF(vUv), 1.9));\n    color *= hsb2rgb(vec3(u_time + radius * sin(vUv.x + vUv.y), u_time + radius, u_time + radius));\n    gl_FragColor = vec4(color , 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:iy,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n//book of shaders\nfloat plot (vec2 st, float pct){\n  return  smoothstep( pct-0.5, pct, st.y) -\n          smoothstep( pct, pct+0.5, st.y);\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv - 0.5);\n    vUv *= 4.0 + sin(u_time);\n    float t = u_time * .75;\n    vUv *= Rot(t);\n    vec3 color = vec3(0.);\n    color += 1. - hsb2rgb(vec3(cos(vUv.x * vUv.y), u_time * PI, 1.0));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cy,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ly=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    void main(){\n        //vec2 vUv = vec2(vUv);\n        vec3 color = vec3(0.);\n        // float left = step(0.1, vUv.x);\n        // float bottom = step(0.1, vUv.y);\n        vec2 bordersBottomLeft = step(vec2(0.1 * abs(sin(u_time * 0.75))), vUv);\n        vec2 bordersTopRight = step(vec2(0.1 * abs(sin(u_time * 0.75))), 1.0 - vUv);\n        float pct = bordersBottomLeft.x * bordersBottomLeft.y * bordersTopRight.x * bordersTopRight.y;\n        color = vec3(pct);\n        gl_FragColor = vec4(vec3(vUv.x * color.x, vUv.y * color.y, color.z), 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:ly,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rect(vec2 vUv, vec2 s){\n        vec2 bl = step(vec2(s), vUv);\n        vec2 tr = step(vec2(s), 1. - vUv);\n        return bl.x * bl.y * tr.x * tr.y;\n    }\n    \n    void main(){\n        //vec2 vUv = vec2(vUv - 0.5);\n        vec3 color = vec3(vUv.x * vUv.y);\n        // vec2 bl = step(vec2(0.5), vUv);\n        // vec2 tr = step(vec2(0.1), 1. - vUv);\n        // float pct = bl.x * bl.y * tr.x * tr.y;\n        // float pct2 = 1. - (bl.x  * bl.y * tr.x * tr.y);\n        // color *= vec3(pct2);\n        // color += vec3(pct);\n        float pct = rect(vec2(vUv.x + 0.25 * sin(u_time), vUv.y + 0.25 * cos(u_time)), vec2(0.25));\n        float pct2 = rect(vec2(vUv.x - 0.25 * cos(u_time), vUv.y - 0.25 * sin(u_time)), vec2(0.25));\n        vec3 finalColor = vec3(pct * abs(cos(u_time)), pct * 0.2,  pct * 0.8);\n        finalColor += vec3(pct2 * abs(sin(u_time)), pct2 * 0.8, 0.2);\n        color = finalColor;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function py(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fy,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var my=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rect(vec2 vUv, vec2 s){\n        vec2 bl = step(vec2(s), vUv);\n        vec2 tr = step(vec2(s), 1. - vUv);\n        return bl.x * bl.y * tr.x * tr.y;\n    }\n    \n    //pixel deck\n    float fill(float x, float size){\n        return 1. - step(size, x);\n    }\n    //pixel deck\n    //triangle SDF\n    float triSDF(vec2 vUv){\n        vUv = (vUv * 2. - 1.) * 2.;\n        return max(abs(vUv.x) * 0.866025 + vUv.y * 0.5, -vUv.y * 0.5);\n    } \n    \n    void main(){\n        //vec2 vUv = vec2(vUv - 0.5);\n        vec3 color = vec3(vUv.x * vUv.y);\n        float pct = fill(triSDF(vec2(vUv.x + 0.25 * sin(u_time * 0.5), vUv.y + 0.25 * cos(u_time* 0.5))), 0.35);\n        float pct2 = fill(triSDF(vec2(vUv.x + 0.25 * cos(u_time* 0.5), vUv.y - 0.25 * sin(u_time* 0.5))), 0.35);\n        float pct3 = fill(triSDF(vec2(vUv.x - 0.25 * cos(u_time* 0.5), vUv.y + 0.25 * sin(u_time* 0.5))), 0.35);\n        float pct4 = fill(triSDF(vec2(vUv.x + 0. * sin(u_time* 0.5), vUv.y + 0. * cos(u_time* 0.5))), 0.35);\n        vec3 finalColor = vec3(pct * abs(sin(u_time)), pct * 0.2,  pct * 0.8);\n        finalColor += vec3(pct2 * abs(sin(u_time)), pct2 * 0.8, pct2 * 0.1);\n        finalColor += vec3(pct3 * abs(sin(u_time)), pct3 * 0.4, pct3 * 0.3);\n        finalColor += vec3(pct4 * abs(cos(u_time)), pct4 * 0.2, pct4 * 0.5);\n        color = finalColor;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:my,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float triSDF(vec2 vUv){\n        vUv=(vUv*2.-1.)*2.;\n        return max(abs(vUv.x)*.866025+vUv.y*.5,-vUv.y*.5);\n    }\n    \n    //rotation function\n    mat2 Rot(float a){\n        float s=sin(a);\n        float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n    \n    void main(){\n        vec2 newvUv = vec2(vUv + 1.5 );\n    \n        newvUv *= 20.25;\n        float t=sin(u_time*.75);\n        \n        vec3 color=vec3(0.);\n        float pct = triSDF(vec2(vUv.x,vUv.y));\n        color = vec3(pct, pct, pct);\n        color.xy*=Rot(t);\n        color.yz*=Rot(t);\n        color.xz*=Rot(t);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hy,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //pixel deck\nfloat fill(float x, float size){\n    return 1. - step(size, x);\n}\n//pixel deck\n//triangle SDF\nfloat triSDF(vec2 vUv){\n    vUv = (vUv * 2. - 1.) * 2.;\n    return max(abs(vUv.x) * 0.866025 + vUv.y * 0.5, -vUv.y * 0.5);\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv - 0.5);\n    vUv *= 2.0;\n    float t = u_time * .75;\n    vUv *= Rot(t);\n    vec3 color = vec3(0.);\n    float tri = fill(triSDF(vUv + 0.5), 1.0);\n    float tri2 = fill(triSDF(vUv + 0.3), 1.25);\n    float tri3 = fill(triSDF(vec2(vUv.x + 0.15, vUv.y + 0.25)), 1.);\n    color = vec3(abs(sin(tri + u_time * vUv.x)), abs(cos(tri + u_time + vUv.y)), (sin(tri + 0.2 + u_time)));\n    vec3 finalColor = vec3(vUv, 1.);\n    vec3 color2 = vec3(tri2);\n    vec3 color3 = vec3(tri3);\n    finalColor += color;\n    finalColor *= color2;\n    finalColor -= color3;\n    gl_FragColor = vec4(finalColor, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gy,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var by=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //pixel deck\nfloat fill(float x, float size){\n    return 1. - step(size, x);\n}\n//pixel deck\n//triangle SDF\nfloat triSDF(vec2 vUv){\n    vUv = (vUv * 2. - 1.) * 2.;\n    return max(abs(vUv.x) * 0.866025 + vUv.y * 0.5, -vUv.y * 0.5);\n}\n\n//rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n//  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vec3 color = vec3(0.);\n    float angle = dot(vUv.y , vUv.x);\n    float radius = length(vUv- 0.5) * 10.0;\n    float tri = 1. - fill(triSDF(vUv), 0.5);\n    float tri2 = fill(triSDF(vec2(vUv.x, vUv.y + 0.1)), 0.4);\n    float tri3 = 1. - fill(triSDF(vec2(vUv.x, vUv.y + 0.2)), 0.3);\n    float shape = float(tri + tri2 * tri3);\n    color = vec3(shape);\n    color += hsb2rgb(vec3(u_time + radius * sin(vUv.x - 0.25 + vUv.y), u_time + radius, u_time + radius));\n    gl_FragColor = vec4(vec3(shape, shape + color.y, shape), 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Uy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:by,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _y=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rect(vec2 size, vec2 vUv){\n        vec2 bl = step(size, vUv);\n        vec2 tr = step(size, 1. - vUv);\n        return bl.x * bl.y * tr.x * tr.y;\n    }\n    \n    //rotation function\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x - 0.75, vUv.y - 0.5);\n        vUv *= 5.0;\n        float t = u_time;\n        vUv *= Rot(t);\n        vec3 color = vec3(0.);\n        float pct = rect(vec2(0.3, 0.49), vUv + sin(u_time));\n        float pct2 = rect(vec2(0.3, 0.49), vec2(vUv.x, vUv.y + 0.5 )+ cos(u_time));\n        float pct3 = rect(vec2(0.49, 0.3), vec2(vUv.x, vUv.y + 0.5 )+ cos(u_time));\n        float pct4 = rect(vec2(0.49, 0.3), vUv + sin(u_time));\n        float pct5 = rect(vec2(0.3, 0.49), vec2(vUv.x, vUv.y + 1.) + sin(u_time));\n        float pct6 = rect(vec2(0.49, 0.3), vec2(vUv.x, vUv.y + 1.) + sin(u_time));\n        color = vec3(0.);\n        color.g += pct;\n        color.r += pct2;\n        color.r += pct3;\n        color.g += pct4;\n        color.b += pct5;\n        color.b += pct6;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_y,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Sy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //  Function from I\xf1igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid main(){\n    vec3 color = vec3(0.);\n    //a\n    float pct = smoothstep(0.1, 0.15, distance(vUv, vec2(0.8 * cos(u_time), 1. * abs(sin(u_time)))));\n    float pct2 = smoothstep(0.1, 0.15, distance(vUv, vec2(0.5, 1. * abs(cos(u_time)))));\n    float pct3 = smoothstep(0.1, 0.15, distance(vUv, vec2(0.2, 1. * abs(sin(u_time)))));\n    color = vec3(pct);\n    color *= vec3(pct2);\n    color *= vec3(pct3);\n\n    color.x = sin(color.x * u_time * 0.25);\n    color.y = sin(color.y * u_time * 0.25);\n    color.z = sin(color.z * u_time * 0.25); \n    // //b\n    // vec2 vUv = vec2(vUv) - 0.5;\n    // float pct = length(vUv);\n    // color = vec3(pct);\n\n    // //c\n    // vec2 vUv = vec2(vUv) - 0.5;\n    // float pct = sqrt(vUv.x * vUv.x + vUv.y * vUv.y);\n    // color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function My(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Sy,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ky=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    void main(){\n        float y = step(distance(vUv, vec2(0.5, 0.5)), 0.5);\n        float x = 1. - step(distance(vUv, vec2(0.5, 0.5)), 0.49);\n        float cir1 = step(distance(vUv, vec2(0.74, 0.49)), 0.25);\n        float cir2 = step(distance(vUv, vec2(0.25, 0.52)), 0.24);\n        x+=step(vUv.y,.5);\n        vec3 color = vec3(y * x);\n        color += vec3(cir1);\n        color -= vec3(cir2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:ky,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Cy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //circle sdf\nfloat circ(vec2 vUv, vec2 pos, float size){\n    return 1. - step(size, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    float y1 = circ(vUv, vec2(0.1, 1. * abs(sin(u_time * 0.9))), 0.05);\n    float y2 = circ(vUv, vec2(0.2, 1. * abs(sin(u_time * 0.85))), 0.05);\n    float y3 = circ(vUv, vec2(0.3, 1. * abs(sin(u_time * 0.80))), 0.05);\n    float y4 = circ(vUv, vec2(0.4, 1. * abs(sin(u_time * 0.75))), 0.05);\n    float y5 = circ(vUv, vec2(0.5, 1. * abs(sin(u_time * 0.70))), 0.05);\n    float y6 = circ(vUv, vec2(0.6, 1. * abs(sin(u_time * 0.65))), 0.05);\n    float y7 = circ(vUv, vec2(0.7, 1. * abs(sin(u_time * 0.60))), 0.05);\n    float y8 = circ(vUv, vec2(0.8, 1. * abs(sin(u_time * 0.55))), 0.05);\n    float y9 = circ(vUv, vec2(0.9, 1. * abs(sin(u_time * 0.50))), 0.05);\n\n    vec3 color = vec3(y1 + y2 + y3 + y4 + y5 + y6 + y7 + y8 + y9);\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ty(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Cy,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ry=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //circle sdf\nfloat circ(vec2 vUv,vec2 pos,float size){\n    return 1.-step(size,distance(vUv,pos));\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y) - 0.5;\n    vUv *= 2.0;\n    float y1=circ(vUv,vec2(.5*(sin(u_time*.1 * 2.)),.5*(cos(u_time*.1))),.05);\n    float y2=circ(vUv,vec2(.5*(sin(u_time*.2* 2.)),.5*(cos(u_time*.2))),.05);\n    float y3=circ(vUv,vec2(.5*(sin(u_time*.3* 2.)),.5*(cos(u_time*.3))),.05);\n    float y4=circ(vUv,vec2(.5*(sin(u_time*.4* 2.)),.5*(cos(u_time*.4))),.05);\n    float y5=circ(vUv,vec2(.5*(sin(u_time*.5* 2.)),.5*(cos(u_time*.5))),.05);\n    float y6=circ(vUv,vec2(.5*(sin(u_time*.6* 2.)),.5*(cos(u_time*.6))),.05);\n    float y7=circ(vUv,vec2(.5*(sin(u_time*.7* 2.)),.5*(cos(u_time*.7))),.05);\n    float y8=circ(vUv,vec2(.5*(sin(u_time*.8* 2.)),.5*(cos(u_time*.8))),.05);\n    float y9=circ(vUv,vec2(.5*(sin(u_time*.9* 2.)),.5*(cos(u_time*.9))),.05);\n    float y10=circ(vUv,vec2(.5*(sin(u_time*1.0*2.)),.5*(cos(u_time*1.0))),.05);\n    float y11=circ(vUv,vec2(.5*(sin(u_time*1.1*2.)),.5*(cos(u_time*1.1))),.05);\n    float y12=circ(vUv,vec2(.5*(sin(u_time*1.2*2.)),.5*(cos(u_time*1.2))),.05);\n    float y13=circ(vUv,vec2(.5*(sin(u_time*1.3*2.)),.5*(cos(u_time*1.3))),.05);\n    float y14=circ(vUv,vec2(.5*(sin(u_time*1.4*2.)),.5*(cos(u_time*1.4))),.05);\n    float y15=circ(vUv,vec2(.5*(sin(u_time*1.5*2.)),.5*(cos(u_time*1.5))),.05);\n    float y16=circ(vUv,vec2(.5*(sin(u_time*1.6*2.)),.5*(cos(u_time*1.6))),.05);\n    float y17=circ(vUv,vec2(.5*(sin(u_time*1.7*2.)),.5*(cos(u_time*1.7))),.05);\n    float y18=circ(vUv,vec2(.5*(sin(u_time*1.8*2.)),.5*(cos(u_time*1.8))),.05);\n    float y19=circ(vUv,vec2(.5*(sin(u_time*1.9*2.)),.5*(cos(u_time*1.9))),.05);\n    float y20=circ(vUv,vec2(.5*(sin(u_time*2.0*2.)),.5*(cos(u_time*2.0))),.05);\n    \n    vec3 color=vec3(y1 + y2 + y3 + y4 + y5 + y6 + y7 + y8 + y9 + y10 + y11 + y12 + y13 + y14 + y15 + y16 + y17 + y18 + y19 + y20);\n    \n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Dy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Ry,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Py=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //circle sdf\nfloat circ(vec2 vUv,vec2 pos,float size){\n    return 1.-step(size,distance(vUv,pos));\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y)-.5;\n    vUv*=2.;\n    float y1=circ(vUv,vec2(0.,0.),abs(cos(u_time * .1)));\n    float y2=circ(vUv,vec2(0.,0.),abs(cos(u_time * .2)));\n    float y3=circ(vUv,vec2(0.,0.),abs(cos(u_time * .3)));\n    float y4=circ(vUv,vec2(0.,0.),abs(cos(u_time * .4)));\n    float y5=circ(vUv,vec2(0.,0.),abs(cos(u_time * .5)));\n    float y6=circ(vUv,vec2(0.,0.),abs(cos(u_time * .6)));\n    float y7=circ(vUv,vec2(0.,0.),abs(cos(u_time * .7)));\n    float y8=circ(vUv,vec2(0.,0.),abs(cos(u_time * .8)));\n    float y9=circ(vUv,vec2(0.,0.),abs(cos(u_time * .9)));\n\n    vec3 color=vec3(0.);\n    color.b-=y1 * y9 / abs(sin(u_time));\n    color.r-=y2 * y8 / abs(sin(u_time));\n    color.g-=y3 * y7 / abs(sin(u_time));\n    color.r+=y4 * y6 / abs(sin(u_time));\n    color.b+=y5 * y1 / abs(sin(u_time));\n    color.g-=y6 * y4 / abs(sin(u_time));\n    color.b+=y7 * y3 / abs(sin(u_time));\n    color.r-=y8 * y2 / abs(sin(u_time));\n    color.g+=y9 * y1 / abs(sin(u_time));\n    \n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Fy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Py,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n\n//circle sdf\nfloat circ(vec2 vUv, vec2 pos, float size){\n    return 1. - step(size, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.5, vUv.y - 0.5);\n    vUv *= 1.5;\n    vec3 color = vec3(0.);\n    float c1 = circ(vUv, vec2(0.5 * sin(u_time * 1.10), 0.5 * cos(u_time -1.10)), 0.025);\n    float c2 = circ(vUv, vec2(0.5 * sin(u_time * 1.15), 0.5 * cos(u_time -1.15)), 0.025);\n    float c3 = circ(vUv, vec2(0.5 * sin(u_time * 1.20), 0.5 * cos(u_time -1.20)), 0.025);\n    float c4 = circ(vUv, vec2(0.5 * sin(u_time * 1.25), 0.5 * cos(u_time -1.25)), 0.025);\n    float c5 = circ(vUv, vec2(0.5 * sin(u_time * 1.30), 0.5 * cos(u_time -1.30)), 0.025);\n    float c6 = circ(vUv, vec2(0.5 * sin(u_time * 1.35), 0.5 * cos(u_time -1.35)), 0.025);\n    float c7 = circ(vUv, vec2(0.5 * sin(u_time * 1.40), 0.5 * cos(u_time -1.40)), 0.025);\n    float c8 = circ(vUv, vec2(0.5 * sin(u_time * 1.45), 0.5 * cos(u_time -1.45)), 0.025);\n    float c9 = circ(vUv, vec2(0.5 * sin(u_time * 1.50), 0.5 * cos(u_time -1.50)), 0.025);\n    float c10 = circ(vUv, vec2(0.5 * sin(u_time * 1.55), 0.5 * cos(u_time - 1.55)), 0.025);\n    float c11 = circ(vUv, vec2(0.5 * sin(u_time * 1.60), 0.5 * cos(u_time - 1.60)), 0.025);\n    float c12 = circ(vUv, vec2(0.5 * sin(u_time * 1.65), 0.5 * cos(u_time - 1.65)), 0.025);\n    float c13 = circ(vUv, vec2(0.5 * sin(u_time * 1.70), 0.5 * cos(u_time - 1.70)), 0.025);\n    float c14 = circ(vUv, vec2(0.5 * sin(u_time * 1.75), 0.5 * cos(u_time - 1.75)), 0.025);\n    float c15 = circ(vUv, vec2(0.5 * sin(u_time * 1.80), 0.5 * cos(u_time - 1.80)), 0.025);\n    float c16 = circ(vUv, vec2(0.5 * sin(u_time * 1.85), 0.5 * cos(u_time - 1.85)), 0.025);\n    float c17 = circ(vUv, vec2(0.5 * sin(u_time * 1.90), 0.5 * cos(u_time - 1.90)), 0.025);\n    float c18 = circ(vUv, vec2(0.5 * sin(u_time * 1.95), 0.5 * cos(u_time - 1.95)), 0.025);\n    float c19 = circ(vUv, vec2(0.5 * sin(u_time * 2.00), 0.5 * cos(u_time - 2.00)), 0.025);\n    float c20 = circ(vUv, vec2(0.5 * sin(u_time * 2.05), 0.5 * cos(u_time - 2.05)), 0.025);\n    float c21 = circ(vUv, vec2(0.5 * sin(u_time * 2.10), 0.5 * cos(u_time - 2.10)), 0.025);\n    float c22 = circ(vUv, vec2(0.5 * sin(u_time * 2.15), 0.5 * cos(u_time - 2.15)), 0.025);\n    float c23 = circ(vUv, vec2(0.5 * sin(u_time * 2.20), 0.5 * cos(u_time - 2.20)), 0.025);\n    float c24 = circ(vUv, vec2(0.5 * sin(u_time * 2.25), 0.5 * cos(u_time - 2.25)), 0.025);\n    float c25 = circ(vUv, vec2(0.5 * sin(u_time * 2.30), 0.5 * cos(u_time - 2.30)), 0.025);\n    float c26 = circ(vUv, vec2(0.5 * sin(u_time * 2.35), 0.5 * cos(u_time - 2.35)), 0.025);\n    float c27 = circ(vUv, vec2(0.5 * sin(u_time * 2.40), 0.5 * cos(u_time - 2.40)), 0.025);\n    float c28 = circ(vUv, vec2(0.5 * sin(u_time * 2.45), 0.5 * cos(u_time - 2.45)), 0.025);\n    float c29 = circ(vUv, vec2(0.5 * sin(u_time * 2.50), 0.5 * cos(u_time - 2.50)), 0.025);\n    float c30 = circ(vUv, vec2(0.5 * sin(u_time * 2.55), 0.5 * cos(u_time - 2.55)), 0.025);\n    float c31 = circ(vUv, vec2(0.5 * sin(u_time * 2.60), 0.5 * cos(u_time - 2.60)), 0.025);\n    float c32 = circ(vUv, vec2(0.5 * sin(u_time * 2.65), 0.5 * cos(u_time - 2.65)), 0.025);\n    float c33 = circ(vUv, vec2(0.5 * sin(u_time * 2.70), 0.5 * cos(u_time - 2.70)), 0.025);\n    float c34 = circ(vUv, vec2(0.5 * sin(u_time * 2.75), 0.5 * cos(u_time - 2.75)), 0.025);\n    float c35 = circ(vUv, vec2(0.5 * sin(u_time * 2.80), 0.5 * cos(u_time - 2.80)), 0.025);\n    float c36 = circ(vUv, vec2(0.5 * sin(u_time * 2.85), 0.5 * cos(u_time - 2.85)), 0.025);\n    float c37 = circ(vUv, vec2(0.5 * sin(u_time * 2.90), 0.5 * cos(u_time - 2.90)), 0.025);\n    float c38 = circ(vUv, vec2(0.5 * sin(u_time * 2.95), 0.5 * cos(u_time - 2.95)), 0.025);\n    float c39 = circ(vUv, vec2(0.5 * sin(u_time * 3.00), 0.5 * cos(u_time - 3.00)), 0.025);\n    float c40 = circ(vUv, vec2(0.5 * sin(u_time * 3.05), 0.5 * cos(u_time - 3.05)), 0.025);\n    float c41 = circ(vUv, vec2(0.5 * sin(u_time * 3.10), 0.5 * cos(u_time - 3.10)), 0.025);\n    float c42 = circ(vUv, vec2(0.5 * sin(u_time * 3.15), 0.5 * cos(u_time - 3.15)), 0.025);\n    float c43 = circ(vUv, vec2(0.5 * sin(u_time * 3.20), 0.5 * cos(u_time - 3.20)), 0.025);\n    float c44 = circ(vUv, vec2(0.5 * sin(u_time * 3.25), 0.5 * cos(u_time - 3.25)), 0.025);\n    float c45 = circ(vUv, vec2(0.5 * sin(u_time * 3.30), 0.5 * cos(u_time - 3.30)), 0.025);\n    float c46 = circ(vUv, vec2(0.5 * sin(u_time * 3.35), 0.5 * cos(u_time - 3.35)), 0.025);\n    float c47 = circ(vUv, vec2(0.5 * sin(u_time * 3.40), 0.5 * cos(u_time - 3.40)), 0.025);\n    float c48 = circ(vUv, vec2(0.5 * sin(u_time * 3.45), 0.5 * cos(u_time - 3.45)), 0.025);\n    float c49 = circ(vUv, vec2(0.5 * sin(u_time * 3.50), 0.5 * cos(u_time - 3.50)), 0.025);\n    float c50 = circ(vUv, vec2(0.5 * sin(u_time * 3.55), 0.5 * cos(u_time - 3.55)), 0.025);\n    color.rg += c1 + c2 + c3 + c4 + c5 + c6 + c7 + c8 + c9 + c10 +\n             c11 + c12 + c13 + c14 + c15 + c16 + c17 + c18 + c19 + c20 +\n             c21 + c22 + c23 + c24 + c25 + c26 + c27 + c28 + c29 + c30 +\n             c31 + c32 + c33 + c34 + c35 + c36 + c37 + c38 + c39 + c40 +\n             c41 + c42 + c43 + c44 + c45 + c46 + c47 + c48 + c49 + c50;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Iy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jy,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ey=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //rotation function\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5. - 2.5;\n    float t = u_time;\n    vUv *= Rot(t);\n    float d1 = length( min(abs(vec2(vUv.x + sin(u_time), vUv.y * cos(u_time)) + 0.15 * 1.1)-.1,0.));\n    float d2 = length( min(abs(vec2(vUv.x * sin(u_time), vUv.y + cos(u_time)) - 0.25 * 2.1)-.1,0.));\n    float d3 = length( min(abs(vec2(vUv.x + sin(u_time), vUv.y * cos(u_time)) + 0.35 * 3.1)-.1,0.));\n    float d4 = length( min(abs(vec2(vUv.x * sin(u_time), vUv.y + cos(u_time)) - 0.45 * 4.1)-.1,0.));\n    float d5 = length( min(abs(vec2(vUv.x + sin(u_time), vUv.y * cos(u_time)) + 0.55 * 5.1)-.1,0.));\n    float d6 = length( min(abs(vec2(vUv.x * sin(u_time), vUv.y + cos(u_time)) - 0.65 * 6.1)-.1,0.));\n    float d7 = length( min(abs(vec2(vUv.x + sin(u_time), vUv.y * cos(u_time)) + 0.75 * 7.1)-.1,0.));\n    float d8 = length( min(abs(vec2(vUv.x * sin(u_time), vUv.y + cos(u_time)) - 0.85 * 8.1)-.1,0.));\n    //d = length( max(abs(vUv)-.3,0.) );\n    vec3 color = vec3(0.);\n    color = vec3(fract(d1 * 10.));\n    color += vec3(fract(d2 * 10.));\n    color += vec3(fract(d3 * 10.));\n    color += vec3(fract(d4 * 10.));\n    color += vec3(fract(d5 * 10.));\n    color += vec3(fract(d6 * 10.));\n    color += vec3(fract(d7 * 10.));\n    color += vec3(fract(d8 * 10.));\n    //color = vec3(step(0.3, d) * step(d, 0.4));\n    //color = vec3(smoothstep(0.3, 0.4, d) * smoothstep(0.6, 0.5, d));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Oy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Ey,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ay=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * 4. -2.;\n        float d1 = step(0.05, length(abs(vec2(vUv.x + sin(u_time * 1.0 * 1.2) - 0.0, vUv.y + cos(u_time *  1.0 * 1.2) - 0.0)) - 0.25));\n        float d2 = step(0.05, length(abs(vec2(vUv.x + cos(u_time * 1.1 * 1.2) - 0.0, vUv.y + sin(u_time *  1.1 * 1.2) - 0.0)) - 0.25));\n        float d3 = step(0.05, length(abs(vec2(vUv.x + cos(u_time * 1.2 * 1.2) - 0.1, vUv.y + sin(u_time *  1.2 * 1.2) - 0.1)) - 0.25));\n        float d4 = step(0.05, length(abs(vec2(vUv.x + sin(u_time * 1.3 * 1.2) - 0.1, vUv.y + cos(u_time *  1.3 * 1.2) - 0.1)) - 0.25));\n        float d5 = step(0.05, length(abs(vec2(vUv.x + cos(u_time * 1.4 * 1.2) + 0.1, vUv.y + sin(u_time *  1.4 * 1.2) + 0.1)) - 0.25));\n        float d6 = step(0.05, length(abs(vec2(vUv.x + sin(u_time * 1.5 * 1.2) + 0.1, vUv.y + cos(u_time *  1.5 * 1.2) + 0.1)) - 0.25));\n        float d7 = step(0.05, length(abs(vec2(vUv.x + cos(u_time * 1.6 * 1.2) + 0.1, vUv.y + sin(u_time *  1.6 * 1.2) - 0.1)) - 0.25));\n        float d8 = step(0.05, length(abs(vec2(vUv.x + sin(u_time * 1.7 * 1.2) + 0.1, vUv.y + cos(u_time *  1.7 * 1.2) - 0.1)) - 0.25));\n        float d9 = step(0.05, length(abs(vec2(vUv.x + cos(u_time * 1.8 * 1.2) - 0.1, vUv.y + sin(u_time *  1.8 * 1.2) + 0.1)) - 0.25));\n        float d10 = step(0.05, length(abs(vec2(vUv.x +sin(u_time * 1.9 * 1.2) - 0.1, vUv.y + cos(u_time *  1.9 * 1.2) + 0.1)) - 0.25));\n    \n        vec3 color = vec3(0.);\n        color = vec3(d1 * d2 * d3 * d4 * d5 * d6 * d7 * d8 * d9 * d10);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ly(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Ay,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Gy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * 4. -2.;\n        float d1 = step(0.1*  abs(sin(2.0 * u_time)), length(abs(vec2(vUv.x - 1.50, vUv.y + cos(u_time *  3.0 * 0.75))) - 0.25));\n        float d2 = step(0.1*  abs(sin(2.1 * u_time)), length(abs(vec2(vUv.x - 1.25, vUv.y + cos(u_time *  3.1 * 0.75))) - 0.25));\n        float d3 = step(0.1*  abs(sin(2.2 * u_time)), length(abs(vec2(vUv.x - 1.00, vUv.y + cos(u_time *  3.2 * 0.75))) - 0.25));\n        float d4 = step(0.1*  abs(sin(2.3 * u_time)), length(abs(vec2(vUv.x - 0.75, vUv.y + cos(u_time *  3.3 * 0.75))) - 0.25));\n        float d5 = step(0.1*  abs(sin(2.4 * u_time)), length(abs(vec2(vUv.x - 0.50, vUv.y + cos(u_time *  3.4 * 0.75))) - 0.25));\n        float d6 = step(0.1*  abs(sin(2.5 * u_time)), length(abs(vec2(vUv.x - 0.25, vUv.y + cos(u_time *  3.5 * 0.75))) - 0.25));\n        float d7 = step(0.1*  abs(sin(2.6 * u_time)), length(abs(vec2(vUv.x + 0.00, vUv.y + cos(u_time *  3.6 * 0.75))) - 0.25));\n        float d8 = step(0.1*  abs(sin(2.7 * u_time)), length(abs(vec2(vUv.x + 0.25, vUv.y + cos(u_time *  3.7 * 0.75))) - 0.25));\n        float d9 = step(0.1*  abs(sin(2.8 * u_time)), length(abs(vec2(vUv.x + 0.50, vUv.y + cos(u_time *  3.8 * 0.75))) - 0.25));\n        float d10 =step(0.1*  abs(sin(2.9 * u_time)), length(abs(vec2(vUv.x + 0.75, vUv.y + cos(u_time *  3.9 * 0.75))) - 0.25));\n        float d11 =step(0.1*  abs(sin(3.0 * u_time)), length(abs(vec2(vUv.x + 1.00, vUv.y + cos(u_time *  4.0 * 0.75))) - 0.25));\n        float d12 =step(0.1*  abs(sin(3.1 * u_time)), length(abs(vec2(vUv.x + 1.25, vUv.y + cos(u_time *  4.1 * 0.75))) - 0.25));\n        float d13 =step(0.1*  abs(sin(3.2 * u_time)), length(abs(vec2(vUv.x + 1.50, vUv.y + cos(u_time *  4.2 * 0.75))) - 0.25));\n    \n        vec3 color = vec3(0.);\n        color = 1. - vec3(d1 * d2 * d3 * d4 * d5 * d6 * d7 * d8 * d9 * d10 * d11 * d12 * d13);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ny(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Gy,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var By=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //rotation function\nmat2 RotClock(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nmat2 RotCounter(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    float t=u_time*.25 - 0.5;\n    \n    vec3 color = vec3(0.);\n    \n    vec2 pos = vec2(0.5 - vUv.x, 0.5 - vUv.y);\n    pos*=RotClock(t*1.)*2.;\n    float r=length(pos)*2.;\n    float a=atan(pos.y,pos.x);\n    \n    vec2 pos2=vec2(.28-vUv.x,.72-vUv.y);\n    pos2*= RotCounter(t*1.)*2.;\n    float r2=length(pos2)*2.;\n    float a2=atan(pos2.y,pos2.x);\n\n    vec2 pos3=vec2(.78-vUv.x,.64-vUv.y);\n    pos3*=RotCounter(t*1.)*2.;\n    float r3=length(pos3)*2.;\n    float a3=atan(pos3.y,pos3.x);\n\n    vec2 pos4=vec2(.55-vUv.x,.19-vUv.y);\n    pos4*=RotCounter(t*1.)*2.;\n    float r4=length(pos4)*2.;\n    float a4=atan(pos4.y,pos4.x);\n    \n    \n    float f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;\n    float f2=smoothstep(-.5,1.,cos(a2*10.))*.2+.5;\n    float f3=smoothstep(-.5,1.,cos(a3*10.))*.2+.5;\n    float f4=smoothstep(-.5,1.,cos(a4*10.))*.2+.5;\n\n    vec3 d1=vec3(1.-smoothstep(f, f + 0.02, r));\n    vec3 d2=vec3(1.-smoothstep(f2,f2+.02,r2));\n    vec3 d3=vec3(1.-smoothstep(f3,f3+.02,r3));\n    vec3 d4=vec3(1.-smoothstep(f4,f4+.02,r4));\n\n    color = d1;\n    color += d2;\n    color += d3;\n    color+=d4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:By,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Vy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //rotation function\nmat2 RotClock(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid main(){\n    vec3 color = vec3(0.);\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. -1.;\n\n    vec2 pos=vec2(vUv.x,vUv.y * abs(cos(u_time * 0.5)));\n    vec2 pos2=vec2(vUv.x * abs(sin(u_time)),vUv.y);\n    vec2 pos3=vec2(vUv.x * abs(cos(u_time)),vUv.y);\n    float t=u_time*.25-.5;\n    pos*=RotClock(t*1.);\n    pos2*=RotClock(t*1.);\n    pos3*=RotClock(t*1.);\n    \n    int tri = 3;\n    int quad= 4;\n    int pent =5;\n    int hex = 6;\n    float a = atan(pos.x, pos.y) + PI ;\n    float a2=atan(pos2.x,pos2.y)+PI;\n    float a3=atan(pos3.x,pos3.y)+PI;\n    float r3=TWO_PI/float(tri) ;\n    float r4=TWO_PI/float(quad);\n    float r6=TWO_PI/float(hex) ;\n    float d3=cos(floor(.5+a/r3)*r3 - a)*(length(vUv)) * 3.0;\n    float d4=cos(floor(.5+a2/r4)*r4 - a2)*(length(vUv)) * 1.0;\n    float d6=cos(floor(.5+a3/r6)*r6 - a3)*(length(vUv)) * 0.5;\n    float shape3= (1.-smoothstep(.4,.41,d3));\n    float shape4= (1.-smoothstep(.4,.41,d4));\n    float shape6= (1.-smoothstep(.4,.41,d6));\n    //shape = vec3(d);\n    color.xz += shape3 - 0.1;\n    color.y += shape4;\n    color.z += shape6;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Wy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Vy,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Hy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * 2. - 1.;\n        vec3 color = vec3(0.);\n        float d = length((vec2((vUv.x) - (sin(u_time/2.)), (vUv.y) - cos(u_time/2.))) );\n        d *= atan(d, d);\n        d *= step(0.05, d);\n        float d2=length((vec2((vUv.x) - (cos(u_time/2.)),(vUv.y) - sin(u_time/2.))) );\n        d2*=atan(d2, d2);\n        d2*=step(.05,d2);\n        color = vec3(d / vUv.x, d +  vUv.y, 0.5);\n        color += vec3(d2 / vUv.x, d2 + vUv.y, 0.5);\n        color *= vec3(d);\n        color *= vec3(d2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Xy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Hy,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Yy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = vUv * 3.0 - 1.5;\n        float t = u_time * u_time;\n        vUv *= Rot(t);\n        float r = length(vec2(vUv.x, vUv.y));\n        float a = atan(vUv.x, vUv.y);\n        float f = cos(a * 3.);\n        float shape = 1. - smoothstep(f, f + 0.02, r);\n        color = vec3(shape * vUv.x, shape * vUv.y, shape * vUv.x * vUv.y);  \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Zy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Yy,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qy=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n        float t = u_time * 0.75;\n        vUv *= Rot(t);\n        vec3 color = vec3(0.);\n        int N = 3;\n        float a  = dot(vUv.x, vUv.y) * TWO_PI * 1. - sin(u_time + TWO_PI);\n        float r = PI/(float(N) * 1.  - (sin(u_time)));\n        float d = cos(floor(.5 + a / r) * r - a) * length(vUv);\n        float shape = 1.0 - smoothstep(.05, 0.9, d);\n        color = vec3(shape * vUv.x + shape, shape * vUv.y + shape, shape);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Jy(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Qy,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ky=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec3 color = vec3(0.);\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 4. -2.;\n        float t = u_time * 0.75;\n        vUv *= Rot(t);\n        int sides = 3;\n        float a = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/float(sides);\n        float shape = cos(floor(.5 + a/r) * r -a) * length(vUv + atan(sin(u_time * 0.5)));\n        float shape2 = cos(floor(.5 + a/r) * r -a) * length(vUv + atan(cos(u_time * 0.75)));\n        float shape3 = cos(floor(.5 + a/r) * r -a) * length(vUv + atan(sin(u_time * 0.6)));\n        float str = 1.0 - smoothstep(.2, .41, shape);\n        float str2 = 1.0 - smoothstep(.2, .41, shape2);\n        float str3 = 1.0 - smoothstep(.2, .41, shape3);\n        color = vec3(str, str, vUv.y * str * vUv.x);\n        color += vec3(str2, vUv.y * str2 * vUv.x, str2);\n        color += vec3(vUv.y * str3 * vUv.x, str3, str3);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $y(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Ky,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 6. - 3.;\n        float a  = atan(vUv.x + cos(u_time) * 2.0, vUv.y + sin(u_time) * 2.0) + (sin(u_time * 0.5) * 3.0);\n        float r = TWO_PI/3.;\n        float d = sin(floor(.8 + a/r) * r -a ) * length(vUv);\n        float shape = 1.0 - smoothstep(.4, .41, d);\n        vec3 color = vec3(0.);\n        color = vec3(shape - 0.2, shape - 0.5, shape + 0.3);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function eb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //rotation function\nmat2 Rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 3. - 1.5;\n    float t=u_time*.25;\n    vUv*=Rot(t*1.);\n    vec3 color = vec3(0.);\n    float r = sin(vUv.x * TWO_PI);\n    float s = cos(vUv.y * TWO_PI);\n    float q = cos(vUv.y * TWO_PI * sin(u_time * 0.5));\n    float p = sin(vUv.x * TWO_PI * sin(u_time * 0.5));\n    float str = r * s + q  + p;\n    float shape = smoothstep(.8, .81, str);\n    color = vec3(shape);\n    color *= q;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ob(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //rotation function\nmat2 Rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vUv = vUv * 2. - 1.;\n    vec2 r1=abs(vUv);\n    r1*=Rot(sin(u_time) );\n    vec2 r2=abs(vUv);\n    r2*=Rot(sin(u_time * .25) );\n    vec2 r3=abs(vUv);\n    r3*=Rot(sin(u_time * .50) );\n    vec2 r4=abs(vUv);\n    r4*=Rot(sin(u_time * .75) );\n    vec2 r5=abs(vUv);\n    r5*=Rot(sin(u_time * 1.25) );\n    float s1=max(r1.x,r1.y);\n    float s2=max(r2.x,r2.y);\n    float s3=max(r3.x,r3.y);\n    float s4=max(r4.x,r4.y);\n    float s5=max(r5.x,r5.y);\n    float shape1=step(.4,s1);\n    float shape2=step(s2,.5);\n    float shape3=step(.6,s3);\n    float shape4=step(s4,.3);\n    float shape5=step(.2,s5);\n    vec3 color = vec3(0.);\n    color = vec3(shape1 * shape2);\n    color += vec3(shape3);\n    color += vec3(shape4);\n    color *= vec3(shape5);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ab(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ib=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    mat2 Rot(float a){\n        float s=sin(a);\n        float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * (6. * sin(u_time * 0.5)) - (3. * sin(u_time * 0.5));\n        vec2 r1=vUv;\n        r1*=Rot(sin(-u_time * 0.5 * 3.));\n        vec2 r2=vUv;\n        r2*=Rot(sin(u_time * 0.4 * 3.));\n        vec2 r3=vUv;\n        r3*=Rot(sin(u_time * 0.6 * 3.));\n        vec2 r4=vUv;\n        r4*=Rot(sin(-u_time * 0.3 * 3.));\n        vec2 r5=vUv;\n        r5*=Rot(sin(u_time * 0.2 * 3.));\n        vec2 r6=vUv;\n        r6*=Rot(sin(-u_time * 0.1 * 3.));\n        vec3 color = vec3(0.);\n        int N = 6;\n        float a1=atan(r1.x,r1.y);\n        float a2=atan(r2.x,r2.y);\n        float a3=atan(r3.x,r3.y);\n        float a4=atan(r4.x,r4.y);\n        float a5=atan(r5.x,r5.y);\n        float a6=atan(r6.x,r6.y);\n        float b = 6.28319 / float(N);\n        vec3 shape1=vec3(smoothstep(.5, .51, cos(floor(.5 + a1/b) * b - a1) * length(vec2(vUv.x,vUv.y))));\n        vec3 shape2=vec3(smoothstep(1.1,1.11,cos(floor(.5+a2/b)*b-a2)*length(vec2(vUv.x,vUv.y))));\n        vec3 shape3=vec3(smoothstep(.1,.11,cos(floor(.5+a3/b)*b-a3)*length(vec2(vUv.x,vUv.y))));\n        vec3 shape4=vec3(smoothstep(1.5,1.51,cos(floor(.5+a4/b)*b-a4)*length(vec2(vUv.x,vUv.y))));\n        vec3 shape5=vec3(smoothstep(2.1,2.11,cos(floor(.5+a5/b)*b-a5)*length(vec2(vUv.x,vUv.y))));\n        vec3 shape6=vec3(smoothstep(2.51,2.51,cos(floor(.5+a6/b)*b-a6)*length(vec2(vUv.x,vUv.y))));\n        color = shape3;\n        color -= shape1;\n        color += shape2;\n        color -= shape4;\n        color += shape5;\n        color -= shape6;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:ib,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 4. - 2.;\n        vec3 color = vec3(0.);\n        float cir1 = circle(vec2(vUv.x + sin(u_time * 1.0), vUv.y - 1.00), 0.0125);\n        float cir2 = circle(vec2(vUv.x + sin(u_time * 1.1), vUv.y - 0.75), 0.0125);\n        float cir3 = circle(vec2(vUv.x + sin(u_time * 1.2), vUv.y - 0.50), 0.0125);\n        float cir4 = circle(vec2(vUv.x + sin(u_time * 1.3), vUv.y - 0.25), 0.0125);\n        float cir5 = circle(vec2(vUv.x + sin(u_time * 1.4), vUv.y - 0.00), 0.0125);\n        float cir6 = circle(vec2(vUv.x + sin(u_time * 1.5), vUv.y + 0.25), 0.0125);\n        float cir7 = circle(vec2(vUv.x + sin(u_time * 1.6), vUv.y + 0.50), 0.0125);\n        float cir8 = circle(vec2(vUv.x + sin(u_time * 1.7), vUv.y + 0.75), 0.0125);\n        float cir9 = circle(vec2(vUv.x + sin(u_time * 1.8), vUv.y + 1.00), 0.0125);\n    \n        float cirv1 = circle(vec2(vUv.x  - 1.00, vUv.y  + sin(u_time * 1.0)), 0.0125);\n        float cirv2 = circle(vec2(vUv.x  - 0.75, vUv.y  + sin(u_time * 1.1)), 0.0125);\n        float cirv3 = circle(vec2(vUv.x  - 0.50, vUv.y  + sin(u_time * 1.2)), 0.0125);\n        float cirv4 = circle(vec2(vUv.x  - 0.25, vUv.y  + sin(u_time * 1.3)), 0.0125);\n        float cirv5 = circle(vec2(vUv.x  - 0.00, vUv.y  + sin(u_time * 1.4)), 0.0125);\n        float cirv6 = circle(vec2(vUv.x  + 0.25, vUv.y  + sin(u_time * 1.5)), 0.0125);\n        float cirv7 = circle(vec2(vUv.x  + 0.50, vUv.y  + sin(u_time * 1.6)), 0.0125);\n        float cirv8 = circle(vec2(vUv.x  + 0.75, vUv.y  + sin(u_time * 1.7)), 0.0125);\n        float cirv9 = circle(vec2(vUv.x  + 1.00, vUv.y  + sin(u_time * 1.8)), 0.0125);\n        color = vec3(cir1 + cir2 + cir3 + cir4 + cir5 + cir6 + cir7 + cir8 + cir9);\n        color += vec3(cirv1 + cirv2 + cirv3 + cirv4 + cirv5 + cirv6 + cirv7 + cirv8 + cirv9);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    mat2 Rot(float a){\n        float s = sin(a);\n        float c = cos(a);\n        return mat2(c, -s, s, c);\n    }\n    \n    void main(){\n        vec2 pos = vec2(0.5) - vec2(vUv.x + 0.3, vUv.y);\n        vec2 pos2 = vec2(0.5) - vec2(vUv.x, vUv.y);\n        vec2 pos3 = vec2(0.5) - vec2(vUv.x - 0.3, vUv.y);\n        vec2 pos4 = vec2(0.5) - vec2(vUv.x + 0.3, vUv.y + 0.3);\n        vec2 pos5 = vec2(0.5) - vec2(vUv.x, vUv.y + 0.3);\n        vec2 pos6 = vec2(0.5) - vec2(vUv.x - 0.3, vUv.y + 0.3);\n        vec2 pos7 = vec2(0.5) - vec2(vUv.x + 0.3, vUv.y - 0.3);\n        vec2 pos8 = vec2(0.5) - vec2(vUv.x, vUv.y - 0.3);\n        vec2 pos9 = vec2(0.5) - vec2(vUv.x - 0.3, vUv.y - 0.3);\n        vec3 color = vec3(0.);\n        float t = u_time * 0.75;\n        pos *= Rot(t);\n        pos2 *= Rot(t * 1.5);\n        pos3 *= Rot(t * 2.0);\n        pos4 *= Rot(t * 2.5);\n        pos5 *= Rot(t * 3.0);\n        pos6 *= Rot(t * 3.5);\n        pos7 *= Rot(t * 2.0);\n        pos8 *= Rot(t * 3.5);\n        pos9 *= Rot(t * 3.0);\n        float r1 = length(pos) * 7.0;\n        float r2 = length(pos2) * 7.0;\n        float r3 = length(pos3) * 7.0;\n        float r4 = length(pos4) * 7.0;\n        float r5 = length(pos5) * 7.0;\n        float r6 = length(pos6) * 7.0;\n        float r7 = length(pos7) * 7.0;\n        float r8 = length(pos8) * 7.0;\n        float r9 = length(pos9) * 7.0;\n        float a = atan(pos.y, pos.x);\n        float a2 = atan(pos2.y, pos2.x);\n        float a3 = atan(pos3.y, pos3.x);\n        float a4 = atan(pos4.y, pos4.x);\n        float a5 = atan(pos5.y, pos5.x);\n        float a6 = atan(pos6.y, pos6.x);\n        float a7 = atan(pos7.y, pos7.x);\n        float a8 = atan(pos8.y, pos8.x);\n        float a9 = atan(pos9.y, pos9.x);\n        float f = cos(a * 3.);\n        float f2 = cos(a2 * 3.);\n        float f3 = cos(a3 * 3.);\n        float f4 = cos(a4 * 3.);\n        float f5 = cos(a5 * 3.);\n        float f6 = cos(a6 * 3.);\n        float f7 = cos(a7 * 3.);\n        float f8 = cos(a8 * 3.);\n        float f9 = cos(a9 * 3.);\n        float shape = 1. - smoothstep(f, f + 0.02, r1);\n        float shape2 = 1. - smoothstep(f2, f2 + 0.02, r2);\n        float shape3 = 1. - smoothstep(f3, f3 + 0.02, r3);\n        float shape4 = 1. - smoothstep(f4, f4 + 0.02, r4);\n        float shape5 = 1. - smoothstep(f5, f5 + 0.02, r5);\n        float shape6 = 1. - smoothstep(f6, f6 + 0.02, r6);\n        float shape7 = 1. - smoothstep(f7, f7 + 0.02, r7);\n        float shape8 = 1. - smoothstep(f8, f8 + 0.02, r8);\n        float shape9 = 1. - smoothstep(f9, f9 + 0.02, r9);\n        color = vec3(shape + shape2 + shape3 + shape4 + shape5 + shape6 + shape7 + shape8 + shape9);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ub(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //box sdf book of shaders\nfloat box(vec2 vUv, vec2 size){\n    size = vec2(0.5) - size * 0.5;\n    vec2 uv = smoothstep(size, size + vec2(0.001), vUv);\n    uv *= smoothstep(size, size + vec2(0.001), vec2(1.0) - vUv);\n    return uv.x * uv.y;\n}\n\n//cross sdf book of shaders\nfloat cross1(vec2 vUv, float size){\n    return box(vUv, vec2(size, size/4.)) + box(vUv, vec2(size/4., size));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vUv = vUv * 2. - 0.5;\n    vec3 color = vec3(0.);\n    vec2 translate = vec2((sin(u_time)), abs(cos(u_time)));\n    vUv += translate * 0.5;\n    float shape = cross1(vUv, 0.5);\n    color = vec3(shape);\n    color += vec3(vUv.x, vUv.y, 0.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //box sdf book of shaders\nfloat box(vec2 vUv, vec2 size){\n    size = vec2(0.5) - size * 0.5;\n    vec2 uv = smoothstep(size, size + vec2(0.001), vUv);\n    uv *= smoothstep(size, size + vec2(0.001), vec2(1.0) - vUv);\n    return uv.x * uv.y;\n}\n\n//cross sdf book of shaders\nfloat cross1(vec2 vUv, float size){\n    return box(vUv, vec2(size, size/4.)) + box(vUv, vec2(size/4., size));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 newUv = vUv;\n    vUv = vUv * 3. - 1.;\n    newUv = newUv * 3. - 1.;\n    vec2 translate = vec2(cos(u_time), sin(u_time));\n    vUv += translate;\n    //newUv += translate;\n    vec3 color = vec3(0.);\n    float shape = cross1(newUv, 0.5);\n    color = vec3(vUv, 0.);\n    color += vec3(shape);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function db(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //box sdf book of shaders\nfloat box(vec2 vUv, vec2 size){\n    size = vec2(0.5) - size * 0.5;\n    vec2 uv = smoothstep(size, size + vec2(0.001), vUv);\n    uv *= smoothstep(size, size + vec2(0.001), vec2(1.0) - vUv);\n    return uv.x * uv.y;\n}\n\n//cross sdf book of shaders\nfloat cross1(vec2 vUv, float size){\n    return box(vUv, vec2(size, size/4.)) + box(vUv, vec2(size/4., size));\n}\n\n//rotation 2d book of shaders\nmat2 rotate2d(float angle){\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vec2 newUv = vUv;\n    vUv = vUv * 2. - 0.5;\n    newUv = newUv * 2. - 1.;\n    newUv = rotate2d(cos(u_time) * PI) * newUv;\n    newUv += vec2(0.5);\n    vec3 color = vec3(0.);\n    float shape = cross1(newUv, 0.5);\n    float shape2 = cross1(vec2(newUv.x, newUv.y - 0.65), 0.5);\n    float shape3 = cross1(vec2(newUv.x, newUv.y + 0.65), 0.5);\n    float shape4 = cross1(vec2(newUv.x - 0.65, newUv.y), 0.5);\n    float shape5 = cross1(vec2(newUv.x + 0.65, newUv.y), 0.5);\n    color = vec3(shape + shape2 + shape3 + shape4 + shape5);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //box sdf book of shaders\nfloat box(vec2 vUv,vec2 size){\n    size=vec2(.5)-size*.5;\n    vec2 uv=smoothstep(size,size+vec2(.001),vUv);\n    uv*=smoothstep(size,size+vec2(.001),vec2(1.)-vUv);\n    return uv.x*uv.y;\n}\n\n//cross sdf book of shaders\nfloat crossSDF(vec2 vUv,float size){\n    return box(vUv,vec2(size,size/4.))+box(vUv,vec2(size/4.,size));\n}\n\n//rotation 2d book of shaders\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\n//scale 2d book of shaders\nmat2 scale(vec2 s){\n    return mat2(s.x, 0.0,\n                0.0, s.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv);\n    vec2 newUv = vUv;\n    newUv = newUv * 2. - 1.;\n    newUv = rotate2d(sin(u_time) * PI) * newUv;\n    newUv += vec2(0.5);\n    newUv -= vec2(0.5);\n    newUv = scale(vec2(sin(u_time) + 1.)) * newUv;\n    newUv += vec2(0.5);\n    //vUv = rotate2d(sin(u_time) * PI) * vUv;\n    vec3 color = vec3(0.);\n    float shape = crossSDF(newUv, 0.5);\n    color += vec3(shape);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // YUV to RGB matrix book of shaders\nmat3 yuv2rgb=mat3(1.,0.,1.13983,\n    1.,-.39465,-.58060,\n    1.,2.03211,0.);\n\n// RGB to YUV matrix book of shaders\nmat3 rgb2yuv=mat3(.2126,.7152,.0722,\n    -.09991,-.33609,.43600,\n    .615,-.5586,-.05639);\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv -= 0.5;\n    vUv *= 4.0;\n    float cir = 1. - smoothstep(1.0, 1.01, distance(vec2(vUv.x + 0.5, vUv.y + 0.5), vec2(0.5)));\n    vec3 color = rgb2yuv * vec3(sin(u_time), vUv.x + sin(u_time), vUv.y + cos(u_time));\n    color *= vec3(cir);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ub(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _b=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float cir(vec2 vUv,vec2 pos,float s){\n        return 1.-smoothstep(s,s+.01,distance(vUv,pos));\n    }\n    \n    mat2 scale(vec2 s){\n        return mat2(s.x, 0.0,\n                    0.0, s.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 0.5;\n        vec2 newUv = vUv;\n        newUv -= vec2(0.5);\n        newUv = scale(vec2(sin((u_time * 1.5) + 1.0/1.5) + 2.0)) * newUv;\n        newUv += vec2(0.5);\n    \n        vec2 newUv2=vUv;\n        newUv2-=vec2(.5);\n        newUv2=scale(vec2(sin((u_time * 1.5) + 2.0/1.5) +2.))*newUv2;\n        newUv2+=vec2(.5);\n    \n        vec2 newUv3=vUv;\n        newUv3-=vec2(.5);\n        newUv3=scale(vec2(sin((u_time * 1.5) + 3.0/1.5) +2.))*newUv3;\n        newUv3+=vec2(.5);\n    \n        vec2 newUv4=vUv;\n        newUv4-=vec2(.5);\n        newUv4=scale(vec2(sin((u_time * 1.5) + 4.0/1.5) +2.))*newUv4;\n        newUv4+=vec2(.5);\n    \n        vec2 newUv5=vUv;\n        newUv5-=vec2(.5);\n        newUv5=scale(vec2(sin((u_time * 1.5) + 5.0/1.5) +2.))*newUv5;\n        newUv5+=vec2(.5);\n    \n        vec3 color = vec3(0.);\n        float c1=cir(newUv ,vec2(-0.2,.5),.1);\n        float c2=cir(newUv2,vec2(.15,.5),.1);\n        float c3=cir(newUv3,vec2(.5,.5),.1);\n        float c4=cir(newUv4,vec2(0.85,.5),.1);\n        float c5=cir(newUv5,vec2(1.2,.5),.1);\n        color = vec3(c1 + c2 + c3 + c4 + c5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_b,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Sb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    mat2 Rot(float x){\n        return mat2(cos(x), -sin(x),\n                    sin(x), cos(x));\n    }\n    \n    mat2 Scale(vec2 s){\n        return mat2(s.x, 0.0,\n                    0.0, s.y);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * 2. - 0.5;\n        vec3 color = vec3(0.);\n    \n        vec2 newUv = vUv;\n        newUv -= vec2(0.5);\n        newUv = Scale(vec2(sin(u_time) )) * newUv;\n        newUv += vec2(0.5);\n        \n        vec2 newUv2 = vUv;\n        newUv2 -= vec2(0.5);\n        newUv2 = Scale(vec2((sin(u_time) + 1.25))) * newUv2;\n        newUv2 += vec2(0.5);\n        \n        vec2 newUv3 = vUv;\n        newUv3 -= vec2(0.5);\n        newUv3 = Scale(vec2((sin(u_time) + 1.5))) * newUv3;\n        newUv3 += vec2(0.5);\n    \n        vec2 newUv4 = vUv;\n        newUv4 -= vec2(0.5);\n        newUv4 = Scale(vec2((sin(u_time) + 1.85))) * newUv4;\n        newUv4 += vec2(0.5);\n    \n        vec2 newUv5 = vUv;\n        newUv5 -= vec2(0.5);\n        newUv5 = Scale(vec2((sin(u_time) + 1.95))) * newUv5;\n        newUv5 += vec2(0.5);\n    \n        vec2 newUv6 = vUv;\n        newUv6 -= vec2(0.5);\n        newUv6 = Scale(vec2((sin(u_time) + 1.0))) * newUv6;\n        newUv6 += vec2(0.5);\n    \n        float shape = Cir(newUv, vec2(0.5), 0.5) - Cir(newUv, vec2(0.5), 0.45);\n        float shape2 = Cir(newUv2, vec2(0.5), 0.4) - Cir(newUv2, vec2(0.5), 0.35);\n        float shape3 = Cir(newUv3, vec2(0.5), 0.3) - Cir(newUv3, vec2(0.5), 0.25);\n        float shape4 = Cir(newUv4, vec2(0.5), 0.2) - Cir(newUv4, vec2(0.5), 0.15);\n        float shape5 = Cir(newUv5, vec2(0.5), 0.6) - Cir(newUv5, vec2(0.5), 0.55);\n        float shape6 = Cir(newUv6, vec2(0.5), 0.7) - Cir(newUv6, vec2(0.5), 0.65);\n        \n    \n        color = vec3(shape + shape2 + shape3 + shape4 + shape5 + shape6);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Mb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Sb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    mat2 rotate2d(float angle){\n        return mat2(cos(angle), -sin(angle),\n                    sin(angle), cos(angle));\n    }\n    \n    float box(vec2 vUv, vec2 size){\n        vUv = vUv * 2. - 1.0;\n        size = vec2(0.5) - size * 0.5;\n        vUv = rotate2d(cos(u_time) * PI) * vUv;\n        vUv += vec2(0.5);\n        vec2 sdf = smoothstep(size, size+vec2(0.01), vUv);\n        sdf *= smoothstep(size, size+vec2(0.01), vec2(1.0) - vUv);\n        vec2 newUv = vUv; \n        newUv -= vec2(0.5);\n        newUv = rotate2d(sin(u_time) * PI) * newUv;\n        newUv += vec2(0.5);\n        vec2 sdf2 = smoothstep(size, size + vec2(0.01), newUv);\n        sdf2 *= smoothstep(size, size + vec2(0.01), vec2(1.0) - newUv);\n        return (sdf.x * sdf.y) + (sdf2.x * sdf2.y);\n    }\n    \n    float shape(vec2 vUv, float size){\n        return box(vUv, vec2(size, size/8.)) +\n               box(vUv, vec2(size/8., size));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float x = shape(vUv, 1.5);\n        color = vec3(x, x * sin(u_time), x*cos(u_time));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Cb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //box sdf\nfloat box(vec2 vUv, vec2 size){\n    size = vec2(0.5) - size * 0.5;\n    vec2 sdf = smoothstep(size, size+vec2(0.01), vUv);\n    sdf *= smoothstep(size, size+vec2(0.01), vec2(1.0) - vUv);\n    return sdf.x * sdf.y;\n}\n\nfloat Cir(vec2 vUv, vec2 pos, float size){\n    return (1. - smoothstep(size, size + 0.01, distance(vUv, pos))) * smoothstep(size/2., size/2. + 0.01, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x - 0.25, vUv.y - 0.5);\n    vUv = vUv * 2.0;\n    vec3 color = vec3(0.);\n    vec2 onevUv = vec2(vUv.x + 0.36, vUv.y);\n    onevUv.y += abs(sin(u_time * 0.75 + 0.1));\n    float oneShape = box(onevUv, vec2(0.09, 0.3));\n    color = vec3(oneShape);\n    vec2 twovUv = vec2(vUv.x, vUv.y);\n    twovUv.y += abs(sin(u_time * 0.75));\n    float twoShape = Cir(twovUv, vec2(0.4, 0.5), 0.15);\n    color += vec3(twoShape);\n    vec2 threevUv = vec2(vUv);\n    threevUv.y += abs(sin(u_time * 0.75 - 0.1));\n    float threeShape = Cir(threevUv, vec2(0.76, 0.5), 0.15);\n    color += vec3(threeShape + cos(u_time), threeShape, threeShape + sin(u_time));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Tb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Cb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Rb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 newUv = vec2(vUv);\n        newUv.x += abs(sin(u_time * 0.45))/ 5.5 - 0.1;\n        // newUv.y += abs(sin(u_time * 0.75))/ 50. - 0.1;\n        float shape1 = cir(vUv, vec2(0.35, 0.7), 0.1);\n        float shape2 = cir(newUv, vec2(0.35, 0.7), 0.05);\n        float shape3 = cir(vUv, vec2(0.65, 0.7), 0.1);\n        float shape4 = cir(newUv, vec2(0.65, 0.7), 0.05);\n        float shape5 = cir(vUv, vec2(0.5, 0.35), 0.2);\n        float shape6 = cir(vUv, vec2(0.5, 0.3), 0.2);\n        color = vec3(shape1);\n        color -= vec3(shape2);\n        color += vec3(shape3);\n        color -= vec3(shape4);\n        color += vec3(shape5);\n        color -= vec3(shape6);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Db(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Rb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Pb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    void main(){\n        vec2 vUv = vec2(vUv);\n        vec3 color=vec3(0.);\n    \n        vec2 uv1=vUv;\n        uv1=uv1*2.-.5;\n        vec2 t1=vec2(cos(u_time*PI*.100),sin(u_time*PI*.480));\n        uv1+=t1*.75;\n    \n        vec2 uv2=vUv;\n        uv2=uv2*2.-.5;\n        vec2 t2=vec2(cos(u_time*PI*.120),sin(u_time*PI*.460));\n        uv2+=t2*.75;\n    \n        vec2 uv3=vUv;\n        uv3=uv3*2.-.5;\n        vec2 t3=vec2(cos(u_time*PI*.140),sin(u_time*PI*.440));\n        uv3+=t3*.75;\n    \n        vec2 uv4=vUv;\n        uv4=uv4*2.-.5;\n        vec2 t4=vec2(cos(u_time*PI*.160),sin(u_time*PI*.420));\n        uv4+=t4*.75;\n    \n        vec2 uv5=vUv;\n        uv5=uv5*2.-.5;\n        vec2 t5=vec2(cos(u_time*PI*.180),sin(u_time*PI*.400));\n        uv5+=t5*.75;\n    \n        vec2 uv6=vUv;\n        uv6=uv6*2.-.5;\n        vec2 t6=vec2(cos(u_time*PI*.200),sin(u_time*PI*.380));\n        uv6+=t6*.75;\n    \n        vec2 uv7=vUv;\n        uv7=uv7*2.-.5;\n        vec2 t7=vec2(cos(u_time*PI*.220),sin(u_time*PI*.360));\n        uv7+=t7*.75;\n    \n        vec2 uv8=vUv;\n        uv8=uv8*2.-.5;\n        vec2 t8=vec2(cos(u_time*PI*.240),sin(u_time*PI*.340));\n        uv8+=t8*.75;\n    \n        vec2 uv9=vUv;\n        uv9=uv9*2.-.5;\n        vec2 t9=vec2(cos(u_time*PI*.260),sin(u_time*PI*.320));\n        uv9+=t9*.75;\n    \n        vec2 uv10=vUv;\n        uv10=uv10*2.-.5;\n        vec2 t10=vec2(cos(u_time*PI*.280),sin(u_time*PI*.300));\n        uv10+=t10*.75;\n    \n        vec2 uv11=vUv;\n        uv11=uv11*2.-.5;\n        vec2 t11=vec2(cos(u_time*PI*.300),sin(u_time*PI*.280));\n        uv11+=t11*.75;\n    \n        vec2 uv12=vUv;\n        uv12=uv12*2.-.5;\n        vec2 t12=vec2(cos(u_time*PI*.320),sin(u_time*PI*.260));\n        uv12+=t12*.75;\n    \n        vec2 uv13=vUv;\n        uv13=uv13*2.-.5;\n        vec2 t13=vec2(cos(u_time*PI*.340),sin(u_time*PI*.240));\n        uv13+=t13*.75;\n    \n        vec2 uv14=vUv;\n        uv14=uv14*2.-.5;\n        vec2 t14=vec2(cos(u_time*PI*.360),sin(u_time*PI*.220));\n        uv14+=t14*.75;\n    \n        vec2 uv15=vUv;\n        uv15=uv15*2.-.5;\n        vec2 t15=vec2(cos(u_time*PI*.380),sin(u_time*PI*.200));\n        uv15+=t15*.75;\n    \n        vec2 uv16=vUv;\n        uv16=uv16*2.-.5;\n        vec2 t16=vec2(cos(u_time*PI*.400),sin(u_time*PI*.180));\n        uv16+=t16*.75;\n    \n        vec2 uv17=vUv;\n        uv17=uv17*2.-.5;\n        vec2 t17=vec2(cos(u_time*PI*.420),sin(u_time*PI*.160));\n        uv17+=t17*.75;\n    \n        vec2 uv18=vUv;\n        uv18=uv18*2.-.5;\n        vec2 t18=vec2(cos(u_time*PI*.440),sin(u_time*PI*.140));\n        uv18+=t18*.75;\n    \n        vec2 uv19=vUv;\n        uv19=uv19*2.-.5;\n        vec2 t19=vec2(cos(u_time*PI*.460),sin(u_time*PI*.120));\n        uv19+=t19*.75;\n    \n        vec2 uv20=vUv;\n        uv20=uv20*2.-.5;\n        vec2 t20=vec2(cos(u_time*PI*.480),sin(u_time*PI*.100));\n        uv20+=t20*.75;\n        \n        float c1= Cir(uv1,vec2(.5,.5),.05);\n        float c2= Cir(uv2,vec2(.5,.5),.05);\n        float c3= Cir(uv3,vec2(.5,.5),.05);\n        float c4= Cir(uv4,vec2(.5,.5),.05);\n        float c5= Cir(uv5,vec2(.5,.5),.05);\n        float c6= Cir(uv6,vec2(.5,.5),.05);\n        float c7= Cir(uv7,vec2(.5,.5),.05);\n        float c8= Cir(uv8,vec2(.5,.5),.05);\n        float c9= Cir(uv9,vec2(.5,.5),.05);\n        float c10=Cir(uv10,vec2(.5,.5),.05);\n        float c11=Cir(uv11,vec2(.5,.5),.05);\n        float c12=Cir(uv12,vec2(.5,.5),.05);\n        float c13=Cir(uv13,vec2(.5,.5),.05);\n        float c14=Cir(uv14,vec2(.5,.5),.05);\n        float c15=Cir(uv15,vec2(.5,.5),.05);\n        float c16=Cir(uv16,vec2(.5,.5),.05);\n        float c17=Cir(uv17,vec2(.5,.5),.05);\n        float c18=Cir(uv18,vec2(.5,.5),.05);\n        float c19=Cir(uv19,vec2(.5,.5),.05);\n        float c20=Cir(uv20,vec2(.5,.5),.05);\n    \n    \n        color += vec3(c1+c2+c3+c4+c5 \n                      +c6+c7+c8+c9+c10+\n                      c11+c12+c13+c14+c15+\n                      +c16+c17+c18+c19+c20);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Fb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Pb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //triangle\nfloat Tri(vec2 vUv, float size){\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI / 3.;\n    float d = cos(floor(.5 + a/r) * r - a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\n//rotate\nmat2 Rot(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\n//Cir\nfloat Cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n\n    vec2 t1vUv = vUv;\n    t1vUv=Rot(sin(u_time * 0.25)*PI)*t1vUv;\n    float t1 = Tri(t1vUv, 0.1) - Tri(t1vUv, 0.075);\n    \n    vec2 t2vUv = vUv;\n    t2vUv = Rot(PI) * t2vUv;\n    t2vUv = Rot(sin(u_time * 0.25) * PI) * t2vUv;\n    float t2 = Tri(vec2(t2vUv.x, t2vUv.y), 0.1) - Tri(vec2(t2vUv.x, t2vUv.y), 0.075);\n\n    float c = Cir(vUv, vec2(0.0), 0.3) - Cir(vUv, vec2(0.0), 0.275);\n    color = vec3(t1 + t2);\n    color += vec3(c);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ib(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Eb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float Shape(vec2 vUv, float x){\n        vec2 pos = vec2(0.5) - vUv;\n        float r = length(pos) * 2.5;\n        float a = atan(pos.y, pos.x);\n        float f = abs(cos(a * 4.) * sin(u_time * x));\n        return 1. - smoothstep(f, f + 0.02, r);\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 uv1 = vUv;\n        uv1 -= vec2(0.5);\n        uv1 = Rot(sin(u_time * PI * 0.5)) * uv1;\n        uv1 += vec2(0.5);\n    \n        vec2 uv2 = vUv;\n        uv2 -= vec2(0.5);\n        uv2 = Rot(sin(u_time * PI * 0.45)) * uv2;\n        uv2 += vec2(0.5);\n    \n        vec2 uv3 = vUv;\n        uv3 -= vec2(0.5);\n        uv3 = Rot(sin(u_time * PI * 0.4)) * uv3;\n        uv3 += vec2(0.5);\n        float s1 = Shape(uv1, 0.5);\n        float s2 = Shape(uv2, 0.61);\n        float s3 = Shape(uv3, 0.71);\n        color.r = s1 * abs(sin(u_time));\n        color.g = s2 * abs(cos(u_time));\n        color.b = s3;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ob(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Eb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ab=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    float Tri(vec2 vUv, float size){\n        float a = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/3.;\n        float d = cos(floor(.5 + a/r) * r -a) * length(vUv);\n        return 1. - smoothstep(size, size + 0.01, d);\n    }\n    \n    void main(){\n        vec3 color = vec3(0.);\n        vec2 vUv = vec2(vUv.x - 0.1, vUv.y + 0.1);\n        vUv = vUv * 9. - 4.5;\n    \n        //vUv -= vec2(1.5);\n        //vUv = Rot(PI * 0.75 + u_time) * vUv;\n        //vUv += vec2(1.5);\n    \n        vec2 rotUv1 = vUv;\n    \n        vec2 rotUv2 = Rot((PI)) * vUv;\n        rotUv2.y  = rotUv2.y + 0.22 ;\n        rotUv2.x = rotUv2.x + 0.45;\n    \n        vec2 rotUv3 = Rot((PI)) * vUv;\n        rotUv3.y  = rotUv3.y + 0.22;\n        rotUv3.x = rotUv3.x - 0.45;\n    \n        vec2 rotUv4 =  vUv;\n        rotUv4.x = rotUv4.x - 0.9 / abs(sin(u_time));\n    \n        vec2 rotUv5 =  vUv;\n        rotUv5.x = rotUv5.x + 0.9;\n    \n        vec2 rotUv6 = Rot(PI) * vUv;\n        rotUv6.y = rotUv6.y + 0.95;\n        \n        vec2 rotUv7 =  vUv;\n        rotUv7.x = rotUv7.x + 0.45;\n        rotUv7.y = rotUv7.y - 0.725;\n    \n        vec2 rotUv8 =  vUv;\n        rotUv8.x = rotUv8.x - 0.45;\n        rotUv8.y = rotUv8.y - 0.725;\n    \n        vec2 rotUv9 = Rot((PI)) * vUv;\n        rotUv9.y  = rotUv9.y + 0.22;\n        rotUv9.x = rotUv9.x - 1.35;\n    \n        vec2 rotUv10 = vUv;\n        rotUv10.x = rotUv10.x + 1.8;\n    \n        vec2 rotUv11 = Rot(PI) * vUv;\n        rotUv11.x = rotUv11.x - 0.9;\n        rotUv11.y = rotUv11.y + 0.95;\n    \n        vec2 rotUv12 = vUv;\n        rotUv12.x = rotUv12.x + 1.35 / abs(sin(u_time));\n        rotUv12.y = rotUv12.y - .725;\n    \n        vec2 rotUv13 = vUv;\n        rotUv13.y = rotUv13.y - 1.45 / abs(sin(u_time));\n    \n        vec2 rotUv14 = vUv;\n        rotUv14.y = rotUv14.y - 1.45;\n        rotUv14.x = rotUv14.x + 0.9;\n    \n        vec2 rotUv15 = Rot(PI) * vUv;\n        rotUv15.y = rotUv15.y + 1.675;\n        rotUv15.x = rotUv15.x - 0.45;\n    \n        vec2 rotUv16 = vUv;\n        rotUv16.y = rotUv16.y - 2.18;\n        rotUv16.x = rotUv16.x + 0.44;\n    \n        vec2 translate1 = vec2(cos(u_time), sin(u_time));\n        //rotUv16 += translate1 * 0.1;\n    \n        // rotUv1 =  vec2(rotUv1.x  + sin(u_time), rotUv1.y  + cos(u_time));\n        // rotUv2 =  vec2(rotUv2.x  + sin(u_time), rotUv2.y  + cos(u_time));\n        // rotUv3 =  vec2(rotUv3.x  + sin(u_time), rotUv3.y  + cos(u_time));\n        // rotUv4 =  vec2(rotUv4.x  + sin(u_time), rotUv4.y  + cos(u_time));\n        // rotUv5 =  vec2(rotUv5.x  + sin(u_time), rotUv5.y  + cos(u_time));\n        // rotUv6 =  vec2(rotUv6.x  + sin(u_time), rotUv6.y  + cos(u_time));\n        // rotUv7 =  vec2(rotUv7.x  + sin(u_time), rotUv7.y  + cos(u_time));\n        // rotUv8 =  vec2(rotUv8.x  + sin(u_time), rotUv8.y  + cos(u_time));\n        // rotUv9 =  vec2(rotUv9.x  + sin(u_time), rotUv9.y  + cos(u_time));\n        // rotUv10 = vec2(rotUv10.x + sin(u_time), rotUv10.y + cos(u_time));\n        // rotUv11 = vec2(rotUv11.x + sin(u_time), rotUv11.y + cos(u_time));\n        // rotUv12 = vec2(rotUv12.x + sin(u_time), rotUv12.y + cos(u_time));\n        // rotUv13 = vec2(rotUv13.x + sin(u_time), rotUv13.y + cos(u_time));\n        // rotUv14 = vec2(rotUv14.x + sin(u_time), rotUv14.y + cos(u_time));\n        // rotUv15 = vec2(rotUv15.x + sin(u_time), rotUv15.y + cos(u_time));\n        // rotUv16 = vec2(rotUv16.x + sin(u_time), rotUv16.y + cos(u_time));\n    \n        float tri1 = Tri(rotUv1, 0.2);\n        float tri2 = Tri(rotUv2, 0.2);\n        float tri3 = Tri(rotUv3, 0.2);\n        float tri4 = Tri(rotUv4, 0.2);\n        float tri5 = Tri(rotUv5, 0.2);\n        float tri6 = Tri(rotUv6, 0.2);\n        float tri7 = Tri(rotUv7, 0.2);\n        float tri8 = Tri(rotUv8, 0.2);\n        float tri9 = Tri(rotUv9, 0.2);\n        float tri10 = Tri(rotUv10, 0.2);\n        float tri11 = Tri(rotUv11, 0.2);\n        float tri12 = Tri(rotUv12, 0.2);\n        float tri13 = Tri(rotUv13, 0.2);\n        float tri14 = Tri(rotUv14, 0.2);\n        float tri15 = Tri(rotUv15, 0.2);\n        float tri16 = Tri(rotUv16, 0.2);\n    \n        color = vec3(tri1 + tri2 + tri3 + tri4 + tri5 + tri6 + tri7 + tri8 + tri9 + tri10 + tri11 + tri12 + tri13 + tri14 + tri15 + tri16);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Lb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Ab,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Gb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    float SquareIn(vec2 vUv, float size){\n        float a  = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/4.;\n        float d = cos(floor(.5 + a/r) * r-a) * length(vUv);\n        return (1.0 - smoothstep(size, size + 0.01, d)) - (1. - smoothstep(size - (size * 0.1), size - (size * 0.1) + 0.01, d));\n    }\n    \n    void main(){\n        vec3 color = vec3(0.);\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n    \n        vec2 uv1 = vUv;\n        uv1 = Rot(sin(u_time * 0.25) * PI) * uv1;\n    \n        vec2 uv2 = vUv;\n        uv2 = Rot(cos(u_time * 0.25) * PI) * uv2;\n    \n        vec2 uv3 = vUv;\n        uv3 = Rot(sin(u_time * 0.35) * PI) * uv3;\n    \n        vec2 uv4 = vUv;\n        uv4 = Rot(cos(u_time * 0.35) * PI) * uv4;\n    \n        vec2 uv5 = vUv;\n        uv5 = Rot(sin(u_time * 0.45) * PI) * uv5;\n    \n        vec2 uv6 = vUv;\n        uv6 = Rot(cos(u_time * 0.45) * PI) * uv6;\n    \n        vec2 uv7 = vUv;\n        uv7 = Rot(sin(u_time * 0.50) * PI) * uv7;\n    \n        vec2 uv8 = vUv;\n        uv8 = Rot(cos(u_time * 0.50) * PI) * uv8;\n    \n        float s1 = SquareIn(uv1, 0.5);\n        float s2 = SquareIn(uv2, 0.5);\n    \n        float s3 = SquareIn(uv3, 0.25);\n        float s4 = SquareIn(uv4, 0.25);\n    \n        float s5 = SquareIn(uv5, 0.75);\n        float s6 = SquareIn(uv6, 0.75);\n    \n        float s7 = SquareIn(uv7, 0.125);\n        float s8 = SquareIn(uv8, 0.125);\n    \n        color = vec3(s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Nb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Gb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Bb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float shape(vec2 vUv){\n        float r = length(vUv);\n        float a  = atan(vUv.x, vUv.y);\n        float f = cos(a * dot(vUv.x,vUv.y));\n        return 1. - smoothstep(f, f + 0.01, r);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), - sin(a),\n                    sin(a), cos(a));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 4. - 2.;\n        vec3 color = vec3(0.);\n        vec2 cirUv1 = vUv;\n        cirUv1 = Rot(sin(0.25) * PI) * cirUv1;\n        vec2 cirUv2 = vUv;\n        cirUv2 = Rot(-sin(0.25) * PI) * cirUv2;\n        vec2 cirUv3 = vUv;\n        float s1 = shape(vUv);\n        float c1 = cir(vec2(cirUv1.x * 1.25, cirUv1.y * 2.5), vec2(0.35, -0.95), 0.5);\n        float c1p = cir(vec2(cirUv1.x * 1.25, cirUv1.y * 2.5), vec2(0.35, -0.95), 0.025);\n        float c2 = cir(vec2(cirUv2.x * 1.25, cirUv2.y * 2.5), vec2(-0.35, -0.95), 0.5);\n        float c2p = cir(vec2(cirUv2.x * 1.25, cirUv2.y * 2.5), vec2(-0.35, -0.95), 0.025);\n        float c3 = cir(vUv, vec2(-0.05, -0.5), 0.01);\n        float c4 = cir(vUv, vec2(0.05, -0.5), 0.01);\n        float c5 = cir(vec2(cirUv3.x / 2.0, cirUv3.y * 2.0), vec2(0., -1.45), 0.1);\n        color.g = (s1 - c1 - c2 - c3 - c4 - c5 + c1p + c2p) * abs(sin(u_time));\n        color.b = (s1-c1-c2 - c3 - c4 -c5 + c1p + c2p) * abs(cos(u_time));\n        color.r = 0.;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Bb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Vb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    float Box(vec2 vUv, vec2 size){\n        size = vec2(0.5) - size * 0.5;\n        vec2 box = smoothstep(size, size + vec2(0.01), vUv);\n        box *= smoothstep(size, size + vec2(0.01), vec2(1.0)- vUv);\n        return box.x * box.y;\n    }\n    \n    float Cross(vec2 vUv, float size){\n        return Box(vUv, vec2(size, size/4.)) + \n               Box(vUv, vec2(size/4., size));\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 0.5;\n        vec3 color = vec3(0.);\n        vUv -= vec2(0.5);\n        vUv = Rot(sin(u_time) * PI) * vUv;\n        vUv += vec2(0.5);\n        float c1 = Cir(vUv, vec2(0.5), 0.45);\n        float c2 = 1. - Cir(vUv, vec2(0.5), 0.75);\n        float b1 = Cross(vUv, 1.);\n        color = vec3(c1 + c2 - b1);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Wb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Vb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Hb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    mat2 Scale(vec2 s){\n        return mat2(s.x, 0.0,\n                    0.0, s.y);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv);\n        vUv = vUv * 2. + 0.5;\n        vec3 color = vec3(0.);\n    \n        vec2 uv1 = vUv;\n        uv1 = uv1 - 0.5;\n        uv1 = Scale(vec2((sin(u_time * 0.25 * vUv *  vUv)) + 1.0 )) * uv1;\n        uv1 = uv1 + 0.5;\n    \n        vec2 uv2 = vUv;\n        uv2 = uv2 - 0.5;\n        uv2 = Scale(vec2((sin(u_time * 0.45 * vUv *  vUv)) + 1.0 )) * uv2;\n        uv2 = uv2 + 0.5;\n    \n        vec2 uv3 = vUv;\n        uv3 = uv3 - 0.5;\n        uv3 = Scale(vec2((sin(u_time * 0.65 * vUv * vUv)) + 1.0 )) * uv3;\n        uv3 = uv3 + 0.5;\n    \n        vec2 uv4 = vUv;\n        uv4 = uv4 - 0.5;\n        uv4 = Scale(vec2((sin(u_time * 0.85 * vUv * vUv)) + 1.0 )) * uv4;\n        uv4 = uv4 + 0.5;\n    \n        vec2 uv5 = vUv;\n        uv5 = uv5 - 0.5;\n        uv5 = Scale(vec2((sin(u_time * 1.05 * vUv * vUv)) + 1.0 )) * uv5;\n        uv5 = uv5 + 0.5;\n    \n        vec2 uv6 = vUv;\n        uv6 = uv6 - 0.5;\n        uv6 = Scale(vec2((sin(u_time * 1.25 * vUv * vUv)) + 1.0 )) * uv6;\n        uv6 = uv6 + 0.5;\n        \n        float c1 = Cir(uv1, vec2(0.5), 0.1);\n        float c2 = Cir(uv2, vec2(0.5), 0.1);\n        float c3 = Cir(uv3, vec2(0.5), 0.1);\n        float c4 = Cir(uv4, vec2(0.5), 0.1);\n        float c5 = Cir(uv5, vec2(0.5), 0.1);\n        float c6 = Cir(uv6, vec2(0.5), 0.1);\n    \n        color.g = c1 + c2 * cos(u_time);\n        color.b = c3 + c4 * sin(u_time);\n        color.r = c5 + c6 * cos(u_time);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Xb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Hb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Yb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float Box(vec2 vUv,vec2 size){\n        size=vec2(.5)-size*.5;\n        vec2 box=smoothstep(size,size+vec2(.01),vUv);\n        box*=smoothstep(size,size+vec2(.01),vec2(1.)-vUv);\n        return box.x*box.y;\n    }\n    \n    float Cross(vec2 vUv,float size){\n        return Box(vUv,vec2(size,size/4.))+\n        Box(vUv,vec2(size/4.,size));\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a),-sin(a),\n        sin(a),cos(a));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 6. - 3.;\n        vec3 color = vec3(0.);\n    \n        vec2 uv1=vUv;\n        uv1=vec2(uv1.x+tan(u_time *1.0),uv1.y);\n        uv1-=vec2(.5);\n        uv1=Rot(sin(u_time)*PI)*uv1;\n        uv1+=vec2(.5);\n    \n        vec2 uv2=vUv;\n        uv2=vec2(uv2.x+tan(u_time *1.1),uv2.y + 0.25);\n        uv2-=vec2(.5);\n        uv2=Rot(sin(u_time)*PI)*uv2;\n        uv2+=vec2(.5);\n    \n        vec2 uv3=vUv;\n        uv3=vec2(uv3.x+tan(u_time *1.2),uv3.y - 0.25);\n        uv3-=vec2(.5);\n        uv3=Rot(sin(u_time)*PI)*uv3;\n        uv3+=vec2(.5);\n    \n        vec2 uv4=vUv;\n        uv4=vec2(uv4.x+tan(u_time *1.3),uv4.y + 0.50);\n        uv4-=vec2(.5);\n        uv4=Rot(sin(u_time)*PI)*uv4;\n        uv4+=vec2(.5);\n    \n        vec2 uv5=vUv;\n        uv5=vec2(uv5.x+tan(u_time *1.4),uv5.y - 0.50);\n        uv5-=vec2(.5);\n        uv5=Rot(sin(u_time)*PI)*uv5;\n        uv5+=vec2(.5);\n    \n        vec2 uv6=vUv;\n        uv6=vec2(uv6.x+tan(u_time*1.5),uv6.y + 0.75);\n        uv6-=vec2(.5);\n        uv6=Rot(sin(u_time)*PI)*uv6;\n        uv6+=vec2(.5);\n    \n        vec2 uv7=vUv;\n        uv7=vec2(uv7.x+tan(u_time*1.6),uv7.y - 0.75);\n        uv7-=vec2(.5);\n        uv7=Rot(sin(u_time)*PI)*uv7;\n        uv7+=vec2(.5);\n    \n        vec2 uv8=vUv;\n        uv8=vec2(uv8.x+tan(u_time*1.7),uv8.y + 1.00);\n        uv8-=vec2(.5);\n        uv8=Rot(sin(u_time)*PI)*uv8;\n        uv8+=vec2(.5);\n    \n        vec2 uv9=vUv;\n        uv9=vec2(uv9.x+tan(u_time*1.8),uv9.y-1.0);\n        uv9-=vec2(.5);\n        uv9=Rot(sin(u_time)*PI)*uv9;\n        uv9+=vec2(.5);\n    \n        vec2 uv11=vUv;\n        uv11=vec2(uv11.x+.00,uv11.y+tan(u_time*1.0));\n        uv11-=vec2(.5);\n        uv11=Rot(sin(u_time)*PI)*uv11;\n        uv11+=vec2(.5);\n    \n        vec2 uv12=vUv;\n        uv12=vec2(uv12.x+.25,uv12.y+tan(u_time*1.1));\n        uv12-=vec2(.5);\n        uv12=Rot(sin(u_time)*PI)*uv12;\n        uv12+=vec2(.5);\n    \n        vec2 uv13=vUv;\n        uv13=vec2(uv13.x-.25,uv13.y+tan(u_time*1.2));\n        uv13-=vec2(.5);\n        uv13=Rot(sin(u_time)*PI)*uv13;\n        uv13+=vec2(.5);\n    \n        vec2 uv14=vUv;\n        uv14=vec2(uv14.x+.50,uv14.y+tan(u_time*1.3));\n        uv14-=vec2(.5);\n        uv14=Rot(sin(u_time)*PI)*uv14;\n        uv14+=vec2(.5);\n    \n        vec2 uv15=vUv;\n        uv15=vec2(uv15.x-.50,uv15.y+tan(u_time*1.4));\n        uv15-=vec2(.5);\n        uv15=Rot(sin(u_time)*PI)*uv15;\n        uv15+=vec2(.5);\n    \n        vec2 uv16=vUv;\n        uv16=vec2(uv16.x+.75,uv16.y+tan(u_time*1.5));\n        uv16-=vec2(.5);\n        uv16=Rot(sin(u_time)*PI)*uv16;\n        uv16+=vec2(.5);\n    \n        vec2 uv17=vUv;\n        uv17=vec2(uv17.x-.75,uv17.y+tan(u_time*1.6));\n        uv17-=vec2(.5);\n        uv17=Rot(sin(u_time)*PI)*uv17;\n        uv17+=vec2(.5);\n    \n        vec2 uv18=vUv;\n        uv18=vec2(uv18.x+1.,uv18.y+tan(u_time*1.7));\n        uv18-=vec2(.5);\n        uv18=Rot(sin(u_time)*PI)*uv18;\n        uv18+=vec2(.5);\n    \n        vec2 uv19=vUv;\n        uv19=vec2(uv19.x-1.,uv19.y+tan(u_time*1.8));\n        uv19-=vec2(.5);\n        uv19=Rot(sin(u_time)*PI)*uv19;\n        uv19+=vec2(.5);\n    \n        float c1=Cross(uv1,.2);\n        float c2=Cross(uv2,.2);\n        float c3=Cross(uv3,.2);\n        float c4=Cross(uv4,.2);\n        float c5=Cross(uv5,.2);\n        float c6=Cross(uv6,.2);\n        float c7=Cross(uv7,.2);\n        float c8=Cross(uv8,.2);\n        float c9=Cross(uv9,.2);\n    \n        float c11=Cross(uv11,.2);\n        float c12=Cross(uv12,.2);\n        float c13=Cross(uv13,.2);\n        float c14=Cross(uv14,.2);\n        float c15=Cross(uv15,.2);\n        float c16=Cross(uv16,.2);\n        float c17=Cross(uv17,.2);\n        float c18=Cross(uv18,.2);\n        float c19=Cross(uv19,.2);\n        \n        color = vec3(c1+c2+c3+c4+c5+c6+c7+c8+c9+\n                     c11+c12+c13+c14+c15+c16+c17+c18+c19);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Zb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Yb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float Cir(vec2 vUv, vec2 pos, float size){\n        float x = 1. - smoothstep(size, size+0.01, distance(vUv, pos));\n        float y = 1. - smoothstep(size * 0.95, (size * 0.95)+0.01, distance(vUv, pos));\n        return x - y;\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    float Box(vec2 vUv, vec2 size){\n        vec2 box = smoothstep(size, size+vec2(0.01), vUv);\n        box *= smoothstep(size, size+vec2(0.01), 1.0 - vUv);\n        return box.x * box.y;\n    }\n    \n    float Tri(vec2 vUv, float size){\n        float a = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/3.0;\n        float d = cos(floor(.5 + a/r) * r-a) * length(vUv);\n        return 1.0 - smoothstep(size, size+0.01, d);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y-0.1);\n        //vUv = vUv * 2. - 0.5;\n        vec3 color = vec3(0.);\n        vec2 cirUv = vUv;\n        cirUv = vec2(cirUv.x, cirUv.y+0.05);\n        float c1 = Cir(cirUv, vec2(0.5), 0.35);\n        vec2 starUv = vUv;\n        starUv = starUv * 2. - 1.;\n        starUv = vec2(starUv.x, starUv.y-0.15);\n        vec2 starUv2 = vUv;\n        starUv2 = starUv2 * 2. - 1.;\n        starUv2 = vec2(starUv2.x, starUv2.y+0.125);\n        vec2 starUv3 = vUv;\n        starUv3 = starUv3 * 2. - 1.;\n        vec2 boxUv = vUv;\n        boxUv = boxUv * 2. - 0.5;\n        boxUv = vec2(boxUv.x, boxUv.y+0.25);\n        float s1 = Tri(starUv, 0.1);\n        float s2 = Tri(starUv2, 0.14);\n        float s3 = Tri(starUv3, 0.12);\n        float s4 = Box(boxUv, vec2(0.45, 0.3) );\n        color = vec3(c1 + s1 + s2 + s3 + s4);\n        gl_FragColor =  vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Jb(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Qb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Kb=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float Box(vec2 vUv, vec2 size){\n        vec2 b = smoothstep(size, size+0.01, vUv);\n        b *= smoothstep(size, size+0.01, 1. - vUv);\n        return b.x * b.y;\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size+0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 boxUv = vUv;\n        boxUv -= vec2(0.5);\n        boxUv = Rot((u_time) *0.5) * boxUv;\n        boxUv += vec2(0.5);\n        \n        vec2 cirUv2=vUv;\n        vec2 translate2=vec2(sin(u_time * 2.0),cos(u_time * 2.0));\n        cirUv2+=translate2*0.15;\n    \n        vec2 cirUv3=vUv;\n        vec2 translate3=vec2(0.,cos(u_time*2.));\n        cirUv3+=translate3*.3;\n    \n        vec2 cirUv4=vUv;\n        vec2 translate4=vec2(sin(u_time*2.),0.);\n        cirUv4+=translate4*.3;\n    \n        float box1 = Box(boxUv, vec2(0.15));\n        float box2 = Box(boxUv, vec2(0.14));\n        float cir2 = Cir(cirUv2, vec2(0.5, 0.5), 0.05);\n        float cir3=  Cir(cirUv3,vec2(.5,.5),.05);\n        float cir4=  Cir(cirUv4,vec2(.5,.5),.05);\n    \n        color = vec3(box2 - box1);\n        color += cir2;\n        color += cir3; \n        color += cir4;\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $b(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Kb,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float BoxBorder(vec2 vUv, vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n        b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        float box1 = b.x * b.y;\n        vec2 b2 = smoothstep(size - vec2(0.01), (size - vec2(0.01)) + vec2(0.01), vUv);\n        b2 *=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1. - vUv);\n        float box2 = b2.x * b2.y;\n        return box2 - box1;\n    }\n    \n    float CirBorder(vec2 vUv, vec2 pos, float size){\n        float a = 1.  - smoothstep(size, size + 0.01, distance(vUv, pos));\n        float b = 1. - smoothstep(size - 0.01, size, distance(vUv, pos));\n        return a - b;\n    }\n    \n    mat2 Rot(float a){\n        return mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n    \n        vec2 uv1 = vUv;\n        uv1-=vec2(0.5);\n        uv1=Rot(sin(u_time)*PI)*uv1;\n        uv1+=vec2(0.5);\n    \n        vec2 uv2=vUv;\n        uv2-=vec2(.5);\n        uv2=Rot(sin(u_time * 1.02)*PI)*uv2;\n        uv2+=vec2(.5);\n    \n        vec2 uv3=vUv;\n        uv3-=vec2(.5);\n        uv3=Rot(sin(u_time * 1.04)*PI)*uv3;\n        uv3+=vec2(.5);\n    \n        vec2 uv4=vUv;\n        uv4-=vec2(.5);\n        uv4=Rot(sin(u_time*1.06)*PI)*uv4;\n        uv4+=vec2(.5);\n    \n        vec2 uv5=vUv;\n        uv5-=vec2(.5);\n        uv5=Rot(sin(u_time*1.08)*PI)*uv5;\n        uv5+=vec2(.5);\n    \n        vec3 color = vec3(0.);\n        float b1 = BoxBorder(uv1, vec2(0.25));\n        float c1 = CirBorder(vUv, vec2(0.5), 0.25);\n        float b2=BoxBorder(uv2,vec2(.3));\n        float c2=CirBorder(vUv,vec2(.5),.2);\n        float b3=BoxBorder(uv3,vec2(.35));\n        float c3=CirBorder(vUv,vec2(.5),.15);\n        float b4=BoxBorder(uv4,vec2(.40));\n        float c4=CirBorder(vUv,vec2(.5),.1);\n        float b5=BoxBorder(uv5,vec2(.45));\n        float c5=CirBorder(vUv,vec2(.5),.05);\n        color = vec3(b1 + c1 + b2 + c2 + b3 + c3 + b4 + c4 + b5 + c5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function eU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float Box(vec2 vUv, vec2 size){\n        vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n        b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        return b.x * b.y;\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size+0.01, distance(vUv, pos));\n    }\n    \n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                 sin(a), cos(a)) * vec2(vUv.x * cos(u_time * 0.25), vUv.y * sin(u_time * 0.25));\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 5.);\n        vUv = Rot(vUv, PI * 0.25 * u_time);\n        color = vec3(vUv, 0.0);\n        color = vec3(Cir(vUv, vec2(0.5), 0.2));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function oU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size+0.01, distance(vUv, pos));\n    }\n    \n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Rot(vUv, PI * u_time * 0.25);\n        vUv = Tile(vUv, 10.5);\n        float c = Cir(vUv, vec2(0.5), 0.25);\n        color += vec3(c * abs(sin(u_time)), c * abs(cos(u_time)), c * abs(sin(u_time)));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function aU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile(vec2 vUv, float z){\n        vUv *= z;\n        return fract(vUv);\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 5.);\n        vUv = Rot(vUv, PI * u_time * 0.25);\n        color = vec3(BoxBorder(vUv, vec2(0.05)));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:iU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        vUv = fract(vUv);\n        return vUv;\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv -= 0.5;\n        vUv = vUv * sin(u_time * 0.25);\n        //vUv = Rot(vUv, cos(u_time) + PI + 2.0) * vUv;\n        vec3 color = vec3(0.);\n    \n        vec2 boxUv = vUv;\n        boxUv = Tile(boxUv, 3.0);\n        boxUv=Rot(boxUv, sin(u_time * 0.5)*PI);\n        float box = BoxBorder(boxUv, vec2(0.25));\n    \n        vec2 boxUv2=vUv;\n        boxUv2=Tile(vec2(boxUv2.x - 1.5, boxUv2.y - 1.5),3.);\n        boxUv2=Rot(boxUv2,cos(u_time * 0.5)*PI);\n        float box2=BoxBorder(boxUv2,vec2(.25));\n    \n    \n        color = vec3(box + box2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile(vec2 vUv,float zoom){\n        vUv*=zoom;\n        vUv.x+=(step(1.,mod(vUv.y,2.))*.5) * sin(u_time);\n    \n        \n        //vUv.y-=step(1.,mod(vUv.x,2.));\n        // vUv.y += step(1., mod(vUv.x, 4.0)) * sin(u_time);\n        //vUv.y += cos(u_time);\n        return fract(vUv);\n    }\n    \n    vec2 Tile2(vec2 vUv,float zoom){\n        vUv*=zoom;\n        vUv.x+=(step(1.,mod(vUv.y,2.))*.5) * sin(u_time);\n        \n        //vUv.y-=step(1.,mod(vUv.x,2.));\n        // vUv.y += step(1., mod(vUv.x, 4.0)) * sin(u_time);\n        //vUv.y += cos(u_time);\n        return fract(vUv);\n    }\n    \n    \n    \n    float Tri(vec2 vUv,float size){\n        vUv-=.5;\n        float a=atan(vUv.x,vUv.y)+PI;\n        float r=TWO_PI/3.;\n        float d=cos(floor(.5+a/r)*r-a)*length(vUv);\n        return 1.-smoothstep(size,size+.01,d);\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2;\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vec3 color=vec3(0.);\n        \n        vec2 newUv=vUv;\n        newUv.y+=cos(u_time*.1);\n        newUv=Tile(newUv,6.);\n        float t1=Tri(newUv,.25);\n    \n        vec2 newUv2=vUv;\n        newUv2 = Rot(newUv2, (PI));\n        newUv2.y += cos(u_time * 0.1);\n        newUv2 =Tile2(newUv2,6.);\n        float t2=Tri(newUv2,.25);\n    \n        color=vec3(t1+t2);\n        \n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        //vUv.x-=step(1.,mod(vUv.y,2.))+u_time;\n        vUv.x += step(1., mod(vUv.y, 2.0)) * (0.5 + u_time);\n        \n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile2(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > .5){\n            if(fract(vUv.y * .5)>.5){\n                vUv.x+= fract(t) * 2.;\n    \n            }else{\n                vUv.x-= fract(t) * 2.;\n            }\n            //vUv = Rot(vUv, PI * 0.5);\n        } else {\n            if(fract(vUv.x*.5) > .5){\n                vUv.y += fract(t) * 2.;\n            } else {\n                vUv.y -= fract(t) * 2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float Tri(vec2 vUv, float size){\n        vUv -= 0.5;\n        float a = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/3.0;\n        float d = cos(floor(.5 + a/r) * r-a) * length(vUv);\n        return 1.0 - smoothstep(size, size+0.01, d);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile2(vUv, 10.0, 0.25);\n        float c1 = Cir(vUv, vec2(0.5), 0.25);\n    \n        vec2 newUv = vUv;\n        newUv = Rot(vUv, sin(u_time + 2.0) * PI);\n        float t1 = Tri(newUv, 0.1);\n        \n        color = vec3(c1 - t1);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float Box(vec2 vUv, vec2 size){\n        vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n        b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        return b.x * b.y;\n    }\n    \n    vec2 Tiles(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        //vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        float t=u_time*speed;\n        if(fract(t)>.5){\n            if(fract(vUv.y*8.)>.5){\n                vUv.x+=fract(t)*2.;\n                \n            }else{\n                vUv.x-=fract(t)*2.;\n            }\n            //vUv = Rot(vUv, PI * 0.5);\n        }else{\n            if(fract(vUv.x * 8.)>.5){\n                vUv.y+=fract(t)*2.;\n            }else{\n                vUv.y-=fract(t)*2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tiles(vUv, 2., 0.25);\n        float b1 = Box(vUv, vec2(0.25));\n        color = vec3(b1);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        //vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        vUv = fract(vUv);\n        return vUv;\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Truchet(vec2 vUv){\n        vUv *= 2.0;\n        float index = 0.0;\n        index += step(1., mod(vUv.x, 2.0));\n        index += step(1., mod(vUv.y, 2.0)) * 2.0;\n        vUv = fract(vUv);\n        if(index == 1.0){\n            vUv = Rot(vUv, PI * 0.5 * sin(u_time));\n        } else if (index == 2.0){\n            vUv = Rot(vUv, PI * -0.5 * sin(u_time));\n        } else if (index == 3.0){\n            vUv = Rot(vUv, PI);\n        }\n        return vUv;\n    }\n    \n    float Box(vec2 vUv, vec2 size){\n        vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n        b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        return b.x * b.y;\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size+0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 c1 = vec3(Cir(vUv, vec2(0.5), 0.35));\n        vUv = Rot(vUv, (u_time * 0.25));\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 3.);\n        vUv = Truchet(vUv);\n        vec3 pattern = vec3(step(vUv.x,vUv.y));\n        \n        color = c1 * pattern;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    vec2 Translate(vec2 vUv){\n        vUv.x = vUv.x + sin(u_time) * 0.25;\n        vUv.y = vUv.y + cos(u_time) * 0.25;\n        return vUv;\n    }\n    \n    vec2 Translate2(vec2 vUv){\n        vUv.x = vUv.x + cos(u_time) * 0.25;\n        vUv.y = vUv.y + sin(u_time) * 0.25;\n        return vUv;\n    }\n    \n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        float index = 0.0;\n        index += step(1., mod(vUv.x, 2.0));\n        index += step(1., mod(vUv.y, 2.0)) * 2.0;\n        vUv = fract(vUv);\n        if(index == 1.0){\n            vUv = Translate(vUv);\n        } else if (index == 2.0){\n            vUv = Translate2(vUv);\n        } else if (index == 3.0){\n            vUv = Translate(vUv);\n        } else{\n            vUv = Translate2(vUv);\n        }\n        vUv = fract(vUv);\n        return vUv;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 5.0);\n        float c = Cir(vUv, vec2(0.5), 0.15);\n        color = vec3(c);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        //vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float angle){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(angle), -sin(angle),\n    //                sin(angle), cos(angle)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        float x = 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n        float y = 1. - smoothstep(size * 0.25, (size * 0.25) + 0.01, distance(vUv, pos));\n        return x - y;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 uv1 = vUv;\n        uv1=Rot(vUv,(u_time*PI * 0.15));\n        uv1 = Tile(uv1, 3.0);\n        float pattern1 = Cir(uv1, vec2(0.5), (0.005 + abs(sin(u_time * 0.5)/1.)));\n        color = vec3(pattern1 * abs(sin(u_time * 0.25)), pattern1 * abs(cos(u_time * 0.25)), 1.0);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _U=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile(vec2 vUv, float zoom){\n        vUv -= 0.5;\n        vUv *= zoom + sin(u_time / 1.0);\n        vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        return fract(vUv);\n    }\n    \n    \n    float Tri(vec2 vUv,float size){\n        vUv-=.5;\n        \n        float a=atan(vUv.x,vUv.y)+PI;\n        float r=TWO_PI/3.;\n        float d=cos(floor(.5+a/r)*r-a)*length(vUv);\n        float s1 = 1. - smoothstep(size,size+.01,d);\n        return s1;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 5.0);\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, -sin(PI + u_time));\n        vUv=Rot(vUv,sin(PI+u_time));\n        float s1 = Tri(vUv, 0.25);\n        float s2 = Tri(newUv,.1);\n        color = vec3(s1 - s2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_U,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var SU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        vUv.x += step(1., mod(vUv.y, 2.0)) * (0.5 + u_time);\n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float angle){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(angle), -sin(angle),\n    //                sin(angle), cos(angle)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile2(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > .5){\n            if(fract(vUv.y * .5)>.5){\n                vUv.x+= fract(t) * 2.;\n                vUv.x-= sin(u_time);\n            }else{\n                vUv.x-= fract(t) * 2.;\n                vUv.x+= cos(u_time);\n            }\n        } else {\n            if(fract(vUv.x*.5) > .5){\n                vUv.y += fract(t) * 2.;\n                vUv.y -= sin(u_time);\n            } else {\n                vUv.y -= fract(t) * 2.;\n                vUv.y += cos(u_time);\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float Box(vec2 vUv, vec2 size){\n        vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n        b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        float b1 = b.x * b.y;\n        vec2 bb = smoothstep(size-0.05, (size-0.05) + vec2(0.01), vUv);\n        bb *= smoothstep(size-0.05, (size-0.05) + vec2(0.01), 1. - vUv);\n        float b2 = bb.x * bb.y;\n        return b2 - b1;\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile2(vUv, 8.0, 0.1);\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, (sin(u_time + 2.0) * PI * 2.0) * 0.25);\n        float box = Box(newUv, vec2(0.025));\n        float cir = Cir(vUv, vec2(0.5), 0.25);\n        color = vec3(box + cir);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function MU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:SU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 Tile1(vec2 vUv, float z){\n        vUv *= z;\n        return fract(vUv);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n       float x = 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n       float y = 1. - smoothstep((size + 0.02), (size + 0.02) + 0.01, distance(vUv, pos));\n       return y - x;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        vUv = Tile1(vUv, 4.0);\n        vec2 newUv = vUv;\n        vUv = Rot(vUv, -sin(u_time * 0.5) * PI);\n        float p1 = Cir(vUv, vec2(0.5), 0.25);\n        float p2 = Cir(vUv, vec2(0.275, 0.5), 0.25);\n        float p3 = Cir(vUv, vec2(0.725, 0.5), 0.25);\n        float p4 = Cir(vUv, vec2(0.5, 0.275), 0.25);\n        float p5 = Cir(vUv, vec2(0.5, 0.725), 0.25);\n        vec3 pattern1 = vec3(p1 + p2 + p3 + p4 + p5);\n        \n        \n        newUv = Rot(newUv, sin(u_time * 0.5) * PI);\n        float p6 = Cir(newUv, vec2(0.5), 0.1);\n        float p7 = Cir(newUv, vec2(0.29, 0.5), 0.1);\n        float p8 = Cir(newUv, vec2(0.71, 0.5), 0.1);\n        float p9 = Cir(newUv, vec2(0.5, 0.29), 0.1);\n        float p10 = Cir(newUv, vec2(0.5, 0.71), 0.1);\n        vec3 pattern2 = vec3(p6 + p7 + p8 + p9 + p10);\n    \n        color = pattern1;\n        color += pattern2;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var CU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float BoxBorder(vec2 vUv,vec2 size){\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2 - box1;\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile(vec2 vUv, float z){\n        vUv *= z;\n        vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        return fract(vUv);\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile(vUv, 4.0);\n    \n        vec2 uv1 = vUv;\n        uv1 = Rot(uv1, PI * (0.5 * sin(u_time)));\n        float b = BoxBorder(uv1, vec2(0.15));\n        color = vec3(b);\n    \n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, PI * (0.25 * sin(u_time)));\n        float b2 = BoxBorder(uv2, vec2(0.15));\n        color += vec3(b2);\n    \n        vec2 uv3 = vUv;\n        uv3 = Rot(uv3, PI * (0.125 * sin(u_time)));\n        float b3 = BoxBorder(uv3, vec2(0.15));\n        color += vec3(b3);\n    \n        vec2 uv4 = vUv;\n        uv4 = Rot(uv4, PI * ((0.125/2.0) * sin(u_time)));\n        float b4 = BoxBorder(uv4, vec2(0.15));\n        color += vec3(b4);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function TU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:CU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var RU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        //vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        return fract(vUv);\n    }\n    \n    //PIXEL SPIRIT\n    float Stroke(float x, float s, float w){\n        float d = smoothstep(s, s+0.01, x + w * 0.5) - smoothstep (s, s + 0.01,x-w * 0.5);\n        return clamp(d, 0., 1.);\n    }\n    \n    float Flip(float v, float pct){\n        return mix(v, 1. - v, pct);\n    }\n    \n    float Cir(vec2 vUv){\n        return length(vUv - 0.5) * 2.;\n    }\n    \n    vec3 Bridge(vec3 c, float d, float s, float w){\n        c *= 1. - Stroke(d, s, w * 2.);\n        return c + Stroke(d, s, w);\n    }\n    //PIXEL SPIRIT\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    \n    void main(){\n        vec3 color = vec3(0.);\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        //vUv = vUv * 2.0 - 0.5;\n        vUv = Tile(vUv, 2.0);\n        vUv.x = Flip(vUv.x, step(0.5, vUv.y));\n        vec2 offset =  vec2(.15/2.0, .0);\n        vec2 offset2 =  vec2(.45/2.0, .0);\n        vUv = Rot(vUv, sin(u_time));\n        float l = Cir(vUv + offset);\n        float r = Cir(vUv - offset);\n        float b = Cir(vUv + offset2);\n        float t = Cir(vUv - offset2);\n        color += Stroke(l, .4/2.0, .075/2.0);\n        color = Bridge(color, r, .4/2.0, .075/2.0);\n        //color += Stroke(b, .4, .075);\n        color = Bridge(color, b, .4/2.0, .075/2.0);\n        color = Bridge(color, t, .4/2.0, .075/2.0);\n        //color = Bridge(color, t, .4, .075);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function DU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:RU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var PU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    vec2 Tile1(vec2 vUv, float zoom){\n        vUv *= zoom;\n        return fract(vUv);\n    }\n    \n    vec2 Tile2(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > .5){\n            if(fract(vUv.y * .5)>.5){\n                vUv.x+= fract(t) * 2.;\n            }else{\n                vUv.x-= fract(t) * 2.; \n            }\n        } else {\n            if(fract(vUv.x*.5) > .5){\n                vUv.y += fract(t) * 2.;  \n            } else {\n                vUv.y -= fract(t) * 2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    float Square(vec2 vUv, vec2 size){\n        vec2 s = smoothstep(size, size + vec2(0.01), vUv);\n        s *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n        return s.x * s.y;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 uv1 = vUv;\n        uv1 = Tile2(uv1, 5.0, 0.1);\n        uv1 =  Rot(uv1, sin(u_time) * PI);\n        float c1 = Cir(uv1, vec2(0.5), 0.25);\n        float s1 = Square(uv1, vec2(0.25));\n        float c2 = Cir(uv1, vec2(0.5), 0.125);\n        vec3 shape1 = vec3(s1 -c1 + c2);\n        color = shape1;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function FU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:PU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 Tile(vec2 vUv, float zoom, float speed){\n        vUv*=zoom;\n        float t=u_time*speed;\n        if(fract(t)>.5){\n            if(fract(vUv.y*.5)>.5){\n                vUv.x+=fract(t)*2.;\n            }else{\n                vUv.x-=fract(t)*2.;\n            }\n        }else{\n            if(fract(vUv.x*.5)>.5){\n                vUv.y+=fract(t)*2.;\n            }else{\n                vUv.y-=fract(t)*2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    mat2 Scale(vec2 s){\n        return mat2(s.x, 0.0,\n                    0.0, s.y);\n    }\n    \n    float CirOutline(vec2 vUv, vec2 pos, float size){\n        float outer = 1. - smoothstep((size + 0.025), (size + 0.025) + 0.01, distance(vUv, pos));\n        float inner = 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n        return outer - inner;\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 uv1 = vUv;\n        vec2 uv2 = vUv;\n        uv1 = Tile(uv1, 4.0, 0.25);\n        uv2 = Tile(uv2,4., 0.25);\n        uv2 -= vec2(0.5);\n        uv2 = Scale(vec2(sin(u_time * 1.5) + 1.65)) * uv2;\n        uv2+=vec2(.5);\n        float c1 = CirOutline(uv1, vec2(0.5), 0.475);\n        float c2 = Cir(uv2, vec2(0.5), 0.25);\n        color = vec3(c1 + c2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function IU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float BoxBorder(vec2 vUv,vec2 size){\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.05),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.05),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    vec2 Tile(vec2 vUv,float zoom,float speed){\n        vUv*=zoom;\n        float t=u_time*speed;\n        if(fract(t)>.5){\n            if(fract(vUv.y*.5)>.5){\n                vUv.x+=fract(t)*2.;\n            }else{\n                vUv.x-=fract(t)*2.;\n            }\n        }else{\n            if(fract(vUv.x*.5)>.5){\n                vUv.y+=fract(t)*2.;\n            }else{\n                vUv.y-=fract(t)*2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.025),(size+.025)+.01,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.01,distance(vUv,pos));\n        return outer-inner;\n    }\n    \n    float Cir(vec2 vUv,vec2 pos,float size){\n        return 1.-smoothstep(size,size+.01,distance(vUv,pos));\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Rot(vUv, PI * 0.25);\n        vUv = Tile(vUv, 4.0, 0.125);\n        vec2 uv1 = vUv;\n        uv1 = Rot(vUv, sin(u_time) * PI);\n        float b1 = BoxBorder(uv1, vec2(0.15));\n        float c1=CirOutline(vUv,vec2(.5),.475);\n        float c2=Cir(vUv,vec2(.5),.25);\n        float c3=Cir(vUv,vec2(.5),.25 /2.0);\n        vec3 shape = vec3(b1 + c1 + c2 - c3);\n        color = shape;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function OU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:EU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float BoxBorder(vec2 vUv,vec2 size){\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    vec2 Tile(vec2 vUv,float zoom,float speed){\n        vUv*=zoom;\n        float t=u_time*speed;\n        if(fract(t)>.5){\n            if(fract(vUv.y*.5)>.5){\n                vUv.x+=fract(t)*2.;\n            }else{\n                vUv.x-=fract(t)*2.;\n            }\n        }else{\n            if(fract(vUv.x*.5)>.5){\n                vUv.y+=fract(t)*2.;\n            }else{\n                vUv.y-=fract(t)*2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.025),(size+.025)+.01,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.01,distance(vUv,pos));\n        return outer-inner;\n    }\n    \n    float Cir(vec2 vUv,vec2 pos,float size){\n        return 1.-smoothstep(size,size+.01,distance(vUv,pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 translate = vec2(cos(u_time), sin(u_time));\n        vUv = Tile(vUv, 4.0, 0.25);\n        float c1 = CirOutline(vUv, vec2(0.5), 0.47);\n        float b1 = BoxBorder(vUv, vec2(0.));\n        vUv += vec2(translate.x * 0.25, translate.y * 0.25 + 0.25);\n        \n        float s1 = Cir(vUv, vec2(0.5, 0.75), 0.25);\n        float s2 = Cir(vUv, vec2(0.5, 0.25), 0.25);\n        \n        float shape = s1;\n        color = vec3(c1);\n        color += shape;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:AU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        return fract(vUv);\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.025),(size+.025)+.01,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.01,distance(vUv,pos));\n        return outer-inner;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv -= 0.5;\n        vUv = Tile(vUv, 5.0 * sin(u_time * 0.05 * 2.0));\n        float c1 = CirOutline(vUv, vec2(0.5,0.75), 0.25);\n        float c2 = CirOutline(vUv, vec2(0.75,0.75), 0.25);\n        float c3 = CirOutline(vUv, vec2(0.5,0.5), 0.25);\n        float c4 = CirOutline(vUv, vec2(0.75,0.5), 0.25);\n        float c5 = CirOutline(vUv, vec2(0.5,0.25), 0.25);\n        float c6 = CirOutline(vUv, vec2(0.25,0.75), 0.25);\n        float c7 = CirOutline(vUv, vec2(0.25,0.25), 0.25);\n        float c8 = CirOutline(vUv, vec2(0.25,0.75), 0.25);\n        float c9 = CirOutline(vUv, vec2(0.25,0.5), 0.25);\n        float c10 =CirOutline(vUv, vec2(0.75,0.25), 0.25);\n        color = vec3(c1+c2+c3+c4+c5+c6+c7+c8+c9+c10);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function NU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:GU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var BU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 Tile(vec2 vUv, float zoom){\n        vUv *= zoom;\n        vUv.x += step(1., mod(vUv.y, 2.0)) * 0.5;\n        return fract(vUv);\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        vec2 b=smoothstep(size,size+vec2(.02),vUv);\n        b*=smoothstep(size,size+vec2(.02),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.02),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.02),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = Rot(vUv, sin(u_time * 0.05) * PI);\n        vUv -= 0.5;\n        vUv = Tile(vUv, 3.0 + sin(u_time * 0.5));\n        vec3 color = vec3(0.);\n        vec2 uv1 = vUv;\n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, PI * 0.25);\n        vec2 uv3 = uv1;\n        vec2 uv4 = uv2;\n        vec2 uv5 = uv1;\n        vec2 uv6 = uv2;\n        uv3.x += 0.25;\n        uv4.x += 0.25;\n        uv4.y -= 0.25;\n        uv5.x -= 0.25;\n        uv6.x -= 0.25;\n        uv6.y += 0.25;\n        float b1 = BoxBorder(uv1, vec2(0.2));\n        float b2 = BoxBorder(uv2, vec2(0.2));\n        float b3 = BoxBorder(uv3, vec2(0.2));\n        float b4 = BoxBorder(uv4, vec2(0.2));\n        float b5 = BoxBorder(uv5, vec2(0.2));\n        float b6 = BoxBorder(uv6, vec2(0.2));\n        vec3 shape1 = vec3(b1 + b2);\n        vec3 shape2 = vec3(b3 + b4);\n        vec3 shape3 = vec3(b5 + b6);\n        color = shape1 + shape2 + shape3;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:BU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var VU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(89.409182734019732490 * u_time * 0.25, 59.793847102347 * u_time * 0.25))) * 43993.23984729384);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float random = rand(vUv);\n        color = vec3(random);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function WU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:VU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var HU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float random(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(14.29384023894, 89.28340928374))));\n    }\n    \n    vec2 truchetPattern(vec2 vUv, float index){\n        index = fract((index - 0.5) * 2.0);\n        if(index > 0.75 *sin(u_time * 0.1) ){\n            vUv = vec2(1.0) - vUv;\n        } else if (index > 0.5 *sin(u_time * 0.1)){\n            vUv = vec2(1.0- vUv.x , vUv.y);\n        } else if (index > 0.25 * sin(u_time * 0.1)){\n            vUv = 1.0 - vec2(1.0 - vUv.x, vUv.y);\n        }\n        return vUv;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv *= 8.0;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = truchetPattern(fpos , random(ipos));\n        float pattern = smoothstep(tile.x-0.3,tile.x,tile.y)-\n                smoothstep(tile.x,tile.x+0.3,tile.y);\n        float circles = (step(length(tile),0.6) -\n                  step(length(tile),0.4) ) +\n                 (step(length(tile-vec2(1.)),0.6) -\n                  step(length(tile-vec2(1.)),0.4) );\n        color = vec3(circles);\n        //color = vec3(fpos, 0.0);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function XU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:HU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var YU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders random function\nfloat random(vec2 vUv){\n    return fract(sin(dot(vUv.xy,\n                vec2(12.9898,78.233)))*\n            43758.5453123 - fract(u_time));\n        }\n\nvec2 Tile2(vec2 vUv,float zoom,float speed){\n    vUv*=zoom;\n    float t=u_time*speed;\n    if(fract(t)>.5){\n        if(fract(vUv.y*.5)>.5){\n            vUv.x+=fract(t)*2.;\n        }else{\n            vUv.x-=fract(t)*2.;\n        }\n    }else{\n        if(fract(vUv.x*.5)>.5){\n            vUv.y+=fract(t)*2.;\n        }else{\n            vUv.y-=fract(t)*2.;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv=Tile2(vUv,5.,0.0001);\n    vec3 color=vec3(0.);\n    vUv *= 10.;\n    vec2 i = floor(vUv);\n    vec2 f = fract(vUv);\n    \n    float shape = random((i));\n    \n    color = vec3(shape+sin(u_time), shape-cos(u_time), 0.);\n    \n    gl_FragColor = vec4(color, random(i));\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ZU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:YU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float random(vec2 vUv){\n        return fract(sin(dot(vUv.xy,\n                vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    //book of shaders\n    vec2 truchet(vec2 vUv, float index){\n        index = fract((index - 0.5) * 2.0);\n        if(index > 0.75){\n            vUv = vec2(1.0) - vUv;\n        } else if (index > 0.5){\n            vUv = vec2(1.0 - vUv.x, vUv.y);\n        } else if (index > 0.25){\n            vUv = 1.0 - vec2(1.0 - vUv.x, vUv.y);\n        }\n        return vUv;\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.125),(size+.125)+.01,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.01,distance(vUv,pos));\n        return outer-inner;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0);\n        vUv *= 5.0;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = truchet(fpos, random(ipos));\n        float y = CirOutline(tile, vec2(0.5), 0.35);\n        y *= smoothstep(tile.x-.3,tile.x,abs(tile.y + sin(u_time)))-\n            smoothstep(tile.x,tile.x+.3,abs(tile.y + cos(u_time)));\n        color = vec3(y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function JU(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:QU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KU=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    float rand (float x){\n        return fract(sin(x) * 1000000.0);\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.025) * rand(15.5),(size+.085)+.01,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.01 ,distance(vUv ,pos ));\n        return outer-inner;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = Rot(vUv, sin(u_time * 5000.) * PI );\n        vec3 color = vec3(0.);\n        float cir = CirOutline(vUv, vec2(0.5), 0.25);\n        color = vec3(cir);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $U(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:KU,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var n_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand (float x){\n        return fract(sin(x) * 100000.0);\n    }\n    \n    float Plot(vec2 vUv, float x){\n        return smoothstep(x - (0.01), x, vUv.y) -\n               smoothstep(x, x + (0.02), vUv.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv;\n        float y = 1. - rand(vUv.x + (u_time * 0.000005) );\n        float pct = Plot(vUv, y);\n        vec3 color = vec3(0.);\n        color = vec3(pct);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function e_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:n_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var t_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(12.4859, 75.2389234))) * 45687.28934720);\n    }\n    \n    float rand(float x){\n        return fract(sin(x) * 10000.0);\n    }\n    \n    //book of shaders\n    float pattern(vec2 vUv, vec2 v, float t){\n        vec2 p = floor(vUv + v);\n        return step(t, rand(100. + p * 0.00001) + rand(p.x) * 0.5);\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n        vec3 color = vec3(0.);\n    \n        vec2 grid = vec2(20.0, 15.0);\n        vUv *= grid;\n    \n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n    \n        vec2 vel = vec2(u_time * (rand(1.0)) * max(grid.x, grid.y));\n        vel *= vec2(0.0, 1.0) * rand(1.0 + ipos.x);\n    \n        vec2 offset = vec2(0., 0.);\n        color.g = pattern(vUv + offset, vel, rand(0.2) * 0.9);\n    \n        color *= step(0.5, fpos.x);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function o_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:t_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var r_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(12.4859, 75.2389234))) * 45687.28934720);\n    }\n    \n    float rand(float x){\n        return fract(sin(x) * 10000.0);\n    }\n    \n    //book of shaders\n    float pattern(vec2 vUv, vec2 v, float t){\n        vec2 p = floor(vUv + v);\n        return step(t, rand(100. + p * 0.00001) + rand(p.x) * 0.1);\n    }\n    \n    float pattern2(vec2 vUv, vec2 v, float t){\n        vec2 p = floor(vUv + v);\n        return step(t, rand(100. + p * 0.00001) + rand(p.y) * 0.1);\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n        vec3 color = vec3(0.);\n    \n        vec2 grid = vec2(50.0, 50.0) ;\n        vUv *= grid;\n    \n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n    \n        vec2 vel = vec2(u_time * (rand(10.0)) * max(grid.y, grid.x));\n        vel *= vec2(-1., 0.0) * rand(1.0 + ipos.y);\n    \n        vec2 vel2 = vec2(u_time * (rand(10.0)) * max(grid.y, grid.x));\n        vel2 *= vec2(0.0, 1.0) * rand(1.0 + ipos.x);\n    \n        vec2 offset = vec2(0., 0.);\n        color.r = pattern(vUv + offset, vel, rand(0.1) * 0.5);\n        color.g = pattern2(vUv + offset, vel2, rand(0.1) * 0.15);\n    \n        color *= 1. - step(0.99999999, fpos.y);\n        color += step(0.99999, fpos.x);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function a_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:r_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var i_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float random(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(12.9898,78.233))) * 43758.5453123);\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        \n        vec2 b=smoothstep(size,size+vec2(.02),vUv);\n        b*=smoothstep(size,size+vec2(.02),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.02),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.02),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        float x = random(vec2(vUv));\n        vec3 color = vec3(0.);\n        vec2 ipos = floor(vUv); //integer\n        vec2 fpos = fract(vUv); //fraction\n        float b1 = BoxBorder(vUv, vec2(0.0) + x * abs(sin(u_time * 0.25)));\n        color = vec3(b1);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function v_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:i_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var c_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // vec2 Rot(vec2 vUv,float a){\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float random(in float x){\n        return fract(sin(x)*1e4);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    float random(vec2 vUv){\n        return fract(sin(dot(vUv.xy,vec2(12.9898,78.233)))*43758.5453123);\n    }\n    \n    //book of shaders\n    float pattern(vec2 vUv,vec2 v,float t){\n        vec2 p=floor(vUv+v);\n        return step(t,random(100.+p*.00001)+random(p.x)*.1);\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        \n        vUv=vUv*2.-1.;\n        vec2 cUv=vUv;\n        vUv = Rot(vUv, u_time * 0.25);\n        \n        vec3 color=vec3(0.);\n    \n        vec2 grid=vec2(25.,5.);\n        vUv*=grid + sin(u_time);\n    \n        \n        \n        vec2 ipos=floor(vUv);\n        vec2 fpos=fract(vUv);\n    \n        vec2 vel=vec2(u_time*.2*max(grid.y +sin(u_time),grid.x ));\n        vel*=vec2(0.,1.)*random(1.+ipos.x);\n    \n        vec2 vel2=vec2(u_time*0.2* max(grid.x +sin(u_time) ,grid.y + sin(u_time)));\n        vel2*=vec2(-1.,0.)*random(1.+ipos.y);\n    \n        vec2 offset2=vec2(1.1,1.0);\n        vec2 offset=vec2(1.0,1.1);\n        \n        color= vec3(pattern(vUv+offset,vel2,1.0));\n        color+= vec3(pattern(vUv+offset2,vel,1.0));\n    \n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function s_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:c_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var l_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nfloat plot(vec2 vUv,float pct){\n    return smoothstep(pct-.04,pct,vUv.y)-\n    smoothstep(pct,pct+.04,vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv.x *= 0.5;\n    vUv.y *= 0.5;\n    vUv.y -= 0.0;\n    vec2 ipos=floor(vUv);// integer\n    vec2 fpos=fract(vUv);// fraction\n    vec3 color = vec3(0.);\n    float y = fract(sin(vUv.x + sin(u_time)) * 100000.0);\n    float pct = plot(vUv, y);\n    color = (1. - pct) * color + pct * vec3(0.0, 1., 0.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function u_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:l_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var f_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    \nfloat rand(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(14.4385, 89.2384972))) * 56937.29837492);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 20.0;\n    vec2 ipos = floor(vec2(vUv.x, vUv.y + (u_time)));\n    vec2 fpos = fract(vUv);\n    float pattern = rand(vec2(ipos.x + (0.0000025 * u_time), ipos.y));\n    color.b = (pattern);\n    color *= 1. - vec3(fpos, 0.0);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function p_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:f_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var m_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(float x){\n        return fract(sin(x) * 56937.29837492);\n    }\n    \n    float rand(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(14.4385, 89.2384972))) * 56937.29837492);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv *= 2.0 - 1.0;\n        vec2 cUv = vUv;\n        vUv = vec2(rand(vUv.x) + (u_time * 0.0000002), rand(vUv.y));\n        vUv = vUv * 20.;\n        vec3 color = vec3(0.);\n        float x = rand(vec2(vUv.x, vUv.y));\n        float y = pow((x), 100.);\n        float cir = Cir(cUv, vec2((0.5 * x) + sin(u_time * 0.5), 0.5), 0.25);\n        float cir2 = Cir(cUv, vec2(0.5, (0.5 * x) + sin(u_time * 0.5)), 0.25);\n        color = vec3(cir + cir2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function d_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:m_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var h_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(12.9898, 78.233))) * 43758.649273);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv *= 10.0;\n        vec2 ipos = floor(vec2(vUv.x - u_time, vUv.y));\n        vec2 fpos = fract(vec2(vUv.x + u_time, vUv.y));\n        vec3 color = vec3(0.);\n        float y = rand(ipos);\n        float x = rand(fpos);\n    \n        color = vec3(y*x * y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function x_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:h_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var g_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//random\n\nfloat rand(in float x){\n    return fract(sin(x)*1e4);\n}\n\nfloat rand(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(23.487503, 89.37610982))) * 45873.34028347);\n}\n\n//book of shaders\nvec2 truchetPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.) - vUv;\n    } else if (i > 0.5) {\n        vUv = vec2(1. - vUv.x, vUv.y);\n    } else if (i > 0.25) {\n        vUv = 1. - vec2(1. - vUv.x, vUv.y);\n    }\n    return vUv;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv -= 0.5;\n    vUv.x += u_time * 0.1;\n    vec3 color=vec3(0.);\n    vec2 grid=vec2(12.,12.);\n    vUv *= grid;\n    vec2 ipos = floor(vUv); //integer\n    vec2 fpos = fract(vUv); //fraction\n    vec2 tile = truchetPattern(fpos, rand(ipos * sin(u_time*.000000125)) );\n    float c = (step(length(tile ),.6)-\n         step(length(tile ),0.4) ) +\n        (step(length(tile-vec2(1.) ),0.6) -\n         step(length(tile-vec2(1.) ),0.4) );\n    color = 1. - vec3(c);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function y_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:g_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var b_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(12.4859, 75.2389234))) * 45687.28934720);\n    }\n    \n    float rand(float x){\n        return fract(sin(x) * 10000.0);\n    }\n    \n    //book of shaders\n    float pattern(vec2 vUv, vec2 v, float t){\n        vec2 p = floor(vUv + v);\n        return step(t, rand(100. + p * 0.00001) + rand(p.x) * 0.5);\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n        vec3 color = vec3(0.);\n    \n        vec2 grid = vec2(10.0, 15.0);\n        vUv *= grid;\n    \n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n    \n        vec2 vel = vec2(u_time * (rand(1.0)) * max(grid.x, grid.y));\n        vel *= vec2(0.0, 1.0) * rand(1.0 + ipos.x);\n    \n        vec2 offset = vec2(0., 0.);\n        color.r = pattern(vUv + offset, vel, rand(0.2) * 0.9);\n    \n        color *= step(0.5, fpos.x);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function U_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:b_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var __=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float cirOutline(vec2 vUv,vec2 pos,float size){\n        float x=1.-smoothstep(size,size+.01,distance(vUv,pos));\n        float y=1.-smoothstep((size*.25)+size,(size*.25)+size+.01,distance(vUv,pos));\n        return y-x;\n    }\n    \n    float rand(vec2 vUv){\n        return fract(sin(dot(vUv.xy,vec2(12.9898,78.233)))*43724.3497231);\n    }\n    \n    float rand1(float x){\n        return fract(sin(x)*1e4);\n    }\n    float rand2(float x){\n        return fract(sin(x)*1e4);\n    }\n    float rand3(float x){\n        return fract(sin(x)*1e4);\n    }\n    float rand4(float x){\n        return fract(sin(x)*1e4);\n    }\n    float rand5(float x){\n        return fract(sin(x)*1e4);\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv=vUv*2.-1.;\n        vec3 color=vec3(0.);\n        vec2 translate1=vec2(rand(vec2(rand1(.5)))+sin(u_time));\n        vec2 translate2=vec2(rand(vec2(rand2(.5)))-cos(u_time));\n        vec2 translate3=vec2(rand(vec2(rand3(.5)))+sin(u_time));\n        vec2 translate4=vec2(rand(vec2(rand4(.5)))-cos(u_time));\n        vec2 translate5=vec2(rand(vec2(rand5(.5)))+sin(u_time));\n        float shape1=cirOutline(vUv,(vec2(rand1(.5),rand1(.1)))*translate1,rand1(.5));\n        float shape2=cirOutline(vUv,(vec2(rand2(.4),rand2(.2)))*translate2,rand2(.5));\n        float shape3=cirOutline(vUv,(vec2(rand3(.3),rand3(.3)))*translate3,rand3(.5));\n        float shape4=cirOutline(vUv,(vec2(rand4(.2),rand4(.4)))*translate4,rand4(.5));\n        float shape5=cirOutline(vUv,(vec2(rand5(.1),rand5(.5)))*translate5,rand5(.5));\n        color=vec3(shape1+shape2+shape3+shape4+shape5);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function w_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:__,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var S_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(vec2 vUv){\n        return fract(cos(dot((vec2(vUv.x, vUv.y + (u_time * 0.001))),vec2(12.9898,78.233)))*43724.3497231 * abs(sin(u_time*.0000075))) ;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv.x *=0.15;\n        vUv.y*=0.15;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        float y = rand(vec2(ipos.x, fpos.y));\n        color.r = y;\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function M_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:S_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var k_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(748.3247298, 89.45870348))) * 2387402.3847293);\n    }\n    \n    vec2 Pattern(vec2 vUv, float i){\n        i = fract((i - 0.5) * 2.0);\n        if(i > 0.8 + (0.1 * cos(u_time))){\n            vUv = vec2(1.0) - vUv;\n        }else if (i > 0.6 + (0.1 * cos(u_time))){\n            vUv = vec2(1.0 - vUv.y, vUv.x);\n        }else if (i > 0.4 + (0.1 * cos(u_time))){\n            vUv = 1.0 - vec2(1.0 - vUv.y, vUv.x);\n        }\n        return vUv;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv -= 0.5;\n        \n        vec3 color = vec3(0.);\n        vUv *= 20. * sin(u_time * 0.1) + 20.0;\n        vUv.x += 0.25;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = Pattern(fpos, rand(ipos));\n        float y = smoothstep(tile.x - 0.1, tile.x, tile.y)-\n                  smoothstep(tile.x, tile.x + 0.1, tile.y);\n        color = vec3(y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function z_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:k_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var C_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(34.89327402, 347023874))) * 23469273.38497290347);\n    }\n    \n    vec2 Tile2(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > .5){\n            if(fract(vUv.y * .5)>.5){\n                vUv.x+= fract(t) * 2.;\n    \n            }else{\n                vUv.x-= fract(t) * 2. ;\n            }\n            //vUv = Rot(vUv, PI * 0.5);\n        } else {\n            if(fract(vUv.x*.5) > .5){\n                vUv.y += fract(t) * 2. ;\n            } else {\n                vUv.y -= fract(t) * 2. ;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile2(vUv, 5.5, 0.5);\n        //vUv *= 20.;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        float shape = cir(vUv, vec2(rand(fpos)), 0.25);\n        \n        \n        color = vec3(shape);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function T_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:C_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var R_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(float x) {\n        return fract(sin(x)*1e4);\n    }\n    //random\n    float rand(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(12.483017652, 87.8729301234))) * 49763419.2834798234);\n    }\n    //book of shaders\n    vec2 tPattern(vec2 vUv, float i){\n        i = fract((i - 0.5) * 2.0);\n        if(i > 0.75){\n            vUv = vec2(1.0) - vUv;\n        } else if (i > 0.5){\n            vUv = vec2(1.0 - vUv.x, vUv.y);\n        }else if (i > 0.25){\n            vUv = 1.0 - vec2(1.0 - vUv.x, - vUv.y);\n        }\n        return vUv;\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv *= 8.0;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = tPattern(fpos, rand(ipos * u_time * 0.000000001));\n        float s = step(tile.y, tile.x) + rand(fpos);\n        color = vec3(s);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function D_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:R_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var P_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //random\nfloat rand(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.483017652, 87.8729301234))) * 49763419.2834798234);\n}\n\nfloat rand(float x) {\n    return fract(sin(x)*1e4);\n}\n\n//book of shaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.0) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1.0 - vUv.x, vUv.y);\n    }else if (i > 0.25){\n        vUv = 1.0 - vec2(1.0 - vUv.x, - vUv.y);\n    }\n    return vUv;\n}\n\nfloat plot(vec2 vUv, float p){\n    return smoothstep(p - 0.075, p, vUv.y) -\n           smoothstep(p, p + 0.075, vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 10.0;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 tile = tPattern(fpos, rand(ipos * u_time * 0.000000001));\n    float y = abs(sin(tile.x));\n    float s = plot(tile, y);\n    color = vec3(s);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function F_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:P_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var j_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //rand\nfloat rand(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.34739482, 74.237492837))) * 2347081.3978489230);\n}\n\n//bookofshaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.0) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1.0 - vUv.x, vUv.y);\n    } else if (i > 0.25){\n        vUv = 1.0 - vec2(1.0 - vUv.x, vUv.y);\n    }\n    return vUv;\n}\n\nfloat plot(vec2 vUv, float p){\n    return smoothstep(p - 0.075, p, vUv.y) -\n           smoothstep(p, p + 0.075, vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 15.;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 tile = tPattern(fpos, rand(ipos * u_time * 0.000000001));\n    float y = 1. - smoothstep(0.25, 0.26, distance(tile, vec2(0.5)));\n    float s = plot(tile, y / abs(sin(u_time)));\n    color = vec3(s);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function I_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:j_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var E_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //rand\nfloat rand(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.34739482, 74.237492837))) * 2347081.3978489230);\n}\n\n//bookofshaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.0) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1.0 - vUv.x, vUv.y);\n    } else if (i > 0.25){\n        vUv = 1.0 - vec2(1.0 - vUv.x, vUv.y);\n    }\n    return vUv;\n}\n\n//plot function\nfloat plot(vec2 vUv, float p){\n    return smoothstep(p - 0.075, p, vUv.y) -\n           smoothstep(p, p + 0.075, vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 10.;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 tile = tPattern(ipos, rand(ipos) + abs(sin(u_time * 0.25)));\n    float y = sin(tile.x);\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function O_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:E_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var A_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //rand\nfloat rand(float x){\n    return fract(sin(x) * 1e4);\n}\n\nfloat rand(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(46.3469872, 98.3468))) * 67382.4684018202);\n}\n\n//pattern\nfloat pattern(vec2 vUv, vec2 pos, float size){\n    vec2 p = floor(vUv + pos);\n    float y = distance(vUv, pos);\n    return step(size, rand(100.+p * 0.000001) + rand(p.x) * 0.5);\n}\n\nfloat pattern2(vec2 vUv,vec2 pos,float size){\n    vec2 p=floor(vUv+pos);\n    float y=distance(vUv,pos);\n    return step(size,rand(100.+p*.000001)+rand(p.x)*.95);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 grid = vec2(25., 25.);\n    vUv *= grid;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 vel = vec2(u_time * 2. * max(grid.x, grid.y));\n    vel *= vec2(-1., 0.0) * rand(1.+ipos.y);\n    vec2 vel2=vec2(u_time*2.*max(grid.x,grid.y));\n    vel2*=vec2(0.,1.)*rand(1.+ipos.x);\n    vec2 offset = vec2(0.1, 0.);\n    float y = pattern(vUv, vel, 0.75);\n    float x=pattern(vUv,vel2,.95);\n    color = vec3(x + y);\n    color*=step(.2,fpos.x);\n    color*=step(.2,fpos.y);\n    gl_FragColor = vec4(1.-color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function L_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:A_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var G_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    uniform float u_rand;\n    //rand\nfloat rand(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(25. * u_rand, 98. * u_rand))) * 2347081. * u_rand);\n}\n\n//bookofshaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.0) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1.0 - vUv.x, vUv.y);\n    } else if (i > 0.25){\n        vUv = 1.0 - vec2(1.0 - vUv.x, vUv.y);\n    }\n    return vUv;\n}\n\n//plot function\nfloat plot(vec2 vUv, float p){\n    return smoothstep(p - 0.075, p, vUv.y) -\n           smoothstep(p, p + 0.075, vUv.y);\n}\n\nfloat plot2(vec2 vUv, float p){\n    return smoothstep(p - 0.075, p, vUv.x) -\n           smoothstep(p, p + 0.075, vUv.x);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 2.;\n    float y = sin(plot(vUv, u_time * u_rand)) * 500.;\n    y*= cir(vUv, vec2(1.), 1.);\n    float x = sin(plot2(vUv, u_time * u_rand)) * 500.;\n    x*= cir(vUv, vec2(1.), 1.);\n    color = (1.0 - y) * color + y * vec3(0.0, 1.0, 0.0);\n    color += (1.0 - x) * color + x * vec3(0.0, 1.0, 0.0);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function N_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:G_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var B_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    uniform float u_rand;\n    float Cir(vec2 vUv, float size){\n        return 1. - smoothstep( size, size + 0.01, distance(vUv, vec2(vUv.x * u_rand+ sin(u_time), vUv.y * u_rand+ cos(u_time))));\n    }\n    \n    float Cir2(vec2 vUv, float size){\n        return 1. - smoothstep( size, size + 0.01, distance(vUv, vec2(vUv.x * u_rand +cos(u_time), vUv.y * u_rand+ sin(u_time))));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 10. - 5.;\n        vec3 color = vec3(0.);\n        float c1 = Cir(vUv, 0.5);\n        float c2 = Cir2(vUv, 0.5);\n        color = vec3(c1 + c2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function q_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:B_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var V_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //rand\nfloat rand(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n//book of shaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * 2.0);\n    if(i > 0.75){\n        vUv = vec2(1.0) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1.0 - vUv.x, vUv.y);\n    }else if (i > 0.25){\n        vUv = 1.0 - vec2(1.0 - vUv.x, - vUv.y);\n    }\n    return vUv;\n}\n\n//sinc curve iquilezles.org\nfloat sinc(float x,float k){\n    float a=PI*((k*x)-1.);\n    return sin(a)/a ;\n}\n\n//plot function bookofshaders\nfloat plot(vec2 st, float pct){\n  \n  return  smoothstep( pct-0.2, pct, st.x ) -\n          smoothstep( pct, pct+0.2, st.x );\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 5.0;\n    vec3 color = vec3(0.);\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 tile = tPattern(fpos, rand(ipos)); \n    float x = (sinc((vUv.y), sin(u_time) * 0.5)) * 0.45;\n    float pct = plot(tile - 0.5, x);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function W_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:V_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var H_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //rand\nfloat rand(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n//bookofshaders\nfloat pattern(vec2 vUv, vec2 v, float t){\n    vec2 p = floor(vUv + v);\n    float y = smoothstep(t, t+0.01, rand(100.+p * 0.00001) + rand(p.x)*0.5);\n    return distance(vUv *y, v * y);\n}\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.001), vUv);\n    b *= smoothstep(size, size + vec2(0.001), 1. - vUv);\n    float b1 = b.x * b.y;\n    vec2 bb = smoothstep(size-0.05, (size-0.05) + vec2(0.01), vUv);\n    bb *= smoothstep(size-0.05, (size-0.05) + vec2(0.01), 1. - vUv);\n    float b2 = bb.x * bb.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float x = Box(vUv, vec2(.125));\n    vec2 grid = vec2(25., 50.);\n    vec2 grid2 = vec2(5., 5.);\n    vUv *= grid;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 vel = vec2(u_time * 0.25 * max(grid.x, grid.y));\n    vel *= vec2(-1., 0.0) * rand(1.0 + ipos.y);\n    vec2 vel2 = vec2(u_time * 1. * max(grid2.x, grid2.y));\n    vel2 *= vec2(0.0, -1.0) * rand(1.0 + ipos.x);\n    float y = pattern(vUv, vel, 0.95);\n    float z = pattern(1. - vUv, vel2, 0.95);\n    color = vec3(y + z);\n    color += 1. - x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function X_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:H_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Y_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //rand\nfloat rand(float x){\n    return fract(sin(x)* 1e4);\n}\n\nfloat rand(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n//book of shaders\nvec2 tPattern(vec2 vUv, float i){\n    i = fract((i - 0.5) * (u_time * 0.25));\n    if(i > 0.75){\n        vUv = vec2(1.) - vUv;\n    } else if (i > 0.5){\n        vUv = vec2(1. - vUv.x, vUv.y) ;\n    } else if (i > 0.25){\n        vUv = 1. - vec2(1. - vUv.x, vUv.y);\n    }\n    return vUv;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color = vec3(0.);\n    vUv *= 10.;\n    vec2 ipos = floor(vUv);\n    vec2 fpos = fract(vUv);\n    vec2 tile = tPattern(fpos, rand(ipos));\n    float y = step(tile.x, tile.y);\n    float z = smoothstep(tile.x - 0.1, tile.x, tile.y) - \n              smoothstep(tile.x, tile.x + 0.1, tile.y);\n    color = vec3(z);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Z_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Y_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Q_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(38.67392, 98.376482))) * 46783.2347982);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    vec2 Tile(vec2 vUv,float zoom,float speed){\n        vUv*=zoom;\n        float t=u_time*speed;\n        if(fract(t)>.5){\n            if(fract(vUv.y*.5)>.5){\n                vUv.x+=fract(t)*2.;\n            }else{\n                vUv.x-=fract(t)*2.;\n            }\n        }else{\n            if(fract(vUv.x*.5)>.5){\n                vUv.y+=fract(t)*2.;\n            }else{\n                vUv.y-=fract(t)*2.;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 newUv = vUv;\n        vUv *= 10.0;\n        newUv = Tile(newUv, 10., 0.5);\n        float z=1. - Cir(newUv,vec2(.5),.25);\n        vec3 color = vec3(0.);\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        float y = 1. - rand(ipos * (u_time * sin(0.00000001)));\n        color = vec3(y * z);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function J_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Q_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var K_=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //bookofshaders\nfloat plot(vec2 vUv, float x){\n    return smoothstep(x - 2000000.5, x, vUv.y) -\n           smoothstep(x, x + 0.05, vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 4. - 1.;\n    vec3 color = vec3(0.);\n    float y = fract(sin(vUv.x) * u_time * u_time);\n    float p = plot(vUv, y);\n    color = vec3(p);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $_(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:K_,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(83.8237492, 12.3874298))) *  2349236.8732947);\n    }\n    \n    //book of shaders\n    vec2 tPattern(vec2 vUv, float i){\n        i = fract((i-0.5) * 2.0);\n        if(i > 0.75){\n            vUv = vec2(1.0) - vUv;\n        } else if (i > 0.5){\n            vUv = vec2(1.0 - vUv.x, vUv.y);\n        } else if (i > 0.25){\n            vUv = 1.0 - vec2(1.0-vUv.x, vUv.y);\n        }\n        return vUv;\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv *= 20.;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = tPattern(fpos, rand(ipos ));\n        float y = BoxBorder(tile, vec2(0.15 * abs(sin(u_time * 0.25))));\n        color = vec3(y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ew(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(83.8237492, 12.3874298))) *  2349236.8732947);\n    }\n    \n    //book of shaders\n    vec2 tPattern(vec2 vUv, float i){\n        i = fract((i-0.5) * 2.0);\n        if(i > 0.75){\n            vUv = vec2(1.0) - vUv;\n        } else if (i > 0.5){\n            vUv = vec2(1.0 - vUv.x, vUv.y);\n        } else if (i > 0.25){\n            vUv = 1.0 - vec2(1.0-vUv.x, vUv.y);\n        }\n        return vUv;\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    float CirOutline(vec2 vUv,vec2 pos,float size){\n        float outer=1.-smoothstep((size+.025),(size+.025)+.25,distance(vUv,pos));\n        float inner=1.-smoothstep(size,size+.05,distance(vUv,pos));\n        return outer-inner;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv *= 10.;\n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = tPattern(fpos, rand(ipos ));\n        float y = BoxBorder(tile, vec2(0.15 * (sin(u_time * 0.15))));\n        float x = CirOutline(tile, vec2(0.5 * abs(sin(u_time * 0.15)), 0.5 * abs(cos(u_time * 0.15))), 0.5);\n        color = vec3(x);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ow(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(83.8237492, 12.3874298))) *  2349236.8732947);\n    }\n    \n    // vec2 Rot(vec2 vUv, float angle){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(angle), -sin(angle),\n    //                sin(angle), cos(angle)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    //book of shaders\n    vec2 tPattern(vec2 vUv, float i){\n        i = fract((i-0.5) * 2.0);\n        if(i > 0.75){\n            vUv = vec2(1.0) - vUv;\n        } else if (i > 0.5){\n            vUv = vec2(1.0 - vUv.x, vUv.y);\n        } else if (i > 0.25){\n            vUv = 1.0 - vec2(1.0-vUv.x, vUv.y);\n        }\n        return vUv;\n    }\n    \n    float BoxBorder(vec2 vUv,vec2 size){\n        //vUv = vUv * 4. - .5;\n        vec2 b=smoothstep(size,size+vec2(.01),vUv);\n        b*=smoothstep(size,size+vec2(.01),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),vUv);\n        b2*=smoothstep(size-vec2(.01),(size-vec2(.01))+vec2(.01),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        vUv *= 5.;\n        \n        vec2 ipos = floor(vUv);\n        vec2 fpos = fract(vUv);\n        vec2 tile = tPattern(fpos, rand(ipos ));\n        tile = Rot(tile, u_time * 0.25);\n        float y = BoxBorder(tile, vec2(0.2 * abs(sin(u_time * 0.0525))));\n        color = vec3(y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function aw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(float x){\n        return fract(sin(x)* 1e4);\n    }\n    \n    float plot(vec2 vUv, float pct){\n        return smoothstep(pct - 0.02, pct, vUv.y) - \n               smoothstep(pct, pct + 0.02, vUv.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv *= 10. - 5.;\n        vUv.y -= 2.;\n        vUv.x += u_time;\n        vec3 color = vec3(0.);\n        float i = floor(vUv.x);\n        float f = fract(vUv.x);\n        float y = rand(i);\n        //y = mix(rand(i), rand(i + 1.0), f);\n        y = mix(rand(i), rand(i + 1.0), smoothstep(0., 1., f));\n        float x = sin(u_time);\n        float pct = plot(vUv, y);\n        color = vec3(pct);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:iw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(float x){\n        return fract(sin(x)* 1e4);\n    }\n    \n    float plot(vec2 vUv, float pct){\n        return smoothstep(pct - 0.02, pct, vUv.y) - \n               smoothstep(pct, pct + .75, vUv.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv *= 10. - 5.;\n        vUv.y -= 2.;\n        vUv.x += u_time;\n        vec3 color = vec3(0.);\n        float i = floor(vUv.x * 1.);\n        float f = fract(vUv.x * 1.);\n    \n        float i2 = floor(vUv.x * 1.5);\n        float f2 = fract(vUv.x * 1.5);\n    \n        float i3 = floor(vUv.x * 2.);\n        float f3 = fract(vUv.x * 2.);\n    \n        float i4 = floor(vUv.x * 2.5);\n        float f4 = fract(vUv.x * 2.5);\n    \n        float i5 = floor(vUv.x * 3.);\n        float f5 = fract(vUv.x * 3.);\n    \n    \n        float y = rand(i);\n        float y2 = rand(i2);\n        float y3 = rand(i3);\n        float y4 = rand(i2);\n        float y5 = rand(i3);\n        //y = mix(rand(i), rand(i + 1.0), f);\n        y = mix(rand(i), rand(i + 1.0), smoothstep(0., 1., f));\n        y2 = mix(rand(i2), rand(i2 + 1.0), smoothstep(0., 1., f2));\n        y3 = mix(rand(i3), rand(i3 + 1.0), smoothstep(0., 1., f3));\n        y4 = mix(rand(i4), rand(i4 + 1.0), smoothstep(0., 1., f4));\n        y5 = mix(rand(i5), rand(i5 + 1.0), smoothstep(0., 1., f5));\n    \n        float pct = plot(vUv, y);\n        float pct2 = plot(vUv, y2);\n        float pct3 = plot(vUv, y3);\n        float pct4 = plot(vUv, y4);\n        float pct5 = plot(vUv, y5);\n    \n        color.r = pct;\n        color.g = pct2;\n        color.b = pct3;\n        // color.r = pct4;\n        // color.g = pct5;\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(float x){\n        return fract(sin(x)*1e5);\n    }\n    \n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-.02,pct,vUv.y)-\n        smoothstep(pct,pct+.02,vUv.y);\n    }\n    \n    float noise(vec2 vUv){\n        float i=floor(vUv.x);\n        float f=fract(vUv.x);\n        float y=rand(i);\n        y=mix(rand(i),rand(i+1.),smoothstep(0.,1.,f));\n        return y;\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        float x = 1.-smoothstep(size,size+.01,distance(vUv,pos));\n        float y = 1.-smoothstep(size + 0.02, size + 0.02+0.01, distance(vUv, pos));\n        return y - x;\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv*=10.-5.;\n        //vUv.y-=2.; \n        //vUv.x+=u_time;\n        vec3 color=vec3(0.);\n        float y = noise(vUv);\n        float x1=cir(vUv,vec2(2.5),1.25+y*cos(u_time));\n        float x2=cir(vUv,vec2(2.5),1.5+y*sin(u_time));\n        float x3=cir(vUv,vec2(2.5),1.+y*cos(u_time));\n        float x4=cir(vUv,vec2(2.5),1.75+y*sin(u_time));\n        float x5=cir(vUv,vec2(2.5),.75+y*cos(u_time));\n        float pct=plot(vUv,y);\n    \n        color=vec3(x1 + x2 + x3 + x4 + x5);\n        //color=vec3(pct + x1);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(float x){\n        return fract(sin(x)* 1e4);\n    }\n    \n    //2D random\n    float rand(vec2 vUv){\n        return fract(sin(dot(vUv.xy, vec2(23.74927,89.23476))) * 64827.27364872 + rand(u_time * 0.00001));\n    }\n    \n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = rand(i);\n        float b = rand(i + vec2(1.0, 0.0));\n        float c = rand(i + vec2(0.0, 1.0));\n        float d = rand(i + vec2(1.0, 1.0));\n    \n        // Smooth Interpolation\n    \n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n    \n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 pos = vec2(vUv * 5.0);\n        float n = noise(pos);\n        vec3 color = vec3(0.);\n        color.r =1. - n - 0.5;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //2D random\nfloat rand(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(23.74927,89.23476))) * 64827.27364872);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat cir(vec2 vUv,vec2 pos,float size){\n    vUv = vec2(0.5) - vUv;\n    float f = size * 1.5;\n    float r = length(vUv) * 2.0;\n    float a = atan(vUv.y, vUv.x);\n    float m = abs(mod(a + u_time * 2., 3.14 * 2.) - 3.14)/3.6;\n    m += noise(vUv + u_time * 0.1) * .5;\n    f += sin(a * 40.) * noise(vUv + u_time * .2) * 0.1;\n    f += sin(a * 10.) * .1 * pow(m, 2.);\n    float x = 1.-smoothstep(size,size+.01,distance(vUv,pos));\n    float y = 1.-smoothstep(size + 0.02, size + 0.02+0.01, distance(vUv, pos));\n    return smoothstep(f, f + 0.01, r) + (x - y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = cir(vUv, vec2(0.0), 0.4);\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //2D random\nfloat rand(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(23.74927,89.23476))) * 64827.27364872);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat lines(vec2 vUv, float b){\n    float s = 10.0;\n    vUv *= s;\n    return smoothstep(0., .5+b * .5, abs((sin(vUv.x * 3.1415) + b * 2.0)) * .5);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv -= 0.25;\n    vec3 color = vec3(0.);\n    vUv = vUv.yx * vec2(3., 3.);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = noise(vUv) * vUv + u_time * 0.25;\n    float p = vUv.x;\n    p = lines(vUv, .5);\n    color = vec3(p);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise2(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vec3 color = vec3(0.);\n    vUv += noise2(vUv * 2.5) * 5.0 + sin(u_time * 0.25);\n    float y = smoothstep(.19, .2, noise2(vUv ));\n    y += smoothstep(.1, .2, noise2(vUv * 10.));\n    y -= smoothstep(.3, .4, noise2(vUv * 10.));\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise2(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vec3 color = vec3(0.);\n    vUv += noise2(vUv * 2.5) * 1.0 + cos(u_time * 0.15);\n    float y = smoothstep(.19, .2, noise2(vUv ));\n    y += smoothstep(.1, .2, noise2(vUv * 10.));\n    y -= smoothstep(.3, .4, noise2(vUv * 10.));\n    y -= smoothstep(.4, .6, noise2(vUv * 20.));\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Uw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _w=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //2D random\nfloat rand(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(23.74927,89.23476))) * 64827.27364872);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat cir(vec2 vUv,vec2 pos,float size){\n    vUv = vec2(0.5) - vUv;\n    float f = size * 1.5;\n    float r = length(vUv) * 2.0;\n    float a = atan(vUv.y, vUv.x);\n    float m = abs(mod(a + u_time * 2., 3.14 * 2.) - 3.14)/3.6;\n    m += noise(vUv + u_time * 0.1) * .5;\n    f += sin(a * 20.) * noise(vUv + u_time * .02) * 0.1;\n    f -= sin(a * 10.) * .1 * pow(m, 2.);\n    float x = 1.-smoothstep(size,size+.01,distance(vUv,pos));\n    float y = 1.-smoothstep(size + 0.05, size + 0.02+0.01, distance(vUv, pos));\n    return smoothstep(f, f + 0.007, r);\n}\n\nfloat boarder(vec2 vUv, float size, float w){\n    return cir(vUv, vec2(0.0), size ) - cir(vUv, vec2(0.0), size + w); \n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = boarder(vUv, 0.5, 0.04);\n    float y2 = boarder(vUv, 0.3, 0.04);\n    float y3 = boarder(vUv, 0.1, 0.04);\n    color = vec3(y + y2 + y3);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ww(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_w,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Sw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(float x){\n        return fract(sin(x)*1e4);\n    }\n    \n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-.2,pct,vUv.y)-\n        smoothstep(pct,pct+.02,vUv.y);\n    }\n    \n    //2D random\n    float rand(vec2 vUv){\n        return fract(sin(dot(vUv.xy,vec2(23.74927,89.23476)))*64827.27364872);\n    }\n    \n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise(in vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        // Four corners in 2D of a tile\n        float a=rand(i);\n        float b=rand(i+vec2(1.,0.));\n        float c=rand(i+vec2(0.,1.));\n        float d=rand(i+vec2(1.,1.));\n        \n        // Smooth Interpolation\n        \n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u=f*f*(3.-2.*f);\n        // u = smoothstep(0.,1.,f);\n        \n        // Mix 4 coorners percentages\n        return mix(a,b,u.x)+\n        (c-a)*u.y*(1.-u.x)+\n        (d-b)*u.x*u.y;\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv*=10.-5.;\n        vUv.y-=2.5;\n        vUv.x+=u_time;\n        vec3 color=vec3(0.);\n        float i=floor(vUv.x);\n        float f=fract(vUv.x);\n        float y=rand(i);\n        //y = mix(rand(i), rand(i + 1.0), f);\n        y=mix(rand(i),rand(i+1.),smoothstep(0.,1.,f));\n        // float x=sin(u_time);\n        float pct=plot(noise(vUv+u_time)+vec2(vUv.x,vUv.y+ 0.8),y);\n        float pct2=plot(noise(vUv+u_time) + vUv,y);\n        float pct3=plot(noise(vUv+u_time)+vec2(vUv.x, vUv.y - 0.8),y);\n        float pct4=plot(noise(vUv+u_time)+vec2(vUv.x,vUv.y+ 1.6),y);\n        float pct5=plot(noise(vUv+u_time)+vec2(vUv.x,vUv.y-1.6),y);\n        color=vec3(pct + pct2 + pct3 + pct4 + pct5);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Mw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Sw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float rand(float x){\n        return fract(sin(x)*1e4);\n    }\n    \n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-.2,pct,vUv.y)-\n        smoothstep(pct,pct+.02,vUv.y);\n    }\n    \n    //2D random\n    float rand(vec2 vUv){\n        return fract(sin(dot(vUv.xy,vec2(23.74927,89.23476)))*64827.27364872);\n    }\n    \n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise(in vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        // Four corners in 2D of a tile\n        float a=rand(i);\n        float b=rand(i+vec2(1.,0.));\n        float c=rand(i+vec2(0.,1.));\n        float d=rand(i+vec2(1.,1.));\n        \n        // Smooth Interpolation\n        \n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u=f*f*(3.-2.*f);\n        // u = smoothstep(0.,1.,f);\n        \n        // Mix 4 coorners percentages\n        return mix(a,b,u.x)+\n        (c-a)*u.y*(1.-u.x)+\n        (d-b)*u.x*u.y;\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv = noise(Rot(vUv, u_time * 0.2)) * vUv;\n        vUv*=20.-10.;\n        vUv.y-=.0;\n        vUv.x+=u_time;\n        vec3 color=vec3(0.);\n        float i=floor(vUv.x);\n        float f=fract(vUv.x);\n        float y=rand(i);\n        //y = mix(rand(i), rand(i + 1.0), f);\n        y=mix(rand(i),rand(i+1.),smoothstep(0.,1.,f));\n        // float x=sin(u_time);\n        float pct=plot(vUv,y);\n        float pct2=plot(noise(vUv+u_time) + vUv,y);\n        float pct3=plot(noise(vUv+u_time)+vec2(vUv.x, vUv.y - 0.2),y);\n        float pct4=plot(noise(vUv+u_time)+vec2(vUv.x,vUv.y+ 0.4),y);\n        float pct5=plot(noise(vUv+u_time)+vec2(vUv.x,vUv.y-0.4),y);\n        color=vec3(pct + pct2 + pct3 + pct4 + pct5);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Cw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //2D random\nfloat rand(vec2 vUv){\n    return fract(sin(dot(vUv.xy, vec2(23.74927,89.23476))) * 64827.27364872);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat lines(vec2 vUv, float b){\n    float s = 10.0;\n    vUv *= s;\n    return smoothstep(0.45, .45+b * .451, abs((sin(vUv.x * 3.1415) + b * 1.)) * .5);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv -= .25;\n    vUv.x += sin(u_time) * 0.2;\n    vec3 color = vec3(0.);\n    vUv = vUv.yx * vec2(3., 3.);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = noise(vUv) * vUv + u_time * 0.025;\n    vUv.x = noise(vUv) * vUv.x;\n    vUv.y = noise(vUv) * vUv.y;\n    float p = vUv.x;\n    p = lines(vUv, .5);\n    color = vec3(p);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Tw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Cw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Rw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    vec2 pos = vec2(vUv * 2.);\n    pos = Rot(pos, u_time);\n    float y = noise(pos + sin(u_time));\n    float d = length( max(abs(vUv)-(.13 * sin(u_time * 0.25) * 2.),0.));\n    color = vec3(y * (fract(d * 10.0)));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Dw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Rw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Pw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 random2(vec2 st){\n        st = vec2( dot(st,vec2(127.1,311.7)),\n                  dot(st,vec2(269.5,183.3)) );\n        return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        vec2 u = f*f*(3.0-2.0*f);\n    \n        return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                         dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                    mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                         dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n    \n    mat2 rotate2d(float angle){\n        return mat2(cos(angle),-sin(angle),\n                    sin(angle),cos(angle));\n    }\n    \n    float lines(in vec2 pos, float b){\n        float scale = 10.0/2.;\n        pos *= scale;\n        return smoothstep(0.001,\n                        .05+b*.251,\n                        abs((sin(pos.x*3.1415)+b*2.0))*.0251);\n    }\n    \n    float Cir(vec2 vUv, vec2 pos, float size){\n        float scale  = 1.;\n        pos *= scale;\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        //vUv -= 0.5;\n        vec3 color = vec3(0.);\n        vec2 pos = vUv.yx*vec2(10.,3.);\n        pos -= vec2(5., 1.5);\n        float p = pos.x;\n        pos = rotate2d(noise2(pos + u_time)) * pos;\n        //p = Cir(pos, vec2(0.75), 0.45);\n        p += lines(pos, .5);\n        float r = smoothstep(0.4, 0.6, vUv.y * p);\n        float b = smoothstep(0.4, 0.6, 1. - vUv.y * p);\n        color.b = p * 0.025 * b;\n        color.b += 1. * r + p * 2. ;\n        //color.b = 1.0 * r;\n        //color.rg = vec2(p * b);\n        color.rg += (.8 - p * 1.23);\n        //color.rg += (.9 - p * 1.23);\n        //color.g = step(0.5, 1.);\n        //color.rg = vec2(1., 1.);\n        //color.b -= sin(u_time * 0.25);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Fw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Pw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 random2(vec2 st){\n        st = vec2( dot(st,vec2(127.1,311.7)),\n                  dot(st,vec2(269.5,183.3)) );\n        return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        vec2 u = f*f*(3.0-2.0*f);\n    \n        return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                         dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                    mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                         dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n    \n    mat2 rotate2d(float angle){\n        return mat2(cos(angle),-sin(angle),\n                    sin(angle),cos(angle));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv *= 10. - 5.;\n        //vUv.x += u_time * 0.2;\n        vec2 newUv = vUv;\n        newUv.x += 1. - noise2(newUv) * newUv.x + u_time;\n        newUv.y += 1. - noise2(newUv) * newUv.y + u_time;\n        \n        newUv = noise2(newUv) * newUv + sin(u_time);\n        color = vec3(newUv, 0.); \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Iw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ew=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 random2(vec2 st){\n        st = vec2( dot(st,vec2(127.1,311.7)),\n                  dot(st,vec2(269.5,183.3)) );\n        return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        vec2 u = f*f*(3.0-2.0*f);\n    \n        return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                         dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                    mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                         dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n    \n    mat2 rotate2d(float angle){\n        return mat2(cos(angle),-sin(angle),\n                    sin(angle),cos(angle));\n    }\n    \n    float Tri(vec2 vUv, float size){\n        vUv = vUv * 5. - 2.5;\n        float a  = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/3.;\n        float d = cos(floor(.05 * a/r) * r-a) * length(vUv);\n        return 1. - smoothstep(size, size+0.01, d);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec2 triUv = vUv;\n        triUv = noise2(triUv + (u_time * 0.5)) + triUv;\n        vec3 color = vec3(0.);\n        float tri = Tri(triUv, 0.5);\n        color = vec3(tri);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ow(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Ew,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Aw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    vec2 rotate2d(vec2 vUv, float angle){\n        vUv -= vec2(0.5);\n        vUv = (cos(angle),-sin(angle),\n                sin(angle),cos(angle)) * vUv ;\n        vUv += vec2(0.5);\n        return vUv;\n    }\n    \n    float Tri(vec2 vUv,float size){\n        vUv=vUv*5.-2.5;\n        float a=atan(vUv.x,vUv.y)+PI;\n        float r=TWO_PI/3.;\n        float d=cos(floor(.05*a/r)*r-a)*length(vUv);\n        return 1.-smoothstep(size,size+.01,d);\n    }\n    \n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-8. - abs(cos(u_time * 0.75)),pct,(vUv.y * (noise2(vUv + u_time))))-\n        smoothstep(pct,pct+8. + abs(sin(u_time * 0.75)),(vUv.y*(noise2(vUv + u_time))));\n    }\n    \n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 15. - 7.5;\n        //vUv = rotate2d(vUv, sin(u_time));\n        //vUv.x -= 0.5;\n        vUv.x = noise2(vUv * sin(u_time * 0.5)) + vUv.x;\n        vUv.y = noise2(vUv * sin(u_time * 0.5)) + vUv.y;\n        vec3 color = vec3(0.);\n        float y = noise2(vUv) + vUv.x;\n        float pct=plot(vUv, y);\n        color = vec3(pct);\n        gl_FragColor = vec4(color, 0.5);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Lw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Aw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Gw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    vec2 rotate2d(vec2 vUv,float angle){\n        vUv-=vec2(.5);\n        vUv=(cos(angle),-sin(angle),\n        sin(angle),cos(angle))*vUv;\n        vUv+=vec2(.5);\n        return vUv;\n    }\n    \n    float plot(vec2 vUv,float pct){\n        return smoothstep(pct-0.01-abs(sin(u_time*.75 )+7.5),pct,(vUv.y*(noise2(vUv+u_time + 2.0))))-\n        smoothstep(pct,pct+0.01+abs(sin(u_time*.75 )+2.0),(vUv.y*(noise2(vUv+u_time + 2.0))));\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv=vUv*15.-7.5;\n        vUv.y += 4.5;\n        //vUv = rotate2d(vUv, sin(u_time));\n        //vUv.x -= 0.5;\n        vUv.x=noise2(vUv)+vUv.x;\n        vUv.y=noise2(vUv)+vUv.y;\n        vec2 newUv = vUv;\n        newUv.y += 7.0;\n        vec3 color=vec3(0.);\n        float y=noise2(vUv)+vUv.y;\n        //float y2=noise2(vec2(newUv))+vUv.y - 7.5;\n        float pct=plot(vUv,y);\n        //float pct2=plot(vUv,y2);\n        float gradient = pow(1.0 - vUv.y, 2.0) * 0.5;\n        float final = pct * gradient;\n        color = final * vec3(pct, pct*pct, pct*pct*pct*pct*pct);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Nw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Gw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Bw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    vec2 rotate2d(vec2 vUv,float angle){\n        vUv-=vec2(.5);\n        vUv=(cos(angle),-sin(angle),\n        sin(angle),cos(angle))*vUv;\n        vUv+=vec2(.5);\n        return vUv;\n    }\n    \n    float plot(vec2 vUv,float p){\n        return smoothstep(p + 4.5, p, vUv.y) -\n               smoothstep(p, p - 0.0005, vUv.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 4. - 2.;\n        vUv.y += 2.5;\n        //vUv = vUv * sin(u_time * 0.5)/2.0;\n        vec3 color = vec3(.5, .8, .9);\n        float y1 = noise2(vUv + u_time);\n        float y2 = noise2(vUv + u_time);\n        float y3 = noise2(vUv + u_time);\n        float y4 = noise2(vUv + u_time);\n        float y5 = noise2(vUv + u_time);\n        float pct1 = plot(vec2(vUv.x + 0.0, vUv.y), y1);\n        float pct2 = plot(vec2(vUv.x + 0.5, vUv.y), y2);\n        float pct3 = plot(vec2(vUv.x + 1.0, vUv.y), y3);\n        float pct4 = plot(vec2(vUv.x - 0.5, vUv.y), y4);\n        float pct5 = plot(vec2(vUv.x - 1.0, vUv.y), y5);\n        color *= vec3(pct1 * pct2 * pct3 * pct4 * pct5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Bw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Vw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p *= vUv.x;\n        return smoothstep(p + vUv.x * 1.5, p, vUv.y) -\n               smoothstep(p, p - vUv.x * 1.5, vUv.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 5.;\n        vUv.x -= 1.5;\n        vUv.y += 1.2;\n        vUv = Rot(vUv, PI * 0.5);\n        //vUv = vUv * sin(u_time * 0.5)/2.0;\n        vec3 color = vec3(0.);\n        float y1 = noise2(vUv - u_time * 0.2);\n        float y2 = noise2(vUv - u_time * 1.0);\n        float y3 = noise2(vUv - u_time * 1.5);\n        float y4 = noise2(vUv - u_time * 1.5);\n        float y5 = noise2(vUv - u_time * 0.5);\n        float pct1 = plot(vec2(vUv.x + 0.0, vUv.y), y1);\n        float pct2 = plot(vec2(vUv.x + 0.5, vUv.y), y2);\n        float pct3 = plot(vec2(vUv.x + 1.0, vUv.y), y3);\n        float pct4 = plot(vec2(vUv.x - 0.5, vUv.y), y4);\n        float pct5 = plot(vec2(vUv.x - 1.0, vUv.y), y5);\n        color = vec3(pct1 * pct2 * pct3 * pct4 * pct5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ww(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Vw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Hw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     //vUv *= 2.0;\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    \n    float plot(vec2 vUv,float p){\n        p *= vUv.x;\n        return smoothstep(p + vUv.x * 1.5, p, vUv.y) -\n               smoothstep(p, p - vUv.x * 1.5, vUv.y);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        //vUv = vUv * 3. - 0.5;\n        //vUv.x -= 1.5;\n        //vUv.y += 1.2;\n        //vUv *= 2.0;\n        vUv = Rot(vUv, PI * u_time * 0.25);\n        vUv = vUv * 2. - 1.;\n        //vUv = vUv * sin(u_time * 0.5)/2.0;\n        vec3 color = vec3(.5, .8, .9);\n        float y1 = noise2(vUv - u_time * 0.2);\n        float y2 = noise2(vUv - u_time * 1.0);\n        float y3 = noise2(vUv - u_time * 1.5);\n        float y4 = noise2(vUv - u_time * 1.5);\n        float y5 = noise2(vUv - u_time * 0.5);\n        float pct1 = plot(vec2(vUv.x + 0.0, vUv.y), y1);\n        float pct2 = plot(vec2(vUv.x + 0.5, vUv.y), y2);\n        float pct3 = plot(vec2(vUv.x + 1.0, vUv.y), y3);\n        float pct4 = plot(vec2(vUv.x - 0.5, vUv.y), y4);\n        float pct5 = plot(vec2(vUv.x - 1.0, vUv.y), y5);\n        color *= vec3(pct1 * pct2 * pct3 * pct4 * pct5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Xw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Hw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Yw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     //vUv *= 2.0;\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    \n    float plot(vec2 vUv,float p){\n        p *= vUv.x;\n        return smoothstep(p + vUv.x * 1.5, p, vUv.y) -\n               smoothstep(p, p - vUv.x * 1.5, vUv.y);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    vec2 Tile2(vec2 vUv, float zoom, float speed){\n        vUv *= zoom;\n        //vUv = noise2(vUv + u_time) + vUv;\n        float t = u_time * speed;\n        if(fract(t) > .5 ){\n            if(fract(vUv.y * .5)>.5){\n                vUv.x+= fract(t) * 2.;\n                vUv.x = noise2(vUv + u_time) + vUv.x;\n            }else{\n                vUv.x-= fract(t) * 2.;\n                vUv.x = noise2(vUv - u_time) - vUv.x;\n            }\n            //vUv = Rot(vUv, PI * 0.5);\n        } else {\n            if(fract(vUv.x*.5) > .5){\n                vUv.y += fract(t) * 2.;\n                vUv.y = noise2(vUv + u_time) + vUv.y;\n            } else {\n                vUv.y -= fract(t) * 2.;\n                vUv.y = noise2(vUv - u_time) - vUv.y;\n            }\n        }\n        return fract(vUv);\n    }\n    \n    float Tri(vec2 vUv, float size){\n        vUv -= 0.5;\n        float a = atan(vUv.x, vUv.y) + PI;\n        float r = TWO_PI/3.0;\n        float d = cos(floor(.5 + a/r) * r-a) * length(vUv);\n        return 1.0 - smoothstep(size, size+0.01, d);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = Tile2(vUv, 10.0, 0.25);\n        float c1 = cir(vUv, vec2(0.5), 0.25);\n    \n        vec2 newUv = vUv;\n        newUv = Rot(vUv, sin(u_time + 2.0) * PI);\n        float t1 = Tri(newUv, 0.1);\n        \n        color = vec3(c1 - t1);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Zw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Yw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv, float a){\n    //     //vUv *= 2.0;\n    //     vUv -= 0.5;\n    //     vUv = mat2(cos(a), -sin(a),\n    //                sin(a), cos(a)) * vUv;\n    //     vUv += 0.5;\n    //     return vUv;\n    // }\n    \n    \n    float plot(vec2 vUv,float p){\n        p *= vUv.x;\n        return smoothstep(p +0.15, p, vUv.y) -\n               smoothstep(p, p - 0.15, vUv.y);\n    }\n    \n    float plot2(vec2 vUv,float p){\n        p *= vUv.y;\n        return smoothstep(p +0.15, p, vUv.x) -\n               smoothstep(p, p - 0.15, vUv.x);\n    }\n    \n    float cir(vec2 vUv, vec2 pos, float size){\n        return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 15. - 7.5;\n        vec3 color = vec3(0.);\n        vUv = noise2(vUv+u_time) * vUv;\n        float y = plot(vUv, 50.);\n        float y2 = plot2(vUv, cos(u_time+ TWO_PI));\n        color = vec3(y);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Jw(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Qw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Kw=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.15,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1. - (smoothstep(size,size+.01,distance(vUv,pos)) - \n                     smoothstep(size-0.025, size-0.025+0.1,distance(vUv,pos)));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2.6 - 1.3;\n        vec3 color = vec3(0.);\n        vec2 translate = noise2(vUv + u_time) * vUv;\n    \n        float c1=cir(vUv,vec2(.50 * translate.x , 0.50 * translate.y),.25);\n        float c2=cir(vUv,vec2(.25 * translate.x +sin(u_time), 0.50 * translate.y),.25);\n        float c3=cir(vUv,vec2(.75 * translate.x, 0.50 * translate.y +sin(u_time)),.25);\n        float c4=cir(vUv,vec2(.50 * translate.x -sin(u_time), 0.25 * translate.y),.25);\n        float c5=cir(vUv,vec2(.50 * translate.x, 0.75 * translate.y -sin(u_time)),.25);\n        color = 1. - vec3(c1*c2*c3*c4*c5);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $w(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Kw,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.15,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n        smoothstep(size-.025,size-.025+.1,distance(vUv,pos)));\n    }\n    \n    float sqr(vec2 vUv,vec2 size){\n        vec2 b=smoothstep(size,size+vec2(.03),vUv);\n        b*=smoothstep(size,size+vec2(.03),1.-vUv);\n        float box1=b.x*b.y;\n        vec2 b2=smoothstep(size-vec2(.03),(size-vec2(.03))+vec2(.03),vUv);\n        b2*=smoothstep(size-vec2(.03),(size-vec2(.03))+vec2(.03),1.-vUv);\n        float box2=b2.x*b2.y;\n        return box2-box1;\n    }\n    \n    void main(){\n        vec2 vUv=vec2(vUv.x,vUv.y);\n        vUv=vUv*3.-1.;\n        \n        vec2 newUv1= vUv;\n        newUv1.x += 1.0;\n        vec2 newUv2 = vUv;\n        newUv2.x -= 2.0;\n        vec3 color=vec3(0.);\n        vec2 translate1=noise2(newUv1+u_time)*newUv1;\n        vec2 translate2=noise2(newUv2+u_time)*newUv2;\n        //vUv = noise2(vUv+u_time ) + vUv;\n        float s1=sqr(vec2(newUv1.x,newUv1.y),vec2(.005+translate1.x,.05));\n        float s2=sqr(vec2(newUv1.x,newUv1.y+1.),vec2(.005-translate1.x,.005));\n        float s3=sqr(vec2(newUv1.x,newUv1.y-1.),vec2(.0005-translate1.x,.005));\n    \n        float s4=sqr(vec2(newUv2.x+1.,newUv2.y),vec2(.005+translate2.x,.05));\n        float s5=sqr(vec2(newUv2.x+1.,newUv2.y+1.),vec2(.005+translate2.x,.005));\n        float s6=sqr(vec2(newUv2.x+1.,newUv2.y-1.),vec2(.0005-translate2.x,.005));\n    \n        color = vec3(s1 + s2 + s3 + s4 + s5 + s6);\n        gl_FragColor=vec4(color,1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function eS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.15,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n        smoothstep(size-.025,size-.025+.1,distance(vUv,pos)));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 0.5;\n        vec3 color = vec3(0.);\n        vUv += noise2(vUv + u_time) * vUv;\n        float c1 = cir(vUv, vec2(0.5,0.0), 0.25);\n        float c2 = cir(vUv, vec2(0.0,0.0), 0.25);\n        float c3 = cir(vUv, vec2(1.0,0.0), 0.25);\n    \n        float c4 = cir(vUv, vec2(0.5,0.5), 0.25);\n        float c5 = cir(vUv, vec2(0.0,0.5), 0.25);\n        float c6 = cir(vUv, vec2(1.0,0.5), 0.25);\n    \n        float c7 = cir(vUv, vec2(0.5,1.0), 0.25);\n        float c8 = cir(vUv, vec2(0.0,1.0), 0.25);\n        float c9 = cir(vUv, vec2(1.0,1.0), 0.25);\n        color = vec3(c1 * c2 * c3 * c4 *c5 * c6 * c7 * c8 * c9);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function oS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.15,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n        smoothstep(size-.025,size-.025+.5,distance(vUv,pos)));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 3. - 1.;\n        vec2 newUv = vUv;\n        vec2 translate = vec2(noise2(newUv+u_time) + newUv.x, sin(noise2(newUv+u_time)) * newUv.y);\n        vec3 color = vec3(0.);\n    \n        vUv = Rot(vUv, u_time * 0.25);\n    \n        vec2 pos = vec2(0.5);\n        pos.x = translate.x * pos.x + 0.25;\n        pos.y = translate.y * pos.y + 0.75;\n        float c1 = cir(vUv, pos, 0.5);\n    \n        vec2 pos2 = vec2(0.5);\n        pos2.x = translate.x * pos2.x + 0.25;\n        pos2.y = translate.y * pos2.y + 0.5;\n        float c2 = cir(vUv, pos2, 0.5);\n    \n        vec2 pos3 = vec2(0.5);\n        pos3.x = translate.x * pos3.x + 0.25;\n        pos3.y = translate.y * pos3.y + 0.25;\n        float c3 = cir(vUv, pos3, 0.5);\n    \n        vec2 pos4 = vec2(0.5);\n        pos4.x = translate.x * pos4.x + 0.25;\n        pos4.y = translate.y * pos4.y + 1.0;\n        float c4 = cir(vUv, pos4, 0.5);\n    \n        vec2 pos5 = vec2(0.5);\n        pos5.x = translate.x * pos5.x + 0.25;\n        pos5.y = translate.y * pos5.y + 1.25;\n        float c5 = cir(vUv, pos5, 0.5);\n    \n        vec2 pos6 = vec2(0.5);\n        pos6.x = translate.x * pos6.x + 0.25;\n        pos6.y = translate.y * pos6.y + 0.0;\n        float c6 = cir(vUv, pos6, 0.5);\n    \n        color = vec3(c1 * c2 * c3 * c4 * c5 * c6);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function aS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.015,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n        smoothstep(size-.025,size-.025+.5,distance(vUv,pos)));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2. - 1.;\n        vUv = noise2(vUv + u_time) + vUv;\n        vec3 color = vec3(0.);\n        float p1 = vUv.y;\n        float p2 = vUv.y - 0.5;\n        float p3 = vUv.y - 1.0;\n        float p4 = vUv.x;\n        float p5 = vUv.x - 0.5;\n        float p6 = vUv.x - 1.0;\n        float pct1 = plot(vUv, p1);\n        float pct2 = plot(vUv, p2);\n        float pct3 = plot(vUv, p3);\n        float pct4 = plot(vUv, p4);\n        float pct5 = plot(vUv, p5);\n        float pct6 = plot(vUv, p6);\n        color = vec3(pct1 + pct2 + pct3 + pct4 + pct5 + pct6);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:iS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    vec2 random2(vec2 st){\n        st=vec2(dot(st,vec2(127.1,311.7)),\n        dot(st,vec2(269.5,183.3)));\n        return-1.+2.*fract(sin(st)*43758.5453123);\n    }\n    \n    // Gradient Noise by Inigo Quilez - iq/2013\n    // https://www.shadertoy.com/view/XdXGW8\n    float noise2(vec2 st){\n        vec2 i=floor(st);\n        vec2 f=fract(st);\n        \n        vec2 u=f*f*(3.-2.*f);\n        \n        return mix(mix(dot(random2(i+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(random2(i+vec2(1.,0.)),f-vec2(1.,0.)),u.x),\n        mix(dot(random2(i+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(random2(i+vec2(1.,1.)),f-vec2(1.,1.)),u.x),u.y);\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv *= 2.0;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    float plot(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.015,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float plot2(vec2 vUv,float p){\n        p*=vUv.x;\n        return smoothstep(p+.015,p,vUv.y)-\n        smoothstep(p,p-.15,vUv.y);\n    }\n    \n    float cir(vec2 vUv,vec2 pos,float size){\n        return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n        smoothstep(size-.025,size-.025+.5,distance(vUv,pos)));\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 5. - 2.5;\n        vec3 color = vec3(0.);\n        vUv *= noise2(vUv+u_time) * vUv;\n        float y = plot(vUv, abs(sin(u_time+ TWO_PI)));\n        float y2 = plot2(vUv,  abs(sin(u_time+ TWO_PI)));\n        color = vec3(y2);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, sin(u_time * 0.25));\n    vec3 color = vec3(0.);\n    vec2 pos = vec2(vUv * 5.);\n    vec2 vel = vec2(u_time * 0.1);\n    float y = snoise(pos + vel) * 0.25 + 0.25;\n    float a = snoise(pos * vec2(cos(u_time * 0.15), sin(u_time * 0.1)) * 0.1) * PI;\n    vel = vec2(cos(a), sin(a));\n    y += snoise(pos + vel) * 0.25 + 0.25;\n    color = vec3(smoothstep(0.7, 0.75, fract(y)));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = Rot(vUv, sin(u_time * 0.25));\n    vec3 color = vec3(0.);\n    vec2 pos = vec2(vUv * 2.);\n    vec2 vel = vec2(u_time * 0.1);\n    float y = snoise(pos) * 2.75 + 0.75;\n    float a = snoise(pos * vec2(cos(u_time * 0.25), sin(u_time * 0.2)) * 0.1) * PI;\n    vel = vec2(cos(a), sin(a));\n    y += snoise(pos + vel) * 0.25 + 0.25;\n    color = 1. - vec3(smoothstep(0.7, 0.75, fract(y)));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    p*=vUv.x;\n    return smoothstep(p+.015,p,vUv.y)-\n    smoothstep(p,p-.15,vUv.y);\n}\n\nfloat cir(vec2 vUv,vec2 pos,float size){\n    return 1.-(smoothstep(size,size+.01,distance(vUv,pos))-\n    smoothstep(size+.292,size+.295,distance(vUv,pos)));\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, (u_time * 0.25));\n    vUv = vUv * 5.0 - 2.5;\n    vec3 color = vec3(0.);\n    vUv = snoise(vUv) * vUv;\n    vec2 pos = vec2(0.5);\n    pos = snoise(pos) * pos;\n    float c1 = cir(vUv, pos, 0.25 + snoise(vUv + (u_time * 0.1)));\n    color = vec3(c1);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    p*=vUv.x;\n    return smoothstep(p+.015,p,vUv.y)-\n    smoothstep(p,p-.15,vUv.y);\n}\n\nfloat cir(vec2 vUv,vec2 pos,float size){\n    float x = 1.-(smoothstep(size,size+.1,distance(vUv,pos)));\n    float y = 1.-(smoothstep(size * 1.5, size * 1.5 + 0.1, distance(vUv, pos)));\n    return y - x;\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, (u_time * 0.25));\n    //vUv.x += u_time * 0.25;\n    vUv = vUv * 2. - 0.5;\n    vec3 color = vec3(0.);\n    //vUv += snoise(vUv) * vUv;\n    vec2 pos = vec2(0.5);\n    vUv = snoise(vUv) * vec2 (0.5);\n    float size = 0.25;\n    size = snoise(vUv * 5.0 + sin(u_time * 0.25)) + size;\n    float x = 1.-(smoothstep(size,size+.5,distance(vUv,pos)));\n    float y = 1.-(smoothstep(size * 1.25, size * 1.75 + 0.5, distance(vUv, pos)));\n    float c1 = y - x;\n    color = vec3(c1);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x = snoise(vUv + u_time * 0.1);\n    p += x;\n    return smoothstep(p+(.045),p,vUv.y)-\n    smoothstep(p,p-(.045),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 1. - 2.;\n    vec3 color = vec3(0.);\n    float x = vUv.x;\n    float y1 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct1 = plot(vec2(vUv.x - 2.5, vUv.y), y1);\n    float y2 =  x*x*(3.0-2.0*x);\n    float pct2 = plot(vec2(vUv.x - 2.0, vUv.y), y2);\n    float y3 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct3 = plot(vec2(vUv.x - 1.5, vUv.y), y3);\n    float y4 =  x*x*(3.0-2.0*x);\n    float pct4 = plot(vec2(vUv.x -1.0, vUv.y), y4);\n    float y5 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct5 = plot(vec2(vUv.x , vUv.y), y5);\n    float y6 =  x*x*(3.0-2.0*x);\n    float pct6 = plot(vec2(vUv.x + 1.0, vUv.y), y6);\n    float y7 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct7 = plot(vec2(vUv.x + 1.5, vUv.y), y7);\n    float y8 =  x*x*(3.0-2.0*x);\n    float pct8 = plot(vec2(vUv.x + 2.0, vUv.y), y8);\n    float y9 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct9 = plot(vec2(vUv.x + 2.5, vUv.y), y9);\n    float y10 =  x*x*(3.0-2.0*x);\n    float pct10 = plot(vec2(vUv.x + 3.5, vUv.y), y10);\n    color = vec3(pct1 + pct2 + pct3 + pct4 + pct5 + pct6 + pct7 + pct8 + pct9 + pct10);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x = snoise(vUv + u_time * 0.1);\n    p += x;\n    return smoothstep(p+(.045),p,vUv.y)-\n    smoothstep(p,p-(.045),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 2.;\n    vUv.x += 1.0;\n    vec3 color = vec3(0.);\n    float noise = snoise(vUv + u_time);\n    float x = vUv.x;\n    float y1 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct1 = plot(vec2(vUv.x - 2.5, vUv.y), y1);\n    float y2 =  x*x*(3.0-2.0*x);\n    float pct2 = plot(vec2(vUv.x - 2.0, vUv.y), y2);\n    float y3 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct3 = plot(vec2(vUv.x - 1.5, vUv.y), y3);\n    float y4 =  x*x*(3.0-2.0*x);\n    float pct4 = plot(vec2(vUv.x -1.0, vUv.y), y4);\n    float y5 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct5 = plot(vec2(vUv.x , vUv.y), y5);\n    float y6 =  x*x*(3.0-2.0*x);\n    float pct6 = plot(vec2(vUv.x + 1.0, vUv.y), y6);\n    float y7 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct7 = plot(vec2(vUv.x + 1.5, vUv.y), y7);\n    float y8 =  x*x*(3.0-2.0*x);\n    float pct8 = plot(vec2(vUv.x + 2.0, vUv.y), y8);\n    float y9 =  x*x*x*(x*(x*6.-15.)+10.);\n    float pct9 = plot(vec2(vUv.x + 2.5, vUv.y), y9);\n    float y10 =  x*x*(3.0-2.0*x);\n    float pct10 = plot(vec2(vUv.x + 3.5, vUv.y), y10);\n    color = vec3(pct1 + pct2 + pct3 + pct4 + pct5 + pct6 + pct7 + pct8 + pct9 + pct10);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function US(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _S=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x = snoise(vUv + u_time * 0.1);\n    p += x;\n    return smoothstep(p+(.045),p,vUv.y)-\n    smoothstep(p,p-(.045),vUv.y);\n}\n\nfloat cir(vec2 vUv,vec2 pos,float size){\n    float x = 1.-(smoothstep(size,size+.01,distance(vUv,pos)));\n    float y = 1.-(smoothstep(size * 1.25, size * 1.25 + 0.01, distance(vUv, pos)));\n    return y - x;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.5 - 0.75;\n    vec3 color = vec3(0.);\n    float noise = snoise(vUv + u_time);\n    float c1 = cir(vUv, vec2(0.5 + sin(noise * 0.1), 0.5), 0.15);\n    float c2 = cir(vUv, vec2(0.5 + sin(noise * 0.1), 0.5), 0.35);\n    float c3 = cir(vUv, vec2(0.5 + sin(noise * 0.1), 0.5), 0.55);\n    float c4 = cir(vUv, vec2(0.5 + sin(noise * 0.1), 0.5), 0.75);\n    float c5 = cir(vUv, vec2(0.5 + sin(noise * 0.1), 0.5), 0.95);\n    color = vec3(c1 + c2 + c3 + c4 + c5);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_S,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var SS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat sqr(vec2 vUv,vec2 size){\n    vec2 b=smoothstep(size,size+vec2(.013),vUv);\n    b*=smoothstep(size,size+vec2(.013),1.-vUv);\n    float box1=b.x*b.y;\n    vec2 b2=smoothstep(size-vec2(.013),(size-vec2(.031))+vec2(.031),vUv);\n    b2*=smoothstep(size-vec2(.013),(size-vec2(.031))+vec2(.031),1.-vUv);\n    float box2=b2.x*b2.y;\n    return box2-box1;\n}\nvec2 tile(vec2 _st, float _zoom){\n    _st *= _zoom;\n    return fract(_st);\n}\n\nvec2 movingTiles(vec2 _st, float _zoom, float _speed){\n    _st *= _zoom;\n    float time = u_time*_speed;\n    if( fract(time)>0.5 ){\n        if (fract( _st.y * 0.5) > 0.5){\n            _st.x += fract(time)*2.0;\n        } else {\n            _st.x -= fract(time)*2.0;\n        }\n    } else {\n        if (fract( _st.x * 0.5) > 0.5){\n            _st.y += fract(time)*2.0;\n        } else {\n            _st.y -= fract(time)*2.0;\n        }\n    }\n    return fract(_st);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv.y -= 2.5;\n    float noise = snoise(vUv + (u_time * 0.5));\n    vUv = movingTiles(vec2(sin(vUv.x) + noise * 0.01, cos(vUv.y) + noise * 0.01), 4., 0.15);\n    vec3 color = vec3(0.);\n    vec2 vUv2 = Rot(vUv, PI * 0.25);\n    vUv = Rot(vUv, u_time * 0.25 );\n    //vUv2 = Rot(vUv2, -u_time * 0.25  );\n    float y1 = sqr(vUv + (noise * 0.05), vec2(0.25));\n    float y2 = sqr(vUv2 + (noise * 0.05), vec2(0.2));\n    float y3 = sqr(vUv + (noise * 0.05), vec2(0.25 * 1.75));\n    float y4 = sqr(vUv2 + (noise * 0.05), vec2(0.2 * 1.75));\n    float y5 = sqr(vUv + (noise * 0.05), vec2(0.25 * 2.));\n    float y6 = sqr(vUv2 + (noise * 0.05), vec2(0.2 * 2.));\n    float y7 = sqr(vUv + (noise * 0.05), vec2(0.25 * 1.5));\n    float y8 = sqr(vUv2 + (noise * 0.05), vec2(0.2 * 1.5));\n    color = vec3(y1 + y2 + y3 + y4 + y5 + y6 + y7 + y8);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function MS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:SS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.1);\n    // p+=x * 0.15;\n    return smoothstep(p+(.045),p,vUv.y)-\n    smoothstep(p,p-(.045),vUv.y);\n}\n\nfloat cir(vec2 vUv, float size){\n    vUv=vec2(.5)-vUv;\n    float r=length(vUv)*2.;\n    float a=atan(vUv.y,vUv.x);\n    float m=abs(mod(a+u_time*1.,3.14*2.)-3.14)/3.6;\n    float f=size;\n    m+=snoise(vUv+u_time*.1)*.01;\n    // a *= 1.+abs(atan(u_time*0.2))*.1;\n    // a *= 1.+noise(st+u_time*0.1)*0.1;\n    f+=sin(a*12.)*snoise(vUv*u_time*.2)*.01;\n    f+=(sin(a*10.)*.1*pow(m,1.));\n    return 1.-smoothstep(f,f+.007,r);\n}\n\nfloat cirOutline(vec2 vUv, float size, float width){\n    return cir(vUv, size) - cir(vUv, size - width);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 0.5;\n    vec3 color = vec3(0.);\n    float y1=cirOutline(vUv,0.9,.025);\n    float y2=cirOutline(vUv,.8,.025);\n    float y3=cirOutline(vUv,0.7,.025);\n    float y4=cirOutline(vUv,.6,.025);\n    float y5=cirOutline(vUv,.5,.025);\n    color = vec3(y1 + y2 + y3 + y4 + y5);\n    gl_FragColor = vec4(color, 1.);\n}\n\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var CS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.1);\n    // p+=x * 0.15;\n    return smoothstep(p+(.045),p,vUv.y)-\n    smoothstep(p,p-(.045),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.2 - 1.1;\n    vUv /= u_time * 0.15;\n    vec3 color = vec3(0.);\n    float y = sin(vUv.x + u_time);\n    y *= snoise(sin(vUv*(u_time))) * 0.5 ;\n    float pct = plot(vec2(vUv.x,vUv.y), y);\n    float pct2= plot(vec2(vUv.x,vUv.y + 0.25),y);\n    float pct3=plot(vec2(vUv.x,vUv.y-.25),y);\n    float pct4=plot(vec2(vUv.x,vUv.y+.50),y);\n    float pct5=plot(vec2(vUv.x,vUv.y-.50),y);\n    color = vec3(pct + pct2 + pct3 + pct4 + pct5);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function TS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:CS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var RS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.1);\n    p=x * 0.15;\n    return smoothstep(p+(.05),p,vUv.y)-\n    smoothstep(p,p-(.5),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5. - 2.5;\n    vec3 color = vec3(0.);\n    float y = sin(vUv.x + u_time * 0.5);\n    float sn = snoise(vUv + u_time);\n    float pct = plot(vUv * sn, y);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function DS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:RS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var PS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.1);\n    p=x * 0.15;\n    return smoothstep(p+(.15),p,vUv.y)-\n    smoothstep(p,p-(2.5),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vUv.y -= 0.5;\n    vec3 color = vec3(0.);\n    vec2 translate = (vec2(snoise(vUv + (u_time * 0.5)) + vUv.x, snoise(vUv + (u_time * 0.5)) + vUv.y));\n    float x = vUv.x;\n    float y = x * x * ( 3. - 2. * x);\n    float pct = plot(vUv + translate, y);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function FS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:PS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.1);\n    p=x * 0.75;\n    return smoothstep(p+(.5),p,vUv.y)-\n    smoothstep(p,p-(2.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vUv = Rot(vUv, u_time * 0.15);\n    vec3 color = vec3(0.);\n    float n = snoise((vUv + u_time));\n    float y = sin(vUv.x + u_time) * n;\n    float pct = plot(vUv + sin(n + u_time * 0.25), y);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function IS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ES=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.1);\n    p=x * 0.5 ;\n    return smoothstep(p+(0.25),p,vUv.y)-\n    smoothstep(p,p-(1.0),vUv.y);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float noise = snoise(vUv);\n    float c1 = cir(vUv, vec2(0.5), 0.25);\n    color = vec3(c1);\n    float x = vUv.x;\n    float y = x*x*x*(x*(x*6.-15.)+10.) + noise;\n    float p1 = plot(vec2(vUv.x * (noise + sin(u_time)), vUv.y - 0.5 + (noise + cos(u_time))), y);\n    color *= p1;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function OS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:ES,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.1);\n    p=x * 0.5 ;\n    return smoothstep(p+(0.25),p,vUv.y)-\n    smoothstep(p,p-(1.0),vUv.y);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv *= 2.0;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float noise = snoise(vUv + (u_time * 0.5)) * 0.1;\n    float c1 = cir(vUv, vec2(0.5 + sin(noise), 0.5), 0.35 + noise);\n    float c2 = cir(vUv, vec2(0.5 + sin(noise), 0.5), 0.325 + noise);\n    float b1 = Box(vUv, vec2(0.25) + noise);\n    float b2 = Box(vUv, vec2(0.225) + noise);\n    color = vec3(c1 - c2);\n    color += (b2 - b1);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:AS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(0.01),p,vUv.y)-\n    smoothstep(p,p-(0.01),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.5;\n    vec3 color = vec3(0.);\n    float noise=snoise((vUv)+(u_time*.15))*.51;\n    vUv = vUv * sin(noise +u_time * 0.5);\n    float x=vUv.x;\n    float y=x*x*x*(x*(x*6.-15.)+10.)*noise;\n    float pct1=plot(vec2(vUv.x,vUv.y-.0),y);\n    float pct2=plot(vec2(vUv.x,vUv.y-.1),y);\n    float pct3=plot(vec2(vUv.x,vUv.y-.2),y);\n    float pct4=plot(vec2(vUv.x,vUv.y-.3),y);\n    float pct5=plot(vec2(vUv.x,vUv.y-.4),y);\n    float pct6=plot(vec2(vUv.x,vUv.y+.0),y);\n    float pct7=plot(vec2(vUv.x,vUv.y+.1),y);\n    float pct8=plot(vec2(vUv.x,vUv.y+.2),y);\n    float pct9=plot(vec2(vUv.x,vUv.y+.3),y);\n    float pct10=plot(vec2(vUv.x,vUv.y+.4),y);\n    color = vec3(pct1 + pct2 + pct3 + pct4 + pct5 + pct6 + pct7 + pct8 + pct9 + pct10);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function NS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:GS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var BS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+(0.5),p,vUv.y)-\n    smoothstep(p,p-(0.025),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5. - 2.5;\n    vUv.x += 1.5;\n    float noise = snoise(vUv) * (sin(u_time)) * 0.5;\n    vec3 color = vec3(0.);\n    float y = sin(vUv.x + (u_time) + noise);\n    float pct1=plot(vec2(vUv.x,vUv.y-0.25),y);\n    float pct2=plot(vec2(vUv.x,vUv.y),y);\n    float pct3=plot(vec2(vUv.x,vUv.y-0.5),y);\n    float pct4=plot(vec2(vUv.x,vUv.y-.75),y);\n    color = vec3(pct1 + pct2 + pct3 + pct4);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:BS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var VS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(.75),p,vUv.y)-\n    smoothstep(p,p-(.01),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    float noise = snoise(vUv);\n    float y1 = sin(vUv.x *noise+ u_time);\n    float pct1 = plot(vUv , y1);\n    vec2 newUv = vUv;\n    newUv = Rot(newUv, TWO_PI);\n    float y2=sin(newUv.x*noise+u_time);\n    float pct2=plot(newUv,y2);\n    vec2 newUv2=newUv;\n    newUv2=Rot(newUv2,TWO_PI);\n    float y3=sin(newUv2.x*noise+u_time);\n    float pct3=plot(newUv2,y3);\n    color = vec3(pct1 + pct2 + pct3);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function WS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:VS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var HS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.25);\n    p=x * 0.75 ;\n    return smoothstep(p+(2.75),p,vUv.y * p)-\n    smoothstep(p,p-(2.75),vUv.y * p);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    \n    vUv = vUv * 5. - 2.5;\n    \n    float noise = snoise(vUv + sin(u_time * 0.25) ) * (22.0);\n    vUv = vUv * (noise);\n    \n    vec3 color = vec3(0.);\n    float y = sin(vUv.x + u_time);\n    float pct = plot(Rot(vUv, u_time * 5.0), y);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function XS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:HS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var YS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(1.75),p,vUv.y * p)-\n    smoothstep(p,p-(1.75),vUv.y * p);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    \n    float n = snoise(vUv);\n    vec2 vUv = vec2(vUv.x + n, vUv.y - n);\n    \n    vUv = vUv * 5. - 2.5;\n    vUv = Rot(vUv, u_time * 0.25);\n    vec3 color = vec3(0.);\n    float y = sin(vUv.x * n * 2.5);\n    float pct = plot(vUv, y);\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ZS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:YS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(0.25),p,vUv.y * p)-\n    smoothstep(p,p-(0.025),vUv.y * p);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float c1 = cir(vUv, vec2(0.5), 0.25);\n    float y = snoise(vUv) + sin(c1);\n    float pct = plot(vec2(vUv.x, vUv.y + 0.5), y + (sin(u_time+ 15.0)) );\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function JS(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:QS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KS=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(0.525),p,vUv.y * p)-\n    smoothstep(p,p-(0.025),vUv.y * p);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 newUv = vUv;\n    newUv = Rot(vUv, u_time * 0.5);\n    float c1 = cir(vUv, vec2(0.5), 0.25);\n    float s1 = Box(newUv, vec2(0.25));\n    float y = snoise(vUv) + sin(s1);\n    float pct = plot(vec2(vUv.x, vUv.y + 0.5) + snoise(vUv + u_time * 0.25), y + (sin(u_time+ 15.0)) );\n    color = vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $S(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:KS,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(0.525),p,vUv.y * p)-\n    smoothstep(p,p-(0.025),vUv.y * p);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float n = snoise(vUv + u_time) * 0.05;\n    vec2 newUv = vUv;\n    newUv = Rot(vUv, u_time * 0.5);\n    float c1 = cir(vUv + n, vec2(0.5), 0.25);\n    float s1 = Box(newUv * n, vec2(0.25));\n    float y = snoise(vUv) + sin(s1);\n    float pct = plot(vUv, s1 - c1);\n    color = 1. - vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function eM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * 0.75 ;\n    return smoothstep(p+(0.525),p,vUv.y * p)-\n    smoothstep(p,p-(0.025),vUv.y * p);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.21, distance(vUv, pos));\n}\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.011), vUv);\n    b *= smoothstep(size, size + vec2(0.011), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float n = snoise(vUv * (u_time)) * 0.15;\n    vec2 newUv = vUv;\n    newUv = Rot(vUv, u_time * 0.5);\n    float c1 = cir(vUv * n, vec2(0.5), 0.25);\n    float s1 = Box(newUv + (n), vec2(0.15));\n    float y = snoise(vUv) + sin(s1);\n    float pct = plot(vUv, s1);\n    color = 1. - vec3(pct);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function oM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    float x=snoise(vUv+u_time*.25);\n    p=x * .95 ;\n    return smoothstep(p + 0.25,p,vUv.y)-\n    smoothstep(p,p-(0.25),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.25);\n    vUv = vUv * 8. - 4.;\n    vec3 color = vec3(0.);\n    float y = sin(vUv.x + u_time);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vUv2 = Rot(vUv2, PI * 0.5);\n    vUv3 = Rot(vUv3, PI * 0.75);\n    vUv4 = Rot(vUv4,-PI * 0.75);\n    float pct1 = plot(vUv1, y);\n    float pct2 = plot(vUv2, y);\n    float pct3 = plot(vUv3, y);\n    float pct4 = plot(vUv4, y);\n    color = vec3(pct1 + pct2 + pct3 + pct4);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function aM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * .05 ;\n    return smoothstep(p + 0.25,p,vUv.y)-\n    smoothstep(p,p-(0.25),vUv.y);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    float n = snoise((vUv) + (u_time * 0.25)) * .19;\n    float y0 = 1. - smoothstep(size - (0.15 * n) + n, size - (0.15 * n) + n + .01, distance(vUv + n, pos));\n    float y1 = 1. - smoothstep(size + n, (size + .01) + n, distance(vUv + n, pos));\n    float y2 = 1. - smoothstep(size + (0.15 * n) + n, size + (0.15 * n)  + n+ .01, distance(vUv + n, pos));\n    return y2 - y1 + y0;\n}\n\nvec2 tile(vec2 vUv, float zoom){\n    float n = snoise(vUv + u_time) * 0.2;\n    vUv *= zoom;\n    float time = u_time * 0.1 ;\n    if (fract(time) > 0.5){\n        if(fract(vUv.y * 0.5) > 0.5){\n            vUv.x += fract(time) * 2.0;\n        } else {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5){\n            vUv.y += fract(time) * 2.0;\n        } else {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vUv = tile(vUv, 1.);\n    vec3 color = vec3(0.);\n    float c1 = cir(vUv, vec2(0.5), 0.125);\n    color = vec3(c1);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:iM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nfloat plot(vec2 vUv,float p){\n    // float x=snoise(vUv+u_time*.25);\n    // p=x * .05 ;\n    return smoothstep(p + 0.015,p,vUv.y)-\n    smoothstep(p,p-(0.015),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    float n = snoise(vUv + u_time) * 1.0;\n    float y = sin((vUv.x * n) + u_time) / 10.0;\n    float p1 = plot(vec2(vUv.x, vUv.y + 0.1), y);\n    float p2 = plot(vec2(vUv.x, vUv.y + 0.2), y);\n    float p3 = plot(vec2(vUv.x, vUv.y + 0.3), y);\n    float p4 = plot(vec2(vUv.x, vUv.y + 0.4), y);\n    float p5 = plot(vec2(vUv.x, vUv.y + 0.5), y);\n    float p6 = plot(vec2(vUv.x, vUv.y - 0.0), y);\n    float p7 = plot(vec2(vUv.x, vUv.y - 0.1), y);\n    float p8 = plot(vec2(vUv.x, vUv.y - 0.2), y);\n    float p9 = plot(vec2(vUv.x, vUv.y - 0.3), y);\n    float p10 =plot(vec2(vUv.x, vUv.y - 0.4), y);\n    float p11 =plot(vec2(vUv.x, vUv.y - 0.5), y);\n    float p12 =plot(vec2(vUv.x, vUv.y + 0.6), y);\n    float p13 =plot(vec2(vUv.x, vUv.y + 0.7), y);\n    float p14 =plot(vec2(vUv.x, vUv.y + 0.8), y);\n    float p15 =plot(vec2(vUv.x, vUv.y + 0.9), y);\n    float p16 =plot(vec2(vUv.x, vUv.y + 1.0), y);\n    float p17 =plot(vec2(vUv.x, vUv.y - 0.6), y);\n    float p18 =plot(vec2(vUv.x, vUv.y - 0.7), y);\n    float p19 =plot(vec2(vUv.x, vUv.y - 0.8), y);\n    float p20 =plot(vec2(vUv.x, vUv.y - 0.9), y);\n    float p21 =plot(vec2(vUv.x, vUv.y - 1.0), y);\n    float p22 =plot(vec2(vUv.x, vUv.y - 1.1), y);\n    float p23 =plot(vec2(vUv.x, vUv.y + 1.1), y);\n    color = vec3(p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9 + p10 + p11\n                 + p11 + p12 + p13 + p14 + p15 + p16 + p17 + p18 + p19 + p20 + p21 + p22 + p23);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 1.5 - 0.25;\n        vec3 color = vec3(0.);\n        //cellular noise loops\n        vec2 point[6];\n        point[0] = vec2(0.83 + sin(u_time * 0.25), 0.75);\n        point[1] = vec2(0.60 - cos(u_time * 0.25), 0.1);\n        point[2] = vec2(0.28 , 0.64 + sin(u_time * 0.25) );\n        point[3] = vec2(0.31 , 0.26 - cos(u_time * 0.25));\n        point[4] = vec2(0.50 + sin(u_time * 0.25), 0.50 + cos(u_time * 0.25) );\n        point[5] = vec2(0.5, 0.5);\n        float m_dist = 1.;\n    \n        for(int i = 0; i < 6; i++){\n            float dist = distance(vUv, point[i]);\n            m_dist = min(m_dist, dist);\n        }\n        color = vec3(smoothstep(.345, .511, abs(sin(50. * m_dist + cos(u_time * 2.)))));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    //cellular noise loops\n   //scale\n   vUv *= 3.;\n\n   //tile the space\n   vec2 vUvI = floor(vUv);\n   vec2 vUvF = fract(vUv);\n   float m_dist = 1.; //min distance\n\n    //double loop\n    for (int y = -1; y <= 1; y++){\n        for (int x = -1; x <= 1; x++){\n            //neighbor grid\n            vec2 neighbor = vec2(float(x), float(y));\n            //random position from current and neighbor place in grid\n            vec2 point = random2(vUvI + neighbor);\n            //animate points\n            point = 0.5 + 0.5 * sin(u_time + TWO_PI * point);\n            //vector b/n pixel and point\n            vec2 diff = neighbor + point - vUvF;\n            //distance to the point\n            float dist = length(diff);\n            //closer distance\n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    color += m_dist;\n    //center cell\n    color += 1. - step(0.02, m_dist);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.25);\n    vUv = vUv * 2. - 1.;\n\n    vec3 color = vec3(0.);\n    //cellular noise loops\n   //scale\n   vUv *= 3.;\n\n   //tile the space\n   vec2 vUvI = floor(vUv);\n   vec2 vUvF = fract(vUv);\n   float m_dist = 1.; //min distance\n   vec2 m_point;//min position\n    //double loop\n    for (int y = -1; y <= 1; y++){\n        for (int x = -1; x <= 1; x++){\n            //neighbor grid\n            vec2 neighbor = vec2(float(x), float(y));\n            //random position from current and neighbor place in grid\n            vec2 point = random2(vUvI + neighbor);\n            //animate points\n            point = 0.25 + 0.35 * sin(u_time * TWO_PI * point);\n            //vector b/n pixel and point\n            vec2 diff = neighbor + (point * sin(u_time - 20.)) - vUvF;\n            //distance to the point\n            float dist = length(diff);\n            //closer distance\n            m_dist = min(m_dist, dist);\n            m_point = point;\n        }\n    }\n\n    color = vec3(m_dist);\n    //color = vec3(abs(cos(100. * m_dist))*0.07);\n    color *= m_dist * 1.025 + abs(sin(u_time * 0.5));\n    //color += vec3(1.)  * (1. - max(0.0, dot(m_dist - cos(u_time), m_dist + sin(u_time))));\n    //center cell\n    //color += 1. - step(0.02, m_dist);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+1.15,p,vUv.y)-\n    smoothstep(p,p-(1.151),vUv.y);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv=Rot(vUv,u_time*.25);\n    vUv=vUv*2.-1.;\n    \n    vec3 color=vec3(0.);\n    //cellular noise loops\n    //scale\n    vUv*=3.;\n    \n    //tile the space\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=1.;//min distance\n    vec2 m_point;//min position\n    //double loop\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            //neighbor grid\n            vec2 neighbor=vec2(float(x),float(y));\n            //random position from current and neighbor place in grid\n            vec2 point=random2(vUvI+neighbor);\n            //animate points\n            // point.x=.15+.15*sin(u_time*TWO_PI*point.x);\n            // point.y=.25+.35*cos(u_time*TWO_PI*point.y);\n            point = 0.5 + 0.5 * sin(u_time + TWO_PI * point);\n            //vector b/n pixel and point\n            vec2 diff=neighbor+point-vUvF;\n            //distance to the point\n            float dist=length(diff);\n            //closer distance\n            m_dist=min(m_dist,m_dist * dist);\n            m_point=point;\n        }\n    }\n    \n    color=1. - vec3(m_dist) - .9;\n    color += smoothstep(0.04, 0.41, m_dist);\n    // //color = vec3(abs(cos(100. * m_dist))*0.07);\n    // //color*=m_dist*1.025+abs(sin(u_time*.5));\n    //color += vec3(1.)  * (1. - max(0.0, dot(m_dist - cos(u_time), m_dist + sin(u_time))));\n    // //center cell\n    //color += 1. - step(.2, m_dist);\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+1.15,p,vUv.y)-\n    smoothstep(p,p-(1.151),vUv.y);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv=Rot(vUv,u_time*.25);\n    vUv=vUv*2.-1.;\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //cellular noise loops\n    //scale\n    vUv*=3.;\n    \n    //tile the space\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=1.;//min distance\n    vec2 m_point;//min position\n    //double loop\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            //neighbor grid\n            vec2 neighbor=vec2(float(x),float(y));\n            //random position from current and neighbor place in grid\n            vec2 point=random2(vUvI+neighbor);\n            //animate points\n            // point.x=.15+.15*sin(u_time*TWO_PI*point.x);\n            // point.y=.25+.35*cos(u_time*TWO_PI*point.y);\n            point = 0.5 + 0.5 * sin(u_time + TWO_PI * point);\n            //vector b/n pixel and point\n            vec2 diff=neighbor+point-vUvF;\n            //distance to the point\n            float dist=length(diff);\n            //closer distance\n            m_dist=min(m_dist,m_dist * dist);\n            m_point=point;\n        }\n    }\n    color = vec3(m_dist);\n    //color += smoothstep(0.04, 0.41, m_dist);\n    // //color = vec3(abs(cos(100. * m_dist))*0.07);\n    // //color*=m_dist*1.025+abs(sin(u_time*.5));\n    //color += vec3(1.)  * (1. - max(0.0, dot(m_dist - cos(u_time), m_dist + sin(u_time))));\n    // //center cell\n    //color += 1. - step(.2, m_dist);\n    color -= smoothstep(.017, .171, abs(sin(12.0*m_dist))) * 0.25;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    uniform vec2 u_mouse;\n\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453) + (u_time * 0.25);\n}\n\n//return min distance\n// float cellular(vec2 vUv, float scale, vec2 vUvI, vec2 vUvF, float minDist){\n//     vUv *= scale;\n//     for(int y=-1; y<=1; y++){\n//         for(int x=-1; x<=1; x++){\n//             vec2 neighbor = vec2(float(x), float(y));\n//             vec2 point = random2(vUvI + neighbor);\n//             point = 0.5 + 0.5 * sin(u_time + TWO_PI * point);\n//             vec2 diff = neighbor + point - vUvF;\n//             float dist = length(diff);\n//             minDist = min(minDist,dist);\n//             //return minDist;\n//         }\n//     }\n    \n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color=vec3(0.);\n    vUv *= 8.;\n    vUv.x +=  u_time;\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    //vUv*=scale;\n    float minDist = 1.;\n    for(int y=-2;y<=2;y++){\n        for(int x=-2;x<=2;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor );\n            point=.5+.5*sin(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF;\n            float dist=length(diff);\n            minDist=min(minDist,dist + u_mouse.x + u_mouse.y);\n        }\n    }\n    color += minDist;\n    //float c1 = cellular(vUv, 4.0, vUvI, vUvF, 12.0);\n    //color += c1;\n    //color.r += step(.98, f_st.x) + step(.98, f_st.y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _M=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453) + (u_time * 0.25);\n}\n\n//simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color=vec3(0.);\n    vUv *= 5.;\n    vUv.x +=  u_time;\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float n = snoise(vUv + u_time) * 0.1;\n    //vUv*=scale;\n    float minDist = 1.;\n    for(int y=-2;y<=2;y++){\n        for(int x=-2;x<=2;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor ) + n;\n            point=.5+.5*sin(u_time+TWO_PI*point);\n            // point.x = point.x + n;\n            // point.y = point.y + n;\n            vec2 diff=neighbor+point-vUvF;\n            float dist=length(diff + n);\n            minDist=min(minDist,dist);\n        }\n    }\n    color += minDist;\n    //color += 1. - step(0.1, minDist);\n    //color.r += step(.98, vUvF.x) + step(.98, vUvF.y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_M,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var SM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+1.15,p,vUv.y)-\n    smoothstep(p,p-(1.151),vUv.y);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    return 1. - smoothstep(size, size + 0.01, distance(vUv, pos));\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv=Rot(vUv,u_time*.25);\n    vUv=vUv*2.-1.;\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //cellular noise loops\n    //scale\n    vUv*=3.;\n    \n    //tile the space\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=10.;//min distance\n    vec2 m_point;//min position\n    //double loop\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            //neighbor grid\n            vec2 neighbor=vec2(float(x),float(y));\n            //random position from current and neighbor place in grid\n            vec2 point=random2(vUvI+neighbor);\n            //animate points\n            // point.x=.15+.15*sin(u_time*TWO_PI*point.x);\n            // point.y=.25+.35*cos(u_time*TWO_PI*point.y);\n            point = 0.5 + 0.5 * sin(u_time + TWO_PI * point);\n            //vector b/n pixel and point\n            vec2 diff=neighbor+point-vUvF;\n            //distance to the point\n            float dist=length(diff);\n            //closer distance\n            m_dist=min(m_dist,m_dist * dist);\n            m_point=point;\n        }\n    }\n    color = 1. - vec3(m_dist);\n    //color += smoothstep(0.04, 0.41, m_dist);\n    // //color = vec3(abs(cos(100. * m_dist))*0.07);\n    // //color*=m_dist*1.025+abs(sin(u_time*.5));\n    //color += vec3(1.)  * (1. - max(0.0, dot(m_dist - cos(u_time), m_dist + sin(u_time))));\n    // //center cell\n    //color += 1. - step(.2, m_dist);\n    color -= smoothstep(.017, .171, abs(sin(12.0*m_dist))) * 0.25;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function MM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:SM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 2.;\n    vec2 vUvI = floor(vUv);\n    vec2 vUvF = fract(vUv);\n    float m_dist = 0.5 * sin(u_time) + 2.0;\n    for(int y = -1; y <= 1; y++){\n        for (int x = -1; x <= 1; x ++){\n            vec2 neighbor = vec2(float(x), float(y));\n            vec2 point = random2(vUvI + neighbor);\n            point = 0.5 + 0.5 * cos(u_time + TWO_PI * point);\n            vec2 diff = neighbor + point - vUvF;\n            float dist = length(diff) ;\n            m_dist = min(m_dist, dist);\n            \n        }\n    }\n    color.rg += m_dist;\n    color.rg += 1.- smoothstep(0.01, 0.011, m_dist);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var CM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    vUv.x+=u_time*.025;\n    vUv*=5.;\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=.05+.2*cos(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF;\n            float dist=length(diff);\n            m_dist=min(m_dist,dist);\n            \n        }\n    }\n    color +=m_dist;\n    color +=1.-smoothstep(.01,.011,m_dist);\n    color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function TM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:CM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var RM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.025,p,vUv.y)-\n    smoothstep(p,p-(0.025),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.025;\n    vUv*=5.;\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 0.25;\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=.5+.5*cos(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF;\n            float dist=length(diff);\n            m_dist=min(m_dist,dist);\n            float y =dist-m_dist;\n            float pct = plot(point, y);\n            color = vec3(pct);\n        }\n    }\n    \n    //color +=m_dist;\n    color +=1.-smoothstep(.01,.011,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function DM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:RM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var PM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.025,p,vUv.y)-\n    smoothstep(p,p-(0.25),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.025;\n    vUv*=5.;\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 0.25;\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=.5+.25*cos(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF;\n            float dist=length(diff);\n            m_dist=min(m_dist,dist);\n            float y =m_dist;\n            float pct = plot(vUvF, y);\n            color = vec3(pct);\n            \n            \n        }\n    }\n    \n    //color +=m_dist;\n    color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function FM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:PM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.025,p,vUv.y)-\n    smoothstep(p,p-(0.025),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=8.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 4.;\n    for(int y=-1;y<=1;y++){\n        for(int x=-1;x<=1;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=.5+.5*cos(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist = dot(diff, diff);\n            dist -= 0.65;\n            m_dist=min(m_dist,dist);\n\n        }\n    }\n    \n    color +=m_dist * 3.;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function IM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.5,p,vUv.y)-\n    smoothstep(p,p-(0.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=3.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    for(int y=-5;y<=5;y++){\n        for(int x=-5; x<=5;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=.75+.75*sin(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.75));\n            dist1=plot(diff, vUvF.y);\n            float dist = dot(diff / dist1, diff/ dist1);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n\n        }\n    }\n    \n    color +=m_dist * 3.;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function OM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:EM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.5,p,vUv.y)-\n    smoothstep(p,p-(0.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-5;y<=5;y++){\n        for(int x=-5; x<=5;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=2.35+1.25*sin(u_time+TWO_PI*point);\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.5));\n            dist1=plot(diff, vUv.y - 2.5);\n            float dist = dot(diff / dist1 / 15., diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n\n        }\n    }\n    \n    color +=m_dist * 3.;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:AM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.5,p,vUv.y)-\n    smoothstep(p,p-(0.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=10.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-5;y<=5;y++){\n        for(int x=-5; x<=5;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor);\n            point=2.35+0.95*abs(sin(u_time+TWO_PI*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.5));\n            dist1=plot(diff, vUv.y - 2.5);\n            float dist = dot(diff / dist1 / 15., diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n\n        }\n    }\n    \n    color +=m_dist;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function NM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:GM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var BM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.5,p,vUv.y)-\n    smoothstep(p,p-(0.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=12.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) * 0.5;\n            point= .8*abs(sin(u_time+TWO_PI+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.15));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff / dist1 / 25., diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n\n        }\n    }\n    \n    \n    color = vec3(0., 0.25, 0.5);\n    color *= vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:BM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var VM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+.5,p,vUv.y)-\n    smoothstep(p,p-(.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv,vec2 size){\n    vec2 b=smoothstep(size,size+vec2(.01),vUv);\n    b*=smoothstep(size,size+vec2(.01),1.-vUv);\n    float b1=b.x*b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=12.;\n    vec3 m=vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8;x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor)*.5;\n            point=4.-abs(sin(u_time+TWO_PI+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF;\n            //float dist=length(diff);\n            float dist1=Box(diff,vec2(.15));\n            dist1=plot(diff,vUv.y-2.75);\n            float dist=dot(diff/m_dist,diff/m_dist);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            \n        }\n    }\n    \n    color=vec3(0.,.25,.5);\n    color=vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function WM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:VM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var HM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+.5,p,vUv.y)-\n    smoothstep(p,p-(.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv,vec2 size){\n    vec2 b=smoothstep(size,size+vec2(.01),vUv);\n    b*=smoothstep(size,size+vec2(.01),1.-vUv);\n    float b1=b.x*b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=3.;\n    vec3 m=vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8;x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor)*.5;\n            point=(sin(u_time+TWO_PI*2.*point));\n            vec2 diff=neighbor+point-vUvF;\n            //float dist=length(diff);\n            float dist1=Box(diff,vec2(.005));\n            dist1=plot(diff,vUv.y-2.75);\n            float dist=dot(diff/m_dist/m_dist,diff/m_dist/m_dist);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            \n        }\n    }\n    \n    color=vec3(0.,.25,.5);\n    color+=vec3(m_dist) * 0.9;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function XM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:HM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var YM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+.5,p,vUv.y)-\n    smoothstep(p,p-(.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv,vec2 size){\n    vec2 b=smoothstep(size,size+vec2(.01),vUv);\n    b*=smoothstep(size,size+vec2(.01),1.-vUv);\n    float b1=b.x*b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=3.;\n    vec3 m=vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=5.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8;x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor)*.25;\n            point=0.5 + 1.5 * (sin(u_time+TWO_PI + TWO_PI* 2.75*point));\n            vec2 diff=neighbor+point-vUvF;\n            //float dist=length(diff);\n            float dist1=Box(diff,vec2(.05));\n            dist1=plot(diff,vUv.y-2.75);\n            float dist=dot(diff/m_dist,diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            \n        }\n    }\n    \n    //color=vec3(0.,.25,.5);\n    color+=vec3(m_dist) * 2.0;\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ZM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:YM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.05,p,vUv.y)-\n    smoothstep(p,p-(0.05),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=12.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) * 0.5;\n            point= .8*abs(sin(u_time+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.15 * sin(u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff, diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            float y = plot(point, m_dist);\n            color = vec3(y);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color = vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function JM(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:QM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KM=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.05,p,vUv.y)-\n    smoothstep(p,p-(0.05),vUv.y);\n}\n\nfloat plot2(vec2 vUv,float p, float m){\n    return smoothstep(p + 0.05,p,vUv.y * m)-\n    smoothstep(p,p-(0.05),vUv.y * m);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) ;\n            point= 0.5 + .8*abs(sin(u_time+TWO_PI*2.75*point) + 12.0);\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.15 * (u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff, diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            float y = plot2(vUv, m_dist, m_dist);\n            color = vec3(y);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color = vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $M(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:KM,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.05,p,vUv.y)-\n    smoothstep(p,p-(0.05),vUv.y);\n}\n\nfloat plot2(vec2 vUv,float p, float m){\n    return smoothstep(p + 0.05,p,vUv.y * m)-\n    smoothstep(p,p-(0.05),vUv.y * m);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b) {\n    float thickness = 1.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa - ba*h);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) ;\n            point= .8*abs(sin(u_time+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.15 * (u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff, diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            // float y = plot2(vUv, m_dist, m_dist);\n            // color = vec3(y);\n            float line = lineSegment(vUvF + m_dist, point, neighbor);\n            color = vec3(line);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color = vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ek(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.05,p,vUv.y)-\n    smoothstep(p,p-(0.05),vUv.y);\n}\n\nfloat plot2(vec2 vUv,float p, float m){\n    return smoothstep(p + 0.05,p,vUv.y * m)-\n    smoothstep(p,p-(0.05),vUv.y * m);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b, float m) {\n    float thickness = 2.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b * m);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 3.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) ;\n            point= .9*abs(sin(u_time+TWO_PI*1.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.25 * (u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff, diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            // float y = plot2(vUv, m_dist, m_dist);\n            // color = vec3(y);\n            float line = lineSegment(vUvF, point, neighbor, m_dist);\n            color = vec3(line);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color *= vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ok(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p+.5,p,vUv.y)-\n    smoothstep(p,p-(.5),vUv.y);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv,vec2 size){\n    vec2 b=smoothstep(size,size+vec2(.01),vUv);\n    b*=smoothstep(size,size+vec2(.01),1.-vUv);\n    float b1=b.x*b.y;\n    return b1;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m=vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist=1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8;x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor)*.5;\n            point=1. + 1.8*abs(sin(u_time+TWO_PI+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF;\n            //float dist=length(diff);\n            float dist1=Box(diff,vec2(.15));\n            dist1=plot(diff,vUv.y-2.75);\n            float dist=dot(diff,diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            \n        }\n    }\n    \n    color=vec3(1.,.25,.5);\n    color*=1. - vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ak(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ik=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.05,p,vUv.y)-\n    smoothstep(p,p-(0.05),vUv.y);\n}\n\nfloat plot2(vec2 vUv,float p, float m){\n    return smoothstep(p + 0.05,p,vUv.y * m)-\n    smoothstep(p,p-(0.05),vUv.y * m);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b, float m) {\n    float thickness = 2.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b * m);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=5.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 8.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) ;\n            point= .7*abs(sin(u_time+TWO_PI*2.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.25 * (u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff, diff);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            // float y = plot2(vUv, m_dist, m_dist);\n            // color = vec3(y);\n            float line = lineSegment(neighbor, point/m_dist, point * m_dist, 0.15);\n            color = 1. - vec3(line);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color *= vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:ik,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ck=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat plot(vec2 vUv,float p){\n    return smoothstep(p + 0.5,p,vUv.y)-\n    smoothstep(p,p-(0.5),vUv.y);\n}\n\nfloat plot2(vec2 vUv,float p, float m){\n    return smoothstep(p + 0.5,p,vUv.y * m)-\n    smoothstep(p,p-(0.5),vUv.y * m);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nfloat Box(vec2 vUv, vec2 size){\n    vec2 b = smoothstep(size, size + vec2(0.01), vUv);\n    b *= smoothstep(size, size + vec2(0.01), 1. - vUv);\n    float b1 = b.x * b.y;\n    return b1;\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b, float m) {\n    float thickness = 5.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b * m);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv -= 0.25;\n    //vUv=Rot(vUv,u_time*.15);\n    vec3 color=vec3(0.);\n    //vUv.x+=u_time*.25;\n    vUv*=3.;\n    vec3 m = vec3(5.);\n    vec2 vUvI=floor(vUv);\n    vec2 vUvF=fract(vUv);\n    float m_dist= 1.;\n    \n    for(int y=-8;y<=8;y++){\n        for(int x=-8; x<=8;x++){\n            vec2 neighbor=vec2(float(x),float(y));\n            vec2 point=random2(vUvI+neighbor) ;\n            point= 0.5 + .35*abs(cos(u_time+PI*20.75*point));\n            vec2 diff=neighbor+point-vUvF ;\n            //float dist=length(diff);\n            float dist1 = Box(diff, vec2(0.25 * (u_time)));\n            dist1=plot(diff, vUv.y - 2.75);\n            float dist = dot(diff/m_dist, diff/m_dist);\n            //dist -= 0.5;\n            m_dist=min(m_dist,dist);\n            // float y = plot2(vUv, m_dist, m_dist);\n            // color = vec3(y);\n            float line = lineSegment(vUvF, point, neighbor, m_dist);\n            color = vec3(line);\n        }\n    }\n    \n    \n    //color = vec3(0., 0.25, 0.5);\n    //color *= vec3(m_dist);\n    \n    //color *= clamp(1.0 - 0.4 * m_dist * m_dist, 0.0, 1.0);\n    //color += smoothstep(.2,.21,m_dist);\n    //color-=step(.05,abs(sin(10. *m_dist)))*.3;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:ck,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b) {\n    float thickness = 1.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec2 mg, mr;\n    float md = 8.0;\n\n    for (int i = -1; i <=1; i++){\n        for(int j = -1; j<= 1; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md){\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n    md = 8.0;\n    for (int i = -3; i <=3; i++){\n        for(int j = -3; j<= 3; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            if (dot(mr -r, mr -r) > 0.00001){\n                md = min(md, dot(0.5 * (mr + r), normalize(r -mr)));\n\n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = Rot(vUv, u_time * 0.25);\n    vUv *= 3.;\n    vec3 c = voronoi(vUv);\n    float dd = length( c.yz );\n    color = mix( vec3(1.0), color, smoothstep( 0.01, 0.02, c.x * c ) );\n    //color += vec3(1.) * (1. - smoothstep(0.0, 0.04, dd));\n    //color = c;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b) {\n    float thickness = 1.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec2 mg, mr;\n    float md = 8.0;\n\n    for (int i = -1; i <=1; i++){\n        for(int j = -1; j<= 1; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md){\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n    md = 8.0;\n    for (int i = -2; i <=2; i++){\n        for(int j = -2; j<= 2; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            if (dot(mr -r, mr -r) > 0.00001){\n                md = min(md, dot(0.5 * (mr + r), normalize(r -mr)));\n\n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv = vUv * 2. - 1.;\n    vUv *= 2.5 + sin(u_time * 0.5);\n    vec3 c = voronoi(vUv);\n    float dd = length( c.yz );\n    color = mix( vec3(1.0), color, smoothstep( 0.01, 0.04, c.x) );\n    //color += vec3(1.) * (1. - smoothstep(0.0, 0.04, dd));\n    color *= c * 20.;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p, vec2 a, vec2 b) {\n    float thickness = 1.0/100.0;\n\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n\n    float h = clamp( dot(pa,ba)/dot(ba, pa), 0.0, 1.0 );\n    // ????????\n    float idk = length(pa*h * b);\n\n    return smoothstep(0.0, thickness, idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\n//simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvec3 voronoi(vec2 x){\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    vec2 mg, mr;\n    float md = 8.0;\n\n    for (int i = -1; i <=1; i++){\n        for(int j = -1; j<= 1; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md){\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n    md = 8.0;\n    for (int i = -2; i <=2; i++){\n        for(int j = -2; j<= 2; j++){\n            vec2 g = vec2(float(j), float(i));\n            vec2 o = random2(n + g);\n            o = 0.5 + 0.5 * sin(u_time + TWO_PI * o);\n\n            vec2 r = g + o - f;\n            if (dot(mr -r, mr -r) > 0.00001){\n                md = min(md, dot(0.5 * (mr + r), normalize(r -mr)));\n\n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    float n = snoise(vUv + (u_time * 0.25)) * 0.4;\n    vUv = vUv * 2. - 1.;\n    vUv *= 2.5 + sin(u_time * 0.5);\n    vec3 c = voronoi(vUv + u_time);\n    float dd = length( c.yz );\n    color = mix( vec3(1.0), color, smoothstep( 0.01, 0.011, c.x * c.y * c.z) );\n    //color += vec3(1.) * (1. - smoothstep(0.0, 0.04, dd));\n    //color *= c * 20.;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=0.1;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-2;i<=2;i++){\n        for(int j=-2;j<=2;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.25;\n    vec3 c=voronoi(vUv);\n    float dd=length(c.yz);\n    color=1. - mix(vec3(1.),color,smoothstep(.01,.04,c.x));\n    color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //simplex noise book of shaders\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n//book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=.1;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=.1;\n    for(int i=-2;i<=2;i++){\n        for(int j=-2;j<=2;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md,mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x+=u_time*.15;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    float n = snoise(vUv + u_time) * 0.05;\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x+=u_time*.25;\n    vec3 c=voronoi(vUv);\n    vec3 c2=voronoi(vec2(vUv.x+n+0.25,vUv.y+n+0.25));\n    vec3 c3=voronoi(vec2(vUv.x-n-0.25,vUv.y-n-0.25));\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.01,.04,c.x));\n    color+=mix(vec3(1.),color,smoothstep(.01,.04,c2.x));\n    color+=mix(vec3(1.),color,smoothstep(.01,.04,c3.x));\n    //color-=vec3(1.)*(1.-smoothstep(.1,.11,dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=3.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-2;i<=2;i++){\n        for(int j=-2;j<=2;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.25;\n    vec3 c=voronoi(vUv);\n    float dd=length(c.yz);\n    color=1. - mix(vec3(1.),color,smoothstep(.01,.04,c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Uk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _k=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=3.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-2;i<=2;i++){\n        for(int j=-2;j<=2;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=3.5;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi(vUv);\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.01 + c.x,.08,c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_k,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Sk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=3.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-2;i<=2;i++){\n        for(int j=-2;j<=2;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=3.5;\n    vUv.x += u_time * 0.125;\n    vec3 c1=voronoi(vec2(vUv.x, vUv.y + sin(u_time)));\n    vec3 c2=voronoi(vec2(vUv.x, vUv.y + 0.25 + sin(u_time)));\n    vec3 c3=voronoi(vec2(vUv.x, vUv.y - 0.25 + sin(u_time)));\n    float dd=length(c1.yz);\n    color=mix(vec3(1.),color,smoothstep(.05,.051,c1.x));\n    color=mix(vec3(1.),color,smoothstep(.045,.0451,c2.x));\n    color=mix(vec3(1.),color,smoothstep(.035,.0351,c3.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Mk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Sk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi((vUv));\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.2,.21,dd + c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ck=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi((vUv));\n    float dd=length(c.yz)/2.;\n    color=1. - mix(vec3(1.),color,smoothstep(.2,.21,dd + c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    //color*=c*20.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Tk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Ck,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Rk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.25;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi((vUv));\n    // float c1 = cir(vec2 vUv, vec2(0.5), 0.25);\n    float dd=length(c.yz);\n    color=1. - mix(vec3(1.),color,smoothstep(.05,.1,c.x));\n    color /= vec3(1.) * (1. - smoothstep(0.01, 0.91, dd ));\n    color*=c.z * c.y / c.x * 50.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Dk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Rk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Pk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin(u_time+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nfloat cir(vec2 vUv, vec2 pos, float size){\n    float x = smoothstep(size + 0.05, size + 0.06, distance(vUv, pos));\n    float y = smoothstep(size, size + 0.01, distance(vUv, pos));\n    return x * y;\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vec2 newUv = vUv;\n    //vUv.x += u_time * 0.25;\n    \n    float c1 = cir(newUv, vec2(0.5), 0.45);\n    vec3 color=vec3(0.);\n    color = vec3(c1); \n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5 * sin(u_time * 0.5) + 5.0;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi((vUv));\n    \n    float dd=length(c.yz);\n    \n    color=1. - mix(vec3(1.),color,smoothstep(.05,.04,c.x));\n    //color /= vec3(1.) * (1. - smoothstep(0.01, 0.91, dd ));\n    color*=c.x * 50.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Fk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Pk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.125;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*2.-1.;\n    vUv*=2.5;\n    vUv.x += u_time * 0.125;\n    vec3 c=voronoi((vUv));\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.5,.51,dd + c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    color+=c.x*50.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ik(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ek=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.125;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*4.-2.;\n    vUv*=1.;\n    vUv.x += u_time * 0.25;\n    vec3 c=voronoi((vUv));\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.45,.751,dd + c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    color/=c.x * 70.;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ok(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Ek,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ak=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders\nvec2 random2(vec2 p){\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat lineSegment(vec2 p,vec2 a,vec2 b){\n    float thickness=1./100.;\n    \n    vec2 pa=p-a;\n    vec2 ba=b-a;\n    \n    float h=clamp(dot(pa,ba)/dot(ba,pa),0.,1.);\n    // ????????\n    float idk=length(pa*h*b);\n    \n    return smoothstep(0.,thickness,idk);\n}\n\n// vec2 Rot(vec2 vUv,float a){\n//     //vUv*=2.;\n//     vUv-=.5;\n//     vUv=mat2(cos(a),-sin(a),\n//     sin(a),cos(a))*vUv;\n//     vUv+=.5;\n//     return vUv;\n// }\n\nvec3 voronoi(vec2 x){\n    vec2 n=floor(x);\n    vec2 f=fract(x);\n    \n    vec2 mg,mr;\n    float md=5.;\n    \n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            float d=dot(r,r);\n            \n            if(d<md){\n                md=d;\n                mr=r;\n                mg=g;\n            }\n            \n        }\n    }\n    md=0.1;\n    for(int i=-5;i<=5;i++){\n        for(int j=-5;j<=5;j++){\n            vec2 g=vec2(float(j),float(i));\n            vec2 o=random2(n+g);\n            o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n            \n            vec2 r=g+o-f;\n            if(dot(mr-r,mr-r)>.00001){\n                md=min(md,dot(.025*(mr+r),normalize(r-mr)));\n                \n            }\n        }\n    }\n    return vec3(md, vec2(mr.x, mr.y/md/(200.0 - sin(u_time))));\n}\n\nvoid main(){\n    vec2 vUv=vec2(vUv.x,vUv.y);\n    vUv.x += u_time * 0.125;\n    vec3 color=vec3(0.);\n    //vUv = Rot(vUv, u_time * 0.125);\n    vUv=vUv*4.-2.;\n    vUv*=2.;\n    vUv.x += u_time * 0.25;\n    vec3 c=voronoi((vUv));\n    float dd=length(c.yz);\n    color=mix(vec3(1.),color,smoothstep(.45,.751,dd + c.x));\n    //color -= vec3(1.) * (1. - smoothstep(0.1, 0.11, dd));\n    color/=c.x;\n    gl_FragColor=vec4(color,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Lk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Ak,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Gk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    float plot(vec2 vUv,float p){\n        return smoothstep(p + 0.09,p,vUv.y)-\n        smoothstep(p,p-(0.02),vUv.y);\n    }\n    \n    float fbm(vec2 vUv, int octaves){\n        //inital values\n        float value = 0.0;\n        float amplitude = 0.5 ;\n        float frequency = 0. ;\n        //loop of octaves\n        for (int i = 0; i < octaves; i++){\n            //vUv += 2.;\n            value += amplitude * (noise(vUv + u_time));\n            //vUv = vUv * 2. - 1.;\n            vUv *= 2.;\n            // vUv.x += u_time * 0.5;\n            amplitude *= 0.5 ;\n        }\n        return value; \n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = fbm(vUv, 6);\n        // float pct = plot(vec2(vUv), y);\n        // color = vec3(pct);\n        color += y;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Nk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Gk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Bk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 2.0;\n    float gain = 0.5;\n    float offset = 0.9;\n\n    float sum = 0.0;\n    float freq = 1.0, amp = 0.5;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        float n = ridge(snoise(p*freq + (u_time * 0.25)), offset);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    color += y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Bk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Vk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = 0.6;\n    vec2 shift = vec2(100.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv);\n        vUv = rot * vUv * 2.0 + shift + (u_time * 0.05);\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 1.5;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv + 0.2 * u_time);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + r);\n\n    color = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.066667,0.666667,0.498039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.,0.5,0.164706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,.2));\n\n    float x = f * f * f + 0.6 * f * f + 0.5 * f;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Wk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Vk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Hk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .9;\n    vec2 shift = vec2(1000.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv);\n        vUv = rot * vUv * 2.0 + shift + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 1.5;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv + 0.2 * u_time);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.101961,0.619608,0.666667),\n                vec3(0.066667,0.666667,0.498039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.,0.5,0.164706),\n    //             clamp(length(q),0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.666667,1.,1),\n    //             clamp(length(r.x),0.0,.2));\n\n    float x = f;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Xk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Hk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Yk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .45;\n    vec2 shift = vec2(1.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv);\n        vUv = rot * vUv * 2.0 + shift + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 4.;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.,.8,0.94706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.166667,.1,0.2),\n                clamp(length(r.x),0.0,.2));\n\n    float x = f;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Zk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Yk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = .0;\n    float a = .55;\n    vec2 shift = vec2(1.5);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv);\n        vUv = rot * vUv * 2.0 + shift + (u_time * 0.25);\n        a *= 1.05 * noise(vUv);\n    }\n    return v;\n}\n\n//  \n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.01);\n    vUv *= 2.;\n    vUv.x += u_time * 0.24;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.3, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(9.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.401961,0.619608,0.666667),\n                vec3(0.466667,0.666667,0.098039),\n                clamp((f),0.4,1.0));\n\n    color = mix(color,\n                vec3(0.15,.78,0.94706),\n                clamp(length(q),.2,1.0));\n\n    color = mix(color,\n                vec3(0.66667,.1,0.2),\n                clamp(length(r.x),0.0,.2));\n\n    float x = 1. - f;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Jk(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Qk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Kk=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .1 ;\n    float gain = 0.5 ;\n    float offset = 1. + snoise(p + (u_time * 0.25));\n\n    float sum = 0.0 ;\n    float freq = 1.0; \n    float amp = 0.5 ;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 5.;\n        float n = ridge(snoise(p*freq + (u_time * 0.25)), offset);\n        sum += n*amp;\n        sum += n*amp*prev ;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    color += y;\n    color -= mix(vec3(0.401961,0.619608,0.666667),\n                vec3(0.466667,0.666667,0.098039),\n                clamp((y),0.4,1.0));\n    color -= mix(color,\n                vec3(0.66667,.1,0.2),\n                clamp(length(y),0.0,.2));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $k(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Kk,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .1 ;\n    float gain = 0.5 ;\n    float offset = 1. + snoise(p + (u_time * 0.25));\n\n    float sum = 0.0 ;\n    float freq = 1.0; \n    float amp = 0.5 ;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 5.;\n        float n = ridge(snoise(p*freq + (u_time * 0.25)), offset);\n        sum += n*amp;\n        sum += n*amp*prev ;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv + snoise(vUv + (u_time * 0.1)));\n    color += y;\n    color -= mix(vec3(0.401961,0.619608,0.666667),\n                vec3(0.466667,0.666667,0.098039),\n                clamp((y),0.4,1.0));\n    color -= mix(color,\n                vec3(0.66667,.1,0.2 + sin(u_time)),\n                clamp(length(y),0.0,.2));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ez(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .1 ;\n    float gain = 1.5 ;\n    float offset = 1.25 + snoise(p + (u_time * 0.5));\n\n    float sum = 0.0 ;\n    float freq = 1.0; \n    float amp = 0.5 ;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 5.;\n        float n = 1. - ridge(snoise(p*freq + (u_time * 0.5)), offset);\n        sum += n*amp;\n        sum += 1. - n*amp*prev ;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = vUv * 5.;\n    float y = ridgedMF(vUv + snoise(vUv + (u_time * 0.1)));\n    color += y;\n    color -= mix(vec3(0.401961,0.619608,0.666667),\n                vec3(0.466667,0.666667,0.098039),\n                clamp((y),0.4,1.0));\n    color -= mix(color,\n                vec3(0.66667,.1,0.2 + sin(u_time)),\n                clamp(length(y),0.0,.2));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function oz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h ;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .1 ;\n    float gain = 1.5 ;\n    float offset = 1.1;\n\n    float sum = 0.0 ;\n    float freq = 1.0; \n    float amp = 0.5 ;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 3.;\n        float n = ridge(snoise(p*freq + (u_time * 0.25)), offset);\n        sum = n*amp;\n        sum += n*amp*prev ;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = vUv * 23.;\n    float y = ridgedMF(vUv);\n    color += y;\n    color -= mix(vec3(0.401961,0.619608,0.666667),\n                vec3(0.466667,0.666667,0.098039),\n                clamp((y),0.4,1.0));\n    color -= mix(color,\n                vec3(0.66667,.1,0.2),\n                clamp(length(y),0.0,.2));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function az(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 2.0 ;\n    float gain = 0.25 ;\n    float offset = .9;\n\n    float sum = .0;\n    float freq = 1.0; \n    float amp = 0.75;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        //p *= 3.;\n        p.x += u_time * 0.2;\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev * snoise(vUv + u_time * 0.5);  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv * 3.0);\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:iz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 2.0 ;\n    float gain = 0.25 ;\n    float offset = .9;\n\n    float sum = .0;\n    float freq = 1.0; \n    float amp = 0.75;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        //p *= 1.5;\n        p.x += u_time * 0.2;\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev - snoise(p + u_time * 0.25);  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv * 3.0);\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .45;\n    vec2 shift = vec2(1.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv);\n        vUv = rot * PI * 0.25 * vUv * 3. + shift + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 5.;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n    float f2 = fbm(vUv + fbm(vUv + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667 + sin(u_time)),\n                vec3(0.966667,0.666667,0.098039 + sin(u_time)),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.,.8,0.94706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.166667,.1,0.2),\n                clamp(length(r.x),0.0,.2));\n\n    float x = f * f2 + f + f2;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .95;\n    vec2 shift = vec2(1.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a * noise(vUv + u_time);\n        //vUv = rot * PI * 0.25 *vUv * 3. + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 10.;\n    //vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    // q.x = fbm(vUv * vec2(8.));\n    // q.y = fbm(vUv * vec2(8.));\n\n    vec2 r = vec2(0.);\n    // r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    // r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n    float f2 = fbm(vUv + fbm(vUv + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667 + sin(u_time)),\n                vec3(0.966667,0.666667,0.098039 + sin(u_time)),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color = mix(color,\n                vec3(0.,.8,0.94706),\n                clamp(length(q),0.0,1.0));\n\n    color = mix(color,\n                vec3(0.166667,.1,0.2),\n                clamp(length(r.x),0.0,.2));\n\n    float x = f * f2 * f * f2;\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 6\n    float fbm (in vec2 st) {\n        // Initial values\n        float value = 0.0;\n        float amplitude = .5;\n        float frequency = 0.1;\n        //\n        // Loop of octaves\n        for (int i = 0; i < OCTAVES; i++) {\n            value += amplitude * noise(st + (u_time * 0.5));\n            st *= 6.;\n            //st.x += u_time * 0.25;\n            amplitude *= .25;\n        }\n        return value;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float x = fbm(vUv * 1.0 + fbm(vUv * 3.0 + fbm(vUv * 5.0 + fbm(vUv * 7.0 + fbm(vUv * 11.0)))));\n    \n        vec2 q = vec2(0.);\n        q.x = fbm( vUv + 0.00*u_time);\n        q.y = fbm( vUv + vec2(1.0));\n    \n        vec2 r = vec2(0.);\n        r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.015*u_time );\n        r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.0126*u_time);\n        //x += x * sin(u_time * 0.15);\n        //color += x;\n        //color.x += sin(u_time * 0.05);\n        color = mix(color,\n                    vec3(0,0,0.164706),\n                    clamp(length(x),0.0,1.0));\n    \n        color = mix(color,\n                    vec3(0.966667,0,0),\n                    clamp(length(x),0.0,1.0));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f) ;\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 6\n    float fbm (in vec2 st) {\n        // Initial values\n        float value = 0.0;\n        float amplitude = .5;\n        float frequency = 0.1;\n        //\n        // Loop of octaves\n        for (int i = 0; i < OCTAVES; i++) {\n            value += amplitude * noise(st + (u_time * 0.5));\n            st *= 5.;\n            //st.x += u_time * 0.25;\n            amplitude *= .25;\n        }\n        return value;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2.75;\n        vec3 color = vec3(0.);\n        float x = fbm(vUv * 1.0 + fbm(vUv * 2.0 + fbm(vUv * 3. + fbm(vUv * 4. + fbm(vUv * 5.)))));\n        x += x - noise(vUv + u_time * 0.1);\n        vec2 q = vec2(0.);\n        q.x = fbm( vUv);\n        q.y = fbm( vUv);\n    \n        vec2 r = vec2(0.);\n        r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n        //x += x * sin(u_time * 0.15);\n        //color += x;\n        //color.x += sin(u_time * 0.05);\n        color = mix(color,\n                    vec3(0.2,0.4,0.64706),\n                    clamp(length(x),0.0,1.0));\n    \n        color = mix(color,\n                    vec3(0.166667,0.9,0.6),\n                    clamp(length(x),0.0,1.0));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.1;\n    float lacunarity = 2.0;\n    float prev = 1.0;\n    float offset = 0.9;\n    float gain = 0.5;\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        float n = ridge(snoise(st * frequency + (u_time * 0.25)), offset);\n        value += n * amplitude;\n        value += n * amplitude * prev;\n        prev = n;\n        frequency *= lacunarity;\n        //st.x += u_time * 0.25;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5.75;\n    vec3 color = vec3(0.);\n    float x = fbm(vUv * 1.0 + fbm(vUv * 5. + fbm(vUv * 10.)));\n    color += x;\n    vec2 q = vec2(0.);\n    q.x = fbm( vUv);\n    q.y = fbm( vUv);\n\n    vec2 r = vec2(0.);\n    r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n    r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n    //x += x * sin(u_time * 0.15);\n    //color += x;\n    //color.x += sin(u_time * 0.05);\n    // color = mix(color,\n    //             vec3(0.2,0.4,0.64706),\n    //             clamp(length(r),0.0,0.5));\n\n    // color = mix(color,\n    //             vec3(0.166667,0.5,0.7),\n    //             clamp(length(q),0.0,1.0));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.1;\n    float lacunarity = 2.0;\n    float prev = 1.0;\n    float offset = 0.9;\n    float gain = 0.5;\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        float n = ridge(snoise(st * frequency + (u_time * 0.25)), offset);\n        value += n * amplitude;\n        value += n * amplitude * prev;\n        prev = n;\n        frequency *= lacunarity;\n        //st.x += u_time * 0.25;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    // vUv = vUv * 1.75;\n    //vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n    float x = fbm(vUv * 1.0 + snoise(vUv + u_time * 0.01) - fbm(vUv * 5. - fbm(vUv * 10. + fbm(vUv ))));\n    color += 1. - x;\n    vec2 q = vec2(0.);\n    q.x = fbm( vUv);\n    q.y = fbm( vUv);\n\n    vec2 r = vec2(0.);\n    r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.0125*u_time );\n    r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.0126*u_time);\n    //x += x * sin(u_time * 0.15);\n    //color += x;\n    //color.x += sin(u_time * 0.05);\n    // color = mix(color,\n    //             vec3(0.2,0.4,0.64706),\n    //             clamp(length(r),0.0,0.5));\n\n    color = mix(color,\n                vec3(0.966667,0.,0.),\n                clamp(length(x),0.0,1.0));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Uz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _z=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.125;\n    float lacunarity = 2.;\n    float prev = 0.25;\n    float offset = 1.;\n    float gain = 0.5;\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        float n = ridge(snoise(st * frequency + (u_time * 0.125)), offset);\n        value += n * amplitude;\n        value += n * amplitude * prev;\n        prev = n;\n        frequency *= lacunarity;\n        //st.x += u_time * 0.25;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5.;\n    //vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n    float x = fbm(vUv * 1.0 + fbm(vUv * 1.1 + fbm(vUv * 1.2 + fbm(vUv * 1.3 ))));\n    color += x;\n    vec2 q = vec2(0.);\n    q.x = fbm( vUv);\n    q.y = fbm( vUv);\n\n    vec2 r = vec2(0.);\n    r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.125*u_time );\n    r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.0126*u_time);\n    //x += x * sin(u_time * 0.15);\n    //color += x;\n    //color.x += sin(u_time * 0.05);\n    // color = mix(color,\n    //             vec3(0.2,0.4,0.64706),\n    //             clamp(length(r),0.0,0.5));\n\n    color = mix(color,\n                vec3(0.066667,0.9,0.),\n                clamp(length(x),0.0,1.0));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_z,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Sz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f) ;\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 6\n    float fbm (in vec2 st) {\n        // Initial values\n        float value = 0.0;\n        float amplitude = .5;\n        float frequency = 0.1;\n        //\n        // Loop of octaves\n        for (int i = 0; i < OCTAVES; i++) {\n            value += amplitude * noise(st + (u_time * 0.5));\n            st *= 5.;\n            //st.x += u_time * 0.25;\n            amplitude *= .125;\n        }\n        return value;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 2.75;\n        vUv.x += u_time * 0.25;\n        vec3 color = vec3(0.);\n        float x = fbm(vUv * 1.0 + fbm(vUv * 2.0 + fbm(vUv * 3. + fbm(vUv * 4. + fbm(vUv * 5.)))));\n        x += x - noise(vUv + u_time * 0.1);\n        vec2 q = vec2(0.);\n        q.x = fbm( vUv);\n        q.y = fbm( vUv);\n    \n        vec2 r = vec2(0.);\n        r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n        //x += x * sin(u_time * 0.15);\n        //color += x;\n        //color.x += sin(u_time * 0.05);\n        color = mix(color,\n                    vec3(0.0,0.,0.54706),\n                    clamp(length(x - r),0.0,1.0));\n    \n        color = mix(color,\n                    vec3(0.96667,0.2,.0),\n                    clamp(length(x - q),0.0,1.0));\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Mz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Sz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .45;\n    vec2 shift = vec2(1.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a / noise(vUv - u_time * 0.2);\n        vUv = rot * PI * 0.25 * vUv * 3. + shift + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return 1. -  v / 4.;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 2.;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n    float f2 = fbm(vUv * 1.2 + fbm(vUv * 1.2 + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color *= mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f2*f2)*5.0,0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.,.8,0.94706),\n    //             clamp(length(q),0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.166667,.1,0.2),\n    //             clamp(length(r.x),0.0,.2));\n\n    float x = f + f2 + noise(vUv + u_time);\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Cz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h;      // sharpen creases\n    return h;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.1;\n    float lacunarity = 2.0;\n    float prev = 1.0;\n    float offset = 0.9;\n    float gain = 0.5;\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        float n = ridge(snoise(st * frequency + (u_time * 0.25)), offset);\n        value += n * amplitude;\n        value += n * amplitude * prev;\n        prev = n;\n        frequency *= lacunarity;\n        //st.x += u_time * 0.25;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.75;\n    vec3 color = vec3(0.);\n    float x = fbm(vUv * 1.0 + fbm(vUv * 5. + fbm(vUv * 10.)));\n    color += x;\n    vec2 q = vec2(0.);\n    q.x = fbm( vUv);\n    q.y = fbm( vUv);\n\n    vec2 r = vec2(0.);\n    r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n    r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n    //x += x * sin(u_time * 0.15);\n    //color += x;\n    //color.x += sin(u_time * 0.05);\n    color = mix(color,\n                vec3(0.1,0.9,0.64706),\n                clamp(length(r- x),0.0,0.5));\n\n    color = mix(color,\n                vec3(0.166667,0.5,0.7),\n                clamp(length(q - x),0.0,1.0));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Tz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Cz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Rz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 5\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h + h ;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .01 ;\n    float gain = 0.25 ;\n    float offset = .1;\n\n    float sum = .25;\n    float freq = 4.15; \n    float amp = 3.25;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        //p *= 1.5;\n        p.x += u_time * 0.2;\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev - snoise(p + u_time * 0.15);  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain * 0.01;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv * 1.0);\n    color = vec3(y);\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Dz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Rz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Pz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h * h * h * (abs(sin(u_time)) + 0.75);      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 112.0;\n    float gain = 0.0125;\n    float offset = 0.9;\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.5;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 2.0;\n        float n = ridge(snoise(p*freq), offset * snoise(p - u_time * 0.5));\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    color.g += y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Fz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Pz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h * h * h * h * (abs(sin(u_time)) + 0.75);      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .25 + snoise(p + u_time)* 0.015;\n    float gain = 1.25;\n    float offset = 0.6;\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.025;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 2.0;\n        float n = ridge(snoise(p*freq), offset * snoise(p - u_time * 0.5));\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    color.br += y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Iz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ez=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset + h; // invert so creases are at top\n    h = h * h * h * h * h * h + snoise(vUv + u_time) * 0.1;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .25 + snoise(1. - p + u_time)* 0.0115;\n    float gain = 1.25;\n    float offset = 0.96;\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.0025;\n    float prev = 12.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 2.05;\n        float n = ridge(snoise(p*freq), offset * snoise(p - u_time) * 1.25);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    //color.br += y;\n    color.b += y;\n    color.bg += y * abs(sin(u_time));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Oz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Ez,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Az=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset + h; // invert so creases are at top\n    h = h * h * h * h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = .25;\n    float gain = 1.25;\n    float offset = 0.01 + snoise(vUv + u_time * 0.25);\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.0025;\n    float prev = 12.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 4.0;\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    //vUv.x += u_time * 0.25;\n    float y = ridgedMF(vUv);\n    //color.br += y;\n    color.rb += y;\n    color.bg += y * abs(sin(u_time));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Lz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Az,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Gz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 1.25;\n    float gain = 0.5;\n    float offset = 0.9 + snoise(vUv + u_time * 0.25);\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.25;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 2.0;\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv.x += u_time * 0.05;\n    float y = ridgedMF(vUv);\n    //color.br += y;\n    color.rb += y;\n    color.bg += y * abs(sin(u_time));\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Nz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Gz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Bz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 5\n    \n    float fbm(vec2 vUv){\n        float v = 0.;\n        float a = 0.65;\n        vec2 shift = vec2(100.);\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.5));\n        for (int i = 0; i < OCTAVES; ++i)\n        {\n             v += a * noise(vUv + (u_time * 0.25));\n             vUv = rot * vUv * 2.25 + shift;\n             a *= 0.5;\n        }\n        return v;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n    \n        vUv = vUv * 2.0;\n    \n        vec2 q = vec2(0.);\n        q.x = fbm( vUv + 0.05*u_time);\n        q.y = fbm( vUv + vec2(1.0));\n    \n        vec2 r = vec2(0.);\n        r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n    \n        float f = fbm(vUv + fbm(vUv + fbm(vUv + fbm(vUv + fbm(vUv + fbm(vUv))))));\n        color = vec3(f * f * f * f);\n    \n        // color = mix(vec3(0.101961,0.619608,0.666667),\n        //             vec3(0.666667,0.666667,0.498039),\n        //             clamp((f*f)*4.0,0.0,1.0));\n    \n        // color = mix(color,\n        //             vec3(0,0,0.164706),\n        //             clamp(length(q),0.0,1.0));\n    \n        // color = mix(color,\n        //             vec3(0.666667,1,1),\n        //             clamp(length(r.x),0.0,1.0));\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Bz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Vz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 5\n    \n    float fbm(vec2 vUv){\n        float v = 0.;\n        float a = 0.65;\n        vec2 shift = vec2(100.);\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.5));\n        for (int i = 0; i < OCTAVES; ++i)\n        {\n             v += a * noise(vUv + (u_time * 0.25));\n             vUv = rot * vUv * 2.25 + shift;\n             a *= 0.53;\n        }\n        return v;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n    \n        vUv = vUv * 2.0;\n    \n        float f = fbm(vUv + fbm(vUv / fbm(vUv)));\n        color = vec3(f * f * f * f);\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Wz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Vz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Hz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 5\n    \n    float fbm(vec2 vUv){\n        float v = 0.;\n        float a = 0.65;\n        vec2 shift = vec2(100.);\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.5));\n        for (int i = 0; i < OCTAVES; ++i)\n        {\n             v += a * noise(vUv + (u_time * 0.25));\n             vUv = rot * vUv * 2.25 + shift;\n             a *= 0.83;\n        }\n        return v;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n    \n        vUv = vUv * 0.5;\n    \n        float f = fbm(vUv / u_time + fbm(vUv * fbm(vUv)));\n        color = 1. - vec3(f * f * f * f);\n    \n        // vec2 q = vec2(0.);\n        // q.x = fbm( vUv + 0.05*u_time);\n        // q.y = fbm( vUv + vec2(1.0));\n    \n        // vec2 r = vec2(0.);\n        // r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        // r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n    \n        // color = mix(vec3(0.101961,0.619608,0.666667),\n        //             vec3(0.666667,0.666667,0.498039),\n        //             clamp((f-f)*.0,0.,1.0));\n    \n        // color = mix(color,\n        //             vec3(0,0,0.164706),\n        //             clamp(length(q),0.0,1.0));\n    \n        // color = mix(color,\n        //             vec3(0.666667,1,1),\n        //             clamp(length(r.x),0.0,1.0));\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Xz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Hz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Yz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 5\n    \n    float fbm(vec2 vUv){\n        float v = 0.;\n        float a = 0.25;\n        vec2 shift = vec2(1.);\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.5));\n        for (int i = 0; i < OCTAVES; ++i)\n        {\n             v += a / noise(vUv + (u_time * 0.25));\n             vUv = rot * vUv * 1. + shift;\n             a *= 0.65;\n        }\n        return v;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n    \n        vUv = vUv * 5.25;\n        vUv.x += u_time * 0.25;\n        float f = fbm(vUv + u_time + fbm(vUv / fbm(vUv)));\n        color = vec3(f / f / f / f);\n    \n        // vec2 q = vec2(0.);\n        // q.x = fbm( vUv + 0.05*u_time);\n        // q.y = fbm( vUv + vec2(1.0));\n    \n        // vec2 r = vec2(0.);\n        // r.x = fbm( vUv + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        // r.y = fbm( vUv + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n    \n        // color = mix(vec3(0.101961,0.619608,0.666667),\n        //             vec3(0.666667,0.666667,0.498039),\n        //             clamp((f-f)*.0,0.,1.0));\n    \n        // color = mix(color,\n        //             vec3(0,0,0.164706),\n        //             clamp(length(q),0.0,1.0));\n    \n        // color = mix(color,\n        //             vec3(0.666667,1,1),\n        //             clamp(length(r.x),0.0,1.0));\n    \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Zz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Yz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = .45;\n    vec2 shift = vec2(1.);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a / noise(vUv - u_time * 0.2);\n        vUv = rot * PI * 0.25 * vUv * 3. + shift + (u_time * 0.5);\n        a *= .95 * noise(vUv);\n    }\n    return 1. -  v / 4.;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 2.;\n    vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv)));\n    float f2 = fbm(vUv * 1.2 + fbm(vUv * 1.2 + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color *= mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f2*f2)*5.0,0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.,.8,0.94706),\n    //             clamp(length(q),0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.166667,.1,0.2),\n    //             clamp(length(r.x),0.0,.2));\n\n    float x = f + f2 + noise(vUv + u_time);\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Jz(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Qz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Kz=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //book of shaders example\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float a = 1.55;\n    vec2 shift = vec2(0.1);\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.5));\n    for(int i = 0; i < NUM_OCTAVES; i++){\n        v += a ;\n        vUv = rot * PI * 0.15 * vUv * 4. + (u_time * 0.25);\n        a *= .95 * noise(vUv + u_time);\n    }\n    return 1. -  v / 4.;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv *= 2.;\n    //vUv.x += u_time * 0.1;\n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm(vUv);\n    q.y = fbm(vUv + vec2(1.));\n\n    vec2 r = vec2(0.);\n    r.x = fbm(vUv + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);\n    r.y = fbm(vUv + 1.0 * q + vec2(8.3, 2.8) + 0.16 * u_time);\n\n    float f = fbm(vUv + fbm(vUv + fbm(vUv * fbm(vUv))));\n    float f2 = fbm(vUv * 1.2 + fbm(vUv * 1.2 + fbm(vUv)));\n\n    //f(p) = fbm( p + fbm( p + fbm( p ) ) )\n    color = mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f*f)*5.0,0.0,1.0));\n\n    color *= mix(vec3(0.901961,0.619608,0.666667),\n                vec3(0.966667,0.666667,0.098039),\n                clamp((f2*f2)*5.0,0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.,.8,0.94706),\n    //             clamp(length(q),0.0,1.0));\n\n    // color = mix(color,\n    //             vec3(0.166667,.1,0.2),\n    //             clamp(length(r.x),0.0,.2));\n\n    float x = f + f2 + noise(vUv + u_time);\n\n   gl_FragColor = vec4(color * x,1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $z(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Kz,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+'\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\n// Ridged multifractal\n// See "Texturing & Modeling, A Procedural Approach", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h * h  * (abs(sin(u_time)) + 0.95);      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 152.0;\n    float gain = 0.0125;\n    float offset = 0.9;\n\n    float sum = 0.0;\n    float freq = 1.0;\n    float amp = 0.5;\n    float prev = 1.0;\n    for(int i=0; i < OCTAVES; i++) {\n        p *= 2.0;\n        float n = ridge(snoise(p*freq), offset * snoise(p - u_time * 0.25));\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float y = ridgedMF(vUv);\n    color.g += y + y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ',uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function eC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n    \n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n    \n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n    \n        vec2 u = f * f * (3.0 - 2.0 * f);\n    \n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n    #define OCTAVES 6\n    \n    float fbm(vec2 vUv){\n        float v = 0.;\n        float amp = 0.5;\n        float freq = 0.1;\n    \n        for( int i = 0; i < OCTAVES; i++){\n            v += amp * noise(vUv + u_time * 0.25);\n            vUv *= 2.;\n            amp *= .5;\n        }\n        return v;\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv.x += u_time * 0.1;\n        float y = fbm(vUv * 5. * fbm(vUv * 5. * fbm(vUv * 5.)));\n        color.x = 1. - y;\n        \n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function oC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.5;\n    float freq = 0.1;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.15)));\n        vUv *= 2.;\n        amp *= .5;\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 0.125;\n    vUv.x += u_time * 0.01;\n    float y = fbm(vUv * 10.) + fbm (vUv * 20.) + fbm(vUv * 10.);\n    color.b = 1. - y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function aC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.35;\n    float freq = 0.8;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        amp *= .35 + snoise(vUv + u_time * 0.1);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.;\n    vUv.x += u_time * 0.1;\n    float y = fbm(vUv + fbm(vUv));\n    color += y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:iC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.35;\n    float freq = 0.8;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        amp *= .35 + snoise(vUv + u_time * 0.1);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .5;\n    vUv.x += u_time * 0.05;\n    float y = fbm(vUv + fbm(vUv));\n    color.r += y + y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.35;\n    float freq = 0.8;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        amp *= .35 + snoise(vUv + u_time * 0.01);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .5;\n    vUv.x += u_time * 0.025;\n    float y = fbm(vUv + fbm(vUv) + snoise(vUv * (u_time * 0.015)));\n    color.br += y * y;\n    color.gr += y * y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.5;\n    float freq = 1.45;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        v *= freq;\n        amp *= .35 + snoise(vUv + u_time * 0.01);\n        \n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .5;\n    vUv.x += u_time * 0.025;\n    float y = fbm(vUv + fbm(vUv) + snoise(vUv * (u_time * 0.015)));\n    color.br += y * y;\n    color.gr += y * y * y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.5;\n    float freq = 1.45;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        v /= freq;\n        amp *= .35 + snoise(vUv + u_time * 0.01);\n        \n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.;\n    vUv.x += u_time * 0.025;\n    float y = fbm(vUv + fbm(vUv) + snoise(vUv + (u_time * 0.015)) + fbm(vUv + fbm(vUv)));\n    color.br *= y * y ;\n    color.gr *= y * y * y;\n    color += y + fbm(vUv + fbm(vUv));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.5;\n    float freq = 1.45;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        v /= freq;\n        amp *= .85 + snoise(vUv + u_time * 0.1);\n        \n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .125;\n    vUv.x += u_time * 0.00125 + 5.;\n    float y = fbm(vUv + fbm(vUv));\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += 1. - y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = .25;\n    float freq = .45;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 1.5;\n        v *= freq;\n        amp *= 1. + snoise(vUv + u_time * 0.1);\n        \n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .125;\n    vUv.x += u_time * 0.00125 + 5.;\n    float y = fbm(vUv - fbm(vUv));\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += 1. - y;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 2.0;\n    float gain = 0.15;\n    float offset = 0.9;\n    float amp = 0.5;\n    float sum = 0.0;\n    float freq = 1.0; \n    float prev = 1.0;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq), offset * sin(snoise(vUv + u_time * 0.25)));\n        sum += v *amp;\n        sum += v * amp * prev;\n        prev = v;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    \n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv*3.0);\n    float x = fbm(vUv*6.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += y;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _C=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 2.0;\n    float gain = 0.25;\n    float offset = 0.9;\n    float amp = 0.5;\n    float sum = 0.0;\n    float freq = 1.0; \n    float prev = 1.0;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq + (u_time * 0.025)), offset * sin(snoise(vUv + (u_time * 0.025))));\n        sum += v *amp;\n        sum += v * amp * prev;\n        prev = v;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    \n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv*3.0 * fbm(vUv));\n    float x = fbm(vUv*6.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += y;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_C,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var SC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 2.0;\n    float gain = 0.125;\n    float offset = 0.19;\n    float amp = 0.125;\n    float sum = 0.;\n    float freq = .75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq + (u_time * 0.125)), offset);\n        sum += v *amp;\n        sum += v * amp * prev ;\n        prev = v;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    \n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv*.5);\n    float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += y / x;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function MC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:SC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 2.0;\n    float gain = 0.125;\n    float offset = 0.99;\n    float amp = 10.125;\n    float sum = 0.;\n    float freq = .75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq + (u_time * 0.125)), offset );\n        sum += v *amp;\n        sum += v * amp * prev ;\n        prev = v;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    \n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv*4.0);\n    float x = fbm(vUv*3.5);\n    //color = vec3(y);\n    color.br += y ;\n    color.gr /= x;\n    //color.gr += y * y * y;\n    //color += y / x;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var CC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 2.0;\n    float gain = 0.125;\n    float offset = 0.19;\n    float amp = 0.125;\n    float sum = 0.;\n    float freq = .75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq * (snoise(vUv + (u_time * 0.125))) ), offset);\n        sum += v *amp ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 0.75;\n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv*0.05);\n    float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color +=1. -  x / y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function TC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:CC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var RC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 1.1;\n    float gain = 0.5;\n    float offset = 1.19;\n    float amp = 0.125;\n    float sum = 0.;\n    float freq = 1.75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq ), offset * (snoise(vUv + (u_time * 0.125))) );\n        sum += v *amp ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 2.75;\n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv);\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function DC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:RC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var PC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 1.1;\n    float gain = 0.95125;\n    float offset = 1.95;\n    float amp = .50;\n    float sum = 0.;\n    float freq = 1.75; \n    float prev = .25;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq ), offset * (snoise(vUv + (u_time * 0.125))) );\n        sum += v *amp ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.75;\n    //vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv);\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function FC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:PC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat fbm(vec2 vUv){\n    float v = 0.;\n    float amp = 0.35;\n    float freq = 0.8;\n\n    for( int i = 0; i < OCTAVES; i++){\n        //v += amp * snoise(vUv + u_time * 0.25);\n        v += amp * abs(snoise(vUv + (u_time * 0.015)));\n        vUv *= 2.;\n        amp *= .35 + snoise(vUv + u_time * 0.01);\n    }\n    return v;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.;\n    vUv.x += u_time * 0.025;\n    float y = fbm(vUv + fbm(vUv + snoise(vUv + (u_time * 0.05))) + snoise(vUv + (u_time * 0.015)));\n    color.br -= y * y * y;\n    color.gr += y * y * y;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function IC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 1.9;\n    float gain = 0.5;\n    float offset = 1.19;\n    float amp = 0.125;\n    float sum = 0.;\n    float freq = 1.75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq ), offset * (snoise(vUv + (u_time * 0.125))) );\n        sum += v *amp ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.75;\n    vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv - fbm(vUv));\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color.gr += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function OC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:EC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 12.9;\n    float gain = 0.25;\n    float offset = .19;\n    float amp = .5;\n    float sum = 0.;\n    float freq = 1.75; \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq ), offset * (snoise(vUv + (u_time * 0.125))) );\n        sum += v *amp ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= .95;\n    vUv.x += u_time * 0.125 + 5.;\n    float y = fbm(vUv + fbm(vUv));\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    //color.br *= y * y ;\n    //color.gr *= y * y * y;\n    color.g += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:AC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = 5.9;\n    float gain = 0.25 ;\n    float offset = .19 ;\n    float amp = .5 ;\n    float sum = 0. ;\n    float freq = 1.35 * (snoise(vUv + (u_time * 0.1))); \n    float prev = .5;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq ), offset * (snoise(vUv + (u_time * 0.125))) );\n        sum += v *amp  ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 1.25;\n    vUv.x += 5.;\n    float y = fbm(vUv) * fbm(vUv) ;\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    color.br += y  ;\n    color.gr += y * y;\n    //color.g += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function NC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:GC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var BC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    // Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 6\n\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    h = h * h + h * h + h ;      // sharpen creases\n    return h;\n}\n\nfloat fbm(vec2 vUv){\n    float lacunarity = .9;\n    float gain = 0.05 ;\n    float offset = .39 ;\n    float amp = .75 ;\n    float sum = 0. ;\n    float freq = 1.5 * (snoise(vUv + (u_time * 0.1))); \n    float prev = .25;\n    for( int i = 0; i < OCTAVES; i++){\n        float v = ridge(snoise(vUv * freq), offset * (snoise(vUv + (u_time * 0.005))) );\n        sum += v *amp  ;\n        sum += v * amp * prev  ;\n        prev = v ;\n        freq *= lacunarity ;\n        amp *= gain ;\n    }\n    return sum ;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv *= 2.;\n    vUv.x += 5.;\n    float y = fbm(vUv) * fbm(vUv) + fbm(vUv) * 0.75 ;\n    //float x = fbm(vUv*4.0);\n    //color = vec3(y);\n    color.r += y * y * y * y ;\n    color.b += y + y;\n    //color.g += y ;\n    //color /= x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:BC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var VC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float plot(vec2 st){\n        return smoothstep(0.5, 0.0, abs(st.y - st.x));\n    }\n    \n    // vec2 Rot(vec2 vUv,float a){\n    //     //vUv*=2.;\n    //     vUv-=.5;\n    //     vUv=mat2(cos(a),-sin(a),\n    //     sin(a),cos(a))*vUv;\n    //     vUv+=.5;\n    //     return vUv;\n    // }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv *= 4. - 3.;\n        vec2 vUv1 = vUv;\n        vec2 vUv2 = vUv;\n        vec2 vUv3 = vUv;\n        vUv3 = Rot(vUv, -(u_time * 4.5));\n        vUv2 = Rot(vUv, -(u_time * 3.0));\n        vUv1 = Rot(vUv, -(u_time * 2.5));\n        vec3 color = vec3(0.);\n        float y = vUv.x;\n        float x = 1. -  vUv.x;\n        float pct = plot(vUv1);\n        float pct2 = plot(vUv2);\n        float pct3 = plot(vUv3);\n        color = vec3(y * x);\n        color += vec3(pct) * vec3(1.0, .0, .0);\n        color += vec3(pct2) * vec3(.0, 1.0, .0);\n        color += vec3(pct3) * vec3(.0, .0, 1.0);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function WC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:VC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var HC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float plot(vec2 st, float pct){\n        return smoothstep(pct-0.1, pct, st.y) -\n               smoothstep(pct, pct+0.1, st.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vUv = vUv * 5. - 2.;\n        //vUv.y += 1.5;\n        \n        vec3 color = vec3(0.);\n        \n        //power function\n        //returns the value of x raised to the power of y\n        float y1 = pow(vUv.x, 5.0);\n        float pct1 = plot(vUv, y1);\n    \n        //exponentiation function\n        //returns the natural exponentiation of x\n        float y2 = exp(vUv.x);\n        float pct2 = plot(vUv, y2);\n    \n        //logarithm function\n        //returns the natural logarithm of x\n        float y3 = log(vUv.x);\n        float pct3 = plot(vUv, y3);\n    \n        //square root function\n        //returns the square root of x\n        float y4 = sqrt(vUv.x);\n        float pct4 = plot(vUv, y4);\n    \n        color += pct1*vec3(0.0,1.0,0.0);\n        color += pct2*vec3(1.0,0.0,0.0);\n        color += pct3*vec3(0.0,0.0,1.0);\n        color += pct4*vec3(1.0,1.0,.0);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function XC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:HC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var YC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    float plot(vec2 st, float pct){\n        return smoothstep(pct-0.35, pct, st.y) -\n               smoothstep(pct, pct+0.35, st.y);\n    }\n    \n    void main(){\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        //rainbow\n        //red\n        float y1 = sqrt(vUv.x);\n        float pct1 = plot(vec2(vUv.x, vUv.y - 0.45 * sin(u_time)), y1);\n    \n        //orange\n        float y2 = sqrt(vUv.x);\n        float pct2 = plot(vec2(vUv.x, vUv.y - 0.30 * sin(u_time)), y2);\n    \n        //yellow\n        float y3 = sqrt(vUv.x);\n        float pct3 = plot(vec2(vUv.x, vUv.y - 0.25 * sin(u_time)), y3);\n    \n        //green\n        float y4 = sqrt(vUv.x);\n        float pct4 = plot(vec2(vUv.x, vUv.y - 0.10 * sin(u_time)), y4);\n    \n        //blue\n        float y5 = sqrt(vUv.x);\n        float pct5 = plot(vec2(vUv.x, vUv.y + 0.25 * sin(u_time)), y5);\n    \n        //indigo\n        float y6 = sqrt(vUv.x);\n        float pct6 = plot(vec2(vUv.x, vUv.y + 0.35 * sin(u_time)), y6);\n    \n        //violet\n        float y7 = sqrt(vUv.x);\n        float pct7 = plot(vec2(vUv.x, vUv.y + 0.55 * sin(u_time)), y7);\n    \n    \n        color += pct1*vec3(1.0,0.0,0.0);\n        color += pct2*vec3(1.0,0.6,0.0);\n        color += pct3*vec3(1.0,1.0,0.0);\n        color += pct4*vec3(0.0,0.5,0.0);\n        color += pct5*vec3(0.0,0.0,1.0);\n        color += pct6*vec3(0.29,0.0,0.5);\n        color += pct7*vec3(0.9,0.5,0.9);\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ZC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:YC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 4. - 2.;\n    vec3 color = vec3(0.);\n\n    float y6 = log(vUv.x - 4. + sin(u_time));\n    float pct6 = plot(vec2(vUv.x, vUv.y), y6);\n    color += pct6;\n\n    float y5 = log(vUv.x - 2. + sin(u_time));\n    float pct5 = plot(vec2(vUv.x, vUv.y), y5);\n    color += pct5;\n\n    float y1 = log(vUv.x + sin(u_time));\n    float pct1 = plot(vUv, y1);\n    color += pct1;\n\n    float y2 = log(vUv.x + 2. + sin(u_time));\n    float pct2 = plot(vec2(vUv.x, vUv.y), y2);\n    color += pct2;\n\n    float y3 = log(vUv.x + 4. + sin(u_time));\n    float pct3 = plot(vec2(vUv.x, vUv.y), y3);\n    color += pct3;\n\n    float y4 = log(vUv.x + 6. + sin(u_time));\n    float pct4 = plot(vec2(vUv.x, vUv.y), y4);\n    color += pct4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function JC(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:QC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KC=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    //step function\n    float y1 = 1. - step(0.142 * 1., vUv.x);\n    float y2 = 1. - step(0.142 * 2., vUv.x);\n    //float y2 = step(0.142 * 5.,1. - vUv.x);\n    float y3 = 1. - step(0.142 * 3., vUv.x);\n    float y4 = 1. - step(0.142 * 4., vUv.x);\n    float y5 = 1. - step(0.142 * 5., vUv.x);\n    float y6 = 1. - step(0.142 * 6., vUv.x);\n    float y7 = 1. - step(0.144 * 7., vUv.x);\n    \n    color.r += y1 + sin(u_time - 0.5);\n    color.g += y2 - sin(u_time + 1.0);\n    color.b += y3 + sin(u_time - 1.5);\n    color.r += y4 - sin(u_time + 2.0);\n    color.g += y5 + sin(u_time - 2.5);\n    color.b += y6 - sin(u_time + 3.0);\n    color.r += y7 + sin(u_time - 3.5);\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $C(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:KC,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 6. - 3.;\n    vec3 color = vec3(0.);\n    //smoothstep line\n    float y1 = (sin(vUv.x + u_time * PI) + 2.0) * sin(u_time * 1.2);\n    float y2 = (sin(vUv.x + u_time * PI) + 1.0) * sin(u_time * 0.9);\n    float y3 = (sin(vUv.x + u_time * PI) - 1.0) * sin(u_time * 0.5);\n    float y4 = (sin(vUv.x + u_time * PI) - 2.0) * sin(u_time * 1.5);\n    float y5 = (sin(vUv.x + u_time * PI) + 0.0) * sin(u_time * 1.0);\n    //y += floor(y);\n    // float y = smoothstep(0.2, 0.5, vUv.x) - smoothstep(0.5, 0.8, vUv.x);\n    float pct1 = plot(vUv, y1);\n    float pct2 = plot(vUv, y2);\n    float pct3 = plot(vUv, y3);\n    float pct4 = plot(vUv, y4);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 + pct2 + pct3 + pct4 + pct5;\n    color -= smoothstep(0., 0.1, vUv.x);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function eT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 6. - 3.;\n    vec3 color = vec3(0.);\n    \n    float y1 = fract(sin(vUv.x + u_time * 0.25 * PI) + 2.0) * sin(u_time * 1.2);\n    float y2 = fract(sin(vUv.x + u_time * 0.25 * PI) + 1.0) * sin(u_time * 0.9);\n    float y3 = fract(sin(vUv.x + u_time * 0.25 * PI) - 1.0) * sin(u_time * 0.5);\n    float y4 = fract(sin(vUv.x + u_time * 0.25 * PI) - 2.0) * sin(u_time * 1.5);\n    float y5 = fract(sin(vUv.x + u_time * 0.25 * PI) + 0.0) * sin(u_time * 1.0);\n    //y += floor(y);\n    // float y = smoothstep(0.2, 0.5, vUv.x) - smoothstep(0.5, 0.8, vUv.x);\n    float pct1 = plot(vUv, y1);\n    float pct2 = plot(vUv, y2);\n    float pct3 = plot(vUv, y3);\n    float pct4 = plot(vUv, y4);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 + pct2 + pct3 + pct4 + pct5;\n   \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function oT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.01, pct, st.y) -\n           smoothstep(pct, pct+0.01, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n//m is threshold (value above m stays unchanged)\n//n is the value given when signal is zero\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    \n    float y = almostIdentity(vUv.x, 0.5, 0.2);\n    float pct = plot(vUv, y);\n\n    color = vec3(y);\n    color = (1.0 - pct) * color + pct * vec3(0., 1., 0.);\n   \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function aT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vUv.y += 1.0;\n    vec3 color = vec3(0.);\n    \n    float y = almostIdentity(vUv.x, 0.5, 0.2);\n    float y2 = almostIdentity2(vUv.x, 0. + cos(u_time));\n    float y3 = almostIdentity2(vUv.x, 0.3 + sin(u_time));\n    float y4 = almostIdentity2(vUv.x, 0.6 + cos(u_time));\n    float y5 = almostIdentity2(vUv.x, 0.9 + sin(u_time));\n    float y6 = almostIdentity2(vUv.x, 1.2 + cos(u_time));\n    float y7 = almostIdentity2(vUv.x, 1.5 + sin(u_time));\n    float pct2 = plot(vUv, y2);\n    float pct3 = plot(vUv, y3);\n    float pct4 = plot(vUv, y4);\n    float pct5 = plot(vUv, y5);\n    float pct6 = plot(vUv, y6);\n    float pct7 = plot(vUv, y7);\n\n    //color = vec3(y2);\n    color = pct2 * vec3(0., 1., 0.);\n    color += pct3 * vec3(0., 1., 0.);\n    color += pct4 * vec3(0., 1., 0.);\n    color += pct5 * vec3(0., 1., 0.);\n    color += pct6 * vec3(0., 1., 0.);\n    color += pct7 * vec3(0., 1., 0.);\n   \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:iT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.025, pct, st.y) -\n           smoothstep(pct, pct+0.025, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    float y = almostUnitIdentity(vUv.x + cos(u_time));\n    float y2 = almostUnitIdentity(1. - vUv.x + sin(u_time));\n    float pct = plot(vUv, y);\n    float pct2 = plot(vUv, y2);\n    color += pct * vec3(0., 1., 0.);\n    color += pct2 * vec3(0., 1., 0.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.025, pct, st.y) -\n           smoothstep(pct, pct+0.025, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    float y = integralSmoothstep(vUv.x, 1.0 + sin(u_time));\n    float pct = plot(vUv, y);\n    color += pct * vec3(0., 1., 0.);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 4.;\n    vec3 color = vec3(0.);\n    float y1 = expImpulse(vUv.x, 0.);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = expImpulse(vUv.x, 0.5 + abs(sin(u_time * 0.25)));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = expImpulse(vUv.x, 1.0);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = expImpulse(vUv.x, 1.5);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = expImpulse(vUv.x, 2.0);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.05, pct, st.y) -\n           smoothstep(pct, pct+0.05, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 2.0 * sqrt(k) * x/(.25 + k * x * x);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 4.;\n    vec3 color = vec3(0.);\n    float y1 = quaImpulse(vUv.x, 0.);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = quaImpulse(vUv.x, 0.5 + abs(sin(u_time * 0.5)));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = quaImpulse(vUv.x, 1.0);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = quaImpulse(vUv.x, 1.5);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = quaImpulse(vUv.x, 2.0);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.025, pct, st.y) -\n           smoothstep(pct, pct+0.025, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.;\n    vec3 color = vec3(0.);\n    float y1 = polyImpulse(vUv.x, 0.0, 4.);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = polyImpulse(vUv.x, 0.5, 4. + sin(u_time));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = polyImpulse(vUv.x, 1.0, 4. + cos(u_time));\n    float pct3 = plot(vUv, y3);\n\n    float y4 = polyImpulse(vUv.x, 1.5, 4.);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = polyImpulse(vUv.x, 2.0, 4.);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.025, pct, st.y) -\n           smoothstep(pct, pct+0.025, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv *3.;\n    vec3 color = vec3(0.);\n    float y1 = expSustainedImpulse(vUv.x, 2.0, 0.25);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = expSustainedImpulse(vUv.x, 1.25 + abs(sin(u_time * 0.25)), 0.25 + abs(cos(u_time * 0.25)));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = expSustainedImpulse(vUv.x, 1.5 + abs(sin(u_time * 0.25)), 0.5 );\n    float pct3 = plot(vUv, y3);\n\n    float y4 = expSustainedImpulse(vUv.x, 1.75, 0.25 + abs(sin(u_time * 0.25)));\n    float pct4 = plot(vUv, y4);\n\n    float y5 = expSustainedImpulse(vUv.x, 2.0, 0.5);\n    float pct5 = plot(vUv, y5);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.025, pct, st.y) -\n           smoothstep(pct, pct+0.025, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv *3.;\n    vUv.x -= 1.15;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = cubicPulse(0.35, 2.00, vUv.x);\n    float pct1 = plot(vUv, y1);\n\n    \n\n    float y2 = cubicPulse(0.35, 1.25, vUv.x);\n    float pct2 = plot(vUv, y2);\n\n    float y3 = cubicPulse(0.35, 1.5, vUv.x);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = cubicPulse(0.35, 1.75, vUv.x);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = cubicPulse(0.35, 1.00, vUv.x);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _T=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\n//9. Exponential step\n//natural attenuation - exponential of a linearly decaying quantity\n//a gaussian - exponential of a quadratically decaying quantity\nfloat expStep(float x, float k, float n)\n{\n    return exp(-k * pow(x, n));\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 1.5;\n    vUv.y -= 0.25;\n    //vUv.x -= 1.15;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = expStep(vUv.x, 1.0, 1.0);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = expStep(vUv.x, 1.5, 2.0);\n    float pct2 = plot(vUv, y2);\n\n    float y3 = expStep(vUv.x, 2.0, 3.0 + sin(u_time));\n    float pct3 = plot(vUv, y3);\n\n    float y4 = expStep(vUv.x, 2.0, 4.0);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = expStep(vUv.x, 3.0, 5.0);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.);\n    color += pct2 * vec3(0., 1., 1.);\n    color += pct3 * vec3(0.5, 1., .5);\n    color += pct4 * vec3(1., 0., 0.);\n    color += pct5 * vec3(0.5, .0, 1.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_T,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ST=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\n//9. Exponential step\n//natural attenuation - exponential of a linearly decaying quantity\n//a gaussian - exponential of a quadratically decaying quantity\nfloat expStep(float x, float k, float n)\n{\n    return exp(-k * pow(x, n));\n}\n\n//10. Gain\n//remapping the unit interval by expanding the sides and compressing the center\n//k =1 - identity curve\n//k < 1 - classic gain\n//k > 1 - s curves\nfloat gain(float x, float k)\n{\n    if(x < 0.5)\n    {\n        float a = 0.5 * pow((2.0 * x), k);\n        return a;\n    }\n    else \n    {\n       float a = 0.5 * pow((2.0 * (1.0 - x)), k);\n       return 1.0 - a;\n    }\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 1.5;\n    //vUv.y -= 0.25;\n    //vUv.x -= 1.15;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = gain(vUv.x, 1.0);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = gain(vUv.x, 2.25 + sin(u_time * 0.5));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = gain(vUv.x, 0.5);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = gain(vUv.x, 5.5);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = gain(vUv.x, 0.25);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.); //yellow\n    color += pct2 * vec3(0., 1., 1.); //teal\n    color += pct3 * vec3(0.5, 1., .5); //green\n    color += pct4 * vec3(1., 0., 0.); //red\n    color += pct5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function MT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:ST,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\n//9. Exponential step\n//natural attenuation - exponential of a linearly decaying quantity\n//a gaussian - exponential of a quadratically decaying quantity\nfloat expStep(float x, float k, float n)\n{\n    return exp(-k * pow(x, n));\n}\n\n//10. Gain\n//remapping the unit interval by expanding the sides and compressing the center\n//k =1 - identity curve\n//k < 1 - classic gain\n//k > 1 - s curves\nfloat gain(float x, float k)\n{\n    if(x < 0.5)\n    {\n        float a = 0.5 * pow((2.0 * x), k);\n        return a;\n    }\n    else \n    {\n       float a = 0.5 * pow((2.0 * (1.0 - x)), k);\n       return 1.0 - a;\n    }\n}\n\n//11. Parabola\n//remap the 0 to 1 interval into 0 to 1 where the corners are mapped to 0 and the center is mapped to 1\nfloat parabola(float x, float k)\n{\n    return pow(4.0*x*(1.0 - x), k);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 1.5;\n    //vUv.y -= 0.25;\n    //vUv.x -= 1.15;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = parabola(vUv.x, 1.0);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = parabola(vUv.x, 2.25 + sin(u_time));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = parabola(vUv.x, 0.75);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = parabola(vUv.x, 1.75);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = parabola(vUv.x, 1.25);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.); //yellow\n    color += pct2 * vec3(0., 1., 1.); //teal\n    color += pct3 * vec3(0.5, 1., .5); //green\n    color += pct4 * vec3(1., 0., 0.); //red\n    color += pct5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var CT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\n//9. Exponential step\n//natural attenuation - exponential of a linearly decaying quantity\n//a gaussian - exponential of a quadratically decaying quantity\nfloat expStep(float x, float k, float n)\n{\n    return exp(-k * pow(x, n));\n}\n\n//10. Gain\n//remapping the unit interval by expanding the sides and compressing the center\n//k =1 - identity curve\n//k < 1 - classic gain\n//k > 1 - s curves\nfloat gain(float x, float k)\n{\n    if(x < 0.5)\n    {\n        float a = 0.5 * pow((2.0 * x), k);\n        return a;\n    }\n    else \n    {\n       float a = 0.5 * pow((2.0 * (1.0 - x)), k);\n       return 1.0 - a;\n    }\n}\n\n//11. Parabola\n//remap the 0 to 1 interval into 0 to 1 where the corners are mapped to 0 and the center is mapped to 1\nfloat parabola(float x, float k)\n{\n    return pow(4.0*x*(1.0 - x), k);\n}\n\n//12. Power Curve\n//generalized parabola that can be control the shape on either side of the curve\n//useful for creating curved shaped\nfloat pcurve(float x, float a, float b)\n{\n    float k = pow(a + b, a + b)/(pow(a, a) * pow(b, b));\n    return k * pow(x, a)*pow(1. - x, b);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 1.5;\n    //vUv.y -= 0.25;\n    //vUv.x -= 1.15;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = pcurve(vUv.x, 0.65, 1.5);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = pcurve(vUv.x, 2.0, 2.25 + sin(u_time));\n    float pct2 = plot(vUv, y2);\n\n    float y3 = pcurve(vUv.x, 2.5, 1.75);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = pcurve(vUv.x, 2.75, 1.75 + cos(u_time));\n    float pct4 = plot(vUv, y4);\n\n    float y5 = pcurve(vUv.x, 3.0, 1.25);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.); //yellow\n    color += pct2 * vec3(0., 1., 1.); //teal\n    color += pct3 * vec3(0.5, 1., .5); //green\n    color += pct4 * vec3(1., 0., 0.); //red\n    color += pct5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function TT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:CT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var RT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n//https://iquilezles.org/articles/functions/\n//1. Almost Identity\nfloat almostIdentity(float x, float m, float n)\n{\n    //m is threshold (value above m stays unchanged)\n    //n is the value given when signal is zero\n    if(x > m) return x;\n    float a = 2.0 * n -m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x/m;\n    return(a * t + b) * t* t + n;\n}\n\n//2. Almost Identity II\nfloat almostIdentity2(float x, float n)\n{\n    //square root of a biased square\n    //zero derivate and non-zero second derivative\n    //useful for symmertric function such as mirrored SDFs\n    return sqrt(x*x+n);\n}\n\n//3. Almost Unit Identity\nfloat almostUnitIdentity(float x)\n{\n    //maps 0 to 0, and 1 to 1\n    //similar to smoothstep()\n    return x * x * (2.0-x);\n}\n\n//4. Smoothstep Integral\nfloat integralSmoothstep(float x, float T)\n{\n    //smoothstep for velocity signal\n    //smoothly accelerate a stationary object into constant velocity motion\n    //no decelerations\n    if (x > T) return x - T/2.0;\n    return x * x * x * (1.0 - x * 0.5/T)/T/T;\n}\n\n//5. Exponential Impulse\nfloat expImpulse(float x, float k)\n{\n    float h = k * x;\n    return h * exp(2.0 - h);\n}\n\n//6. Polynomial Impulse\nfloat quaImpulse(float x, float k)\n{\n    //doesnt use exponentials\n    return 6.0 * sqrt(k) * x/(1.25 + k * x * x);\n}\n\n//adjust fallof shapes - n \nfloat polyImpulse(float x, float k, float n)\n{\n    return (n/(n-1.0))*pow((n-1.0)*k, 1.0/n)*x/(1.0 + k * pow(x, n));\n}\n\n//7. Sustained Impulse\nfloat expSustainedImpulse(float x, float k, float f)\n{\n    //k - control width of attack\n    //f - release \n    float s = max(x - f, 0.0);\n    return min(x * x / (f * f), 1.0 + (2.0/f) * s * exp(-k*s));\n}\n\n//8. Cubic Pulse\n//smoothstep(c-w, c, x ) - smoothstep(c, c+w, x)\n//performant replacement for gaussian\nfloat cubicPulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if(x > w) return 0.0;\n    x /= w;\n    return 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\n//9. Exponential step\n//natural attenuation - exponential of a linearly decaying quantity\n//a gaussian - exponential of a quadratically decaying quantity\nfloat expStep(float x, float k, float n)\n{\n    return exp(-k * pow(x, n));\n}\n\n//10. Gain\n//remapping the unit interval by expanding the sides and compressing the center\n//k =1 - identity curve\n//k < 1 - classic gain\n//k > 1 - s curves\nfloat gain(float x, float k)\n{\n    if(x < 0.5)\n    {\n        float a = 0.5 * pow((2.0 * x), k);\n        return a;\n    }\n    else \n    {\n       float a = 0.5 * pow((2.0 * (1.0 - x)), k);\n       return 1.0 - a;\n    }\n}\n\n//11. Parabola\n//remap the 0 to 1 interval into 0 to 1 where the corners are mapped to 0 and the center is mapped to 1\nfloat parabola(float x, float k)\n{\n    return pow(4.0*x*(1.0 - x), k);\n}\n\n//12. Power Curve\n//generalized parabola that can be control the shape on either side of the curve\n//useful for creating curved shaped\nfloat pcurve(float x, float a, float b)\n{\n    float k = pow(a + b, a + b)/(pow(a, a) * pow(b, b));\n    return k * pow(x, a)*pow(1. - x, b);\n}\n\n//13. Sinc curve\n//bouncing behavior\n//k - number for bounces\nfloat sinc(float x, float k)\n{\n    float a = PI *(k * x - 1.0);\n    return sin(a)/a;\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.5 - 0.5;\n    //vUv.y -= 0.25;\n    vUv.x += 0.25;\n\n    vec3 color = vec3(0.);\n\n    \n\n    float y1 = sinc(vUv.x, 1.5);\n    float pct1 = plot(vUv, y1);\n\n    float y2 = sinc(vUv.x, 2.25);\n    float pct2 = plot(vUv, y2);\n\n    float y3 = sinc(vUv.x, 1.75);\n    float pct3 = plot(vUv, y3);\n\n    float y4 = sinc(vUv.x, 1.4);\n    float pct4 = plot(vUv, y4);\n\n    float y5 = sinc(vUv.x, 1.25);\n    float pct5 = plot(vUv, y5);\n\n    //color = vec3(y1);\n\n    color += pct1 * vec3(1., 1., 0.); //yellow\n    color += pct2 * vec3(0., 1., 1.); //teal\n    color += pct3 * vec3(0.5, 1., .5); //green\n    color += pct4 * vec3(1., 0., 0.); //red\n    color += pct5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function DT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:RT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var PT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.5 - 1.25;\n    //vUv.y -= 0.25;\n    //vUv.x += 0.25;\n\n    vec3 color = vec3(0.);\n\n    float y1 = sdCircle(vUv, .15 + abs(sin(u_time)));\n\n    float y2 = sdCircle(vUv, 0.5 + (cos(u_time)));\n\n    float y3 = sdCircle(vUv, 0.25 + (sin(u_time)));\n\n    float y4 = sdCircle(vUv, 0.35 + abs(cos(u_time)));\n\n    float y5 = sdCircle(vUv, 0.45 + (sin(u_time)));\n\n    //color = vec3(y1);\n\n    color += y1 * vec3(1., 1., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function FT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:PT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n//circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n//box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2.5 - 1.25;\n    //vUv.y -= 0.25;\n    //vUv.x += 0.25;\n\n    vec3 color = vec3(0.);\n\n    float y1 = sdBox(vUv, vec2(2.5 * abs(cos(u_time))));\n\n    float y2 = sdBox(vUv, vec2(2.0 * abs(sin(u_time))));\n\n    float y3 = sdBox(vUv, vec2(1.5 * (cos(u_time))));\n\n    float y4 = sdBox(vUv, vec2(1.0 * (sin(u_time))));\n\n    float y5 = sdBox(vUv, vec2(0.5 * abs(cos(u_time))));\n\n    //color = vec3(y1);\n\n    color += y1 * vec3(1., 1., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function IT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ET=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n//circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2.5 - 1.25;\n    //vUv.y -= 0.25;\n    //vUv.x += 0.25;\n\n    vec3 color = vec3(0.);\n\n    float y1 = sdSegment(vUv, vec2(0.5), vec2(2.5 * (cos(u_time))));\n\n    float y2 = sdSegment(vUv, vec2(0.5), vec2(.05 * (sin(u_time))));\n\n    float y3 = sdSegment(vUv, vec2(0.5), vec2(1.5 * (cos(u_time))));\n\n    float y4 = sdSegment(vUv, vec2(0.5), vec2(1.0 * (sin(u_time))));\n\n    float y5 = sdSegment(vUv, vec2(0.25), vec2(0.5 * (cos(u_time))));\n\n    //color = vec3(y1);\n\n    color += y1 * vec3(1., 1., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function OT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:ET,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 6. - 3.;\n    //vUv.y -= 0.25;\n    vUv.y += 0.25;\n\n    vec3 color = vec3(0.);\n\n    float y1 = sdEqTriangle(vUv * abs(sin(u_time) * 0.1));\n    float y2 = sdEqTriangle(vUv * abs(sin(u_time) * 0.2));\n    float y3 = sdEqTriangle(vUv * abs(sin(u_time) * 0.3));\n    float y4 = sdEqTriangle(vUv * abs(sin(u_time) * 0.4));\n    float y5 = sdEqTriangle(vUv * abs(sin(u_time) * 1.5));\n\n    //color = vec3(y1);\n\n    color += y1 * vec3(1., 1., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:AT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = vUv * 6. - 3.;\n    //vUv.y -= 0.25;\n    vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n\n    float y1 = 1. -  sdEqTriangle(vUv * 5.5 * abs(sin(u_time * 0.5) + 1.5)) * 2.;\n    float x = smoothstep(2.5, 2.51, y1);\n    // float y2 = sdEqTriangle(vUv * abs(sin(u_time) * 0.2));\n    // float y3 = sdEqTriangle(vUv * abs(sin(u_time) * 0.3));\n    // float y4 = sdEqTriangle(vUv * abs(sin(u_time) * 0.4));\n    // float y5 = sdEqTriangle(vUv * abs(sin(u_time) * 1.5));\n\n    //color = vec3(y1);\n\n    color += x * vec3(1., 1., 0.); //yellow\n    // color += y2 * vec3(0., 1., 1.); //teal\n    // color += y3 * vec3(0.5, 1., .5); //green\n    // color += y4 * vec3(1., 0., 0.); //red\n    // color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function NT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:GT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var BT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = vUv * 6. - 3.;\n    //vUv.y -= 0.25;\n    //vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n\n    float y1 =1. - sdHexagon(vUv, 18.25);\n    float y2 =1. - sdHexagon(vUv, 20.25);\n    float y3 =1. - sdHexagon(vUv, 21.25);\n    float y4 =1. - sdHexagon(vUv, 22.25);\n    float y5 =1. - sdHexagon(vUv, 23.25);\n\n    color = vec3(y1);\n\n    color += y1 * vec3(1., 0., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:BT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var VT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = vUv * 40. - 20.;\n    //vUv.y -= 0.25;\n    //vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n\n    float y1 = 1. - sdCircle(vUv * abs(sin(u_time + 4.0 * 0.25)) , 1.9);\n    float y2 = 1. - sdCircle(vUv * abs(sin(u_time + 4.0 * 0.5)), 3.5);\n    float y3 = sdCircle(vUv * cos(u_time + 4.0 * 0.5), 2.5);\n    float y4 = 1. - sdCircle(vUv * sin(u_time + 4.0 * 0.25), 3.5);\n    float y5 = sdCircle(vUv * sin(u_time + 4.0 * 0.25), 3.0);\n\n    color = vec3(y1);\n\n    color += y1 * vec3(1., 0., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function WT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:VT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var HT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n// //hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 60. - 30.;\n    //vUv.y -= 0.25;\n    //vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n\n    float y1 = 1. - sdHexagram(vUv * abs(sin(u_time + 4.0 * 0.25)) , 1.9);\n    float y2 = 1. - sdHexagram(vUv * abs(sin(u_time + 4.0 * 0.5)), 3.5);\n    float y3 = sdHexagram(vUv * cos(u_time + 4.0 * 0.5), 2.5);\n    float y4 = 1. - sdHexagram(vUv * sin(u_time + 4.0 * 0.25), 3.5);\n    float y5 = sdHexagram(vUv * sin(u_time + 4.0 * 0.25), 3.0);\n\n    color = vec3(y1);\n\n    color += y1 * vec3(1., 0., 0.); //yellow\n    color += y2 * vec3(0., 1., 1.); //teal\n    color += y3 * vec3(0.5, 1., .5); //green\n    color += y4 * vec3(1., 0., 0.); //red\n    color += y5 * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function XT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:HT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var YT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 4. - 2.;\n    //vUv.y -= 0.25;\n    //vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n    float a = PI * (0.5 + 0.5 * sin(u_time * 0.5 + 2.0));\n    float b = 0.25 *(0.75 + 0.75);\n    float y1 = sdArc(vUv, vec2(a * 2.50, a * 2.50), 1.0, b * 1.0);\n    float y2 = sdArc(vUv, vec2(a * 2.25, a * 2.25), 1.0, b * 0.8);\n    float y3 = sdArc(vUv, vec2(a * 2.15, a * 2.15), 1.0, b * 0.6);\n    float y4 = sdArc(vUv, vec2(a * 2.45, a * 2.45), 1.0, b * 0.4);\n    float y5 = sdArc(vUv, vec2(a * 2.35, a * 2.35), 1.0, b * 0.2);\n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ZT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:YT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 3. - 1.5;\n    //vUv.y -= 0.25;\n    //vUv.y += 0.25;\n    \n    vec3 color = vec3(0.);\n    float a = PI * (0.5 + 0.5);\n    float b = 0.25 *(0.75 + 0.75);\n    float y1 = sdPie(vUv, vec2(a * 2.50, a * 2.50), b * 1.0 + abs(sin(u_time)));\n    float y2 = sdPie(vUv, vec2(a * 2.25, a * 2.25), b * 0.8 + abs(sin(u_time)));\n    float y3 = sdPie(vUv, vec2(a * 2.15, a * 2.15), b * 0.6 + abs(sin(u_time)));\n    float y4 = sdPie(vUv, vec2(a * 2.45, a * 2.45), b * 0.4 + abs(sin(u_time)));\n    float y5 = sdPie(vUv, vec2(a * 2.35, a * 2.35), b * 0.2 + abs(sin(u_time)));\n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function JT(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:QT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KT=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 3. - 1.5;\n    //vUv.y -= 0.25;\n    vUv.y += 1.0;\n    \n    vec3 color = vec3(0.);\n    float y1 = sdHeart(vUv * 0.12 * abs(sin(u_time) - 5.5));\n    float y2 = sdHeart(vUv * 0.14 * abs(sin(u_time) - 5.5));\n    float y3 = sdHeart(vUv * 0.16 * abs(sin(u_time) - 5.5));\n    float y4 = sdHeart(vUv * 0.1 * abs(sin(u_time) - 5.5));\n    float y5 = sdHeart(vUv * 0.11 * abs(sin(u_time) - 5.));\n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $T(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:KT,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n// //hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    vec2 s = 0.6 + 0.3*cos(u_time + vec2(0.0, 1.57));\n    if (s.x < s.y){\n        s = s.yx;\n    }\n    vec3 color = vec3(0.);\n    float y1 = sdCross(vUv, s, 0.25);\n    float y2 = sdCross(vUv, s, 0.15);\n    float y3 = sdCross(vUv, s, 0.35);\n    float y4 = sdCross(vUv, s, 0.45);\n    float y5 = sdCross(vUv, s, 0.50);\n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function eR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    vec2 s = 0.6 + 0.3*cos(u_time + vec2(0.0, 1.57));\n    if (s.x < s.y){\n        s = s.yx;\n    }\n    vec3 color = vec3(0.);\n    float y1 = sdRoundedX(vUv, 0.5, 0.25 * sin(u_time * 0.5));\n    float y2 = sdRoundedX(vUv, 0.5, 0.15 * abs(cos(u_time * 0.5)));\n    float y3 = sdRoundedX(vUv, 0.5, 0.35 * abs(sin(u_time * 0.5)));\n    float y4 = sdRoundedX(vUv, 0.5, 0.45 / sin(u_time * 0.5));\n    float y5 = sdRoundedX(vUv, 0.5, 0.50 * cos(u_time * 0.5));\n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function oR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\n// float sdHexagon(vec2 p, float r)\n// {\n//     vec3 k = vec3(-0.866025404,0.5,0.577350269);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n//     return length(p) * sin(p.y);\n// }\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\nconst int N = 4;\n\nfloat sdPolygon(vec2 p, vec2[N] v)\n{\n    int num = v.length();\n    float d = dot(p-v[0], p-v[0]);\n    float s = 1.0;\n    for(int i=0, j =num-1; i <num; j=i, i++)\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e,e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ){\n             s=-s;\n            }\n        }\n\n    return s * sqrt(d);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    \n    vec2 v0 = 0.5 * cos(0.25 * u_time + vec2(0., 1.0) + 1.0);\n    vec2 v1 = 0.5 * cos(0.35 * u_time + vec2(0., 1.5) + 2.0);\n    vec2 v2 = 0.5 * cos(0.45 * u_time + vec2(0., 2.0) + 3.0);\n    vec2 v3 = 0.5 * cos(0.55 * u_time + vec2(0., 2.5) + 4.0);\n\n    vec2[] polygon = vec2[](v0, v1, v2, v3);\n\n    float d = sdPolygon(vUv, polygon);\n    vec3 color = vec3(0.);\n    color += 1.0 - exp(-6.0*abs(d));\n\n    color += smoothstep(0.0, 0.015, d) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, d) * vec3(0., 1., 1.); //teal\n    // color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    // color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    // color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function aR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vUv = Rot(vUv,   u_time * 0.4 * 2.);\n    vUv2 = Rot(vUv2, u_time * 0.6 * 2.);\n    vUv3 = Rot(vUv3, u_time * 0.8 * 2.);\n    vUv4 = Rot(vUv3, u_time * 0.2 * 2.);\n    vUv = vUv * 4. - 2.;\n    vUv2 = vUv2 * 4. - 2.;\n    vUv3 = vUv3 * 4. - 2.;\n    vUv4 = vUv4 * 4. - 2.;\n\n    \n    vec3 color = vec3(0.);\n    float a = PI * (0.5 + 0.5);\n    float b = 0.25 *(0.75 + 0.75);\n    float y1 = sdArc(vUv4 * 0.65, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y2 = sdArc(vUv, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y21 = sdArc(vUv2 / 0.65, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y211 = sdArc(vUv3 / 0.4, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    \n    \n\n    //color = vec3(y1);\n\n    color += smoothstep(0.0, 0.015, y1); //yellow\n    color *= smoothstep(0.0, 0.015, y2) * vec3(0., 1., 1.); //teal\n    color *= smoothstep(0.0, 0.015, y21) * vec3(0.5, 1., .5); //green\n    color *= smoothstep(0.0, 0.015, y211); //red\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:iR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vec2 vUv5 = vUv;\n\n    vUv = Rot(vUv,   u_time * 0.4 * 4.);\n    vUv2 = Rot(vUv2, u_time * 0.6 * 4.);\n    vUv3 = Rot(vUv3, u_time * 0.8 * 4.);\n    vUv4 = Rot(vUv4, u_time * 1.0 * 4.);\n    vUv5 = Rot(vUv5, u_time * 0.2 * 4.);\n\n    vUv = vUv * 4. - 2.;\n    vUv2 = vUv2 * 4. - 2.;\n    vUv3 = vUv3 * 4. - 2.;\n    vUv4 = vUv4 * 4. - 2.;\n    vUv5 = vUv5 * 4. - 2.;\n\n    \n    vec3 color = vec3(0.);\n    float a = PI * (0.25 + 0.25);\n    float b = 0.025 *(0.5 + 0.5);\n    float y1 = sdArc(vUv4 * 0.65, vec2(a * 2.5, a * 2.5), 1.0 , b * 0.4 );\n    float y2 = sdArc(vUv, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y21 = sdArc(vUv2 / 0.65, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y211 = sdArc(vUv3 / 0.4, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    float y2111 = sdArc(vUv5 /0.225, vec2(a * 2.5, a * 2.5), 1.0, b * 0.4);\n    \n\n    color = vec3(y1);\n\n    y1 = smoothstep(0.0, 0.015, y1); //yellow\n    y2 = smoothstep(0.0, 0.015, y2); //teal\n    y21 = smoothstep(0.0, 0.015, y21); //green\n    y211 = smoothstep(0.0, 0.015, y211); //red\n    y2111 = smoothstep(0.0, 0.015, y2111); //red\n\n    color += y1;\n    color *= y2;\n    color *= y21;\n    color *= y211;\n    color *= y2111;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n// //arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vec2 vUv5 = vUv;\n\n    vUv = Rot(vUv,   u_time * 0.15);\n\n    vUv = vUv * (100. *sin(u_time * 0.5) + 25.) - (50. * sin(u_time * 0.5) + 12.5);    \n    vec3 color = vec3(0.);\n    \n    float y1 = sdHexagram(vUv, 1.5);\n    float y2 = sdHexagram(vUv, 1.2);\n    float y21 = sdHexagram(vUv, 1.0);\n    float y211 = sdHexagram(vUv, 0.8);\n    float y2111 = sdHexagram(vUv, 0.5);\n\n    y1 = smoothstep(0.0, 0.015, y1); //yellow\n    y2 = smoothstep(0.0, 0.015, y2); //teal\n    y21 = smoothstep(0.0, 0.015, y21); //green\n    y211 = smoothstep(0.0, 0.015, y211); //red\n    y2111 = smoothstep(0.0, 0.015, y2111); //red\n\n    color += y1;\n    color += y2 ;\n    color *= y21 ;\n    color *= y211;\n    color *= y2111;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\nconst int N = 8;\n\nfloat sdPolygon(vec2 p, vec2[N] v)\n{\n    int num = v.length();\n    float d = dot(p-v[0], p-v[0]);\n    float s = 1.0;\n    for(int i=0, j =num-1; i <num; j=i, i++)\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e,e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ){\n             s=-s;\n            }\n        }\n\n    return s * sqrt(d);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    \n    vec2 v0 = 0.5 * cos(0.25 * u_time + vec2(0., 1.0) + 1.0);\n    vec2 v1 = 0.5 * cos(0.35 * u_time + vec2(0., 1.5) + 2.0);\n    vec2 v2 = 0.5 * cos(0.45 * u_time + vec2(0., 2.0) + 3.0);\n    vec2 v3 = 0.5 * cos(0.55 * u_time + vec2(0., 2.5) + 4.0);\n    vec2 v4 = 0.5 * cos(0.65 * u_time + vec2(0., 1.0) + 1.0);\n    vec2 v5 = 0.5 * cos(0.75 * u_time + vec2(0., 1.5) + 2.0);\n    vec2 v6 = 0.5 * cos(0.85 * u_time + vec2(0., 2.0) + 3.0);\n    vec2 v7 = 0.5 * cos(0.95 * u_time + vec2(0., 2.5) + 4.0);\n\n    vec2[] polygon = vec2[](v0, v1, v2, v3,v4, v5, v6, v7);\n\n    float d = sdPolygon(vUv, polygon);\n    vec3 color = vec3(0.);\n    color += 1.0 - exp(-6.0*abs(d));\n\n    color += smoothstep(0.0, 0.015, d) * vec3(1., 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, d) * vec3(0., 1., 1.); //teal\n    // color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    // color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    // color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\n// float sdHexagon(vec2 p, float r)\n// {\n//     vec3 k = vec3(-0.866025404,0.5,0.577350269);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n//     return length(p) * sin(p.y);\n// }\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\nconst int N = 3;\n\nfloat sdPolygon(vec2 p, vec2[N] v)\n{\n    int num = v.length();\n    float d = dot(p-v[0], p-v[0]);\n    float s = 1.0;\n    for(int i=0, j =num-1; i <num; j=i, i++)\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e,e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ){\n             s=-s;\n            }\n        }\n\n    return s * sqrt(d);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    \n    vec2 v0 = 0.5 * cos(0.25 * u_time + vec2(0., 1.0) + 1.0);\n    vec2 v1 = 0.5 * cos(0.55 * u_time + vec2(0., 1.5) + 2.0);\n    vec2 v2 = 0.5 * cos(0.95 * u_time + vec2(0., 2.0) + 3.0);\n    vec2 v3 = 0.5 * cos(0.55 * u_time + vec2(0., 2.5) + 4.0);\n    vec2 v4 = 0.5 * cos(0.65 * u_time + vec2(0., 1.0) + 1.0);\n    vec2 v5 = 0.5 * cos(0.75 * u_time + vec2(0., 1.5) + 2.0);\n    vec2 v6 = 0.5 * cos(0.85 * u_time + vec2(0., 2.0) + 3.0);\n    vec2 v7 = 0.5 * cos(0.95 * u_time + vec2(0., 2.5) + 4.0);\n    vec2 v8 = 0.5 * cos(1.25 * u_time + vec2(0., 3.5) + 4.0);\n\n    vec2[] polygon = vec2[](v0, v1, v2);\n    vec2[] polygon2 = vec2[](v3, v4, v5);\n    vec2[] polygon3 = vec2[](v6, v7, v8);\n\n    float d = sdPolygon(vUv, polygon);\n    float d2 = sdPolygon(vUv, polygon2);\n    float d3 = sdPolygon(vUv, polygon3);\n    vec3 color = vec3(0.);\n    color += exp(-16.0*abs(d));\n    color += exp(-16.0*abs(d2));\n    color += exp(-16.0*abs(d3));\n\n    color += smoothstep(0.0, 0.015, d) * vec3(0.2, 0., 0.); //yellow\n    color += smoothstep(0.0, 0.015, d2) * vec3(0., 0.2, 0.); //teal\n    color += smoothstep(0.0, 0.015, d3) * vec3(0.3, 0., 0.); //teal\n    // color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    // color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    // color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n// //circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\nconst int N = 4;\n\nfloat sdPolygon(vec2 p, vec2[N] v)\n{\n    int num = v.length();\n    float d = dot(p-v[0], p-v[0]);\n    float s = 1.0;\n    for(int i=0, j =num-1; i <num; j=i, i++)\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e,e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ){\n             s=-s;\n            }\n        }\n\n    return s * sqrt(d);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    \n    vec2 v0 = 0.5 * cos(0.15 * u_time + vec2(10., 0.0) + 1.0);\n    vec2 v1 = 0.5 * cos(0.15 * u_time + vec2(0., 1.0) + 2.0);\n    vec2 v2 = 0.5 * cos(0.15 * u_time + vec2(1.0, 0.0) + 3.0);\n    vec2 v3 = 0.5 * cos(0.15 * u_time + vec2(1.0, 1.0) + 4.0);\n    vec2 v4 = 0.5 * cos(0.15 * u_time + vec2(1.5, 0.0) + 1.0);\n    vec2 v5 = 0.5 * cos(0.15 * u_time + vec2(1.5, 2.5) + 2.0);\n    vec2 v6 = 0.5 * cos(0.15 * u_time + vec2(3.0, 0.0) + 3.0);\n    vec2 v7 = 0.5 * cos(0.15 * u_time + vec2(3.0, 2.5) + 1.0);\n    vec2 v8 = 0.5 * cos(1.15 * u_time + vec2(0., 3.5) + 2.0);\n\n    vec2[] polygon = vec2[](v0, v1, v2, v3);\n    vec2[] polygon2 = vec2[](v4, v5, v6, v7);\n    vec2[] polygon3 = vec2[](v6, v7, v8);\n\n    float d = sdPolygon(vUv, polygon);\n    float d2 = sdPolygon(vUv, polygon2);\n    //float d3 = sdPolygon(vUv, polygon3);\n    vec3 color = vec3(0.);\n    color += exp(-32.0*abs(d));\n    color += exp(-32.0*abs(d2));\n    //color += exp(-32.0*abs(d3));\n\n    color += smoothstep(0.0, 0.015, d) * vec3(0.2, 0., 0.2); //yellow\n    color += smoothstep(0.0, 0.015, d2) * vec3(0., 0.2, 0.); //teal\n    //color += smoothstep(0.0, 0.015, d3) * vec3(0.1, 0., 0.); //teal\n    // color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    // color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    // color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //Shaping functions 1.1\n//plot from book of shaders\n\nfloat plot(vec2 st, float pct){\n    return smoothstep(pct-0.02, pct, st.y) -\n           smoothstep(pct, pct+0.02, st.y);\n}\n\n/*\nhttps://iquilezles.org/articles/distfunctions2d/\n*/\n\n//circle sdf\n// float sdCircle(vec2 p, float r)\n// {\n//     return length(p) - r;\n// }\n\n// //box\n// float sdBox(vec2 p, vec2 b)\n// {\n//     vec2 d = abs(p) - b;\n//     return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n// }\n\n// //segment\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p - a;\n//     vec2 ba = b - a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n//equilateral triangle\nfloat sdEqTriangle(vec2 p)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if(p.x + k * p.y > 0.0){\n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    }\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sin(p.y);\n}\n\n//regular hexagon\nfloat sdHexagon(vec2 p, float r)\n{\n    vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p) * sin(p.y);\n}\n\n//hexagram\n// float sdHexagram(vec2 p, float r)\n// {\n//     vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n//     p = abs(p);\n//     p -= 2.0 * min(dot(k.xy,p), 0.0) * k.xy;\n//     p -= 2.0 * min(dot(k.yx,p), 0.0) * k.yx;\n//     p -= vec2(clamp(p.x,r*k.z, r*k.w), r);\n//     return length(p) * sin(p.y);\n// }\n\n//pie\nfloat sdPie(vec2 p, vec2 c, float r)\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p - c * clamp(dot(p,c), 0.0, r));\n    return max(l, m * sin(c.y*p.x-c.x*p.y));\n}\n\n//arc\n// float sdArc(vec2 p, vec2 sc, float ra, float rb){\n//     //sc is arc's aperture\n//     p.x = abs(p.x);\n//     sc = vec2(sin(sc.x), cos(sc.y));\n//     if (sc.y * p.x > sc.x * p.y){\n//         return length(p - sc*ra) - rb;\n//     }\n//     else {\n//         return abs(length(p) - ra) - rb;\n//     }\n// }\n\n// float dot2(vec2 v)\n// {\n//     return dot(v, v);\n// }\n\n//heart\nfloat sdHeart(vec2 p)\n{\n    p.x = abs(p.x);\n    if(p.y + p.x > 1.0)\n    {\n    return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    }\n    else {\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n    }\n}\n\n//cross\nfloat sdCross(vec2 p, vec2 b, float r)\n{\n    vec2 w;\n    p = abs(p);\n    if (p.y > p.x)\n    {\n        p = p.yx;\n    } else {\n        p = p.xy;\n    }\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    if (k > 0.0) {\n         w = q;\n    } else {\n         w = vec2(b.y-p.x, -k);\n    }\n    return sign(k) * length(max(w, 0.0)) + r;\n\n}\n\n//rounded x\nfloat sdRoundedX(vec2 p, float w, float r)\n{\n    p = abs(p);\n    return length(p - min(p.x + p.y, w) * 0.5) - r;\n}\n\nconst int N = 4;\n\nfloat sdPolygon(vec2 p, vec2[N] v)\n{\n    int num = v.length();\n    float d = dot(p-v[0], p-v[0]);\n    float s = 1.0;\n    for(int i=0, j =num-1; i <num; j=i, i++)\n    {\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e,e), 0.0, 1.0);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3( p.y>=v[i].y, \n                            p.y <v[j].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ){\n             s=-s;\n            }\n        }\n\n    return s * sqrt(d);\n}\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main(){\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.4);\n    vUv = vUv * 2. - 1.;\n    //vUv.y -= 0.25;\n    //vUv.y += 1.0;\n    \n    vec2 v0 = 0.5 * cos(0.15 * u_time + vec2(0.0, 0.0) + 1.5);\n    vec2 v1 = 0.5 * cos(0.15 * u_time + vec2(0.0, 4.0) + 2.3);\n    vec2 v2 = 0.5 * cos(0.15 * u_time + vec2(4.0, 2.0) + 3.5);\n    vec2 v3 = 0.5 * cos(0.15 * u_time + vec2(2.0, 0.0) + 4.1);\n    vec2 v4 = 0.5 * cos(0.15 * u_time + vec2(1.5, 0.0) + 1.0);\n    vec2 v5 = 0.5 * cos(0.15 * u_time + vec2(1.5, 2.5) + 2.0);\n    vec2 v6 = 0.5 * cos(0.15 * u_time + vec2(3.0, 0.0) + 3.0);\n    vec2 v7 = 0.5 * cos(0.15 * u_time + vec2(3.0, 2.5) + 1.0);\n    vec2 v8 = 0.5 * cos(1.15 * u_time + vec2(0., 3.5) + 2.0);\n\n    vec2[] polygon = vec2[](v0, v1, v2, v3);\n    vec2[] polygon2 = vec2[](v4, v5, v6, v7);\n    // vec2[] polygon3 = vec2[](v6, v7, v8);\n\n    float d = sdPolygon(vUv, polygon);\n    float d2 = sdPolygon(vUv, polygon2);\n    //float d3 = sdPolygon(vUv, polygon3);\n    vec3 color = vec3(0.);\n    color += exp(-16.0*abs(d));\n    color += exp(-32.0*abs(d2));\n    //color += exp(-32.0*abs(d3));\n\n    color += smoothstep(0.0, 0.015, d * d2) * vec3(0.2, 0., 0.2); //yellow\n    //color += smoothstep(0.0, 0.015, d2) * vec3(0., 0.2, 0.); //teal\n    //color += smoothstep(0.0, 0.015, d3) * vec3(0.1, 0., 0.); //teal\n    // color += smoothstep(0.0, 0.015, y3) * vec3(0.5, 1., .5); //green\n    // color += smoothstep(0.0, 0.015, y4) * vec3(1., 0., 0.); //red\n    // color += smoothstep(0.0, 0.015, y5) * vec3(0.5, .0, 1.); //purple\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = step(((1.0 - width)/ 2.0), vUv.x);\n//     float right = step(((1.0 - width)/2.0), 1. - vUv.x);\n//     float top = step(((1.0 - height)/2.0), 1. - vUv.y);\n//     float bottom = step(((1.0 - height)/2.0), vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = Rot(vUv, u_time * 0.75);\n    float rectangle1 = rect(vUv, 0.25, 0.25);\n    float rectangle2 = rect(vUv, 0.025, 0.5);\n    float rectangle3 = rect(vUv, 0.5, 0.025);\n    color = vec3(rectangle1 + rectangle2 + rectangle3);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _R=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = Rot(vUv, u_time * 0.75);\n    float rectangle1 = rect(vec2(vUv.x-0.25,vUv.y), 0.25, 0.25);\n    float rectangle2 = rect(vec2(vUv.x-0.25,vUv.y), 0.025, 0.5);\n    float rectangle3 = rect(vec2(vUv.x-0.25,vUv.y), 0.5, 0.025);\n    float rectangle4 = rect(vec2(vUv.x,vUv.y), 0.25, 0.25);\n    float rectangle5 = rect(vec2(vUv.x,vUv.y), 0.025, 0.5);\n    float rectangle6 = rect(vec2(vUv.x,vUv.y), 0.5, 0.025);\n    float rectangle7 = rect(vec2(vUv.x+0.25,vUv.y), 0.25, 0.25);\n    float rectangle8 = rect(vec2(vUv.x+0.25,vUv.y), 0.025, 0.5);\n    float rectangle9 = rect(vec2(vUv.x+0.25,vUv.y), 0.5, 0.025);\n    color = vec3(rectangle1 - rectangle2 + rectangle3);\n    color += vec3(rectangle4 - rectangle5 + rectangle6);\n    color += vec3(rectangle7 - rectangle8 + rectangle9);\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_R,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var SR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1  - 366\n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float b1 = rect(vec2(vUv.x - 0.5, vUv.y - 0.225), 0.2, 0.2);\n    float b2 = rect(vec2(vUv.x - 0.5, vUv.y - 0.45), 0.2, 0.2);\n    float b3 = rect(vec2(vUv.x -0.125, vUv.y - 0.45), 0.65, 0.5);\n    float b4 = rect(vec2(vUv.x -0.125, vUv.y + 0.125 ), 0.45, 0.5);\n    float b5 = rect(vec2(vUv.x -0.125, vUv.y + 0.45 ), 0.15, 0.5);\n    float b6 = rect(vec2(vUv.x -0.5, vUv.y + 0.125 ), 0.45, 0.2);\n    float b7 = rect(vec2(vUv.x -0.5, vUv.y + 0.45 ), 0.15, 0.2);\n    float b8 = rect(vec2(vUv.x + 0.5, vUv.y + 0.45 ), 0.15, 0.2);\n    float b9 = rect(vec2(vUv.x + 0.5, vUv.y - 0.225 ), 0.75, 0.695);\n    float b10 = rect(vec2(vUv.x +0.5, vUv.y + 0.265), 0.175, 0.695);\n    float b11 = rect(vec2(vUv.x + 0.265, vUv.y + 0.445 ), 0.14, 0.22);\n\n    color.r = b1 * (sin(u_time * 0.1));\n    color.b += b2 * (sin(u_time * 0.2));\n    color.rgb += b3 * (sin(u_time * 0.3));\n    color.rg += b4 * (sin(u_time * 0.4));\n    color.b += b5 * (sin(u_time * 0.5));\n    color.rgb += b6 * (sin(u_time * 0.6));\n    color.r += b7 * (sin(u_time * 0.7));\n    color.rg += b8 * (sin(u_time * 0.8));\n    color.rg += b9 * (sin(u_time * 0.9));\n    color.rgb += b10 * (sin(u_time * 0.11));\n    color.r += b11 * (sin(u_time * 0.12));\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function MR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:SR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec3 color = vec3(0.);\n\n    vUv1 = Rot(vUv1, u_time * 0.5 * 1.5);\n    vUv2 = Rot(vUv2, u_time * 0.25 * 1.5);\n    vUv3 = Rot(vUv3, u_time * 0.75 * 1.5);\n\n    float c1 = circle(vUv, 0.5);\n    color = vec3(c1);\n    float r1 = rect(vUv1, 0.55, 0.55);\n    color -= r1;\n\n    float c2 = circle(vUv, 0.25);\n    color += c2;\n    float r2 = rect(vUv2, 0.4, 0.4);\n    color -= r2;\n    \n    float c3 = circle(vUv, 0.125);\n    color += c3;\n    //float r3 = rect(vUv, 0.35, 0.035);\n    //color -= c3;\n\n    float c4 = circle(vUv, 0.75);\n    color += c4;\n    float r4 = rect(vUv3, 0.75, 0.75);\n    color -= r4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var CR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.25);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec3 color = vec3(0.);\n\n    vUv1 = Rot(vUv, PI * 0.25);\n    vUv2 = Rot(vUv, -PI * 0.25);\n    float c1 = circle(vUv, 0.25);\n    float c2 = circle(vUv, 0.35);\n\n    float c3 = circle(vUv, 0.15);\n    float c4 = circle(vUv, 0.1);\n    float r1 = rect(vUv, 0.05, 0.65);\n    float r2 = rect(vUv, 0.65, 0.05);\n    float r3 = rect(vUv1, 0.65, 0.05);\n    float r4 = rect(vUv2, 0.65, 0.05);\n\n    color += c2;\n    color -= c1;\n    color += c3;\n    color -= c4;\n\n    color -= r1;\n    color -= r2;\n    color -= r3;\n    color -= r4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function TR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:CR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var RR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vUv1 = Rot(vUv, u_time);\n    vec3 color = vec3(0.);\n\n    float r1 = rect(vUv1, 0.3, 0.75);\n    float c1 = circle(vUv, 0.35);\n    \n    float r2 = rect(vUv1, 0.75, 0.3);\n    float c2 = circle(vUv, 0.025);\n\n    float r3 = rect(vUv2, 0.3, 0.3);\n    \n    \n    color += r1;\n    color += r2;\n    color -= c1;\n    color += c2;\n    color -= r3;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function DR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:RR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var PR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vUv1 = Rot(vUv, u_time);\n    vec3 color = vec3(0.);\n\n    float r1 = rect(vUv1, 0.3, 0.75);\n    float c1 = circle(vUv, 0.35);\n    \n    float r2 = rect(vUv1, 0.75, 0.3);\n    float c2 = circle(vUv, 0.025);\n\n    float r3 = rect(vUv2, 0.3, 0.3);\n    \n    \n    color -= r1;\n    color -= r2;\n    color += c1;\n    color -= c2;\n    color += r3;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function FR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:PR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.6);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vUv1 = Rot(vUv1, PI);\n    vUv2 = Rot(vUv2, PI * 0.5);\n    vec3 color = vec3(0.);\n\n    float r1 = rect(vUv1, 0.5, 0.5);\n    float r2 = 1. - rect(vUv1, 0.25, 0.5);\n    float r3 = rect(vUv1, 0.1, 0.7);\n    \n\n    float r4 = rect(vUv2, 0.5, 0.5);\n    float r5 = 1. - rect(vUv2, 0.25, 0.5);\n    float r6 = rect(vUv2, 0.1, 0.7);\n    \n    color += r1;\n    color -= r2;\n    color -= r3;\n    color += r4;\n    color -= r5;\n    color -= r6;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function IR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ER=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 1.6);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vUv1 = Rot(vUv1, PI);\n    vUv2 = Rot(vUv2, PI * 0.5);\n    vec3 color = vec3(0.);\n\n    float r1 = rect(vUv1, 0.5, 0.5);\n    float r2 = 1. - rect(vUv1, 0.35, 0.75);\n    float r3 = rect(vUv1, 0.2, 0.7);\n    \n\n    float r4 = rect(vUv2, 0.25, 0.25);\n    float r5 = 1. - rect(vUv2, 0.55, 0.55);\n    float r6 = rect(vUv2, 0.1, 0.1);\n    \n    color += r1;\n    color -= r2;\n    color -= r3;\n    color += r4;\n    color -= r5;\n    color -= r6;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function OR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:ER,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 1.6);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vUv1 = Rot(vUv1, PI);\n    vUv2 = Rot(vUv2, PI * 0.5);\n    vec3 color = vec3(0.);\n\n    float r1 = rect(vUv1, 0.5, 0.5);\n    float r2 = 1. - rect(vUv1, 0.35, 0.75);\n    float r3 = rect(vUv1, 0.2, 0.7);\n    \n\n    float r4 = rect(vUv2, 0.15, 0.45);\n    float r5 = 1. - rect(vUv2, 0.55, 0.55);\n    float r6 = rect(vUv2, 0.82, 0.1);\n    \n    color += r1;\n    color -= r2;\n    color -= r3;\n    color -= r4;\n    color -= r5;\n    color += r6;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:AR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    float c1 = circle(vUv, 0.5 * abs(sin(u_time)));\n    float c2 = circle(vUv, 0.51 * abs(sin(u_time)));\n    float c3 = smoothstep(0.1, 0.2, c2 - c1);\n    color += c3;\n\n    float r1 = rect(vUv, 0.6 * abs(cos(u_time)), 0.6 * abs(cos(u_time)));\n    float r2 = rect(vUv, 0.61 * abs(cos(u_time)), 0.61 * abs(cos(u_time)));\n    float r3 = smoothstep(0.1, 0.2, r2 - r1);\n    color += r3;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function NR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:GR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var BR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    float c1 = cirOutline(vUv, 0.50 * abs(sin(u_time * 0.95)) + .15);\n    float c2 = cirOutline(vUv, 0.45 * abs(sin(u_time * 0.85)) + .15);\n    float c3 = cirOutline(vUv, 0.40 * abs(sin(u_time * 0.75)) + .15);\n    float c4 = cirOutline(vUv, 0.35 * abs(sin(u_time * 0.65)) + .15);\n    float c5 = cirOutline(vUv, 0.30 * abs(sin(u_time * 0.56)) + .15);\n    float c6 = cirOutline(vUv, 0.25 * abs(sin(u_time * 0.45)) + .15);\n    float c7 = cirOutline(vUv, 0.20 * abs(sin(u_time * 0.35)) + .15);\n    float c8 = cirOutline(vUv, 0.15 * abs(sin(u_time * 0.25)) + .15);\n    float c9 = cirOutline(vUv, 0.10 * abs(sin(u_time * 0.15)) + .15);\n    float c10 = cirOutline(vUv, 0.05 *abs(sin(u_time * 0.05)) + .15);\n    color += c1 + c2 + c3 + c4 + c5 + c6 + c7 + c8 + c9 + c10;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:BR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var VR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    float r1 = rectOutline(vUv, 0.3 - (0.04 * 6.5) * sin(u_time), 0.3 - (0.04 * 6.5) * cos(u_time));\n    float r2 = rectOutline(vUv, 0.3 - (0.03 * 6.5) * sin(u_time), 0.3 - (0.03 * 6.5) * cos(u_time));\n    float r3 = rectOutline(vUv, 0.3 - (0.02 * 6.5) * sin(u_time), 0.3 - (0.02 * 6.5) * cos(u_time));\n    float r4 = rectOutline(vUv, 0.3 - (0.01 * 6.5) * sin(u_time), 0.3 - (0.01 * 6.5) * cos(u_time));\n    float r5 = rectOutline(vUv, 0.3 + (0.00 * 6.5) * sin(u_time), 0.3 + (0.00 * 6.5) * cos(u_time));\n    float r6 = rectOutline(vUv, 0.3 + (0.01 * 6.5) * sin(u_time), 0.3 + (0.01 * 6.5) * cos(u_time));\n    float r7 = rectOutline(vUv, 0.3 + (0.02 * 6.5) * sin(u_time), 0.3 + (0.02 * 6.5) * cos(u_time));\n    float r8 = rectOutline(vUv, 0.3 + (0.03 * 6.5) * sin(u_time), 0.3 + (0.03 * 6.5) * cos(u_time));\n    float r9 = rectOutline(vUv, 0.3 + (0.04 * 6.5) * sin(u_time), 0.3 + (0.04 * 6.5) * cos(u_time));\n\n    color += r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8 + r9;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function WR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:VR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var HR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    float r1 = rectOutline(vUv, 0.3 - (0.04 * 6.5) * cos(u_time + 1.5), 0.3 - (0.04 * 6.5) * cos(u_time * 0.5));\n    float r2 = rectOutline(vUv, 0.3 - (0.03 * 6.5) * cos(u_time + 1.5), 0.3 - (0.03 * 6.5) * cos(u_time * 0.5));\n    float r3 = rectOutline(vUv, 0.3 - (0.02 * 6.5) * cos(u_time + 1.5), 0.3 - (0.02 * 6.5) * cos(u_time * 0.5));\n    float r4 = rectOutline(vUv, 0.3 - (0.01 * 6.5) * cos(u_time + 1.5), 0.3 - (0.01 * 6.5) * cos(u_time * 0.5));\n    float r5 = rectOutline(vUv, 0.3 + (0.00 * 6.5) * cos(u_time + 1.5), 0.3 + (0.00 * 6.5) * cos(u_time * 0.5));\n    float r6 = rectOutline(vUv, 0.3 + (0.01 * 6.5) * cos(u_time + 1.5), 0.3 + (0.01 * 6.5) * cos(u_time * 0.5));\n    float r7 = rectOutline(vUv, 0.3 + (0.02 * 6.5) * cos(u_time + 1.5), 0.3 + (0.02 * 6.5) * cos(u_time * 0.5));\n    float r8 = rectOutline(vUv, 0.3 + (0.03 * 6.5) * cos(u_time + 1.5), 0.3 + (0.03 * 6.5) * cos(u_time * 0.5));\n    float r9 = rectOutline(vUv, 0.3 + (0.04 * 6.5) * cos(u_time + 1.5), 0.3 + (0.04 * 6.5) * cos(u_time * 0.5));\n\n    color += r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8 + r9;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function XR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:HR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var YR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = vUv * 2. - 0.5;\n\n    vec2 vUv1 = vUv;\n    vUv1.x += sin(u_time * 0.25);\n    float c1 = cirOutline(vUv1, 0.05);\n\n    vec2 vUv2 = vUv;\n    vUv2.x -= sin(u_time * 0.5);\n    float c2 = cirOutline(vUv2, 0.05);\n\n    vec2 vUv3 = vUv;\n    vUv3.x += sin(u_time * 0.2);\n    float c3 = cirOutline(vUv3, 0.05);\n\n    vec2 vUv4 = vUv;\n    vUv4.x += sin(u_time * 1.9);\n    float c4 = cirOutline(vUv4, 0.05);\n\n    vec2 vUv5 = vUv;\n    vUv5.x -= sin(u_time * 1.15);\n    float c5 = cirOutline(vUv5, 0.05);\n\n    vec2 vUv6 = vUv;\n    vUv6.x += sin(u_time * 0.85);\n    vUv6.y -= 0.25;\n    float c6 = cirOutline(vUv6, 0.05);\n\n    vec2 vUv7 = vUv;\n    vUv7.x -= sin(u_time * 0.55);\n    vUv7.y -= 0.25;\n    float c7 = cirOutline(vUv7, 0.05);\n\n    vec2 vUv8 = vUv;\n    vUv8.x += sin(u_time * 0.35);\n    vUv8.y -= 0.25;\n    float c8 = cirOutline(vUv8, 0.05);\n\n    vec2 vUv9 = vUv;\n    vUv9.x += sin(u_time * 1.24);\n    vUv9.y -= 0.25;\n    float c9 = cirOutline(vUv9, 0.05);\n\n    vec2 vUv10 = vUv;\n    vUv10.x -= sin(u_time * .25);\n    vUv10.y -= 0.25;\n    float c10 = cirOutline(vUv10, 0.05);\n\n    vec2 vUv11 = vUv;\n    vUv11.x -= sin(u_time * .25);\n    vUv11.y += 0.25;\n    float c11 = cirOutline(vUv11, 0.05);\n\n    vec2 vUv12 = vUv;\n    vUv12.x -= sin(u_time * .25);\n    vUv12.y += 0.25;\n    float c12 = cirOutline(vUv12, 0.05);\n\n    vec2 vUv13 = vUv;\n    vUv13.x -= sin(u_time * .45);\n    vUv13.y += 0.25;\n    float c13 = cirOutline(vUv13, 0.05);\n\n    vec2 vUv14 = vUv;\n    vUv14.x -= sin(u_time * .75);\n    vUv14.y += 0.25;\n    float c14 = cirOutline(vUv14, 0.05);\n\n    vec2 vUv15 = vUv;\n    vUv15.x -= sin(u_time * 1.35);\n    vUv15.y += 0.25;\n    float c15 = cirOutline(vUv15, 0.05);\n\n    color += c1 + c2 + c3 + c4 + c5;\n    color += c6 + c7 + c8 + c9 + c10;\n    color += c11 + c12 + c13 + c14 + c15;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ZR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:YR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    //vUv = vUv * 2. - 0.5;\n\n    float r1 = rect(vUv, 0.5, 0.5);\n    float c1 = circle(vUv, 0.15);\n    float c2 = cirOutline(vUv, 0.045 + abs(sin(u_time) / 16.));\n    float r2 = rectOutline(vUv, 0.45 + abs(sin(u_time) / 32.), 0.45 + abs(sin(u_time) / 32.) );\n    color += r1;\n    color -= c1;\n    color += c2;\n    color -= r2;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function JR(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:QR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KR=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = vUv * 4. - 2.;\n\n    float d = 1. - length(max(abs(vUv) - .3, 0.));\n\n    d = fract((d * 2. + (u_time * 0.75)));\n    d = smoothstep(0.3, 0.4, d) * smoothstep(0.6, 0.5, d);\n    color += d;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $R(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:KR,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    //vUv = Rot(vUv, (u_time * 0.25));\n    vUv = vUv * 4. - 2.;\n    \n    float d = 1. - length(max(abs(vUv) - .3, 0.));\n\n    d = fract((d + d * d * d * 2. - (u_time * 0.75)));\n    d /= smoothstep(0.3, 0.31, d) * smoothstep(0.4, 0.41, d);\n    color += 1. - d;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function eD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vUv = Rot(vUv, (u_time * 0.25));\n    vUv = vUv * 4. - 2.;\n    \n    float d = 1. - length(max(abs(vUv) - .3, 0.));\n    d += length( min(abs(vUv)-.3,0.) );\n\n    d = fract((d * d + d + d + 2. - (u_time * 0.25)));\n    d =  step(.3,d );\n    d /= smoothstep(0.3, 0.31, d) * smoothstep(0.4, 0.41, d);\n    color += 1. - d;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function oD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 vUv1 = vUv;\n    vUv1 = Rot(vUv1, (u_time * 5.));\n    vUv *= 2. - 1.;\n    vec2 pos = vec2(0.5) - vUv1;\n\n    float r = length(pos) * 5.0;\n    float a = atan(pos.y, pos.x);\n\n    float f = cos(a * 3.);\n\n    float i = smoothstep(f, f + 0.1, r);\n    float r1 = 1. - rect(vec2(vUv.x, vUv.y + 0.27), 0.56, 0.025);\n    color = vec3(i);\n    color *= r1;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function aD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vUv1 = Rot(vUv1, (u_time * 0.5));\n    float i1 = flower(vUv1, 6., 4.0 * cos(u_time * 0.5));\n    float i2 = flower(vUv1, 6., 4.25 * cos(u_time * 0.5));\n    float i3 = flower(vUv1, 6., 2.0 * sin(u_time * 0.25));\n    float i4 = flower(vUv1, 6., 2.25 * sin(u_time * 0.25));\n    float i5 = flower(vUv1, 6., 8.0 * cos(u_time * 0.75));\n    float i6 = flower(vUv1, 6., 8.125 * cos(u_time * 0.75));\n    float i7 = flower(vUv1, 6., 6.0 * sin(u_time * 1.0));\n    float i8 = flower(vUv1, 6., 6.125 * sin(u_time * 1.0));\n    float x1 = i2 - i1;\n    float x2 = i4 - i3;\n    float x3 = i6 - i5;\n    float x4 = i8 - i7;\n    color += x1 + x1;\n    color += x2 + x2;\n    color += x3 + x3;\n    color += x4 + x4;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:iD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n\n    vUv1 = Rot(vUv1, u_time * 0.50);\n    vUv2 = Rot(vUv2, u_time * 0.75);\n    vUv3 = Rot(vUv3, u_time * 0.25);\n    vUv4 = Rot(vUv4, u_time * 1.00);\n    \n    float f1 = flower(vUv1, 4., 4.);\n    color.rg += f1 * sin(u_time);\n\n    float f2 = flower(vUv2, 4., 3.5);\n    color.g += f2 * 0.5 * abs(cos(u_time));\n\n    float f3 = flower(vUv3, 4., 3.);\n    color.r += f3 * 0.25 * abs(sin(u_time));\n\n    float f4 = flower(vUv4, 4., 2.5);\n    color.b += f4 * cos(u_time) * 0.25;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1.0 - smoothstep(size, size + 0.01, d);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vec2 vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time * 0.25);\n\n    vec2 vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time * 0.75);\n\n    vec2 vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time * 0.95);\n\n    vec2 vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time * 0.50);\n    \n    float p1 = polygon(vUv1, 6, 0.5);\n    float p2 = polygon(vUv2, 8, 0.5);\n    float p3 = polygon(vUv3, 7, 0.5);\n    float p4 = polygon(vUv4, 9, 0.5);\n\n    color += p1;\n    color.g -= p2;\n    color.b -= p3;\n    color.r -= p4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return smoothstep(size, size + 0.01, d);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vec2 vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time * 0.25);\n\n    vec2 vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time * 0.75);\n\n    vec2 vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time * 0.95);\n\n    vec2 vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time * 0.50);\n    \n    float p1 = polygon(vUv1, 6, 0.15);\n    float p2 = polygon(vUv2, 8, 0.25);\n    float p3 = polygon(vUv3, 7, 0.35);\n    float p4 = polygon(vUv4, 9, 0.45);\n\n    color -= p1 * cos(u_time);\n    color.g += p2 + cos(u_time);\n    color.b += p3 + sin(u_time);\n    color.r -= p4;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.01 + 0.01, d);\n   return y - x;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5, vUv6;\n    vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time * 1.0);\n\n    vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time * 0.9);\n\n    vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time * 0.8);\n\n    vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time * 0.7);\n\n    vUv5 = vUv;\n    vUv5 = Rot(vUv5, u_time * 0.6);\n\n    vUv6 = vUv;\n    vUv6 = Rot(vUv6, u_time * 0.5);\n\n    float s1 = polygonOutline(vUv1, 6, 0.50);\n    float s2 = polygonOutline(vUv2, 6, 0.45);\n    float s3 = polygonOutline(vUv3, 6, 0.40);\n    float s4 = polygonOutline(vUv4, 6, 0.35);\n    float s5 = polygonOutline(vUv5, 6, 0.30);\n    float s6 = polygonOutline(vUv6, 6, 0.25);\n\n    color += s1 + s2 + s3 + s4 + s5 + s6;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    //vUv = vUv * 2. - 0.5;\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5, vUv6;\n    vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time * 1.0);\n\n    vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time * 0.9);\n\n    vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time * 0.8);\n\n    vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time * 0.7);\n\n    vUv5 = vUv;\n    vUv5 = Rot(vUv5, u_time * 0.6);\n\n    vUv6 = vUv;\n    vUv6 = Rot(vUv6, u_time * 0.5);\n\n    float s1 = polygonOutline(vUv1, 8, 0.5);\n    float s2 = polygonOutline(vUv2, 8, 0.4);\n    float s3 = polygonOutline(vUv3, 8, 0.3);\n    float s4 = polygonOutline(vUv4, 8, 0.2);\n    float s5 = polygonOutline(vUv5, 8, 0.1);\n    float s6 = polygonOutline(vUv6, 8, 0.025);\n\n    color += s1 + s2 + s3 + s4 + s5 + s6;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.0125, size + 0.125 + 0.01, d);\n   return y - x;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 0.5;\n    vec3 color = vec3(0.);\n\n    //vUv = vUv / 2. + 0.25;\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5, vUv6;\n    vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time + 1.0 * (2. * sin(u_time)));\n\n    vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time + 0.9 * (2. * sin(u_time)));\n\n    vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time + 0.8 * (2. * sin(u_time)));\n\n    vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time + 0.7 * (2. * sin(u_time)));\n\n    vUv5 = vUv;\n    vUv5 = Rot(vUv5, u_time + 0.6 * (2. * sin(u_time)));\n\n    vUv6 = vUv;\n    vUv6 = Rot(vUv6, u_time + 0.5 * (2. * sin(u_time)));\n\n    \n\n    float s1 = polygonOutline(vUv1, 3, 0.5);\n    float s2 = polygonOutline(vUv2, 3, 0.4);\n    float s3 = polygonOutline(vUv3, 3, 0.3);\n    float s4 = polygonOutline(vUv4, 3, 0.2);\n    float s5 = polygonOutline(vUv5, 3, 0.1);\n    float s6 = polygonOutline(vUv6, 3, 0.025);\n\n    color.r += s1 + s2 + s3 + s4 + s5 + s6 - 0.6 * (sin(u_time)/15.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.000005, size + 0.225 + 0.01, d);\n   return y - x;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 0.5;\n    vec3 color = vec3(0.);\n\n    //vUv = vUv / 2. + 0.25;\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5, vUv6;\n    vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time + 1.0 * (2. * sin(u_time)));\n\n    vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time + 0.9 * (2. * sin(u_time)));\n\n    vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time + 0.8 * (2. * sin(u_time)));\n\n    vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time + 0.7 * (2. * sin(u_time)));\n\n    vUv5 = vUv;\n    vUv5 = Rot(vUv5, u_time + 0.6 * (2. * sin(u_time)));\n\n    vUv6 = vUv;\n    vUv6 = Rot(vUv6, u_time + 0.5 * (2. * sin(u_time)));\n\n    \n\n    float s1 = polygonOutline(vUv1, 4, 0.5);\n    float s2 = polygonOutline(vUv2, 4, 0.4);\n    float s3 = polygonOutline(vUv3, 4, 0.3);\n    float s4 = polygonOutline(vUv4, 4, 0.2);\n    float s5 = polygonOutline(vUv5, 4, 0.1);\n    float s6 = polygonOutline(vUv6, 4, 0.025);\n\n    color.b += s1 + s2 + s3 + s4 + s5 + s6 - 0.6 * (sin(u_time)/15.);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _D=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.000005, size + 0.225 + 0.01, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv / 2. + 0.25;\n    vec3 color = vec3(0.);\n\n    float x = blobOutline(vUv, 8., 0.5);\n    float y = blob(vUv, 8., 0.5);\n    color = vec3(x + y);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_D,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var SD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //shapes week 1 \n\n// float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.000005, size + 0.225 + 0.01, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 vUv1, vUv2, vUv3, vUv4;\n    vUv1 = vUv;\n    vUv1 = Rot(vUv1, u_time * 0.75);\n\n    vUv2 = vUv;\n    vUv2 = Rot(vUv2, u_time * 1.00);\n\n    vUv3 = vUv;\n    vUv3 = Rot(vUv3, u_time * 0.50);\n\n    vUv4 = vUv;\n    vUv4 = Rot(vUv4, u_time * 1.25);\n\n    float y = spike(vUv1, 5, 0.5);\n    float x = spike(vUv2, 5, 0.25);\n    float z = spike(vUv3, 5, 0.75);\n    float a = spike(vUv4, 5, 0.05);\n    color += y + x + z + a;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function MD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:SD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// // float circle(vec2 vUv, float radius)\n// // {\n// //     vec2 dist = vUv - vec2(0.5);\n// //     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// // }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.521 + 0.01, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nvec2 scale(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 1.0) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 scale2(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 2.0) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 scale3(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 3.0) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 scale4(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 4.0) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 scale5(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 0.6) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    \n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vec2 vUv4 = vUv;\n    vec2 vUv5 = vUv;\n    //vUv1 = Rot(vUv1, u_time * 0.5);\n    vUv2, vUv3, vUv4, vUv5 = vUv1;\n    vUv1 = scale(vUv1);\n    vUv2 = scale2(vUv2);\n    vUv3 = scale3(vUv3);\n    vUv4 = scale4(vUv4);\n    vUv5 = scale5(vUv5);\n    vec2 translate = vec2(cos(u_time), sin(u_time));\n    //vUv1 += translate * 0.25;\n\n    float s1 = polygonOutline(vUv1, 4, 0.15);\n\n    float s2 = polygonOutline(vUv2, 4, 0.25);\n\n    float s3 = polygonOutline(vUv3, 4, 0.35);\n\n    float s4 = polygonOutline(vUv4, 4, 0.45);\n\n    float s5 = polygonOutline(vUv5, 4, 0.55);\n\n    color += s1 + s2 + s3 + s4 + s5;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var CD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.521 + 0.01, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/3.);\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/3.);\n    float r2 = rect(vUv, size/3., size);\n    float r = r1 + r2;\n    float ra = rect(vUv, size + 0.01, size + 0.01/3.);\n    float rb = rect(vUv, size + 0.01, size + 0.02/3.);\n    float rn = ra + rb;\n    return rn - r;\n}\n\nvec2 scale(vec2 vUv){\n    vUv -= vec2(0.5);\n    vUv = vec2(sin(u_time) + 1.0) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5 = vUv;\n    vUv1 = vec2(vUv.x, vUv.y);\n    vUv2 = vec2(vUv.x, vUv.y);\n    vUv3 = vec2(vUv.x, vUv.y);\n    vUv4 = vec2(vUv.x, vUv.y);\n    vUv5 = vec2(vUv.x, vUv.y);\n\n    vUv1 = Rot(vUv1, u_time * 0.50);\n    vUv2 = Rot(vUv2, u_time * 0.45);\n    vUv3 = Rot(vUv2, u_time * 0.35);\n    vUv4 = Rot(vUv2, u_time * 0.25);\n    vUv5 = Rot(vUv2, u_time * 0.15);\n    vec2 translate = (vec2(cos(u_time), sin(u_time)));\n    vUv2 += translate *0.25;\n    vUv3 += translate *0.25;\n    vUv4 += translate *0.25;\n    vUv5 += translate *0.25;\n\n    float s1 = crossSDF(vUv1, 0.15);\n    float s2 = crossSDF(vUv2, 0.15);\n    float s3 = crossSDF(vUv3, 0.15);\n    float s4 = crossSDF(vUv4, 0.15);\n    float s5 = crossSDF(vUv5, 0.15);\n\n    color += s1 + s2 + s3 + s4 + s5;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function TD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:CD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var RD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.521 + 0.01, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vec2 vUv1, vUv2, vUv3, vUv4, vUv5, vUv6, vUv7;\n\n    vUv1 = vUv;\n    vUv2 = vUv;\n    vUv3 = vUv;\n    vUv4 = vUv;\n    vUv5 = vUv;\n    vUv6 = vUv;\n    vUv7 = vUv;\n\n    vUv1 = scale(vUv1, sin(u_time * 0.5));\n    vUv2 = scale(vUv2, sin(u_time * 0.6));\n    vUv3 = scale(vUv3, sin(u_time * 0.7));\n    vUv4 = scale(vUv4, sin(u_time * 0.8));\n    vUv5 = scale(vUv5, sin(u_time * 0.9));\n    vUv6 = scale(vUv6, sin(u_time * 1.0));\n    vUv7 = scale(vUv7, sin(u_time * 1.1));\n\n    float c1 = crossSDFOutline(vUv1, 0.5 * 0.1);\n    float c2 = crossSDFOutline(vUv2, 0.5 * 0.2);\n    float c3 = crossSDFOutline(vUv3, 0.5 * 0.3);\n    float c4 = crossSDFOutline(vUv4, 0.5 * 0.4);\n    float c5 = crossSDFOutline(vUv5, 0.5 * 0.5);\n    float c6 = crossSDFOutline(vUv6, 0.5 * 0.6);\n    float c7 = crossSDFOutline(vUv7, 0.5 * 0.7);\n\n    color += c1 + c2 + c3 + c4 + c5 + c6 + c7;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function DD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:RD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var PD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// // float circle(vec2 vUv, float radius)\n// // {\n// //     vec2 dist = vUv - vec2(0.5);\n// //     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// // }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.02, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.15 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 5.);\n\n    float s1 = polygonOutline(vUv, 6, 1.);\n    float s2 = polygon(vUv, 6, 0.8);\n\n    color += s1 + s2;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function FD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:PD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// // float circle(vec2 vUv, float radius)\n// // {\n// //     vec2 dist = vUv - vec2(0.5);\n// //     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// // }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.01, size + 0.02, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.15 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 5.);\n\n    float s1 = polygonOutline(vUv, 6, 1.);\n    float s2 = polygon(vUv, 6, 0.28);\n\n    color.r += 1. - s2;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ID(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ED=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * sin(a * (x + cos(u_time) + 0.5))) * .02+ .2;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 0.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.15 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 5.);\n\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n\n    vUv1 = Rot(vUv1, u_time * 0.25);\n    vUv2 = Rot(vUv2, -u_time * 0.95);\n\n    float s1 = polygonOutline(vUv1, 4, 0.75);\n    float s2 = polygon(vUv2, 4, 0.5);\n\n    color.r += s1 + s2 * vUv.x * vUv.y * 2.;\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function OD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:ED,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 1.);\n\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    \n    vUv2 = tile(vUv2, 3.);\n\n    vUv1 = Rot(vUv1, u_time * 0.25);\n    vUv2 = Rot(vUv2, -u_time * 0.5);\n\n    float s1 = blobOutline(vUv1, 0.15, 0.36);\n    float s2 = blobOutline(vUv2, 1.15, 1.);\n\n    color += s1 * vUv.x * vUv.y * 2.;\n    color += s2;\n\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:AD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.1, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    return vec3(str * shape );\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    float s1 = circle(vUv, 0.25);\n    vec3 mat = matrix(vUv, s1);\n\n    color = vec3(mat.x * 0.5 * abs(sin(u_time)), mat.y * 0.25 * abs(cos(u_time + 0.5)), mat.z * 0.1 );\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ND(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:GD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var BD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = Rot(vUv, u_time * 0.25);\n\n    float c1 = crossSDF(vUv, 0.6);\n    float s1 = circle(vUv, 0.25);\n    vec3 mat = matrix(vUv, c1);\n\n    color = vec3(mat);\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:BD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var VD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 3.);\n\n    vUv = Rot(vUv, u_time * 0.25);\n\n    float c1 = crossSDF(vUv, 0.61);\n    float s1 = circle(vUv, 0.25);\n    vec3 mat = matrix(vUv, c1);\n\n    color = vec3(mat.x * cos(u_time), mat.y, mat.z * sin(u_time));\n    \n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function WD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:VD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var HD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5, 0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = vUv * 2. - 1.;\n\n    float y = sdRoundedBox(vUv, vec2(0.5, 0.7), vec4(0.5, 0.0, 0.5, 0.0));\n    color += y;\n\n    float t1 =  polygon((vec2(vUv.x+0.86, vUv.y + 1.1)), 3, 0.3);\n\n    float t2 =  polygon((vec2(vUv.x+0.51, vUv.y + 1.1)), 3, 0.3);\n\n    float t3 =  polygon((vec2(vUv.x+0.16, vUv.y + 1.1)), 3, 0.3);\n\n    \n\n    color -= vec3(t1, 0.5, 0.5);\n    color -= vec3(t2, 0.5, 0.5);\n    color -= vec3(t3, 0.5, 0.5);\n\n    float c1 = circle(vec2(vUv.x+ 0.65, vUv.y + 0.2), 0.065);\n    float c2 = circle(vec2(vUv.x+ 0.65, vUv.y + 0.225), 0.065);\n\n    float c3 = circle(vec2(vUv.x+ 0.35, vUv.y + 0.2), 0.065);\n    float c4 = circle(vec2(vUv.x+ 0.35, vUv.y + 0.225), 0.065);\n\n    float c5 = circle(vec2(vUv.x+ 0.725 + ((sin(u_time)/12.) - 0.08), vUv.y + 0.2125), 0.0125);\n    float c6 = circle(vec2(vUv.x+ 0.425 + ((sin(u_time)/12.) - 0.08), vUv.y + 0.2125), 0.0125);\n\n    color += vec3(c1 + c2) * 2.;\n    color += vec3(c3 + c4) * 2.;\n\n    color *= 1. - vec3(c5 + c6);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function XD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:HD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var YD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5, 0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = vUv * 2. - 1.;\n\n    float y = sdRoundedBox(vUv, vec2(0.5, 0.7), vec4(0.5, 0.0, 0.5, 0.0));\n    \n\n    float t1 =  polygon((vec2(vUv.x+0.86 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t1 = smoothstep(0.01, 0.021, t1);\n    float t2 =  polygon((vec2(vUv.x+0.51 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t2 = smoothstep(0.01, 0.021, t2);\n    float t3 =  polygon((vec2(vUv.x+0.16 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t3 = smoothstep(0.01, 0.021, t3);\n    float t4 =  polygon((vec2(vUv.x-0.18 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t4 = smoothstep(0.01, 0.021, t4);\n    float t5 =  polygon((vec2(vUv.x+1.2 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t5 = smoothstep(0.01, 0.021, t5);\n    float t6 =  polygon((vec2(vUv.x+1.55 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t6 = smoothstep(0.01, 0.021, t6);\n    float t7 =  polygon((vec2(vUv.x-0.53 + (sin(u_time)/8.), vUv.y + 1.1)), 3, 0.3);\n    t7 = smoothstep(0.01, 0.021, t7);\n    \n\n    \n\n    float c1 = circle(vec2(vUv.x+ 0.65, vUv.y + 0.2), 0.065);\n    float c2 = circle(vec2(vUv.x+ 0.65, vUv.y + 0.225), 0.065);\n    c1 = smoothstep(0.01, 0.03, c1);\n    c2 = smoothstep(0.01, 0.03, c2);\n    float c3 = circle(vec2(vUv.x+ 0.35, vUv.y + 0.2), 0.065);\n    float c4 = circle(vec2(vUv.x+ 0.35, vUv.y + 0.225), 0.065);\n    c3 = smoothstep(0.01, 0.03, c3);\n    c4 = smoothstep(0.01, 0.03, c4);\n    float c5 = circle(vec2(vUv.x+ 0.725 + ((sin(u_time)/12.) - 0.08), vUv.y + 0.2125), 0.0125);\n    float c6 = circle(vec2(vUv.x+ 0.425 + ((sin(u_time)/12.) - 0.08), vUv.y + 0.2125), 0.0125);\n    c5 = smoothstep(0.01, 0.03, c5);\n    c6 = smoothstep(0.01, 0.03, c6);\n    \n    \n    color = vec3(y, y * 0.75, 0.);\n    color += vec3(c1 + c2) * 2.;\n    color += vec3(c3 + c4) * 2.;\n    color *= 1. - vec3(c5 + c6);\n\n    color -= vec3(t1);\n    color -= vec3(t2);\n    color -= vec3(t3);\n    color -= vec3(t4);\n    color -= vec3(t5);\n    color -= vec3(t6);\n    color -= vec3(t7);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ZD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:YD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5, 0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvec2 rotatedTilepattern(vec2 st)\n{\n    st *= 2.0;\n    float index = 0.0;\n    index += step(1., mod(st.x, 2.0));\n    index += step(1., mod(st.y, 2.0)) * 2.0;\n    st = fract(st);\n    if(index == 1.0){\n        st = Rot(st, PI * 0.5);\n    } else if (index == 2.0){\n        st = Rot(st, PI * -0.5);\n    } else if (index == 3.0){\n        st = Rot(st, PI);\n    }\n    return st;\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 3.);\n\n    vUv = rotatedTilepattern(vUv * 1.);\n\n    vUv = Rot(vUv, PI * u_time * 0.25);\n\n    float x = smoothstep(vUv.x, vUv.y, 0.01);\n    x = smoothstep(0.01, 0.04, x);\n\n    color = vec3(x);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function JD(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:QD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KD=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5, 0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvec2 rotatedTilepattern(vec2 st)\n{\n    st *= 4.0;\n    float index = 0.0;\n    index += step(1., mod(st.x, 2.0));\n    index += step(1., mod(st.y, 2.0)) * 2.0;\n    st = fract(st);\n    if(index == 1.0){\n        st = Rot(st, PI * 0.5);\n    } else if (index == 2.0){\n        st = Rot(st, PI * -0.5);\n    } else if (index == 3.0){\n        st = Rot(st, PI);\n    }\n    return st;\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n\n    vUv = tile(vUv, 1.);\n\n    vUv = rotatedTilepattern(vUv);\n\n    vUv = Rot(vUv, PI * u_time * 0.25);\n\n    float x = polygonOutline(vUv, 4, 0.35);\n    x = smoothstep(0.01, 0.02, x);\n\n    color = vec3(x);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $D(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:KD,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nP=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n//     float rect( vec2 vUv, float height, float width)\n// {\n//     float left = smoothstep(((1.0 - width)/ 2.0), ((1.0 - width)/ 2.0) + 0.01, vUv.x);\n//     float right = smoothstep(((1.0 - width)/2.0), ((1.0 - width)/ 2.0) + 0.01, 1. - vUv.x);\n//     float top = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, 1. - vUv.y);\n//     float bottom = smoothstep(((1.0 - height)/2.0), ((1.0 - height)/2.0) + 0.01, vUv.y);\n//     return left * right * top * bottom;\n// }\n\n// float rectOutline(vec2 vUv, float height, float width)\n// {\n//     float y = rect(vUv, height, width);\n//     float x = rect(vUv, height + 0.01, width + 0.01);\n//     return x - y;\n// }\n\n// float circle(vec2 vUv, float radius)\n// {\n//     vec2 dist = vUv - vec2(0.5, 0.5);\n//     return 1. - smoothstep(radius - (radius * 0.05), radius + (radius * 0.05), dot(dist, dist) * 4.);\n// }\n\n// float cirOutline(vec2 vUv, float r)\n// {\n//     vec2 dist = vUv - vec2(0.5);\n//     float a = 1. - smoothstep(r - (r * 0.05), r + (r * 0.05), dot(dist, dist) * 4.);\n//     float b = 1. - smoothstep(r + 0.01 - ((r + 0.01) * 0.05), r + 0.01 + ((r + 0.01) * 0.05), dot(dist, dist) * 4.);\n//     return b - a;\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nfloat flower(vec2 vUv, float n, float zoom)\n{\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * zoom;\n    float a = atan(pos.y, pos.x);\n    float f = cos(a * n );\n    return smoothstep(f, f + 0.25, r );\n}\n\nfloat polygon(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n    return 1. - smoothstep(size, size + 0.01, d);\n}\n\nfloat polygonOutline(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) + PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.04, size + 0.65, d);\n   return y - x;\n}\n\nfloat blob(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(r * (x + sin(u_time) + 0.5))) * .05+ .1;\n    return 1. - smoothstep(f, f+0.01, r);\n}\n\nfloat blobOutline(vec2 vUv, float x, float y){\n    vec2 pos = vec2(0.5) - vUv;\n    float r = length(pos) * 2.0;\n    float a = atan(pos.y, pos.x);\n    float f = abs(cos(a * 13.) * cos(a * (x + sin(u_time) + 1.5))) * .1+ .3;\n    float m = 1. - smoothstep(f, f+0.01, r);\n    float n = 1. - smoothstep(f+ 0.05, f+0.06, r);\n    return n - m;\n}\n\nfloat spike(vec2 vUv, int N, float size)\n{\n    vUv = vUv * 2. - 1.;\n    //vUv = vUv * (2. * sin(u_time)) - (1. * sin(u_time));\n    float a = atan(vUv.x, vUv.y) * PI;\n    float r = TWO_PI/float(N);\n    float d = cos(floor(.5+a/r) * r -a) * length(vUv);\n   float x = 1. - smoothstep(size, size + 0.01, d);\n   float y = 1. - smoothstep(size + 0.05, size + 0.05 + 0.01, d);\n   return y - x;\n}\n\nfloat crossSDF(vec2 vUv, float size)\n{\n    float r1 = rect(vUv, size, size/(3.));\n    float r2 = rect(vUv, size/3., size);\n    return r1 + r2;\n}\n\nfloat crossSDFOutline(vec2 vUv, float size)\n{\n    float r1 = crossSDF(vUv, size);\n    float r2 = crossSDF(vUv, size + (size * 0.1));\n    return r2 - r1;\n}\n\nvec2 scale(vec2 vUv, float time){\n    vUv -= vec2(0.5);\n    vUv = vec2(time + 1.5) * vUv;\n    vUv += vec2(0.5);\n    return vUv;\n}\n\nvec2 tile(vec2 vUv, float zoom)\n{\n    vUv *= zoom;\n    float time = 0.075 * u_time;\n    if(fract(time) >  0.5)\n    {\n        if(fract(vUv.y * 0.5) > 0.5)\n        {\n            vUv.x += fract(time) * 2.0;\n        } \n        else \n        {\n            vUv.x -= fract(time) * 2.0;\n        }\n    } else {\n        if(fract(vUv.x * 0.5) > 0.5)\n        {\n            vUv.y += fract(time) * 2.0;\n        }\n        else \n        {\n            vUv.y -= fract(time) * 2.0;\n        }\n    }\n    return fract(vUv);\n}\n\nvec2 rotatedTilepattern(vec2 st)\n{\n    st *= 4.0;\n    float index = 0.0;\n    index += step(1., mod(st.x, 2.0));\n    index += step(1., mod(st.y, 2.0)) * 2.0;\n    st = fract(st);\n    if(index == 1.0){\n        st = Rot(st, PI * 0.5);\n    } else if (index == 2.0){\n        st = Rot(st, PI * -0.5);\n    } else if (index == 3.0){\n        st = Rot(st, PI);\n    }\n    return st;\n}\n\nfloat randFloat(float x){\n    return fract(sin(x) * 4748393.7585);\n}\n\nfloat randVec2(vec2 vUv){\n    return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n}\n\nvec3 matrix(vec2 vUv, float s){\n    float rows = 15.0;\n    vec2 a = floor(vUv * rows) + vec2(0.9, 0.4);\n    a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n    vec2 b = fract(vUv * rows);\n    vec2 newUv = 0.5 - b;\n    float str = randVec2(a);\n    float shape = smoothstep(0.01, 0.1, (1. - dot(newUv, newUv) * 5.) * 1.);\n    float s1 = s * shape;\n    return vec3(str * s1 );\n}\n\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float val1 = (sin(u_time * 0.5)/2.);\n    float val2 = (sin(u_time * 1.0)/3.);\n    float val3 = (sin(u_time * 1.5)/4.);\n    float val4 = (sin(u_time * 2.0)/5.);\n\n    float x = sdRoundedBox(vUv, vec2(0.5, 0.5), vec4(0.0 + val1, 0.0 + val2, 0.0 + val3, 0.0 + val4));\n\n    color = vec3(x);\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function eP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tP=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //iquilezles.org/articls/distfunctions2d\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\n// float sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n// {\n//     //x - thickness\n//     float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n//     float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n//     return (c - a);\n// }\n\n// float sdBox(vec2 p, vec2 b)\n// {\n//     //p - point \n//     //b -\n//     p = p * 2.0 - 1.; \n//     vec2 d = abs(p) - b;\n//     float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n//     float y = length(max(d, 0.0)) + min(max(d.x + 0.01, d.y + 0.01), 0.0);\n//     return smoothstep(0.01, 0.11, y / x);\n// }\n\n// float sdCircle(vec2 p, float r)\n// {\n//     p = p * 2.0 - 1.;\n//     float x = length(p) - r;\n//     return 1. - smoothstep(0.01, 0.02, x);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    float val1 = (sin(u_time * 0.5)/2.);\n    float val2 = (sin(u_time * 1.0)/3.);\n    float val3 = (sin(u_time * 1.5)/4.);\n    float val4 = (sin(u_time * 2.0)/5.);\n\n    float x = sdRoundedBox(vec2(vUv.x, vUv.y + 0.125), vec2(0.2, 0.125), vec4(0.0, 0.14, 0.0, 0.14));\n    float x1 = sdRoundedBox(vec2(vUv.x, vUv.y + 0.125), vec2(0.15 * (sin(u_time)/5. + 1.), 0.08), vec4(0.0, 0.08, 0.0, 0.08));\n    float y = sdRoundedBoxOutline(vUv, vec2(0.4, 0.45), vec4(0.1, 0.25, 0.1, 0.25), 0.02);\n    float z = sdCircle(vec2(vUv.x - 0.1, vUv.y - 0.1), 0.1);\n    float z1 = sdCircle(vec2(vUv.x - 0.1, vUv.y - 0.1), 0.05);\n    float a = sdCircle(vec2(vUv.x + 0.1, vUv.y - 0.1), 0.1);\n    float a1 = sdCircle(vec2(vUv.x + 0.1, vUv.y - 0.1), 0.05);\n\n    color = vec3(x + y + z + a);\n    color -= z1 + a1 + x1;\n\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function oP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rP=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //iquilezles.org/articls/distfunctions2d\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\n// float sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n// {\n//     //x - thickness\n//     float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n//     float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n//     return (c - a);\n// }\n\n// float sdBox(vec2 p, vec2 b)\n// {\n//     //p - point \n//     //b -\n//     p = p * 2.0 - 1.; \n//     vec2 d = abs(p) - b;\n//     float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n//     float y = length(max(d, 0.0)) + min(max(d.x + 0.01, d.y + 0.01), 0.0);\n//     return smoothstep(0.01, 0.11, y / x);\n// }\n\n// float sdCircle(vec2 p, float r)\n// {\n//     p = p * 2.0 - 1.;\n//     float x = length(p) - r;\n//     return 1. - smoothstep(0.01, 0.02, x);\n// }\n\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p-a;\n//     vec2 ba = b-a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    //vUv = vUv * 2. - 1.;\n    vec2 vUv2 = vUv;\n    vUv2 = Rot(vUv2, PI * 0.5 );\n    vec3 color = vec3(0.);\n    float y =1. - smoothstep(0.01, 0.014, sdSegment(vec2(vUv.x, vUv.y), vec2(0.75 + (sin(u_time)/3.)), vec2(-0.75 + (cos(u_time)/3.))));\n    float x = sdSegment(vec2(vUv.x, vUv.y), vec2(0.75 + (sin(u_time)/3.)), vec2(-0.75 + (cos(u_time)/3.)));\n    float y1 =1. - smoothstep(0.01, 0.014, sdSegment(vec2(vUv2.x, vUv2.y), vec2(0.75 + (cos(u_time)/3.)), vec2(-0.75 + (cos(u_time)/3.))));\n    float x1 = sdSegment(vec2(vUv2.x, vUv2.y), vec2(0.75 + (sin(u_time)/4.)), vec2(-0.75 + (cos(u_time)/4.)));\n    color.g += y;\n    color.r += y1;\n    color.g += x;\n    color.r += x1;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function aP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iP=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //iquilezles.org/articls/distfunctions2d\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\n// float sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n// {\n//     //x - thickness\n//     float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n//     float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n//     return (c - a);\n// }\n\n// float sdBox(vec2 p, vec2 b)\n// {\n//     //p - point \n//     //b -\n//     p = p * 2.0 - 1.; \n//     vec2 d = abs(p) - b;\n//     float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n//     float y = length(max(d, 0.0)) + min(max(d.x + 0.01, d.y + 0.01), 0.0);\n//     return smoothstep(0.01, 0.11, y / x);\n// }\n\n// float sdCircle(vec2 p, float r)\n// {\n//     p = p * 2.0 - 1.;\n//     float x = length(p) - r;\n//     return 1. - smoothstep(0.01, 0.02, x);\n// }\n\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p-a;\n//     vec2 ba = b-a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\n// float ndot(vec2 a, vec2 b)\n// {\n//     return a.x * b.x - a.y * b.y;\n// }\n\n// float sdRhombus(vec2 p, vec2 b)\n// {\n//     p = abs(p);\n//     float h = clamp(ndot(b-2. *p, b) / dot(b, b), -1., 1.);\n//     float d = length(p - 0.5* b*vec2(1.0-h, 1.0+h));\n//     return d * sign(p.x * b.y + p.y * b.x - b.x*b.y);\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 2. - 1.;\n    vec3 color = vec3(0.);\n    vec2 vUv2 = vUv;\n    vUv2 = Rot(vUv2, PI * 0.5 );\n    float x = sdRhombus(vUv, vec2(0.5 * (sin(u_time)/4. + 1.), 0.75 * (sin(u_time)/4. + 1.)));\n    float x1 = sdRhombus(vUv, vec2(0.5 * (sin(u_time)/4. + 1.), 0.75 * (sin(u_time)/4. + 1.)));\n    float y = sdRhombus(vec2(vUv.x, vUv.y - 0.05), vec2(0.5 * (sin(u_time)/4. + 1.), 0.25 * (sin(u_time)/4. + 1.)));\n    float y1 = sdRhombus(vec2(vUv.x, vUv.y), vec2(0.5 * (sin(u_time)/4. + 1.), 0.25 * (sin(u_time)/4. + 1.)));\n    color.g = 1. -  smoothstep(0.01, 0.014, x);\n    color.b -= 1. - smoothstep(0.01, 0.014, y);\n    color.br += x1;\n    color.rgb += 1. - smoothstep(0.01, 0.014, y1);\n    \n    color -= step(0., vUv.x) * 0.1;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:iP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cP=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //iquilezles.org/articls/distfunctions2d\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\n// float sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n// {\n//     //x - thickness\n//     float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n//     float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n//     return (c - a);\n// }\n\n// float sdBox(vec2 p, vec2 b)\n// {\n//     //p - point \n//     //b -\n//     p = p * 2.0 - 1.; \n//     vec2 d = abs(p) - b;\n//     float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n//     float y = length(max(d, 0.0)) + min(max(d.x + 0.01, d.y + 0.01), 0.0);\n//     return smoothstep(0.01, 0.11, y / x);\n// }\n\n// float sdCircle(vec2 p, float r)\n// {\n//     p = p * 2.0 - 1.;\n//     float x = length(p) - r;\n//     return 1. - smoothstep(0.01, 0.02, x);\n// }\n\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p-a;\n//     vec2 ba = b-a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\n// float ndot(vec2 a, vec2 b)\n// {\n//     return a.x * b.x - a.y * b.y;\n// }\n\n// float sdRhombus(vec2 p, vec2 b)\n// {\n//     p = abs(p);\n//     float h = clamp(ndot(b-2. *p, b) / dot(b, b), -1., 1.);\n//     float d = length(p - 0.5* b*vec2(1.0-h, 1.0+h));\n//     return d * sign(p.x * b.y + p.y * b.x - b.x*b.y);\n// }\n\n// float dot2(vec2 a)\n// {\n//     return dot(a.x, a.y);\n// }\n\n// float trapezoid(vec2 p, float r1, float r2, float he)\n// {\n//     vec2 k1 = vec2(r2, he);\n//     vec2 k2 = vec2(r2-r1, 2.0 * he);\n//     p.x = abs(p.x);\n//     vec2 ca = vec2(p.x-min(p.x, (p.y<0.)?r1:r2), abs(p.y)-he);\n//     vec2 cb = p - k1 + k2 * clamp(dot(k1-p,k2)/dot2(k2), 0., 1.);\n//     float s = (cb.x < 0. && ca.y<0.)? -1.: 1.;\n//     return s*sqrt(min(dot(ca, ca),dot(cb, cb)));\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 15. - 7.5;\n    vec3 color = vec3(0.);\n    vUv = Rot(vUv, (u_time));\n    float x =1. - trapezoid(vUv, 0.8, 0.2, 2. + sin(u_time));\n    x = smoothstep(0.01, 0.081, x);\n    color += x;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lP=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n    //iquilezles.org/articls/distfunctions2d\n// float sdRoundedBox(vec2 p, vec2 b, vec4 r)\n// {\n//     //p - point\n//     //b - size of box\n//     //r - round box - top right, bottom right, top left, bottom left\n//     p = p * 2.0 - 1.;\n//     r.xy = (p.x > 0.0) ? r.xy : r.zw;\n//     r.x = (p.y > 0.0) ? r.x : r.y;\n//     vec2 q = abs(p)-b+r.x;\n//     float v =  min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n//     return 1. - smoothstep(0.01, 0.02, v);\n// }\n\n// float sdRoundedBoxOutline(vec2 p, vec2 b, vec4 r, float x)\n// {\n//     //x - thickness\n//     float a = sdRoundedBox(vec2(p), vec2(b), vec4(r));\n//     float c = sdRoundedBox(vec2(p), vec2(b.x + x, b.y + x), vec4(r));\n//     return (c - a);\n// }\n\n// float sdBox(vec2 p, vec2 b)\n// {\n//     //p - point \n//     //b -\n//     p = p * 2.0 - 1.; \n//     vec2 d = abs(p) - b;\n//     float x = length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n//     float y = length(max(d, 0.0)) + min(max(d.x + 0.01, d.y + 0.01), 0.0);\n//     return smoothstep(0.01, 0.11, y / x);\n// }\n\n// float sdCircle(vec2 p, float r)\n// {\n//     p = p * 2.0 - 1.;\n//     float x = length(p) - r;\n//     return 1. - smoothstep(0.01, 0.02, x);\n// }\n\n// float sdSegment(vec2 p, vec2 a, vec2 b)\n// {\n//     vec2 pa = p-a;\n//     vec2 ba = b-a;\n//     float h = clamp(dot(pa, ba)/dot(ba,ba), 0., 1.);\n//     return length(pa - ba * h);\n// }\n\n// vec2 Rot(vec2 vUv, float a){\n//     vUv -= 0.5;\n//     vUv = mat2(cos(a), -sin(a),\n//                sin(a), cos(a)) * vUv;\n//     vUv += 0.5;\n//     return vUv;\n// }\n\n// float ndot(vec2 a, vec2 b)\n// {\n//     return a.x * b.x - a.y * b.y;\n// }\n\n// float sdRhombus(vec2 p, vec2 b)\n// {\n//     p = abs(p);\n//     float h = clamp(ndot(b-2. *p, b) / dot(b, b), -1., 1.);\n//     float d = length(p - 0.5* b*vec2(1.0-h, 1.0+h));\n//     return d * sign(p.x * b.y + p.y * b.x - b.x*b.y);\n// }\n\n// float dot2(vec2 a)\n// {\n//     return dot(a.x, a.y);\n// }\n\n// float trapezoid(vec2 p, float r1, float r2, float he)\n// {\n//     vec2 k1 = vec2(r2, he);\n//     vec2 k2 = vec2(r2-r1, 2.0 * he);\n//     p.x = abs(p.x);\n//     vec2 ca = vec2(p.x-min(p.x, (p.y<0.)?r1:r2), abs(p.y)-he);\n//     vec2 cb = p - k1 + k2 * clamp(dot(k1-p,k2)/dot2(k2), 0., 1.);\n//     float s = (cb.x < 0. && ca.y<0.)? -1.: 1.;\n//     return s*sqrt(min(dot(ca, ca),dot(cb, cb)));\n// }\n\n// float sdEqTriangle(vec2 p, float size)\n// {\n//     p = p / size;\n//     float k = sqrt(3.);\n//     p.x = abs(p.x) - 1.;\n//     p.y = p.y + 1.0/k;\n//     if(p.x+k*p.y > 0.)\n//     {\n//         p = vec2(p.x-k*p.y, -k*p.x-p.y)/2.0; \n//     }\n//     p.x -= clamp(p.x, -2., 0.);\n//     return -length(p) * sign(p.y);\n// }\n\n// float sdEqTriangleOutline(vec2 p, float size)\n// {\n//     float x = 1. - sdEqTriangle(p, size);\n//     float y = 1. - sdEqTriangle(p, size + 0.025);\n//     x = smoothstep(0.01, 0.021, x);\n//     y = smoothstep(0.01, 0.021, y);\n//     return y - x;\n// }\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = vUv * 5. - 2.5;\n    vec3 color = vec3(0.);\n    vec2 vUv1 = vUv;\n    vec2 vUv2 = vUv;\n    vec2 vUv3 = vUv;\n    vUv1 = Rot(vUv1, (u_time));\n    vUv2 = Rot(vUv2, (u_time));\n    vUv3 = Rot(vUv3, (u_time));\n    // vUv = Rot(vUv, (u_time));\n    float x = sdEqTriangleOutline(vUv1, 0.4);\n    float y = sdEqTriangleOutline(vUv2, 0.25);\n    float z = sdEqTriangleOutline(vUv3, 0.125);\n    //x = smoothstep(0.01, 0.021, x);\n    color += x + y + z ;\n    gl_FragColor = vec4(color, 1.);\n}\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fP=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n        void main()\n        {\n            vec2 vUv = vec2(vUv.x, vUv.y);\n            vUv = vUv * 2.;\n            //vUv.y -= 0.25;\n            vec2 vUv2 = vUv;\n            vUv2 -= 1.;\n            vUv2 = Rot(vUv2, PI);\n            vec3 color = vec3(0.);\n            float y = sdTriIsosceles(vUv, vec2(0.25 +(sin(u_time)/4.), 0.5 +(cos(u_time)/4.)));\n            float x = sdTriIsosceles(vUv2, vec2(0.25 +(cos(u_time)/4.), 0.5 +(sin(u_time)/4.)));\n            y = 1. - smoothstep(0.01, 0.021, y);\n            x = 1. - smoothstep(0.01, 0.021, x);\n            color += y;\n            color += x;\n            gl_FragColor = vec4(color, 1.);\n        }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vUv = Rot(vUv, u_time * 0.2);\n    vUv = vUv * 2.;\n    \n    //vUv.y -= 0.25;\n    vec2 vUv2 = vUv;\n    vUv2 -= 1.;\n    vec2 vUv3 = vUv;\n    vUv3 -= 1.;\n    vUv3.y += 1.;\n    vec2 vUv4 = vUv;\n    vUv4 -= 1.;\n    vUv4.x += 1.;\n    vUv2 = Rot(vUv2, PI);\n    vUv3 = Rot(vUv3, PI * 0.5);\n    \n    vUv4 = Rot(vUv4, PI * -0.5);\n    vec3 color = vec3(0.);\n    float y = sdTriIsosceles(vUv, vec2(0.25 +(sin(u_time)/4.), 0.5 +(cos(u_time)/4.)));\n    float x = sdTriIsosceles(vUv2, vec2(0.25 +(cos(u_time)/4.), 0.5 +(sin(u_time)/4.)));\n    float y2 = sdTriIsosceles(vUv3, vec2(0.25 +(cos(u_time)/4.), 0.5 +(sin(u_time)/4.)));\n    float x2 = sdTriIsosceles(vUv4, vec2(0.25 +(sin(u_time)/4.), 0.5 +(cos(u_time)/4.)));\n    y = 1. - smoothstep(0.01, 0.021, y);\n    x = 1. - smoothstep(0.01, 0.021, x);\n    y2 = 1. - smoothstep(0.01, 0.021, y2);\n    x2 = 1. - smoothstep(0.01, 0.021, x2);\n    color.g += y + y2;\n    color.r += x + x2;\n    gl_FragColor = vec4(color, 1.);\n}\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\nvoid main()\n{\n    vec2 vUv = vec2(vUv.x, vUv.y);\n    vec3 color = vec3(0.);\n    vec2 onevUv = vUv;\n    vec2 vUvy2 = vUv;\n    vUv = vUv * 2. - 0.5;\n    vec2 twovUv = vUv;\n    twovUv = twovUv * 2. - 1.;\n    twovUv.x -= 0.5;\n    \n    onevUv = Rot(onevUv, PI * -0.25);\n    float one = sdRoundedBox(vec2(vUv.x + 0.275, vUv.y), vec2(0.17, 0.85), vec4(0.1, 0.1, 0.1, 0.1));\n    float oneP = sdRoundedBox(vec2(onevUv.x + 0.24, onevUv.y + 0.05), vec2(0.07, 0.2), vec4(0.1, 0.075, 0.1, 0.075));\n    \n    // color += one;\n    float a = PI * (0.5 + 0.25);\n    float b = 0.2 *(0.5 + 0.5);\n    twovUv = Rot(twovUv, PI * 1.85);\n    float y1 = sdArc(vec2(twovUv.x - 0.1, twovUv.y - 0.15), vec2(a * 0.8, a * 0.8), .35, b * 0.84 );\n    y1 = smoothstep(0.0, 0.015, y1); //yellow\n    vUvy2 = Rot(vUvy2, PI * -0.22);\n    float y2 = sdRoundedBox(vec2(vUvy2.x - 0.122, vUvy2.y - 0.05), vec2(0.075, 0.35), vec4(0.2, 0.1, 0.1, 0.1));\n    float y3 = sdRoundedBox(vec2(vUv.x - 0.25, vUv.y + 0.335), vec2(0.5, 0.155), vec4(0.1, 0.1, 0.1, 0.1));\n    color += y1;\n    color -= one;\n    color -= y2;\n    color -= y3; \n    color -= oneP;\n    gl_FragColor = vec4(color, 1.);\n}\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        // vUv = vUv * 2. - 0.5;\n        float one = sdOne(vec2(vUv.x + 0.35, vUv.y));\n        // color += one;\n        float two = sdTwo(vec2(vUv.x + 0.05, vUv.y));\n        // color += two;\n        float three = sdThree(vec2(vUv.x, vUv.y));\n        color += three;\n        // color += one;\n        // color += two;\n\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = vUv * 2. - 0.5;\n        float one = sdOne(vec2(vUv.x + 0.5 * sin(u_time), vUv.y - 0.5 * cos(u_time)));\n        color += one;\n        float two = sdTwo(vec2(vUv.x + 0.5 * sin(u_time), vUv.y + 0.5 * cos(u_time)));\n        color += two;\n        float three = sdThree(vec2(vUv.x - 0.5 * cos(u_time), vUv.y - 0.5 * sin(u_time)));\n        color += three;\n        float four = sdFour(vec2(vUv.x - 0.5 * cos(u_time), vUv.y + 0.5 * sin(u_time)));\n        color += four;\n\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _P=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vUv = vUv * 2. - 0.5;\n        float one = sdOne(vec2(vUv.x + 0.5 * sin(u_time), vUv.y - 0.5 * cos(u_time)));\n        color += one;\n        float two = sdTwo(vec2(vUv.x + 0.5 * sin(u_time), vUv.y + 0.5 * cos(u_time)));\n        color += two;\n        float three = sdThree(vec2(vUv.x - 0.5 * cos(u_time), vUv.y - 0.5 * sin(u_time)));\n        color += three;\n        float four = sdFour(vec2(vUv.x - 0.5 * cos(u_time), vUv.y + 0.5 * sin(u_time)));\n        color += four;\n        float five = sdFive(vec2(vUv.x + (sin(u_time)*0.5), vUv.y));\n        color += five;\n\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_P,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var SP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    float randFloat(float x){\n        return fract(sin(x) * 4748393.7585);\n    }\n    \n    float randVec2(vec2 vUv){\n        return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n    }\n    \n    vec3 matrix(vec2 vUv){\n        float rows = 15.0;\n        vec2 a = floor(vUv * rows);\n        a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n        vec2 b = fract(vUv * rows);\n        vec2 newUv = 0.5 - b;\n        float str = randVec2(a);\n        float one = sdOne(b);\n        float zero = sdZero(b);\n        float shape;\n        if(str > .5 )\n        {\n            shape = smoothstep(0.01, 0.011, one);\n        } else {\n            shape = smoothstep(0.01, 0.011, zero);\n        }\n        \n        return vec3(shape * str );\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        // vUv = vUv * 2. - 0.5;\n        float one = sdOne(vec2(vUv.x , vUv.y ));\n        // color += one;\n        float zero = sdZero(vUv);\n        // color += zero;\n        // float two = sdTwo(vec2(vUv.x + 0.5 * sin(u_time), vUv.y + 0.5 * cos(u_time)));\n        // color += two;\n        // float three = sdThree(vec2(vUv.x - 0.5 * cos(u_time), vUv.y - 0.5 * sin(u_time)));\n        // color += three;\n        // float four = sdFour(vec2(vUv.x - 0.5 * cos(u_time), vUv.y + 0.5 * sin(u_time)));\n        // color += four;\n        // float five = sdFive(vec2(vUv.x + (sin(u_time)*0.5), vUv.y));\n        // color += five;\n        vec3 m = matrix(vUv);\n        color.g += m.x * 1.5;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function MP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:SP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float randFloat(float x){\n        return fract(sin(x) * 4748393.7585);\n    }\n    \n    float randVec2(vec2 vUv){\n        return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n    }\n    \n    vec3 matrix(vec2 vUv){\n        float rows = 8.0;\n        vec2 a = floor(vUv * rows);\n        a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n        vec2 b = fract(vUv * rows);\n        vec2 newUv = 0.5 - b;\n        float str = randVec2(a);\n        float shape;\n        float zero = sdZero(b);\n        float one = sdOne(b);\n        float two = sdTwo(b);\n        float three = sdThree(b);\n        float four = sdFour(b);\n        float five = sdFive(b);\n        float six = sdSix(b);\n         if(str > 0.0 && str < 0.1 ){\n            shape = smoothstep(0.01, 0.011, zero);\n        }if(str > 0.1 && str < 0.2 ) {\n            shape = smoothstep(0.01, 0.011, one);\n        }if(str > 0.2 && str < 0.3 ) {\n            shape = smoothstep(0.01, 0.011, two);\n        }if(str > 0.3 && str < 0.4 ) {\n            shape = smoothstep(0.01, 0.011, three);\n        }if(str > 0.4 && str < 0.5 ) {\n            shape = smoothstep(0.01, 0.011, four);\n        }if(str > 0.5 && str < 0.6 ) {\n            shape = smoothstep(0.01, 0.011, five);\n        }if(str > 0.6 && str < 0.7 ) {\n            shape = smoothstep(0.01, 0.011, six);\n        }if(str > 0.7 && str < 0.8 ) {\n            shape = smoothstep(0.01, 0.011, two);\n        }if(str > 0.8 && str < 0.9 ) {\n            shape = smoothstep(0.01, 0.011, three);\n        }if(str > 0.9 && str < 1.0 ) {\n            shape = smoothstep(0.01, 0.011, four);\n        }\n        \n        return vec3(shape * str );\n    }\n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec3 m = matrix(vUv);\n        m.x *= sin(u_time * 0.25);\n        m.y *= cos(u_time * 0.25);\n        color = m * 2.5;\n       \n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var CP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float randFloat(float x){\n        return fract(sin(x) * 4748393.7585);\n    }\n    \n    float randVec2(vec2 vUv){\n        return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n    }\n    \n    vec3 matrix(vec2 vUv){\n        float rows = 15.0;\n        vec2 a = floor(vUv * rows);\n        a += vec2(1., floor(u_time * 6. * randFloat(a.x)));\n        vec2 b = fract(vUv * rows);\n        vec2 newUv = 0.5 - b;\n        float str = randVec2(a);\n        float shape;\n        float zero = sdZero(b);\n        float one = sdOne(b);\n        float two = sdTwo(b);\n        float three = sdThree(b);\n        float four = sdFour(b);\n        float five = sdFive(b);\n        float six = sdSix(b);\n        float seven = sdSeven(b);\n        float eight = sdEight(b);\n        float nine = sdNine(b);\n         if(str >= 0.0 && str < 0.1 ){\n            shape = zero;\n        }if(str >= 0.1 && str < 0.2 ) {\n            shape = one;\n        }if(str >= 0.2 && str < 0.3 ) {\n            shape = two;\n        }if(str >= 0.3 && str < 0.4 ) {\n            shape = three;\n        }if(str >= 0.4 && str < 0.5 ) {\n            shape = four;\n        }if(str >= 0.5 && str < 0.6 ) {\n            shape = five;\n        }if(str >= 0.6 && str < 0.7 ) {\n            shape = six;\n        }if(str >= 0.7 && str < 0.8 ) {\n            shape = seven;\n        }if(str >= 0.8 && str < 0.9 ) {\n            shape = eight;\n        }if(str >= 0.9 && str < 1.0 ) {\n            shape = nine;\n        }\n        return vec3(shape);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec3 m = matrix(vUv);\n        // m.x *= sin(u_time * 0.25) + 2.;\n        // m.y *= cos(u_time * 0.25) ;\n        color = m;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function TP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:CP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var RP=new qa({vertexShader:"\n    varying vec2 vUv;\n    \n    void main()\n    {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n    }",fragmentShader:qh+Vh+Bh+"\n\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdTwo(vec2(p.x, p.y));\n        float right = sdFive(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    float hexagramOutline(vec2 p, float size)\n    {\n        float x = sdHexagram(p, size);\n        x = 1. - smoothstep(0.01, 0.02, x);\n        float y = sdHexagram(p, size * 0.95);\n        y = 1. - smoothstep(0.01, 0.02, y);\n        return x - y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time);\n        newUv = newUv * 2. - 1.;\n        vec2 uv2 = newUv;\n        uv2 *= ((sin(u_time) / 1.25) - 2.);\n        float hexagram = sdHexagram(newUv, 0.25);\n        hexagram = 1. - smoothstep(0.01, 0.02, hexagram);\n        color += hexagram;\n        float hexOutline = hexagramOutline(newUv, 0.28);\n        color += hexOutline;\n        float hexOutline2 = hexagramOutline(uv2, 0.2);\n        color -= hexOutline2;\n        float shaderLabel = label(vUv);\n        color += shaderLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n    ",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function DP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:RP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var PP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdTwo(vec2(p.x, p.y));\n        float right = sdSix(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        vec2 vUv2 = vUv;\n        float s1 = sdSegment(vUv, vec2(0.5 + (sin(u_time)/2.5),0.5 + (cos(u_time) / 2.5)), vec2(0.5, 0.5));\n        float s2 = sdSegment(vUv2, vec2(0.5 + (sin(u_time * 0.5)/5.), 0.5 + (cos(u_time * 0.5) / 5.)), vec2(0.5, 0.5));\n        s1 = 1. - smoothstep(0.01, 0.012, s1);\n        s2 = 1. - smoothstep(0.01, 0.012, s2);\n        color.r += s1;\n        color.g += s2;\n        float shaderLabel = label(vUv);\n        color += shaderLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function FP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:PP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdTwo(vec2(p.x, p.y));\n        float right = sdSeven(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 evUv = vUv;\n        evUv = evUv * 2. - 1.;\n        float e1 = sdEgg(evUv, 0.5, 0.25);\n        e1 = 1. - smoothstep(0.01, 0.02, e1);\n        color += e1;\n\n        float s1 = sdSegment(vUv, vec2(0.45, 0.5), vec2(0.45, 0.1));\n        float s2 = sdSegment(vUv, vec2(0.55, 0.5), vec2(0.55, 0.1));\n        s1 = 1. - smoothstep(0.01, 0.015, s1);\n        s2 = 1. - smoothstep(0.01, 0.015, s2);\n        color += s1 + s2;\n\n        float numberLabel = label(vUv);\n        color += numberLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function IP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdTwo(vec2(p.x, p.y));\n        float right = sdEight(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 5. - 2.5;\n        p.y -= 1.25;\n        p.x += 0.5;\n        float c;\n        float steps = 15.;\n        for(float i = 1.; i < steps; i++)\n        {\n            c += sdCircle(vec2(p.x  + i/ 4. * (sin(u_time * i * 0.25)), p.y + i / 4. ), a);\n        }\n        \n        return c;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float x = newfunc(vUv, 0.25);\n        color += x;\n        float num = label(vUv);\n        color += num;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function OP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:EP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdTwo(vec2(p.x, p.y));\n        float right = sdNine(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 8. - 4.;\n        //p.y -= 1.25;\n        p.x += 0.5;\n        p.y += 0.5;\n        float c;\n        float steps = 25.;\n        for(float i = 1.; i < steps; i++)\n        {\n            c += sdCircle(vec2(p.x  + i/ 4. * (sin(u_time * i * 0.25)), p.y + i / 12. * (cos(u_time * i * 0.25)) ), a);\n        }\n        return c;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        float y = newfunc(vUv, 0.25);\n        color += y;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:AP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdZero(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n    float sdCircleHighlight(vec2 p, float r)\n    {\n        p = p * 2.0 - 1.;\n        float x = length(p) - r;\n        return 1. - smoothstep(0.01, 1.5, x);\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 8. - 4.;\n        //p.y -= 1.25;\n        p.x += 0.5;\n        p.y += 0.5;\n        float c;\n        float d;\n        float e;\n        float f;\n        float steps = 25.;\n        for(float i = 1.; i < steps; i++)\n        {\n            c += sdCircle(vec2(p.x  + i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y + i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n            d += sdCircle(vec2(p.x  - i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y - i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n            e += sdCircleHighlight(vec2(p.x  + i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y + i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n            f += sdCircleHighlight(vec2(p.x  - i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y - i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n        }\n        e *= 0.25;\n        f *= 0.25;\n        return c + d + e + f ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        gl_FragColor = vec4(color, 1.);\n    } \n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function NP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:GP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var BP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdOne(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n    \n    float newfunc(vec2 p, float a)\n    {\n        p = p * 8. - 4.;\n        // //p.y -= 1.25;\n        p.x += 0.5;\n        p.y += 0.5;\n        p*= 0.5;\n        // float c;\n        // float d;\n        // float steps = 25.;\n        // for(float i = 1.; i < steps; i++)\n        // {\n        //     c += sdCircle(vec2(p.x  + i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y + i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n        //     d += sdCircle(vec2(p.x  - i/ 5. * (sin(u_time * i * 0.5 * 0.2)), p.y - i / 5. * (cos(u_time * i * 0.5 * 0.2)) ), a);\n            \n        // }\n        // return c + d;\n        float b;\n        float steps = 30.;\n        for(float i = 1.; i<steps; i++)\n        {\n            b += sdSegment(vec2(p.x, p.y), vec2(0.25 + i/20. * (cos(u_time * i * 0.015)) , 0.25 + i/20. * (sin(u_time * i * 0.05)) ), vec2(0.75 + i/20. * (cos(u_time * i * 0.025)), 0.75 + i/20. * (sin(u_time * i * 0.05)) ));\n            \n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:BP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var VP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdTwo(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 12. - 6.;\n        // //p.y -= 1.25;\n        // p.x += 0.5;\n        // p.y += 0.5;\n        p*= 0.5;\n        float b;\n        float steps = 25.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            b += sdEqTriangleOutline(vec2(p.x + i / 10. * sin(u_time + i / 5. ), p.y + i / 10. * cos(u_time + i / 10.)), a);\n            b += sdEqTriangleOutline(vec2(p.x - i / 10. * sin(u_time + i / 5. ), p.y + i / 10. * cos(u_time + i / 10.)), a);\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function WP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:VP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var HP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdThree(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 12. - 6.;\n        // //p.y -= 1.25;\n        p.x += 1.;\n        p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 25.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            b += sdCircleOutline(vec2(p.x + i / 10. * sin(u_time + i / 5. ), p.y + i / 10. * cos(u_time + i / 10.)), a);\n            b += sdCircleOutline(vec2(p.x - i / 10. * sin(u_time + i / 5. ), p.y + i / 10. * cos(u_time + i / 10.)), a);\n            b += sdCircleOutline(vec2(p.x + i / 10. * cos(u_time + i / 5. ), p.y + i / 10. * sin(u_time + i / 10.)), a);\n            b += sdCircleOutline(vec2(p.x - i / 10. * cos(u_time + i / 5. ), p.y + i / 10. * sin(u_time + i / 10.)), a);\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    } \n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function XP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:HP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var YP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdFour(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 100. - 50.;\n        // //p.y -= 1.25;\n        p.x += 1.;\n        p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 25.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, sin(u_time * i/1.));\n            b += 1. - sdBox(vec2(p.x + i + sin(u_time * i), p.y + sin(u_time * i)), vec2(1.5, 0.5));\n            b += 1. - sdBox(vec2(p.x - i + cos(u_time * i), p.y + sin(u_time * i)), vec2(1.5, 0.5));\n            b += 1. - sdBox(vec2(p.x + sin(u_time * i), p.y + i + cos(u_time * i)), vec2(0.5, 1.5));\n            b += 1. - sdBox(vec2(p.x + sin(u_time * i) , p.y - i + sin(u_time * i)), vec2(0.5, 1.5));\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    } \n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ZP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:YP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdFive(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 100. - 50.;\n        // //p.y -= 1.25;\n        p.x += 1.;\n        p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 25.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, cos(u_time * i/25.));\n            b += 1. - sdBox(vec2(p.x + i + sin(u_time * i / 50.), p.y + sin(u_time * i / 50.)), vec2(2.5 * i/50., 2.5 * i/50.));\n            b += 1. - sdBox(vec2(p.x - i + cos(u_time * i / 50.), p.y + sin(u_time * i / 50.)), vec2(2.5 * i/50., 2.5 * i/50.));\n            b += 1. - sdBox(vec2(p.x + sin(u_time * i / 50.), p.y + i + cos(u_time * i / 50.)), vec2(2.5 * i/50., 2.5 * i/50.));\n            b += 1. - sdBox(vec2(p.x + sin(u_time * i / 50.) , p.y - i + sin(u_time * i / 50.)), vec2(2.5 * i/50., 2.5 * i/50.));\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    } \n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function JP(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:QP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KP=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdSix(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 100. - 50.;\n        // //p.y -= 1.25;\n        p.x += 1.;\n        p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 30.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, (sin(u_time * i/10.)));\n            b += sdCircle(vec2(p.x + i /1.75 + sin(u_time * i / 150.), p.y + sin(u_time * i / 150.)),  2.5 * i/50.);\n            b += sdCircle(vec2(p.x - i/1.75 + cos(u_time * i / 150.), p.y + sin(u_time * i / 150.)),  2.5 * i/50.);\n            b += sdCircle(vec2(p.x + sin(u_time * i / 150.), p.y + i/1.75 + cos(u_time * i / 150.)),  2.5 * i/50.);\n            b += sdCircle(vec2(p.x + sin(u_time * i / 150.) , p.y - i/1.75 + sin(u_time * i / 150.)),  2.5 * i/50.);\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float y = newfunc(vUv, 0.25);\n        color += y;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    } \n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $P(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:KP,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.1;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdSeven(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 10. - 5.;\n        // //p.y -= 1.25;\n        p.x += 1.;\n        p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 30.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, (sin(u_time * i/15.)));\n            b += sdSegment(p, vec2(0.25 * i + ((sin(u_time) * 2.) - 12.5), 0.25 ), vec2(2.75 * i, 2.75));\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        color += numLabel;\n        float n = newfunc(vUv, 0.5);\n        color += n;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function eF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdEight(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 2.;\n\n        // //p.y -= 1.25;\n        // p.x += 1.;\n        // p.y += 1.;\n        p*= 0.5;\n        float b;\n        float steps = 15.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, (sin(u_time * i/15.)));\n            b += rectOutline(vec2(p.x, p.y), 0.5 * i / 15., 0.5 * i / 15.);\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        color += numLabel;\n        float n = newfunc(vUv, 0.5);\n        color += n;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function oF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdThree(vec2(p.x -0.05, p.y));\n        float right = sdNine(vec2(p.x - 0.36, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 8. - 3.;\n        p*= 0.5;\n        float b;\n        float steps = 15.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            p = Rot(p, (sin(u_time * i/15.)));\n            b += cirOutline(vec2(p.x + sin(u_time * i/15. + i), p.y + cos(u_time * i/15. + i)), 0.5 * (i + sin(u_time)) * 0.25);\n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        color += numLabel;\n        float n = newfunc(vUv, 0.5);\n        color += n;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function aF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdZero(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = p * 8. - 3.;\n        p*= 0.5;\n        float b;\n        float steps = 25.;\n        for(float i = 1.; i<steps; i++)\n        {\n            // p = p * sin(u_time);\n            // if(i < 12.)\n            // {\n            //     p = Rot(p, (cos(u_time * i/50.)));\n            // } else \n            // {\n            //     p = Rot(p, (sin(u_time * i/50.)));\n            // }\n\n            p = Rot(p, (sin(u_time * i/50.)));\n            b += cirOutline(vec2(p.x + 0.75, p.y + sin(u_time * i/25. + 5.)), 0.5);\n            b += cirOutline(vec2(p.x - 0.75, p.y + sin(u_time * i/25. + 5.)), 0.5);\n\n           \n        }\n        return b;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        color += numLabel;\n        float n = newfunc(vUv, 0.5);\n        color += n;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:iF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdOne(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    float random(vec2 vUv){\n        return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        // vUv = vUv * 4. - 2.;\n        float x = random(vUv);\n        float y = sin(vUv.x);\n        vec2 cp = vec2(cos(u_time), sin(u_time  )) * 0.45 + 0.5;\n        y = quadraticBezier(y, cp);\n        // y += mod(vUv.x, 0.5);\n        float line = plot(vec2(vUv.x, vUv.y) , y, 0.01);\n        float line2 = plot(vec2(vUv.x, vUv.y) , y / x, 0.1);\n        float line3 = plot(vec2(vUv.x, vUv.y), y * x, 0.001);\n        color += line + line2 + line3;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdTwo(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // vec3 sdgBox(vec2 p, vec2 b)\n    // {\n    //     vec2 w = abs(p) - b;\n    //     vec2 s = vec2(p.y < 0. ? -1. : 1., p.x < 0. ? -1. : 1.);\n    //     float g = max(w.x, w.y);\n    //     vec2 q = max(w, 0.0);\n    //     float l = length(q);\n    //     vec3 x = vec3((g > 0.0) ? l : g, s * ((g > 0.0) ? q /l : ((w.x > w.y) ? vec2(1., 0.) : vec2(0., 1.))));\n    //     return smoothstep(0.01, 0.02, x);\n    // }\n\n    vec3 sdgCircle(vec2 p, float r)\n    {\n        float d = length(p);\n        return vec3(d -r, p /d);\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        \n        vUv = Rot(vUv, u_time);\n        vUv = vUv * 6. - 3.;\n        \n        float ra = 0.5;\n        vec3 cir = 1. - sdgCircle(vUv, ra);\n        float d = cir.x;\n        vec2 g = cir.yz;\n        \n        color += (d > 0.) ? vec3(1.) : vec3(0.0);\n        color *= 1.0 + vec3(0.5 * g, 0.0);\n        color *= 1.0 - 0.5 * exp(-16.0 * abs(d));\n        color *= 0.5 + 0.1 * cos(150.0 * d);\n        color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdThree(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    vec3 sdgBox(vec2 p, vec2 b)\n    {\n        vec2 w = abs(p) - b;\n        vec2 s = vec2(p.y < 0. ? -1. : 1., p.x < 0. ? -1. : 1.);\n        float g = max(w.x, w.y);\n        vec2 q = max(w, 0.0);\n        float l = length(q);\n        vec3 x = vec3((g > 0.0) ? l : g, s * ((g > 0.0) ? q /l : ((w.x > w.y) ? vec2(1., 0.) : vec2(0., 1.))));\n        return x;\n    }\n\n    vec3 sdgCircle(vec2 p, float r)\n    {\n        float d = length(p);\n        return vec3(d -r, p /d);\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        \n        vUv = Rot(vUv, u_time);\n        vUv = vUv * 6. - 3.;\n        \n        float ra = 0.5;\n        vec3 cir = 1. - sdgCircle(vUv, ra);\n        vec3 box = 1. - sdgBox(vUv, vec2(0.5, 0.5));\n        float d = cir.x;\n        vec2 g = cir.yz;\n\n        d = box.x;\n        g = box.yz;\n        \n        color += (d > 0.) ? vec3(1.) : vec3(0.0);\n        color *= 1.0 + vec3(0.5 * g, 0.0);\n        color *= 1.0 - 0.5 * exp(-16.0 * abs(d));\n        color *= 0.5 + 0.1 * cos(150.0 * d);\n        color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    vec3 sdgBox(vec2 p, vec2 b)\n    {\n        vec2 w = abs(p) - b;\n        vec2 s = vec2(p.y < 0. ? -1. : 1., p.x < 0. ? -1. : 1.);\n        float g = max(w.x, w.y);\n        vec2 q = max(w, 0.0);\n        float l = length(q);\n        vec3 x = vec3((g > 0.0) ? l : g, s * ((g > 0.0) ? q /l : ((w.x > w.y) ? vec2(1., 0.) : vec2(0., 1.))));\n        return x;\n    }\n\n    vec3 sdgCircle(vec2 p, float r)\n    {\n        float d = length(p);\n        return vec3(d -r, p /d);\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n        \n        vUv = Rot(vUv, u_time);\n        vUv = vUv * 4. - 2.;\n        \n        float ra = 0.5;\n        vec3 cir = 1. - sdgCircle(vUv, ra);\n        vec3 box = 1. - sdgBox(vUv, vec2(0.5, 0.5));\n        float d = cir.x;\n        vec2 g = cir.yz;\n\n        d = box.x;\n        g = box.yz;\n        \n        color += (d > 0.) ? vec3(1.) : vec3(0.0);\n        // color *= 1.0 + vec3(0.5 * g, 0.0);\n        color *= 1.0 - 0.5 * exp(-16.0 * abs(d));\n        color *= 0.1 + 0.5 * cos(20.0 * d * (sin(u_time * 0.5) * 2.) + 5. );\n        color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdFive(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    vec3 sdgCircle(vec2 p, float r)\n    {\n        float d = length(p);\n        return vec3(d -r, p /d);\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n\n        vUv = vUv * 2. - 1.;\n        float k = 1. + 20. * (0.5 - 0.5 * cos(u_time + 1.5));\n        float spiral = sdSpiral(vUv, 1.0, k);\n        color += 1. - smoothstep(0.01, 0.02, spiral);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdSix(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = Rot(p , u_time);\n        p = p * 2. - 1.;\n        // //p.y -= 1.25;\n        // p.x += 1.;\n        // p.y += 1.;\n        // p*= 0.5;\n        float b;\n        float steps = 15.;\n        \n        for(float i = 1.; i<steps; i++)\n        {\n            // p = Rot(p, u_time * 0.25);\n            // p = p * 2. - 1.;\n            float k = 1. + i * (0.25 - 0.25 * cos(u_time * i * 0.025));\n            b += sdSpiral(p , a  * i, k + i * 0.2);\n        }\n        return b;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n\n        // vUv = vUv * 2. - 1.;\n        float k = 1. + 20. * (0.5 - 0.5 * cos(u_time + 1.5));\n        float spiral = sdSpiral(vUv, 1.0, k);\n        // color += spiral;\n        float func = newfunc(vUv, 1.0);\n        // color.g += func * 0.25;\n        color.r += func * 0.25 - abs(cos(u_time * 0.5));\n        color.b += func * 0.25 - (sin(u_time * 0.5)  /2.) - 0.5;\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdSeven(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    float newfunc(vec2 p, float a)\n    {\n        p = Rot(p , u_time);\n        p = p * 2. - 1.;\n        // //p.y -= 1.25;\n        // p.x += 1.;\n        // p.y += 1.;\n        // p*= 0.5;\n        float b;\n        float steps = 15.;\n        \n        for(float i = 1.; i<steps; i++)\n        {\n            // p = Rot(p, u_time * 0.25);\n            // p = p * 2. - 1.;\n            p = p * i / (3. + sin(u_time * 0.5));\n            float k = 1. + i * (0.25 - 0.25 * cos(u_time * i * 0.025));\n            b += sdSpiral(p , a  * i, k + i * 0.2);\n        }\n        return b;\n    }\n\n    \n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        \n        vec3 color = vec3(0.);\n        float numLabel = label(vUv);\n\n        // vUv = vUv * 2. - 1.;\n        float k = 1. + 20. * (0.5 - 0.5 * cos(u_time + 1.5));\n        float spiral = sdSpiral(vUv, 1.0, k);\n        // color += spiral;\n        float func = newfunc(vUv, 1.0);\n        // color.g += func * 0.25;\n        color.r += func * 0.25 - abs(cos(u_time * 0.5));\n        color.b += func * 0.25 - (sin(u_time * 0.5)  /2.) - 0.5;\n        color += numLabel + numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _F=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\nfloat label(vec2 p)\n{\n    p *= 10.;\n    p.x -= 0.25;\n    float left = sdFour(vec2(p.x + 0.3, p.y));\n    float center = sdFour(vec2(p.x -0.05, p.y));\n    float right = sdEight(vec2(p.x - 0.38, p.y));\n    return left + center + right;\n}\n\nfloat newfunc(vec2 p, float a)\n{\np = Rot(p , u_time);\np = p * 2. - 1.;\n// //p.y -= 1.25;\n// p.x += 1.;\n// p.y += 1.;\n// p*= 0.5;\nfloat b;\nfloat steps = 15.;\n\nfor(float i = 1.; i<steps; i++)\n{\n    // p = Rot(p, u_time * 0.25);\n    // p = p * 2. - 1.;\n    p = p * i / (3.);\n    float k = 1. + i * (0.25 - 0.25 * cos(u_time * i * 0.025));\n    b += sdSpiral(p * i, a  * i, k + i * 0.2);\n    b += sdSegment(p * i , vec2(0.0), vec2(0.25));\n}\nreturn b;\n}\n\nvoid main()\n{\nvec2 vUv = vec2(vUv.x, vUv.y);\nvec3 color = vec3(0.);\nfloat numLabel = label(vUv);\nvec2 newUv = vUv;\n// vUv = vUv * 2. - 1.;\nfloat k = 1. + 20. * (0.5 - 0.5 * cos(u_time + 1.5));\nfloat spiral = sdSpiral(vUv, 1.0, k);\n// color += spiral;\nvUv = Rot(vUv, u_time);\nnewUv = Rot(newUv, PI * 0.25);\nfloat func = newfunc(vUv, 1.0);\nfloat func2 = newfunc(newUv, 1.0);\n// color.g += func * 0.25;\ncolor.r += func * 0.25 - abs(cos(u_time * 0.5));\ncolor.r += func2 * 0.25 - abs(cos(u_time * 0.5));\ncolor.b += func * 0.25 - (sin(u_time * 0.5)  /2.) - 0.5;\ncolor.b += func2 * 0.25 - (sin(u_time * 0.5)  /2.) - 0.5;\ncolor += numLabel + numLabel + numLabel;\ngl_FragColor = vec4(color, 1.);\n}\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_F,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var SF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFour(vec2(p.x -0.05, p.y));\n        float right = sdNine(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n\n        float y = (sin(noiseUv.x + u_time) )  / 2. ;\n        float line = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y, 0.01);\n        float line2 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n, 0.01);\n        float line3 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n * n, 0.01);\n        color += line;\n        color += line2;\n        color += line3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function MF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:SF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = newUv / 1.25 + 0.1;\n        float box = sdRoundedBoxOutline(newUv, vec2(0.5), vec4(\n            0.25 * n + (sin(u_time * (sin(n + u_time/5.))/50.) / 10.) + 0.2, \n            0.25 * n + (sin(u_time * (sin(n + u_time/5.))/50.) / 10.) + 0.2, \n            0.25 * n + (sin(u_time * (cos(n + u_time/5.))/50.) / 10.) + 0.2, \n            0.25 * n + (sin(u_time * (cos(n + u_time/5.))/50.) / 10.) + 0.2), \n            0.025);\n        float y = (sin(noiseUv.x + u_time) )  / 2. ;\n        float line = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y, 0.01);\n        float line2 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n, 0.01);\n        float line3 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n * n, 0.01);\n        // color += line;\n        // color += line2;\n        // color += line3;\n        color += box;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var CF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = newUv / 1.25 + 0.1;\n        float box = sdRoundedBox(newUv, vec2(0.5), vec4(\n            0.25 * n + (sin(u_time + abs(sin(n * u_time * 0.5) + 125.0)/2.) / 2.) + 0.2, \n            0.25 * n + (sin(u_time + abs(sin(n * u_time * 0.5) + 125.0)/2.) / 2.) + 0.2, \n            0.25 * n + (sin(u_time + abs(sin(n * u_time * 0.5) + 125.0)/2.) / 2.) + 0.2, \n            0.25 * n + (sin(u_time + abs(sin(n * u_time * 0.5) + 125.0)/2.) / 2.) + 0.2));\n        float y = (sin(noiseUv.x + u_time) )  / 2. ;\n        float line = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y, 0.01);\n        float line2 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n, 0.01);\n        float line3 = plot(vec2(noiseUv.x, noiseUv.y - 0.5), y * n * n, 0.01);\n        // color += line;\n        // color += line2;\n        // color += line3;\n        color += box;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function TF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:CF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var RF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 120.)/5.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n       \n        float k = 1. + 20. * (0.5 - 0.5 + (n * 0.025 + (sin(u_time) + 1.)/5.));\n        float spiral = sdSpiral(vec2(vUv.x * 2. - 1., vUv.y * 2. - 1. ), 1.0 + (sin(u_time) + 2.), k);\n        color += spiral;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function DF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:RF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var PF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 120.)/5.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time * 0.25);\n        newUv = newUv * 2. - 1.;\n        vec2 newUv2 = vUv;\n        newUv2 = Rot(newUv2, u_time * 0.5);\n        newUv2 = newUv2 * 2. - 1.;\n        float tri = sdEqTriangleOutline(newUv, 0.35 + (n * 0.05 * sin(u_time)));\n        float tri2 = sdEqTriangleOutline(newUv2, 0.15 + (n * 0.05 * sin(u_time)));\n        float k = 1. + 20. * (0.5 - 0.5 + (n * 0.025 + (sin(u_time) + 1.)/5.));\n        float spiral = sdSpiral(vec2(vUv.x * 2. - 1., vUv.y * 2. - 1. ), 1.0 + (sin(u_time) + 2.), k);\n        // color += spiral;\n        color += tri;\n        color += tri2;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function FF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:PF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 120.)/5.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time * 0.25);\n        // newUv = newUv * 2. - 1.;\n        vec2 newUv2 = vUv;\n        newUv2 = Rot(newUv2, u_time * 0.5);\n        // newUv2 = newUv2 * 2. - 1.;\n        float c1 = cirOutline(newUv, 0.35 + (n * 0.05 * sin(u_time)));\n        float c2 = cirOutline(newUv2, 0.15 + (n * 0.05 * sin(u_time)));\n        float c3 = cirOutline(newUv, 0.5 + (n * 0.05 * sin(u_time)));\n        float c4 = cirOutline(newUv2, 0.25 + (n * 0.035 * sin(u_time)));\n        float k = 1. + 20. * (0.5 - 0.5 + (n * 0.025 + (sin(u_time) + 1.)/5.));\n        float spiral = sdSpiral(vec2(vUv.x * 2. - 1., vUv.y * 2. - 1. ), 1.0 + (sin(u_time) + 2.), k);\n        // color += spiral;\n        color += c1;\n        color += c2 + c3 + c4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function IF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 120.)/25.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = newUv * 4. - 2.;\n        float y = sin(vUv.x + u_time + n);\n        float x = sin(vUv.y + u_time + n);\n        float line = plot(newUv, y, 0.5);\n        float line2 = plot(newUv, x, 0.25);\n        color += line;\n        color += line2;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function OF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:EF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 220. * 1.2)/10.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n       \n        float shape = rectOutline(vUv, 0.5 + n/5., 0.25);\n        color += shape;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:AF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 82. * 1.2)/15.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n       \n        float shape = rectOutline(vUv, 0.5 + n/5. * sin(u_time), 0.5 + n/5. * cos(u_time));\n        color += shape;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function NF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:GF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var BF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 82. * 1.2)/15.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time * 0.25);\n        float shape = rectOutline(newUv, 0.5 + n/5. * sin(u_time), 0.5 + n/5. * cos(u_time));\n        float shape2 = cirOutline(vUv, 0.5 + n/5. * sin(u_time));\n        color += shape;\n        color += shape2;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:BF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var VF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 1580. * 1.2)/35.);\n        vec2 vUv2, vUv3, vUv4, vUv5;\n        vUv2 = vUv;\n        vUv2 = vUv2 * 2. - 0.5;\n        vUv2.x += 0.56;\n        vUv3 = vUv;\n        vUv3 = vUv3 * 2. - 0.5;\n        vUv3.x += 0.2;\n        vUv4 = vUv;\n        vUv4 = vUv4 * 2. - 0.5;\n        vUv4.x -= 0.05;\n        vUv5 = vUv;\n        vUv5 = vUv5 * 2. - 0.5;\n        vUv5.x -= 0.4;\n\n        float two = sdTwo(vUv2 * abs(sin(n + u_time)+ 25.)/25.);\n        float zero = sdZero(vUv3 * abs(cos(n + u_time) + 25.)/25.);\n        float two1 = sdTwo(vUv4 * abs(sin(n + u_time)+ 25.)/25.);\n        float three = sdThree(vUv5 * abs(cos(n + u_time)+ 25.)/25.);\n        color += two;\n        color += zero;\n        color += two1;\n        color += three;\n\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function WF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:VF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var HF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 82. * 1.2)/15.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time * 0.25);\n        float shape = rect(newUv, 0.5 + n/5. * sin(u_time), 0.5 + n/5. * cos(u_time));\n        float shape2 = circle(vUv * 2. - 0.5, 0.5 + n/5. * sin(u_time));\n        float shape3 = circle(vUv * 2.5 - 0.75, 0.5 + n/5. * sin(u_time));        color += shape;\n        color += shape2;\n        color -= shape3;\n        float shape4 = rect(newUv, 0.45 + n/5. * sin(u_time), 0.45 + n/5. * cos(u_time));\n        color -= shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function XF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:HF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var YF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * ((u_time) / 5.) + 65.);\n        vec2 newUv = vUv;\n        float y = vUv.x * n;\n\n        float line = plot(vUv, y, 0.01);\n        // newUv = newUv * 2.;\n        float cir = cirOutline(newUv, 0.25); \n        // color += line;\n        color += cir;\n        color += line;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ZF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:YF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    \n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv + u_time);\n        // vUv.x += u_time;\n        float y = sin(vUv.x * n * u_time);\n\n        float line = plot(vUv, y, 0.5 + n);\n        color += line;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function JF(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:QF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KF=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float n = noise(vUv * (u_time + 120.)/5.);\n        vec2 noiseUv = vUv;\n        noiseUv = noiseUv * 4. - 2.;\n        // noiseUv.y += 2.;\n        noiseUv = noiseUv * n;\n        vec2 newUv = vUv;\n        newUv = Rot(newUv, u_time * 0.25);\n        // newUv = newUv * 2. - 1.;\n        vec2 newUv2 = vUv;\n        newUv2 = Rot(newUv2, u_time * 0.5);\n        // newUv2 = newUv2 * 2. - 1.;\n        float c1 = circle(newUv, 0.35 + (n * 0.07 * sin(u_time)));\n        float c2 = circle(newUv2, 0.15 + (n * 0.05 * cos(u_time)));\n        float c3 = circle(newUv, 0.5 + (n * 0.04 * sin(u_time)));\n        float c4 = circle(newUv2, 0.25 + (n * 0.035 * cos(u_time)));\n        float k = 1. + 20. * (0.5 - 0.5 + (n * 0.025 + (sin(u_time) + 1.)/5.));\n        float spiral = sdSpiral(vec2(vUv.x * 2. - 1., vUv.y * 2. - 1. ), 1.0 + (sin(u_time) + 2.), k);\n        // color += spiral;\n        \n        color += c2;\n        color -= c1;\n        color += c3;\n        // color -= c3;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $F(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:KF,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        // float shape1 = sdPolygonOutline(vUv, 7.0 + sin(u_time), 0.1);\n        // float shape2 = sdPolygonOutline(vUv, 6.0 + sin(u_time), 0.2);\n        // float shape3 = sdPolygonOutline(vUv, 5.0 + sin(u_time), 0.3);\n        // float shape4 = sdPolygonOutline(vUv, 4.0 + sin(u_time), 0.4);\n        //float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        //color += shape1 + shape2 + shape3 + shape4;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ej(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        for (int i=4; i<=15; i++)\n        {\n            shape1 += sdPolygonOutline(vUv, i, float(i) * 0.1 + (sin(u_time)/2.) - 0.95);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function oj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 2. - 0.5;\n        newvUv = Rot(newvUv, u_time * 0.25);\n        for (int i=4; i<=15; i++)\n        {\n            shape1 += sdPolygonOutline(vec2(newvUv.x, newvUv.y + sin(float(i)/2.)), i, float(i) * 0.1 + (sin(u_time)/4.) - 0.95);\n            shape2 += sdPolygonOutline(vec2(newvUv.x + cos(float(i)/2.), newvUv.y ), i, float(i) * 0.1 + (cos(u_time)/4.) - 0.95);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        color += shape2;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function aj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var ij=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 2. - 0.5;\n        newvUv = Rot(newvUv, u_time * 0.25);\n        for (int i=3; i<=7; i++)\n        {\n            shape1 += sdPolygonOutline(vec2(newvUv.x, newvUv.y + sin(float(i)/1.)), i, float(i) * 0.1 + (sin(u_time * float(i) * 0.5)/1.) - 0.95);\n            shape2 += sdPolygonOutline(vec2(newvUv.x + cos(float(i)/1.), newvUv.y ), i, float(i) * 0.1 + (cos(u_time * float(i) * 0.5)/1.) - 0.95);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        color += shape2;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:ij,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 2. - 1.;\n        // newvUv = Rot(newvUv, u_time * 0.25);\n        float k = 1. + 20. * (0.5 - 0.5 + (0.025 + (sin(u_time * 0.25) + .5)/015.));\n        for (int i=3; i<=7; i++)\n        {\n            shape1 += sdSpiral(newvUv, 0.5* float(i), k);\n            shape2 += sdSpiral(newvUv, 0.5* float(i), 5./k );\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        color *= shape2;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSix(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 4. - 1.5;\n        // newvUv = Rot(newvUv, u_time * 0.25);\n        float k = 1. + 20. * (0.5 - 0.5 + (0.025 + (sin(u_time * 0.25) + .5)/015.));\n        for (int i=3; i<=7; i++)\n        {\n            // shape1 += sdSpiral(newvUv, 0.5* float(i), k);\n            // shape2 += sdSpiral(newvUv, 0.5* float(i), 20./k );\n            // shape3 += sdSpiral(newvUv, 0.5* float(i), 100./k );\n            shape1 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + sin(u_time * 0.75), 0.5* float(i)), vec4(float(i)), 0.1);\n            shape2 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + sin(u_time * 0.25), 0.5* float(i)), vec4(float(i)), 0.1);\n            shape3 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + sin(u_time * 0.5), 0.5* float(i)), vec4(float(i)), 0.2);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        color *= shape2;\n        color *= shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 4. - 1.5;\n        newvUv = Rot(newvUv, u_time * 0.5);\n        float k = 1. + 20. * (0.5 - 0.5 + (0.025 + (sin(u_time * 0.25) + .5)/015.));\n        for (int i=0; i<=10; i++)\n        {\n            // shape1 += sdSpiral(newvUv, 0.5* float(i), k);\n            // shape2 += sdSpiral(newvUv, 0.5* float(i), 20./k );\n            // shape3 += sdSpiral(newvUv, 0.5* float(i), 100./k );\n            shape1 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + sin(u_time * 0.35), 0.25* float(i)), vec4(float(i)), 0.1);\n            shape2 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + cos(u_time * 0.25), 0.5* float(i)), vec4(float(i)), 0.1);\n            shape3 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + cos(u_time * 0.35), 0.5* float(i)), vec4(float(i)), 0.1);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        color *= shape2;\n        color *= shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = Rot(newvUv, u_time * 0.5);\n        newvUv = newvUv * 4. - 2.;\n        \n        float k = 1. + 20. * (0.5 - 0.5 + (0.025 + (sin(u_time * 0.25) + .5)/015.));\n        for (int i=0; i<=10; i++)\n        {\n            // shape1 += sdSpiral(newvUv, 0.5* float(i), k);\n            // shape2 += sdSpiral(newvUv, 0.5* float(i), 20./k );\n            // shape3 += sdSpiral(newvUv, 0.5* float(i), 100./k );\n            shape1 += sdEqTriangleOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.25), newvUv.y + cos(float(i) * u_time * 0.25)), 0.3 * (float(i) * 0.1));\n            // shape2 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + cos(u_time * 0.25), 0.5* float(i)), vec4(float(i)), 0.1);\n            // shape3 += sdRoundedBoxOutline(newvUv, vec2(0.5* float(i) + cos(u_time * 0.35), 0.5* float(i)), vec4(float(i)), 0.1);\n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        color += shape1;\n        // color *= shape2;\n        // color *= shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 3. - 1.;\n        newvUv = Rot(newvUv, u_time * 0.25);\n        \n        for (int i=4; i<=10; i++)\n        {\n            // shape1 += sdEqTriangleOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.25), newvUv.y + cos(float(i) * u_time * 0.25)), 0.3 * (float(i) * 0.1));\n            shape2 += sdPolygonOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.0725), newvUv.y + sin(float(i) * u_time * 0.0725)), 4, 0.1 * (float(i) - 0.125));\n            shape3 += sdPolygonOutline(vec2(newvUv.x - sin(float(i) * u_time * 0.0725), newvUv.y - sin(float(i) * u_time * 0.0725)), 4, 0.1 * (float(i) - 0.125));\n            \n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        // color += shape1;\n        color += shape2;\n        color *= shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 3. - 1.;\n        // newvUv = Rot(newvUv, u_time * 0.25);\n        \n        for (int i=4; i<=8; i++)\n        {\n            // shape1 += sdEqTriangleOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.25), newvUv.y + cos(float(i) * u_time * 0.25)), 0.3 * (float(i) * 0.1));\n            shape2 += sdPolygonOutline(vec2(newvUv.x - sin(float(i) * u_time * 0.25), newvUv.y + sin(float(i) * u_time * 0.125)), 4, 0.05 * (float(i) - 0.125));\n            shape3 += sdPolygonOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.25), newvUv.y + sin(float(i) * u_time * 0.125)), 4, 0.05 * (float(i) - 0.125));\n            \n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        // color += shape1;\n        color += shape2;\n        color += shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = newvUv * 2. - 0.5;\n        \n        \n        for (int i=4; i<=15; i++)\n        {\n            newvUv = Rot(newvUv, u_time * 0.125);\n            // shape1 += sdEqTriangleOutline(vec2(newvUv.x + sin(float(i) * u_time * 0.25), newvUv.y + cos(float(i) * u_time * 0.25)), 0.3 * (float(i) * 0.1));\n            shape2 += sdPolygonOutline(vec2(newvUv), 3, 0.0525 * (float(i) - 0.125));\n            shape3 += sdPolygonOutline(vec2(newvUv.x + cos(float(i) * u_time * 0.125), newvUv.y + sin(float(i) * u_time * 0.125)), 3, 0.025 * (float(i) - 0.125));\n            \n        }\n        \n        \n        // float shape5 = sdPolygonOutline(vec2(vUv.x, vUv.y - 0.01), 3.0 + sin(u_time), 0.5);\n        // color += shape1;\n        color += shape2;\n        // color += shape3;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Uj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _j=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        vec2 newvUv = vUv;\n        newvUv = Rot(newvUv, u_time * 4.);\n        newvUv = newvUv / 2. - 0.25;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=4; i<=15; i++)\n        {\n            shape1 += sdSpiral(vec2(newvUv), 0.45, k);\n        }\n        \n        color += shape1;\n        shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        color += shape2;\n        color += shape3;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_j,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Sj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        newvUv = Rot(newvUv, u_time * .25);\n        // newvUv = newvUv / 2. - 0.25;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=0; i<=10; i++)\n        {\n            shape1 += rectOutline(vec2(newvUv.x + (float(i) * (sin(u_time) / 2.)/ 20.), newvUv.y), 0.25, 0.25);\n            shape2 += rectOutline(vec2(newvUv.x , newvUv.y + (float(i) * (sin(u_time) / 2.)/ 20.)), 0.25, 0.25);\n            // shape3 += rectOutline(vec2(newvUv.x + (float(i) * (cos(u_time) / 2.)/ 20.), newvUv.y), 0.25, 0.25);\n            // shape4 += rectOutline(vec2(newvUv.x , newvUv.y + (float(i) * (cos(u_time) / 2.)/ 20.)), 0.25, 0.25);\n        }\n        \n        color += shape1;\n        // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        color += shape2;\n        // color += shape3;\n        // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Mj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Sj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        newvUv = Rot(newvUv, u_time * .25);\n        // newvUv = newvUv / 2. +0.125;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=5; i<=15; i++)\n        {\n            shape1 += rectOutline(vec2(newvUv) , 0.0725 * float(i) * cos(u_time * float(i) * 0.01), 0.0725 * float(i) * sin(u_time * float(i) * 0.05));\n        //     shape2 += rectOutline(vec2(newvUv.x , newvUv.y), 0.025 * float(i), 0.25);\n        //     shape3 += rectOutline(vec2(newvUv.x , newvUv.y), 0.025 * float(i), 0.25);\n        //     shape4 += rectOutline(vec2(newvUv.x , newvUv.y), 0.025 * float(i), 0.25);\n        }\n        \n        color += shape1;\n        // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        color += shape2;\n        color += shape3;\n        color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Cj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        // newvUv = Rot(newvUv, u_time * .25);\n        newvUv = newvUv * 4. - 1.5;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=0; i<=13; i++)\n        {\n            shape1 += circle(vec2(newvUv.x + sin(u_time * float(i) * 0.1 + 0.5), newvUv.y +  float(i) * 0.1), 0.15 * (sin(float(i) * u_time * 0.1))+0.15);\n            shape2 += circle(vec2(newvUv.x + sin(u_time * float(i) * 0.1 + 0.5) , newvUv.y -  float(i) * 0.1), 0.15 * (sin(float(i) * u_time * 0.1))+0.15);\n            shape3 += cirOutline(vec2(newvUv.x + sin(u_time * float(i) * 0.1 + 0.5), newvUv.y +  float(i) * 0.1), 0.15 * (sin(float(i) * u_time * 0.1))+0.15);\n            shape4 += cirOutline(vec2(newvUv.x + sin(u_time * float(i) * 0.1 + 0.5) , newvUv.y -  float(i) * 0.1), 0.15 * (sin(float(i) * u_time * 0.1))+0.15);\n        }\n        \n        color += shape1 * shape3;\n        // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        color += shape2 * shape4;\n        // color *= shape3;\n        // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Tj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Cj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Rj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdSeven(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        // newvUv = Rot(newvUv, u_time * .25);\n        newvUv = newvUv * 3. - 1.5;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=1; i<=15; i++)\n        {\n            shape1 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.5 * (sin(u_time * float(i) * 0.1)), 0.75 * (cos(u_time * float(i) * 0.21))));\n            shape2 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.5 * (sin(u_time * float(i) * 0.1)), 0.75 * (cos(u_time * float(i) * 0.21))));\n            shape3 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.75 * (cos(u_time * float(i) * 0.21)), 0.75 * (sin(u_time * float(i) * 0.21))));\n            shape4 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.75 * (cos(u_time * float(i) * 0.21)), 0.75 * (sin(u_time * float(i) * 0.21))));\n        }\n        \n        // color += shape1;\n        color += shape1 * shape3;\n        color += shape2 * shape4;\n        // // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        \n        // // color *= shape3;\n        // // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Dj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Rj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Pj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        // newvUv = Rot(newvUv, u_time * .25);\n        newvUv = newvUv * 3. - 1.5;\n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        for (int i=1; i<=15; i++)\n        {\n            shape1 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.25 * (sin(u_time * float(i) * 0.1)), 0.25 * (cos(u_time * float(i) * 0.1))));\n            shape2 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.15 + (sin(u_time * float(i) * 0.1)), 0.15 + (cos(u_time * float(i) * 0.1))));\n            shape3 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(0.15 + (sin(u_time * float(i) * 0.1)), -0.15 + (cos(u_time * float(i) * 0.1))));\n            shape4 += sdSegment(vec2(newvUv), vec2(0. + (sin(u_time * float(i) * 0.1)), 0. + (cos(u_time * float(i) * 0.1))), vec2(-0.15 + (sin(u_time * float(i) * 0.1)), 0.15 + (cos(u_time * float(i) * 0.1))));\n        }\n        \n        // color += shape1;\n        color += shape1; \n        color += shape3;\n        color += shape2;\n        color += shape4;\n        // // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        \n        // // color *= shape3;\n        // // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Fj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Pj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        \n        newvUv = newvUv * 2. - 0.5;\n        newvUv.y -= 0.7;\n        newvUv = Rot(newvUv, PI * 0.25);\n        float k = 1. + 20. * (0.25 - 0.125);\n        vec2 uv2 = newvUv;\n        \n        uv2.x += 1.;\n        uv2.y -0.2;\n        uv2 = Rot(uv2, PI * 0.5);\n        \n        for (int i=1; i<=15; i++)\n        {\n            shape1 += sdSegment(vec2(newvUv.x + sin(float(i) * u_time * 0.1), newvUv.y + cos(float(i) * u_time * 0.1)), vec2(0. + sin(u_time * float(i) * (0.1))), vec2(0.0 + cos(u_time * float(i) * 0.1)));\n            \n        }\n        \n        // color += shape1;\n        color += shape1; \n        color += shape3;\n        color += shape2;\n        color += shape4;\n        // // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        \n        // // color *= shape3;\n        // // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Ij(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Ej=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 newvUv = vUv;\n        vec2 uv2 = newvUv;\n        newvUv = Rot(newvUv, PI * 0.5);\n        uv2 = Rot(uv2, PI *0.5);\n        newvUv = newvUv * 2. - 0.5;\n        newvUv.y -= 0.7;\n        newvUv = Rot(newvUv, PI * 0.25);\n        uv2 = uv2 * 2. - 0.5;\n        uv2.y -= 0.7;\n        \n        float k = 1. + 20. * (0.25 - 0.125);\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        \n        for (int i=1; i<=15; i++)\n        {\n            uv2 = Rot(uv2, PI * 0.25 + u_time * 0.1);\n            shape1 += sdSegment(vec2(newvUv.x + cos(float(i) * u_time * 0.01), newvUv.y + sin(float(i) * u_time * 0.1)), vec2(0. + cos(u_time * float(i) * (0.1))), vec2(0.0 + sin(u_time * float(i) * 0.1)));\n            shape2 += sdSegment(vec2(uv2.x + cos(float(i) * u_time * 0.01), uv2.y + sin(float(i) * u_time * 0.1)), vec2(0. + cos(u_time * float(i) * (0.1))), vec2(0.0 + sin(u_time * float(i) * 0.0)));\n            \n        }\n        \n        // color += shape1;\n        color += shape1; \n        color += shape3;\n        color += shape2;\n        color += shape4;\n        // // shape2 = rect(vec2(vUv.x, vUv.y), 1., 0.01);\n        // // shape3 = rect(vec2(vUv.x, vUv.y), 0.01, 1.);\n        \n        // // color *= shape3;\n        // // color += shape4;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Oj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Ej,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Aj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.39, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2 = Rot(uv2, u_time * 0.1);\n        for (int i=1; i<=15; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, u_time * 0.05 * float(i));\n            shape1 += sdSegment(vec2(uv2.x + float(i) /10. - 0.25, uv2.y + float(i) /10. - 0.25), vec2(0.0), vec2(0.25));\n            \n        }\n        \n        color += shape1; \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Lj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Aj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Gj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.25;\n        // uv2 = Rot(uv2, u_time * 0.1);\n        for (int i=1; i<=15; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, u_time * 0.05 * float(i));\n            shape1 += sdSegment(vec2(uv2.x + (float(i) * sin(u_time) /10. ) , uv2.y + (float(i) * cos(u_time) /10. )), vec2(0.0), vec2(0.5));\n            shape2 += sdSegment(vec2(uv2.x - (float(i) * sin(u_time) /10. ) , uv2.y - (float(i) * cos(u_time) /10. )), vec2(0.0), vec2(0.5));\n            shape3 += sdSegment(vec2(uv2.x + (float(i) * sin(u_time) /10. ) , uv2.y - (float(i) * cos(u_time) /10. )), vec2(0.0), vec2(0.5));\n            shape4 += sdSegment(vec2(uv2.x - (float(i) * sin(u_time) /10. ) , uv2.y + (float(i) * cos(u_time) /10. )), vec2(0.0), vec2(0.5));\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Nj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Gj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Bj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.1);\n        for (int i=0; i<=20; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, u_time * 0.05 * float(i));\n            shape1 += circle(vec2(uv2.x + float(i) / 10. + sin(u_time*(float(i)/15.)), uv2.y - float(i) / 150. + cos(u_time*(float(i)/10.))), 0.25);\n            shape2 += cirOutline(vec2(uv2.x + float(i) / 10. + sin(u_time*(float(i)/15.)), uv2.y - float(i) / 150. + cos(u_time*(float(i)/10.))), 0.25);\n            \n        }\n        \n        color += shape1; \n        color *= shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Bj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Vj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.1);\n        for (int i=1; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, u_time * 0.05 * float(i));\n            shape1 += circle(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) * cos(u_time)), 0.005);\n            shape2 += circle(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * sin(u_time)), 0.005);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Wj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Vj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Hj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.1);\n        for (int i=1; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, u_time * 0.0000005 * float(i));\n            shape1 += circle(vec2(uv2.x + sin(u_time*(float(i)/25.)) - sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) + cos(u_time)), 0.005);\n            shape2 += circle(vec2(uv2.x + cos(u_time*(float(i)/25.)) - cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) + sin(u_time)), 0.005);\n            shape3 += circle(vec2(uv2.x + sin(u_time*(float(i)/12.5)) + sin(u_time), uv2.y - cos(u_time*(float(i)/12.5)) - cos(u_time)), 0.005);\n            shape4 += circle(vec2(uv2.x - cos(u_time*(float(i)/12.5)) + cos(u_time), uv2.y + sin(u_time*(float(i)/12.5)) - sin(u_time)), 0.005);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Xj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Hj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Yj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=1; i<=45; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, u_time * 0.0000005 * float(i));\n            shape1 += circle(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) + sin(u_time)), 0.005);\n            shape2 += circle(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) + sin(u_time)), 0.005);\n            shape3 += circle(vec2(uv2.x + sin(u_time*(float(i)/12.5)) * cos(u_time), uv2.y - cos(u_time*(float(i)/12.5)) - cos(u_time)), 0.005);\n            shape4 += circle(vec2(uv2.x + cos(u_time*(float(i)/12.5)) * sin(u_time), uv2.y + sin(u_time*(float(i)/12.5)) - sin(u_time)), 0.005);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Zj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Yj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Qj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdEight(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=1; i<=50; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, u_time * 0.0000005 * float(i));\n            shape1 += rectOutline(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) * sin(u_time)), 0.25, 0.25);\n            shape2 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * sin(u_time)), 0.25, 0.25);\n            shape3 += rectOutline(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) * cos(u_time)), 0.25, 0.25);\n            shape4 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * sin(u_time)), 0.05, 0.05);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function Jj(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Qj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var Kj=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=1; i<=40; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, ((u_time * 0.5) * float(i/25))/200825.);\n            // shape1 += rectOutline(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) * sin(u_time)), 0.25, 0.25);\n            shape2 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/5.)) * abs(cos(u_time * 0.5)), uv2.y + sin(u_time*(float(i)/5.)) * abs(sin(u_time * 0.5))), 0.0525, 0.0525);\n            shape3 += rectOutline(vec2(uv2.x + (sin(u_time*(float(i)/5.))) * (sin(u_time * 0.5)), uv2.y + cos(u_time*(float(i)/5.)) * abs(cos(u_time * 0.5))), 0.0525, 0.0525);\n            // shape4 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * cos(u_time)), 0.05, 0.05);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $j(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:Kj,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=1; i<=40; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, ((u_time * 0.5) * float(i/25))/200825.);\n            // shape1 += rectOutline(vec2(uv2.x + sin(u_time*(float(i)/25.)) * sin(u_time), uv2.y + cos(u_time*(float(i)/25.)) * sin(u_time)), 0.25, 0.25);\n            shape2 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/5.)) + abs(cos(u_time * 0.5)), uv2.y + sin(u_time*(float(i)/5.)) * abs(sin(u_time * 0.5))), 0.0525, 0.0525);\n            shape3 += rectOutline(vec2(uv2.x + (sin(u_time*(float(i)/5.))) - (sin(u_time * 0.5)), uv2.y + cos(u_time*(float(i)/5.)) * abs(cos(u_time * 0.5))), 0.0525, 0.0525);\n            // shape4 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * cos(u_time)), 0.05, 0.05);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function eI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=1; i<=40; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, ((u_time * 0.5) * float(i/25))/200825.);\n            shape1 += rectOutline(vec2(uv2.x + sin(u_time*(float(i)/25.)) + sin(u_time), uv2.y + cos(u_time*(float(i)/15.)) - cos(u_time * float(i/10))), 0.25, 0.25);\n            // shape2 += rectOutline(vec2(uv2.x / cos(u_time*(float(i)/5.)) + abs(cos(u_time * 0.5)), uv2.y + sin(u_time*(float(i)/5.)) * abs(sin(u_time * 0.5))), 0.0525, 0.0525);\n            // shape3 += rectOutline(vec2(uv2.x * (sin(u_time*(float(i)/5.))) - (sin(u_time * 0.5)), uv2.y + cos(u_time*(float(i)/5.)) * abs(cos(u_time * 0.5))), 0.0525, 0.0525);\n            // shape4 += rectOutline(vec2(uv2.x + cos(u_time*(float(i)/25.)) * cos(u_time), uv2.y + sin(u_time*(float(i)/25.)) * cos(u_time)), 0.05, 0.05);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function oI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.5);\n        for (int i=0; i<=10; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            \n            shape1 += circle(vec2(uv2.x + sin(float(i) + u_time) * 2. , uv2.y), 0.0525);\n            shape2 += circle(vec2(uv2.x  , uv2.y + sin(float(i) + u_time) * 2.), 0.0525);\n            shape3 += circle(vec2(uv2.x + sin(float(i) + u_time) * 2. , uv2.y + sin(float(i) + u_time) * 2.), 0.0525);\n            shape4 += circle(vec2(uv2.x - sin(float(i) + u_time) * 2. , uv2.y + sin(float(i) + u_time) * 2.), 0.0525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function aI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.15);\n        for (int i=5; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.15));\n            shape1 += circle(vec2(uv2.x + cos(float(i) + u_time) * 2. , uv2.y), 0.0525);\n            shape2 += circle(vec2(uv2.x  , uv2.y - sin(float(i) + u_time) * 2.), 0.0525);\n            shape3 += circle(vec2(uv2.x + sin(float(i) + u_time) * 2. , uv2.y + sin(float(i) + u_time) * 2.), 0.0525);\n            shape4 += circle(vec2(uv2.x - sin(float(i) + u_time) * 2. , uv2.y + sin(float(i) + u_time) * 2.), 0.0525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:iI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.15);\n        for (int i=5; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, sin(u_time * 0.15 * (float(i))));\n            shape1 += circle(vec2(uv2.x + cos(float(i) + u_time) - float(i)/10. , uv2.y + sin(float(i) + u_time) + float(i)/10.), 0.0525);\n            shape2 += circle(vec2(uv2.x + cos(float(i) + u_time) + float(i)/10.  , uv2.y - sin(float(i) + u_time) - float(i)/10.), 0.0525);\n            shape3 += circle(vec2(uv2.x + sin(float(i) + u_time) + float(i)/10. , uv2.y + cos(float(i) + u_time) - float(i)/10.), 0.0525);\n            shape4 += circle(vec2(uv2.x - sin(float(i) + u_time) + float(i)/10. , uv2.y + cos(float(i) + u_time) - float(i)/10.), 0.0525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.15);\n        for (int i=5; i<=150; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.0125 * (float(i))));\n            shape1 += circle(vec2(uv2.x + cos(float(i) + u_time) - float(i)/50. , uv2.y ), 0.0525);\n            shape2 += circle(vec2(uv2.x + cos(float(i) + u_time) + float(i)/50. , uv2.y ), 0.0525);\n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.15);\n        for (int i=0; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, sin(u_time * 0.0125));\n            shape1 += cirOutline(vec2(uv2.x + sin(float(i) * u_time/12.) - float(i)/12. , uv2.y + sin(float(i) * u_time/12.) + float(i)/10.), 0.0525);\n            shape2 += cirOutline(vec2(uv2.x - sin(float(i) * u_time/12.) + float(i)/12. , uv2.y + sin(float(i) * u_time/12.) + float(i)/10. ), 0.0525);\n            shape3 += circle(vec2(uv2.x + sin(float(i) * u_time/12.) - float(i)/12. , uv2.y + sin(float(i) * u_time/12.) + float(i)/10.), 0.0525);\n            shape4 += circle(vec2(uv2.x - sin(float(i) * u_time/12.) + float(i)/12. , uv2.y + sin(float(i) * u_time/12.) + float(i)/10. ), 0.0525);\n        }\n        \n        color += shape1; \n        color += shape2;\n        color -= shape3; \n        color -= shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        for (int i=0; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.25));\n            shape1 += cirOutline(vec2(uv2.x + (float(i)/4.) + cos(u_time * 0.5 + (float(i))), uv2.y+ sin(float(i)/4.) + sin(u_time * 0.5 + (float(i)))), 0.0525);\n            shape2 += cirOutline(vec2(uv2.x + (float(i)/4.) + cos(u_time + (float(i)) ), uv2.y+ sin(float(i)/4.) + sin(u_time * 0.5 + (float(i)))), 0.0525);\n            shape3 += cirOutline(vec2(uv2.x + (float(i)/4.) + sin(u_time * 0.5 + (float(i))), uv2.y+ sin(float(i)/4.) + cos(u_time)), 0.0525);\n            shape4 += cirOutline(vec2(uv2.x + (float(i)/4.) + sin(u_time + (float(i))), uv2.y+ sin(float(i)/4.) + cos(u_time)), 0.0525);\n        }\n        \n        color += shape1; \n        color += shape2;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFour(vec2(p.x + 0.3, p.y));\n        float center = sdNine(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *8. - 3.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=0; i<=25; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.25));\n            float y = sin(u_time + uv2.x + (float(i) * sin(u_time + 25.) * 0.1));\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i)), uv2.y), y, 0.05 );\n        }\n        \n        color += shape1; \n        color += shape2;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=0; i<=20; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.125) + 2.5);\n            float y = abs(sin(u_time + uv2.x + (float(i) * cos(u_time + 025.) * 0.00161)) + 1.5);\n            float x = abs(cos(u_time + uv2.x + (float(i) * sin(u_time + 025.) * 0.00161)) + 1.5);\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i)), uv2.y), x / y, 0.0375 );\n        }\n        \n        color += shape1; \n        color += shape2;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=0; i<=20; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.125) + 2.5);\n            float y = abs(sin(u_time + uv2.x + (float(i) * cos(u_time + 025.) * 0.00161)) + .05);\n            float x = abs(cos(u_time + uv2.x + (float(i) * sin(u_time + 025.) * 0.00161)) + .05);\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i) * u_time), uv2.y), x, 0.04575 );\n        }\n        \n        color += shape1; \n        color += shape2;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _I=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=8; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            uv2 = Rot(uv2, sin(u_time * 0.25) + 10.5);\n            float y = (sin(u_time + uv2.x + (float(i) * cos(u_time * 25.) * 0.00161)) + .05);\n            float x = (cos(u_time + uv2.x + (float(i) * sin(u_time * 25.) * 0.00161)) + .05);\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i)/100. + u_time), uv2.y), x, 0.04575 );\n        }\n\n        float z = circle(uv2, 10.5);\n        \n        color += shape1; \n        color += shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_I,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var SI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=8; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, cos(u_time * 0.025) + 10.5 / 1.);\n            float y = (sin(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05);\n            float x = (sin(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05);\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i)/100. + u_time), uv2.y), x * y, 0.04575 );\n        }\n\n        float z = circle(uv2, 10.5);\n        \n        color += shape1; \n        color += shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function MI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:SI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *5. - 2.;\n        // uv2.x -= 1.;\n        uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=5; i++)\n        {\n            // uv2 = uv2 * 1.1 - 0.1;\n            // uv2 = Rot(uv2, cos(u_time * 0.025) + 10.5 / 1.);\n            float y = (sin(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            float x = (sin(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            float z = (cos(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            float a = (cos(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            shape1 += plot(vec2(uv2.x + sin(u_time + float(i)/100. + u_time), uv2.y), y * x, 0.075 );\n            shape2 += plot(vec2(uv2.x + cos(u_time + float(i)/100. * u_time), uv2.y), z * a, 0.075 );\n        }\n\n        float z = circle(uv2, 10.5);\n        \n        color += shape1; \n        color *= shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var CI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        vec2 uv3 = vUv;\n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, PI * 0.5);\n        uv2 = uv2 *15. - 15.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=10; i++)\n        {\n            for(int j=1; j<=10; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i) * 1.5, newUv.y + float(j) * 1.5), sin(u_time + 0.075 * float(j + i))*4.);\n                float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(1.));\n                \n                shape1 += line;\n            }\n            // uv2 = uv2 * 1.1 - 0.1;\n            \n            // float y = (sin(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            // float x = (sin(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            // float z = (cos(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            // float a = (cos(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            // shape1 += plot(vec2(uv2.x + sin(u_time + float(i)/100. + u_time), uv2.y), y * x, 0.075 );\n            // shape2 += plot(vec2(uv2.x + cos(u_time + float(i)/100. * u_time), uv2.y), z * a, 0.075 );\n        }\n\n        float z = circle(uv3, 0.75);\n        \n        color += shape1; \n        // color *= shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function TI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:CI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var RI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        vec2 uv3 = vUv;\n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *25. - 25.5;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=20; i++)\n        {\n            for(int j=1; j<=20; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i) * 1.5, newUv.y + float(j) * 1.5), sin(u_time + 0.075 * float(j * i)/4.)*4.);\n                float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                \n                shape1 += line;\n            }\n            // uv2 = uv2 * 1.1 - 0.1;\n            \n            // float y = (sin(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            // float x = (sin(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            // float z = (cos(u_time + uv2.x + (float(i) * sin(u_time * .5) * 0.161)) + .05)/1.25;\n            // float a = (cos(u_time * 0.005 * uv2.x + (float(i) * (u_time * .05))) + .05)/1.25;\n            // shape1 += plot(vec2(uv2.x + sin(u_time + float(i)/100. + u_time), uv2.y), y * x, 0.075 );\n            // shape2 += plot(vec2(uv2.x + cos(u_time + float(i)/100. * u_time), uv2.y), z * a, 0.075 );\n        }\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color *= shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function DI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:RI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var PI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        vec2 uv3 = vUv;\n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *25. - 24.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=15; i++)\n        {\n            for(int j=1; j<=15; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i) * 1.5, newUv.y + float(j) * 1.5), cos(u_time + 0.08 * float(j * i)/5.) + 0.53*1.9);\n                float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                float r = rect(vec2(newUv), 0.45, 3.);\n                shape1 += r;\n            }\n        }\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color *= shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function FI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:PI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        vec2 uv3 = vUv;\n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *15. - 15.;\n        // uv2.x -= 1.;\n        // uv2 = Rot(uv2, u_time * 0.15);\n        \n        for (int i=1; i<=15; i++)\n        {\n            for(int j=1; j<=15; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i) * 1.5, newUv.y + float(j) * 1.5), cos(u_time + 0.08 * float(j * i)/5.) + 0.53*1.9);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                shape1 += c;\n            }\n        }\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color *= shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function II(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdZero(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *2. - 0.5;\n        // uv2.x -= 1.;\n        vec2 uv3 = uv2;\n        uv2 = Rot(uv2, u_time * 0.75);\n        uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<=5; i++)\n        {\n            for(int j=1; j<=15; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i) * 0.085, newUv.y + float(i) * .085), (u_time + 0.08 * float(j * i)/5.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                shape1 += rectOutline(vec2(newUv), 0.5, 0.5);\n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function OI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:EI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *1.5 - 0.5;\n        uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<=13; i++)\n        {\n            for(int j=1; j<=10; j++)\n            {\n                \n                vec2 newUv = uv2;\n                newUv = Rot(vec2(newUv.x + float(i /2) * 0.085, newUv.y + float(j) * .085), sin(u_time + 0.05 * float(j * i)/2.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                // float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                shape1 += rectOutline(vec2(newUv), 0.15, 0.15);\n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:AI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<=5; i++)\n        {\n            for(int j=1; j<=5; j++)\n            {\n                \n                vec2 newUv = uv2;\n                // newUv = Rot(vec2(newUv.x + float(i /2) * 0.085, newUv.y + float(j) * .085), sin(u_time + 0.05 * float(j * i)/2.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                // float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                // shape1 += rectOutline(vec2(newUv), 0.15, 0.15);\n                // for (int i=0; i<=10; i++)\n                \n            // uv2 = uv2 * 1.1 - 0.1;\n                uv2 = Rot(uv2, (u_time * float(i * j) * 0.025)/11. + 100.);\n                shape1 += circle(vec2(uv2.x + sin(float(i) + u_time)  , uv2.y), 0.00525);\n                shape2 += circle(vec2(uv2.x  , uv2.y + sin(float(i) + u_time)), 0.00525);\n                shape3 += circle(vec2(uv2.x + sin(float(i) + u_time), uv2.y + sin(float(i) + u_time)), 0.00525);\n                shape4 += circle(vec2(uv2.x - sin(float(i) + u_time), uv2.y + sin(float(i) + u_time)), 0.00525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        \n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        color += shape2;\n        // color *= z;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function NI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:GI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var BI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<7; i++)\n        {\n            for(int j=1; j<=7; j++)\n            {\n                \n                vec2 newUv = uv2;\n                // newUv = Rot(vec2(newUv.x + float(i /2) * 0.085, newUv.y + float(j) * .085), sin(u_time + 0.05 * float(j * i)/2.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                // float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                // shape1 += rectOutline(vec2(newUv), 0.15, 0.15);\n                // for (int i=0; i<=10; i++)\n                \n            // uv2 = uv2 * 1.1 - 0.1;\n                uv2 = Rot(uv2, sin(u_time * 0.000115));\n                shape1 += circle(vec2(uv2.x + sin(float(i * j) + (u_time * 0.5))  , uv2.y), 0.00525);\n                shape2 += circle(vec2(uv2.x  , uv2.y + cos(float(i - j) + (u_time * 0.5))), 0.00525);\n                shape3 += circle(vec2(uv2.x + sin(float(j -i  ) + (u_time * 0.5)), uv2.y + cos(float(j * i) + (u_time * 0.5))), 0.00525);\n                shape4 += circle(vec2(uv2.x - sin(float(j * i) +(u_time * 0.5)), uv2.y + cos(float(j * i) + (u_time * 0.5))), 0.00525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        \n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        color += shape2;\n        // color *= z;\n        color += shape3; \n        color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:BI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var VI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<15; i++)\n        {\n            for(int j=1; j<=10; j++)\n            {\n                \n                vec2 newUv = uv2;\n                // newUv = Rot(vec2(newUv.x + float(i /2) * 0.085, newUv.y + float(j) * .085), sin(u_time + 0.05 * float(j * i)/2.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                // float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                // shape1 += rectOutline(vec2(newUv), 0.15, 0.15);\n                // for (int i=0; i<=10; i++)\n                \n            // uv2 = uv2 * 1.1 - 0.1;\n                uv2 = Rot(uv2, sin(u_time * 0.00115 * float(i)));\n                shape1 += circle(vec2(uv2.x + sin(float(i - j)/30. + (u_time * 0.25)) * 2. , uv2.y), 0.00525);\n                shape2 += circle(vec2(uv2.x  , uv2.y + cos(float(i - j) + (u_time * 0.5))), 0.00525);\n                shape3 += circle(vec2(uv2.x + sin(float(j -i  ) + (u_time * 0.5)), uv2.y + cos(float(j * i) + (u_time * 0.5))), 0.00525);\n                shape4 += circle(vec2(uv2.x - sin(float(j * i) +(u_time * 0.5)), uv2.y + cos(float(j * i) + (u_time * 0.5))), 0.00525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        \n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function WI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:VI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var HI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<15; i++)\n        {\n            for(int j=1; j<=5; j++)\n            {\n                \n                vec2 newUv = uv2;\n                // newUv = Rot(vec2(newUv.x + float(i /2) * 0.085, newUv.y + float(j) * .085), sin(u_time + 0.05 * float(j * i)/2.) + 0.53*1.);\n                // float line = sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.));\n                // float line = sdPolygonOutline(vec2(newUv.x , newUv.y ), int(3), float(0.5 + sin(u_time * 0.125)/5.));\n                // float r = rect(vec2(newUv), 0.45, 3.);\n                // float c = sdCircleOutline(vec2(newUv), float(i - j) * sin(u_time)/2. + 1.);\n                // shape1 += c;\n                // shape1 += rectOutline(vec2(newUv), 0.15, 0.15);\n                // for (int i=0; i<=10; i++)\n                \n            // uv2 = uv2 * 1.1 - 0.1;\n                uv2 = Rot(uv2, (sin(u_time * 0.0525)));\n                // shape1 += circle(vec2(uv2.x + sin(float(i * j)/30. + (u_time * 0.25)) * 1. , uv2.y), 0.00525);\n                shape1 += sdSegment(vec2(newUv.x , newUv.y ), vec2(0.0), vec2(0.5 + sin(u_time * 0.125)/5.) * sin(float(i + j)));\n                // shape2 += circle(vec2(uv2.x  , uv2.y + cos(float(i - j) + (u_time * 0.5))), 0.00525);\n                // shape3 += circle(vec2(uv2.x + sin(float(j ) + (u_time * 0.5)), uv2.y + cos(float(j) + (u_time * 0.5))), 0.00525);\n                // shape4 += circle(vec2(uv2.x - sin(float(j) +(u_time * 0.5)), uv2.y + cos(float(j ) + (u_time * 0.5))), 0.00525);\n            // uv2 = Rot(uv2, u_time * 0.25 * float(i)/5.);\n            \n        \n                // shape2 += rectOutline(vec2(uv3), 0.5, 0.5);\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function XI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:HI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var YI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *4. - 1.5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<15; i++)\n        {\n            for(int j=1; j<=5; j++)\n            {\n                \n                vec2 newUv = uv2;\n                \n                uv2 = Rot(uv2, ((u_time * 0.01525) + 10.));\n                uv2 = noise(uv2) * 0.08 + uv2;\n                shape1 += sdSegment(vec2(uv2.x , uv2.y ), vec2(0.0), vec2(2.));\n                \n\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ZI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:YI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *2. - .5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=2; i<5; i++)\n        {\n            for(int j=2; j<=5; j++)\n            {\n                \n                vec2 newUv = uv2;\n                \n                uv2 = Rot(uv2, (sin(u_time * 1.525)/5. - 10.2));\n                // uv2 = (noise(uv2) * 0.15) + uv2;\n                shape1 += sdSegment(vec2(uv2.x , uv2.y), vec2(0.0 + noise(uv2) * (cos(u_time)/1. + 2.) * 0.2, 0.0 + noise(uv2) * (sin(u_time)/1. + 2.)), vec2(0.0 + noise(uv2) * (cos(u_time)/1. + 2.), 0.0 + noise(uv2) * (sin(u_time)/1. + 2.)));\n                \n\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        // float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        // color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function JI(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:QI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KI=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *2. - .5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<14; i++)\n        {\n            for(int j=1; j<=4; j++)\n            {\n                \n                vec2 newUv = uv2;\n                \n                uv2 = Rot(uv2, (sin(u_time * .175)/4. + 11.0));\n                uv2 = (noise(uv2) * 0.15) + uv2;\n                shape1 += sdSegment(vec2(uv2.x , uv2.y), vec2(0.0), vec2(0.01 * float(i + j), 0.01 * float(i +j)));\n                shape2 += sdSegment(vec2(uv2.x , uv2.y), vec2(0.0), vec2(0.015 * float(j + i), 0.015 * float(j + i)));\n                \n\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        // float z = circle(uv3, 0.95);\n        \n        color += shape1; \n        color += shape2;\n        // color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $I(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:KI,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        \n        // uv2.x += 1.;\n        // uv2.y -0.2;\n        // uv2 = Rot(uv2, 0.15 * u_time);\n        uv2 = uv2 *2. - .5;\n        // uv2.y -= .2;\n        vec2 uv3 = uv2;\n        // uv2 = Rot(uv2, u_time * 0.75);\n        // uv3 = Rot(uv3, u_time * 0.5 + PI * 0.25);\n\n        for (int i=1; i<5; i++)\n        {\n            for(int j=1; j<=4; j++)\n            {\n                \n                vec2 newUv = uv2;\n                \n                uv2 = Rot(uv2, (sin(u_time * .175)/6. + 11.0));\n                uv2 = (noise(uv2) * 0.15) + uv2;\n                shape1 += sdSegment(vec2(uv2.x , uv2.y), vec2(0.0), vec2(0.05 * float(i) + cos(u_time), 0.05 / float(i) + cos(u_time)));\n                shape2 += sdSegment(vec2(uv2.x , uv2.y), vec2(0.0), vec2(0.05 * float(i) + sin(u_time), 0.05 / float(i) + sin(u_time)));\n                \n\n            }\n        }\n       \n        \n        \n        // shape1 += box;\n        // shape2 += box2;\n\n        float z = circle(uv3, 2.);\n        \n        color += shape1; \n        color += shape2;\n        color *= z;\n        // color += shape3; \n        // color += shape4;  \n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function eE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdOne(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    float semi (vec2 p, float n)\n    {\n        float c = circle(vec2(p), n);\n        float c2 = circle(vec2(p), n + n * 0.05);\n        float r = rect(vec2(p.x, p.y- n * 0.45), n - n * 0.1, n + n * 0.5);\n        float r2= rect(vec2(p.x, p.y -0.2), n, n * 0.3);\n        float shape = r * c * 2.;\n        float shape2 = r2 * c2* 2.;\n        return shape;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        uv2 = uv2 *2. - .5;\n\n        for(int i = 1; i < 20; i++)\n        {\n            uv2 = Rot(uv2, ((u_time * .175)/1. + 1.0));\n            vec2 newUv = uv2;\n            shape1 += semi(newUv, float(i)/10. + 0.5);\n            shape2 -= semi(newUv, float(i)/10. + 0.45);\n        }\n        \n        \n        color += shape1; \n        color += shape2;\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function oE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    float semi (vec2 p, float n)\n    {\n        float c = circle(vec2(p), n);\n        float c2 = circle(vec2(p), n + n * 0.05);\n        float r = rect(vec2(p.x, p.y- n * 0.45), n - n * 0.1, n + n * 0.5);\n        float r2= rect(vec2(p.x, p.y -0.2), n, n * 0.3);\n        float shape = r * c * 2.;\n        float shape2 = r2 * c2* 2.;\n        return shape;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        uv2 = uv2 *2. - .5;\n\n        for(int i = 0; i < 20; i++)\n        {\n            uv2 = Rot(uv2, ((u_time * .275)));\n            vec2 newUv = uv2;\n            float n = noise(newUv) + u_time;\n            \n            shape1 += semi(newUv, float(i)/5. + 0.5);\n            shape2 -= semi(newUv, float(i)/5. + 0.45);\n            shape3 += semi(newUv, float(i)/10. + 0.52);\n            shape4 -= semi(newUv, float(i)/10. + 0.45);\n        }\n        \n        color += shape1; \n        color += shape2;\n        color *= shape3 * 1.5; \n        color += shape4;\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function aE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    float semi (vec2 p, float n)\n    {\n        float c = circle(vec2(p), n);\n        float c2 = circle(vec2(p), n + n * 0.05);\n        float r = rect(vec2(p.x, p.y- n * 0.45), n - n * 0.1, n + n * 0.5);\n        float r2= rect(vec2(p.x, p.y -0.2), n, n * 0.3);\n        float shape = r * c * 2.;\n        float shape2 = r2 * c2* 2.;\n        return shape;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float shape1;\n        float shape2;\n        float shape3;\n        float shape4;\n        vec2 uv2 = vUv;\n        \n        uv2 = uv2 *3. - 1.;\n\n        for(int i = 1; i < 80; i++)\n        {\n            uv2 = Rot(uv2, ((u_time * .275 )));\n            // uv2 *= 2. - 1.;\n            vec2 newUv = uv2;\n            // float n = noise(newUv) * u_time;\n            // newUv += n * 0.0005;\n            shape1 += semi(newUv, float(i)/5. + 0.5);\n            shape2 -= semi(newUv, float(i)/5. + 0.45);\n            shape3 += semi(newUv, float(i)/10. + 0.52);\n            shape4 -= semi(newUv, float(i)/10. + 0.45);\n        }\n        \n        color += shape1; \n        color += shape2;\n        color *= shape3 * 2.5; \n        color += shape4;\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:iE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n\n        uv2 *= 4.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 1.;\n        float seg;\n        float shape;\n\n        for(int y = -2; y <=2; y++){\n            for(int x = -2; x <=2; x++){\n                vec2 n = vec2(float(x), float(y));\n                vec2 p = random2(iUv + n);\n                p = 0.5 + 0.5 * sin(u_time + TWO_PI * p);\n                vec2 dif = n + p - fUv;\n                float dist = length(dif);\n                m_dist = min(m_dist, dist);\n                shape = min(m_dist, dist);\n                // m_dist = smoothstep(0.05, 0.051, m_dist);\n                \n                // seg = sdSegment(fUv, dif, dif * dis);\n            }\n        }\n        color += seg;\n        color += shape;\n        // color += smoothstep(0.9, 0.11, shape);\n        // color += 1. - m_dist;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n    \n        vec2 mg,mr;\n        float md=1.;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.75)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=0.5;\n        for(int i=-5;i<=5;i++){\n            for(int j=-5;j<=5;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.75)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.001){\n                    md=min(md,dot(.25*(mr+r),normalize(r-mr)));\n                    \n                }\n            }\n        }\n        return vec3(md, mr);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n\n        uv2 *= 5.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 50.;\n        float seg;\n        float shape;\n\n        vec3 s = voronoi(uv2);\n        float dd = length(s.yz);\n\n        color+=mix(vec3(1.), color, smoothstep(0.002, 0.05, dd * s.x));\n        // color += 1. - smoothstep(0.01, 0.012, s.x);\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n    \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n            }\n        }\n        return vec3(md, mr);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n\n        uv2 *= 10.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 50.;\n        float seg;\n        float shape;\n\n        vec3 s = voronoi(uv2);\n        float dd = length(s.yz) + 0.;\n\n        color+=mix(vec3(1.), color, smoothstep(0.09, 0.061, dd * s.x));\n        // color += 1. - smoothstep(0.01, 0.02, s.x);\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float seg;\n        vec2 uv2 = vUv;\n\n        uv2 *= 5.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 50.;\n        float shape;\n\n        vec3 s = voronoi(uv2);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/4., uv2.y  + cos(u_time)/4.));\n        float dd = length(s.yz) + 0.;\n        seg = sdSegment(fUv, vec2(s2.yz), vec2(s.yz));\n        color+=mix(vec3(1.), color, smoothstep(0.01, 0.021, s.x));\n        color+= mix(vec3(1.), color,smoothstep(0.01, 0.021, s2.x));\n        // color += 1. - smoothstep(0.01, 0.02, s.x);\n        \n        // color += seg;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float seg;\n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, u_time * 0.1);\n        uv2 *= 10.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 50.;\n        float shape;\n\n        vec3 s = voronoi(uv2);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        float dd = length(s.yz) + 0.;\n        seg = sdSegment(fUv, vec2(s2.yz), vec2(s.yz));\n        color.r+= 1. - smoothstep(0.01 * 2., 0.021 * 2., s.x);\n        color.g+= 1. - smoothstep(0.0075 * 2., (0.021-0.0025) * 4., s2.x);\n        color.b+= 1. - smoothstep(0.005 * 2., (0.021 -0.005) * 4., s3.x);\n        // color += 1. - smoothstep(0.01, 0.02, s.x);\n        \n        // color += seg;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        float seg;\n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, u_time * 0.1);\n        uv2 *= 5.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 50.;\n        float shape;\n\n        vec3 s = voronoi(uv2);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        float dd = length(s.yz) + 0.;\n        seg = sdSegment(fUv, vec2(s2.yz), vec2(s.yz));\n        color.r+= 1. - smoothstep(0.01 * 2., 0.021 * 2.,  dd);\n        color.g+= 1. - smoothstep(0.0075 * 2., (0.021-0.0025) * 4., dd);\n        color.b+= 1. - smoothstep(0.005 * 2., (0.021 -0.005) * 4., s3.x / dd);\n        // color += 1. - smoothstep(0.01, 0.02, s.x);\n        \n        // color += seg;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    // 2D Random\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n                            vec2(12.9898,78.233)))\n                    * 43758.5453123);\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    // 2D Noise based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 st) {\n        vec2 i = floor(st);\n        vec2 f = fract(st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        // Smooth Interpolation\n\n        // Cubic Hermine Curve.  Same as SmoothStep()\n        vec2 u = f*f*(3.0-2.0*f);\n        // u = smoothstep(0.,1.,f);\n\n        // Mix 4 coorners percentages\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n\n        uv2 *= 4.;\n\n        vec2 iUv = floor(uv2);\n        vec2 fUv = fract(uv2);\n\n        float m_dist = 1.;\n        float seg;\n        float shape;\n\n        for(int y = -2; y <=2; y++){\n            for(int x = -2; x <=2; x++){\n                vec2 n = vec2(float(x), float(y));\n                vec2 p = random2(iUv + n);\n                p = 0.25 + 0.25 * sin(u_time + TWO_PI * p );\n                vec2 dif = n + p - fUv;\n                float dist = length(dif);\n                m_dist = min(m_dist, dist);\n                shape = min(m_dist, dist);\n                // m_dist = smoothstep(0.05, 0.051, m_dist);\n                \n                seg = sdSegment(p, vec2(m_dist /dist), vec2(m_dist));\n                color += seg;\n            }\n        }\n        \n        // color += shape;\n        // color += smoothstep(0.9, 0.11, shape);\n        // color += 1. - m_dist;\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _E=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdTwo(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    #define S(a, b, t) smoothstep(a, b, t)\n\n    float DistLine(vec2 p, vec2 a, vec2 b)\n    {\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n        return length(pa - ba * t);\n    }\n\n    float N21(vec2 p)\n    {\n        p = fract(p * vec2(445.23, 789.92));\n        p += dot(p, p + 54.23 );\n        return fract(p.x * p.y);\n    }\n\n    vec2 N22(vec2 p)\n    {\n        float n = N21(p);\n        return vec2(n, N21(p + n));\n    }\n\n    vec2 GetPos(vec2 id, vec2 offset)\n    {\n        vec2 n = N22(id+offset) * u_time;\n        // float x = sin(u_time* n.x);\n        // float y = cos(u_time*n.y);\n        return offset + sin(n) * .4;\n    }\n\n    float Line(vec2 p, vec2 a, vec2 b)\n    {\n        float d = DistLine(p, a, b);\n        float m = S(.03, 0.01, d);\n        m *= S(1.0, .5, length(a -b));\n        return m;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n        \n        // float d = DistLine(uv2, vec2(0.), vec2(1.));\n        float m = 0.;\n        \n        uv2 *= 8.;\n        vec2 gv = fract(uv2) - 0.5;\n        vec2 id = floor(uv2);\n\n        // vec2 p = N22(id) - 0.5;\n\n        vec2 p[9];\n\n        // vec2 p = GetPos(id);\n        // float d = length(gv - p);\n        // m = S(0.1, 0.05, d);\n\n        int i = 0;\n        for(float y=-1.; y <=1.; y++)\n        {\n            for(float x=-1.; x<=1.; x++)\n            {\n                p[i++]= GetPos(id, vec2(x, y));\n            }\n        }\n\n        float t = u_time * 10.;\n\n        for(int i=0; i < 9; i++)\n        {\n            m += Line(gv, p[4], p[i]);\n            \n            vec2 j = (p[i] - gv) * 40.;\n            float sparkle = 1. / dot(j, j);\n\n            m += sparkle * (sin(t+p[i].x * 10.) * .5 + .5);\n        }\n        m += Line(gv, p[1], p[3]);\n        m += Line(gv, p[1], p[5]);\n        m += Line(gv, p[7], p[3]);\n        m += Line(gv, p[7], p[5]);\n\n        vec3 col = vec3(m);\n        // col.rg = gv;\n\n        // color.rg = col.rg;\n\n        // color += m;\n        // if(gv.x > .48 || gv.y > .48) col = vec3(1., 0, 0);\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_E,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var SE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    #define S(a, b, t) smoothstep(a, b, t)\n\n    float DistLine(vec2 p, vec2 a, vec2 b)\n    {\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n        return length(pa - ba * t);\n    }\n\n    float N21(vec2 p)\n    {\n        p = fract(p * vec2(445.23, 789.92));\n        p += dot(p, p + 54.23 );\n        return fract(p.x * p.y);\n    }\n\n    vec2 N22(vec2 p)\n    {\n        float n = N21(p);\n        return vec2(n, N21(p + n));\n    }\n\n    vec2 GetPos(vec2 id, vec2 offset)\n    {\n        vec2 n = N22(id+offset) * u_time;\n        // float x = sin(u_time* n.x);\n        // float y = cos(u_time*n.y);\n        return offset + sin(n) * .4;\n    }\n\n    float Line(vec2 p, vec2 a, vec2 b)\n    {\n        float d = DistLine(p, a, b);\n        float m = S(.03, 0.01, d);\n        float d2 = length(a - b);\n        m *= S(1.2, .8, d2) * .5 + S(.05, .03, abs(d2-.75));\n        return m;\n    }\n\n    float Layer(vec2 uv2)\n    {\n        float m;\n        vec2 gv = fract(uv2) - 0.5;\n        vec2 id = floor(uv2);\n\n        // vec2 p = N22(id) - 0.5;\n\n        vec2 p[9];\n\n        // vec2 p = GetPos(id);\n        // float d = length(gv - p);\n        // m = S(0.1, 0.05, d);\n\n        int i = 0;\n        for(float y=-1.; y <=1.; y++)\n        {\n            for(float x=-1.; x<=1.; x++)\n            {\n                p[i++]= GetPos(id, vec2(x, y));\n            }\n        }\n\n        float t = u_time * 10.;\n\n        for(int i=0; i < 9; i++)\n        {\n            m += Line(gv, p[4], p[i]);\n            \n            vec2 j = (p[i] - gv) * 40.;\n            float sparkle = 1. / dot(j, j);\n\n            m += sparkle * (sin(t+fract(p[i].x) * 10.) * .5 + .5);\n        }\n        m += Line(gv, p[1], p[3]);\n        m += Line(gv, p[1], p[5]);\n        m += Line(gv, p[7], p[3]);\n        m += Line(gv, p[7], p[5]);\n\n        return m;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, u_time * 0.1);\n        uv2 -= 0.5;\n        \n        // float d = DistLine(uv2, vec2(0.), vec2(1.));\n        float m = 0.;\n        float t = u_time * 0.05;\n        \n        for(float i =0.; i <1.; i+= 1./4.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(20., .1, z);\n            float fade = S(0., 0.5, z) * S(1., 0.8, z);\n            m += Layer(uv2 * size + i * 20.) * fade;\n        }\n        \n\n        vec3 base = sin(t * vec3(.345, .456, .678)) * .4 + .6;\n        vec3 col = m * base;\n        col += uv2.y * base * 0.2;\n        col -= uv2.x  * base * 0.2;\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ME(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:SE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.4, p.y));\n        return left + center + right;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float GetDist(vec3 p)\n    {\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p.y;\n\n        float d = min(sphereDist, planeDist);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(0, 5, 6);\n        lightPos.xz += vec2(sin(u_time), cos(u_time)) * 2.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 1, 0);//camera\n        vec3 rd = normalize(vec3(uv2.x, uv2.y, 1));//ray direction\n\n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n\n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var CE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p.y;\n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, .5, 6), vec2(1., 0.3));\n        float bd = sdBox(p - vec3(-3, .75, 6), vec3(.5));\n        float cyld = sdCylinder(p, vec3(0, .3, 3), vec3(3, 1, 6), 0.2);\n\n        // float d = min(sphereDist, planeDist);\n        float d = min(cd, planeDist);\n        d = min(d, td);\n        d = min(d, bd);\n        d = min(d, cyld);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(0, 5, 6);\n        lightPos.xz += vec2(sin(u_time), cos(u_time)) * 2.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(sin(u_time), 3, -2.-cos(u_time));//camera\n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2, 1));//ray direction\n\n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n\n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function TE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:CE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var RE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p.y;\n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p - vec3(0, 2.75, 6.+ sin(u_time) * 2.), vec3(.5));\n        float bd2 = sdBox(p - vec3(0, 2.75+ cos(u_time * 2.) * 2., 6.), vec3(.5));\n        float bd3 = sdBox(p - vec3(0. + cos(u_time * 2.) * 2., 0.75, 6.), vec3(.5));\n        float cyld = sdCylinder(p, vec3(0, .3, 3), vec3(3, 1, 6), 0.2);\n\n        float d = min(bd, planeDist);\n        // float d = min(bd, planeDist);\n        d = min(bd, d);\n        d = min(bd2, d);\n        d = min(bd, d);\n        d = min(bd3, d);\n        // d = min(d, cyld);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 5, -2.-cos(u_time));//camera\n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2, 1));//ray direction\n\n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n\n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function DE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:RE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var PE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p2 - vec3(0, 2.75, 6.+ sin(u_time) * 2.), vec3(.5));\n        float bd2 = sdBox(p2 - vec3(0, 2.75+ cos(u_time * 2.) * 2., 6.), vec3(.5));\n        float bd3 = sdBox(p2 - vec3(0. + cos(u_time * 2.) * 2., 0.75, 6.), vec3(.5));\n        float cyld = sdCylinder(p, vec3(0, .3, 3), vec3(3, 1, 6), 0.2);\n\n        float d = min(bd, planeDist);\n        // float d = min(bd, planeDist);\n        d = min(bd, d);\n        d = min(bd2, d);\n        d = min(bd, d);\n        d = min(bd3, d);\n        // d = min(d, cyld);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(-1, 5, -6.);//camera\n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2, 1));//ray direction\n\n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n\n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function FE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:PE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p2 - vec3(0, 2.75 + sin(u_time), 6.), vec3(.5));\n        float bd2 = sdBox(p2 - vec3(-2. + sin(u_time), 2.75, 6.), vec3(.5));\n        float bd3 = sdBox(p2 - vec3(2. + sin(u_time), 2.75, 6.), vec3(.5));\n        float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        float d = min(bd, planeDist);\n        // float d = min(bd, planeDist);\n        d = min(bd, d);\n        d = min(bd2, d);\n        d = min(bd3, d);\n        d = min(cyld, d);\n        // d = min(d, cyld);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(-1, 5., -6.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function IE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, u_time);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p2 - vec3(0, 4.75 - sin(u_time), 6.), vec3(.5));\n        float bd2 = sdBox(p2 - vec3(-2. + sin(u_time), 2.75, 6.), vec3(.5));\n        float bd3 = sdBox(p2 - vec3(2. - sin(u_time), 2.75, 6.), vec3(.5));\n        float bd4 = sdBox(p2 - vec3(0. , 1.75 + sin(u_time), 6.), vec3(.5));\n        float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        float d = min(bd, planeDist);\n        // float d = min(bd, planeDist);\n        d = min(bd, d);\n        d = min(bd2, d);\n        d = min(bd3, d);\n        d = min(bd4, d);\n        // d = min(cyld, d);\n        // d = min(d, cyld);\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(-1, 5., -6.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function OE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:EE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, u_time);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p2 - vec3(0, 4.75 - sin(u_time), 6.), vec3(.5));\n        float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float shape;\n        for(int i =0; i<= 5; i++)\n        {\n            // shape = sdBox(p2 - vec3(0., 0.+ (float(i)), 5.), vec3(.5));\n            // float d = min(shape, planeDist);\n            float d = min(sdBox(p2 - vec3(0. , 0. + 2., 6.), vec3(.5)), planeDist);\n            // d = min(bd, d);\n            d = min(bd2, d);\n            d = min(bd3, d);\n            d = min(bd4, d);\n        // d = min(cyld, d);\n        // d = min(d, cyld);\n            return d;\n            // return d;\n        }\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(-1, 5., -6.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:AE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, u_time);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox2(vec3 p, vec3 s)\n    {\n        p = rotateX(p, u_time);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox3(vec3 p, vec3 s)\n    {\n        p = rotateZ(p, u_time);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p - vec3(0, 3. , 6.), vec3(.5));\n        float bd2 = sdBox2(p - vec3(0, 4.5 , 6.), vec3(.5));\n        float bd3 = sdBox3(p - vec3(0, 1.5 , 6.), vec3(.5));\n        float bd4 = sdBox3(p - vec3(-1.5, 3. , 6.), vec3(.5));\n        float bd5 = sdBox(p - vec3(-1.5, 4.5 , 6.), vec3(.5));\n        float bd6 = sdBox2(p - vec3(-1.5, 1.5 , 6.), vec3(.5));\n        float bd7 = sdBox2(p - vec3(1.5, 3. , 6.), vec3(.5));\n        float bd8 = sdBox3(p - vec3(1.5, 4.5 , 6.), vec3(.5));\n        float bd9 = sdBox(p - vec3(1.5, 1.5 , 6.), vec3(.5));\n        // float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        // float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        // float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        // float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float d = min(bd, planeDist);\n        d = min(bd2, d);\n        d = min(bd3, d);\n        d = min(bd4, d);\n        d = min(bd5, d);\n        d = min(bd6, d);\n        d = min(bd7, d);\n        d = min(bd8, d);\n        d = min(bd9, d);\n\n        return d;\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 4., 0.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function NE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:GE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var BE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdThree(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        p.x += sin(u_time);\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    mat3 identity() {\n        return mat3(\n            vec3(1, 0, 0),\n            vec3(0, 1, 0),\n            vec3(0, 0, 1)\n        );\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox2(vec3 p, vec3 s)\n    {\n        p = rotateX(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox3(vec3 p, vec3 s)\n    {\n        p = rotateZ(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 1.5, 6), vec2(1., 0.3));\n        float bd = sdBox(p - vec3(0. + sin(u_time), 3. + cos(u_time), 6.), vec3(.5));\n        float bd2 = sdBox2(p - vec3(0. + cos(u_time), 4.5 + cos(u_time) , 6.), vec3(.5));\n        float bd3 = sdBox3(p - vec3(0. + sin(u_time), 1.5 + cos(u_time), 6.), vec3(.5));\n        float bd4 = sdBox3(p - vec3(-1.5 + sin(u_time), 3. + cos(u_time) , 6.), vec3(.5));\n        float bd5 = sdBox(p - vec3(-1.5, 4.5 , 6.), vec3(.5));\n        float bd6 = sdBox2(p - vec3(-1.5, 1.5 , 6.), vec3(.5));\n        float bd7 = sdBox2(p - vec3(1.5 + sin(u_time), 3. + sin(u_time) , 6.), vec3(.5));\n        float bd8 = sdBox3(p - vec3(1.5, 4.5 , 6.), vec3(.5));\n        float bd9 = sdBox(p - vec3(1.5, 1.5 , 6.), vec3(.5));\n        // float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        // float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        // float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        // float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float d = min(bd, planeDist);\n        d = min(bd2, d);\n        d = min(bd3, d);\n        d = min(bd4, d);\n        // d = min(bd5, d);\n        // d = min(bd6, d);\n        d = min(bd7, d);\n        // d = min(bd8, d);\n        // d = min(bd9, d);\n\n        return d;\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 4., 0.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:BE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var VE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus2(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox2(vec3 p, vec3 s)\n    {\n        p = rotateX(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox3(vec3 p, vec3 s)\n    {\n        p = rotateZ(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 3., 6), vec2(1., 0.3));\n        float bd = sdBox(p - vec3(0., 3., 6.), vec3(.5));\n        float td2 = sdTorus2(p-vec3(0, 3., 6), vec2(.4, 0.2));\n        // float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        // float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        // float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        // float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float d = min(td, planeDist);\n\n        d = min(td2, d);\n\n        return d;\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 4., 0.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function WE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:VE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var HE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus2(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus3(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateZ(p, (u_time));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus4(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time *2.));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox2(vec3 p, vec3 s)\n    {\n        p = rotateX(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox3(vec3 p, vec3 s)\n    {\n        p = rotateZ(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 3., 6), vec2(1., 0.2));\n        float bd = sdBox(p - vec3(0., 3., 6.), vec3(.5));\n        float td2 = sdTorus2(p-vec3(0, 3., 6), vec2(.4, 0.1));\n        float td3 = sdTorus3(p-vec3(0, 3., 6), vec2(1.5, 0.1));\n        float td4 = sdTorus4(p-vec3(0, 3., 6), vec2(2.0, 0.2));\n        // float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        // float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        // float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        // float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float d = min(td, planeDist);\n\n        d = min(td2, d);\n        d = min(td3, d);\n        d = min(td4, d);\n\n        return d;\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 4., 0.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function XE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:HE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var YE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    // mat3 rotateY(float theta) {\n    //     float c = cos(theta);\n    //     float s = sin(theta);\n    //     return mat3(\n    //         vec3(c, 0, s),\n    //         vec3(0, 1, 0),\n    //         vec3(-s, 0, c)\n    //     );\n    // }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    float sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        t = clamp(t, 0., 1.);\n\n        vec3 c = a + t * ab;\n        return length(p - c) - r;\n    }\n\n    float sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n    {\n        vec3 ab = b-a;\n        vec3 ap = p-a;\n\n        float t = dot(ab, ap)/dot(ab, ab);\n        // t = clamp(t, 0., 1.); //infinite\n\n        vec3 c = a + t * ab;\n        float x = length(p - c) - r;\n        float y = (abs(t - .5) - .5) * length(ab);\n        float e = length(max(vec2(x,y), 0.));\n        float i = min(max(x, y), 0.);\n\n        return e + i;\n    }\n\n    float sdTorus(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus2(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus3(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateZ(p, (u_time));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdTorus4(vec3 p, vec2 r)\n    {\n        // p.x += sin(u_time);\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time *2.));\n        \n        float x = length(p.xz) - r.x;\n        return length(vec2(x, p.y)) - r.y;\n    }\n\n    float sdBox(vec3 p, vec3 s)\n    {\n        p = rotateY(p, (u_time));\n        p = rotateX(p, (u_time));\n        p = rotateZ(p, (u_time));\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox2(vec3 p, vec3 s)\n    {\n        p = rotateX(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float sdBox3(vec3 p, vec3 s)\n    {\n        p = rotateZ(p, sin(u_time)*2.);\n        return length(max(abs(p) - s, 0.));\n    }\n\n    float GetDist(vec3 p)\n    {\n        \n        vec3 p2 = vec3(p);\n        // p2 = rotateY(p2, sin(u_time)*0.5);\n        // mat3 i = identity(p2);\n        vec4 s = vec4(0, 1, 6, 1);\n        float sphereDist = length(p -s.xyz) - s.w;\n        float planeDist = p2.y;\n\n        // float shape; \n        float n = cnoise(p + u_time) * 0.15;\n        float cd = sdCapsule(p, vec3(0, 1, 6), vec3(1, 2, 6), 0.2);\n        float td = sdTorus(p-vec3(0, 3., 6) + n, vec2(1., 0.2));\n        float bd = sdBox(p - vec3(0., 3., 6.) + n, vec3(.5));\n        float td2 = sdTorus2(p-vec3(0, 3., 6), vec2(.4, 0.1));\n        float td3 = sdTorus3(p-vec3(0, 3., 6), vec2(1.5, 0.1));\n        float td4 = sdTorus4(p-vec3(0, 3., 6) + n, vec2(2.0, 0.2));\n        // float bd2 = sdBox(p2 - vec3(1. + sin(u_time), 4., 6.), vec3(.5));\n        // float bd3 = sdBox(p2 - vec3( sin(u_time)-1., 4., 6.), vec3(.5));\n        // float bd4 = sdBox(p2 - vec3(0. , 2. + abs(sin(u_time)), 6.), vec3(.5));\n        // float cyld = sdCylinder(p2, vec3(0.  + sin(u_time) * 2., .3 , 3), vec3(3, 1. , 6), 0.2);\n\n        \n        float d = min(bd, planeDist);\n\n        // d = min(td2, d);\n        // d = min(td3, d);\n        d = min(td4, d);\n\n        return d;\n\n        \n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd)\n    {\n        float dO=0.;\n\n        for(int i=0; i <MAX_STEPS; i++)\n        {\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO>MAX_DIST || dS<SURF_DIST) break;\n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d = GetDist(p);\n        vec2 e = vec2(0.01, 0);\n        vec3 n = d - vec3(\n            GetDist(p-e.xyy),\n            GetDist(p-e.yxy),\n            GetDist(p-e.yyx)\n        );\n        return normalize(n);\n    }\n\n    float GetLight(vec3 p)\n    {\n        vec3 lightPos = vec3(2, 15, 3);\n        // lightPos.xz += vec2(sin(u_time), cos(u_time)) * 4.;\n        vec3 l = normalize(lightPos - p);\n        vec3 n = GetNormal(p);\n\n        float dif = clamp(dot(n, l), 0., 1.);\n\n        float d = RayMarch(p + n * SURF_DIST * 2., l);\n        if(d < length(lightPos -p)) dif *= .1;\n\n        return dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0, 4., 0.);//camera\n        \n        vec3 rd = normalize(vec3(uv2.x, uv2.y - .2 , 1));//ray direction\n        \n        float d = RayMarch(ro, rd);\n\n        vec3 p = ro + rd * d;\n        \n        float dif = GetLight(p);\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ZE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:YE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.35, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        float d = max(a.w, b.w);\n        return d == a.w? a : b;\n    }\n    \n    vec4 unionSDF(vec4 a, vec4 b) {\n        float d = min(a.w, b.w);\n        return d == a.w? a : b;\n    }\n    \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        float d = max(a.w, -b.w);\n        return d == a.w ? a : vec4(b.rgb,-b.w);\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1.); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(u_time * .2);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.,1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,1.05));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0);\n     \n    csg0 = differenceSDF(b0,s0); // Intersect box with sphere creating a CSG object.\n\n    \n     \n    // csg1 = unionSDF(c0,c1); // Unite cylinders\n    // csg1 = unionSDF(csg1,c2);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg0, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(5.*sin(u_time),5.,5.*cos(u_time));// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.5,-3.5); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function JE(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:QE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KE=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdFour(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        float d = max(a.w, b.w);\n        return d == a.w? a : b;\n    }\n    \n    vec4 unionSDF(vec4 a, vec4 b) {\n        float d = min(a.w, b.w);\n        return d == a.w? a : b;\n    }\n    \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        float d = max(a.w, -b.w);\n        return d == a.w ? a : vec4(b.rgb,-b.w);\n    }\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1.); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(u_time * .2);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.85,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .2);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .2);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.,1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,1.05));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0);\n     \n    csg0 = differenceSDF(b0, b1); // Intersect box with sphere creating a CSG object.\n\n    \n     \n    csg1 = differenceSDF(csg0,b2);\n\n    // csg1 = unionSDF(csg1,c2);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg1, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.5,-3.5); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $E(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:KE,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdFive(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1.); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(u_time * .2);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.85,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .2);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .2);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2.,1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0.,0.5,1.);\n    s1p=p-s1p;\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, b1, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, s0, 0.15 + sin(u_time * 1.5)/8.);\n     \n    csg2 = smoothDifferenceSDF(csg1, s1, 0.15 + cos(u_time * 1.5)/8.);\n\n    csg3 = smoothDifferenceSDF(csg2, b2, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg3, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function eO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdSix(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(1,0,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1.); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(u_time * .4);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(1.5,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2.,1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0.,0.5,1.);\n    s1p=p-s1p;\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n     \n    csg0 = smoothUnionSDF(b0, b1, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothUnionSDF(csg0, s0, 0.25);\n     \n    // csg2 = smoothDifferenceSDF(csg1, s1, 0.15 + cos(u_time * 1.5)/8.);\n\n    csg3 = smoothUnionSDF(csg1, b2, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg3, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function oO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdSeven(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(1,0,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(u_time * .4);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(1.5,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2. - sin(u_time),1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0.,2. + sin(u_time),1.);\n    s1p=p-s1p;\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, b1, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothUnionSDF(csg0, s1, 0.25);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.25);\n\n    csg3 = smoothUnionSDF(csg2, s1, 0.25);\n\n    csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    csg5 = smoothDifferenceSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg5, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function aO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdEight(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(1,0,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.0175,1.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(1.5,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2. - sin(u_time),1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0. + sin(u_time),2. ,1.);\n    s1p=p-s1p;\n    s1p.xz *=Rotate(0.1);\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, p0, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothUnionSDF(csg0, s1, 0.25);\n     \n    // csg2 = smoothUnionSDF(csg1, s1, 0.25);\n\n    // csg3 = smoothUnionSDF(csg2, s1, 0.25);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothDifferenceSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg1, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:iO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFour(vec2(p.x -0.035, p.y));\n        float right = sdNine(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.0175,1.75,1.5); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1 + sin(u_time));\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(1.5,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(2.,2. - sin(u_time),2.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0. + sin(u_time) * 2.,2. ,.5);\n    s1p=p-s1p;\n    s1p.xz *=Rotate(0.1);\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, p0, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothUnionSDF(csg0, s1, 0.25);\n     \n    // csg2 = smoothUnionSDF(csg1, s1, 0.25);\n\n    // csg3 = smoothUnionSDF(csg2, s1, 0.25);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothDifferenceSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg1, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdZero(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.25 + sin(u_time)/5.)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.75); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(BoxColor1.rgb,roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(2.,2. - sin(u_time),2.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, p0, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b2, 0.25);\n     \n    csg2 = smoothDifferenceSDF(csg1, b1, 0.25);\n\n    // csg3 = smoothUnionSDF(csg2, s1, 0.25);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothDifferenceSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg0, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdOne(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.25 + sin(u_time)/5.)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.75); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(1.25,.5,.75);\n    vec3 b3p = vec3(0., 1.5, 1.);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2. - sin(u_time),0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,.5));\n\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothUnionSDF(b1, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b2, 0.125);\n     \n    csg2 = unionSDF(csg1, b3);\n\n    csg3 = smoothUnionSDF(csg2, s0, 0.125);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothDifferenceSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg3, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdTwo(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.25 + sin(u_time)/5.)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.75); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,0.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.0,0.75);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p,1.5 + sin(u_time)/2. - 0.5));\n\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, s1, 0.125); // Intersect box with sphere creating a CSG object.\n\n    // csg1 = smoothDifferenceSDF(csg0, s1, 0.125);\n     \n    // csg2 = unionSDF(csg1, b3);\n\n    // csg3 = smoothUnionSDF(csg2, s0, 0.125);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothUnionSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg0, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.035, p.y));\n        float right = sdThree(vec2(p.x - 0.38, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.,1. ); // box position\n    b0p = p-b0p;\n    b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.25 + sin(u_time)/5.)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.75); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,0.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.0,0.75);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p,1.5 + sin(u_time)/2. - 0.5));\n\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, s1, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothUnionSDF(csg0, b1, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, b2, 0.125);\n\n    // csg3 = smoothUnionSDF(csg2, s0, 0.125);\n\n    // csg4 = smoothUnionSDF(csg3, b2, 0.25);\n\n    // csg5 = smoothUnionSDF(csg4, b1, 0.25);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg2, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdFour(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.0005,0.25); //box size\n    vec3 b0p = vec3(0.,1.5,-0.4 ); // box position\n    b0p = p-b0p;\n    // b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.045 + sin(u_time)/8. + 0.2)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.175); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    // b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    // b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.1,-0.45);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p, 0.35));\n\n     // Sphere.\n     vec3 s2p=vec3(-0.65,2.5,-0.45);\n     s2p=p-s2p;\n    //  s2p.xz *=Rotate(u_time * .4);\n     vec4 s2 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s2p, 0.35));\n\n     // Sphere.\n     vec3 s3p=vec3(0.65,2.5,-0.45);\n     s3p=p-s3p;\n     vec4 s3 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s3p, 0.35));\n\n      // Sphere.\n      vec3 s4p=vec3(-0.65,2.5,-0.1);\n      s4p=p-s4p;\n     //  s2p.xz *=Rotate(u_time * .4);\n      vec4 s4 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s4p, 0.25));\n \n      // Sphere.\n      vec3 s5p=vec3(0.65,2.5,-0.15);\n      s5p=p-s5p;\n      vec4 s5 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s5p, 0.25));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0), csg6 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b0, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.125);\n\n    csg3 = smoothDifferenceSDF(csg2, s2, 0.5);\n\n    csg4 = smoothDifferenceSDF(csg3, s3, 0.5);\n\n    csg5 = smoothUnionSDF(csg4, s4, 0.15);\n\n    csg6 = smoothUnionSDF(csg5, s5, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg6, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,10.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdFive(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.0005,0.25); //box size\n    vec3 b0p = vec3(0.,1.5,-0.4 ); // box position\n    b0p = p-b0p;\n    // b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.045 + sin(u_time)/8. + 0.2)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.175); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    // b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    // b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n\n    //smile\n    vec3 b4s = vec3(.5);\n    vec3 b4p = vec3(0.,2.,-0.65 ); // box position\n    b4p = p-b4p;\n    b4p.zy *=Rotate(PI);\n    vec4 b4 = vec4(BoxColor1.rgb, cappedTorusSDF(b4p, vec2(.65 + abs(sin(u_time))/5., 0.5), 0.8, 0.075 ));\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.1,-0.45);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p, 0.35));\n\n     // Sphere.\n     vec3 s2p=vec3(-0.65,2.5,-0.45);\n     s2p=p-s2p;\n    //  s2p.xz *=Rotate(u_time * .4);\n     vec4 s2 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s2p, 0.35));\n\n     // Sphere.\n     vec3 s3p=vec3(0.65,2.5,-0.45);\n     s3p=p-s3p;\n     vec4 s3 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s3p, 0.35));\n\n      // Sphere.\n      vec3 s4p=vec3(-0.65,2.5,-0.1);\n      s4p=p-s4p;\n     //  s2p.xz *=Rotate(u_time * .4);\n      vec4 s4 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s4p, 0.25));\n \n      // Sphere.\n      vec3 s5p=vec3(0.65,2.5,-0.15);\n      s5p=p-s5p;\n      vec4 s5 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s5p, 0.25));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0), csg6 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b4, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.125);\n\n    csg3 = smoothDifferenceSDF(csg2, s2, 0.5);\n\n    csg4 = smoothDifferenceSDF(csg3, s3, 0.5);\n\n    csg5 = smoothUnionSDF(csg4, s4, 0.15);\n\n    csg6 = smoothUnionSDF(csg5, s5, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg6, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _O=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdSix(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.0005,0.25); //box size\n    vec3 b0p = vec3(0.,1.5,-0.4 ); // box position\n    b0p = p-b0p;\n    // b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.045 + sin(u_time)/8. + 0.2)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.175); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    // b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    // b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n\n    //smile\n    vec3 b4s = vec3(.5);\n    vec3 b4p = vec3(0.,0.6,-0.7 - sin(u_time)/15. ); // box position\n    b4p = p-b4p;\n    b4p.zy *=Rotate(PI * 2.);\n    vec4 b4 = vec4(BoxColor1.rgb, cappedTorusSDF(b4p, vec2(.65 + abs(sin(u_time))/5., 0.5), 0.8, 0.075 ));\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.1,-0.45);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p, 0.35));\n\n     // Sphere.\n     vec3 s2p=vec3(-0.65,2.24,-0.45);\n     s2p=p-s2p;\n    //  s2p.xz *=Rotate(u_time * .4);\n     vec4 s2 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s2p, 0.35));\n\n     // Sphere.\n     vec3 s3p=vec3(0.65,2.24,-0.6);\n     s3p=p-s3p;\n     vec4 s3 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s3p, 0.35));\n\n      // Sphere.\n      vec3 s4p=vec3(-0.65,2.24,-0.1);\n      s4p=p-s4p;\n     //  s2p.xz *=Rotate(u_time * .4);\n      vec4 s4 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s4p, 0.125));\n \n      // Sphere.\n      vec3 s5p=vec3(0.65,2.24,-0.1);\n      s5p=p-s5p;\n      vec4 s5 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s5p, 0.125));\n\n      vec4 s6 = vec4(vec3(0, 0, 0), sphereSDF(s5p, 0.125));\n      vec4 s7 = vec4(vec3(0, 0, 0), sphereSDF(s4p, 0.125));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0), csg6 = vec4(0), csg7 = vec4(0), csg8 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b4, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.125);\n\n    csg3 = smoothDifferenceSDF(csg2, s2, 0.5);\n\n    csg4 = smoothDifferenceSDF(csg3, s3, 0.5);\n\n    csg5 = smoothUnionSDF(csg4, s4, 0.15);\n\n    csg6 = smoothUnionSDF(csg5, s5, 0.15);\n\n    csg7 = smoothUnionSDF(csg6, s6, 0.15);\n\n    csg8 = smoothUnionSDF(csg7, s7, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg8, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_O,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var SO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 t = vUv;\n        vUv -= 0.5;\n        // t *= 0.5;\n\n        for(int i = 0; i < 20; i++) {\n            float t = 2.0 * PI * float(i) / 30.0 * u_time * 0.5;\n            float x = cos(0.0*t);\n\t\t    float y = sin(2.0*t);\n            vec2 o = 0.40 * vec2(x + sin(u_time) - 1., y);\n            float r = fract(x);\n            float g = 1.0 - r;\n            color += 0.003 / (length(vUv - o)) * vec3(r, g, 0.9);\n        }\n        for(int i = 0; i < 20; i++) {\n            float t = 2.0 * PI * float(i) / 30.0 * u_time * 0.5;\n            float x = cos(2.0*t);\n\t\t    float y = sin(0.0*t);\n            vec2 o = 0.40 * vec2(x , y - sin(u_time) );\n            float r = fract(x);\n            float g = 1.0 - r;\n            color += 0.003 / (length(vUv - o)) * vec3(r, g, 0.9);\n        }\n        for(int i = 0; i < 20; i++) {\n            float t = 2.0 * PI * float(i) / 30.0 * u_time * 0.5;\n            float x = cos(2.0*t);\n\t\t    float y = sin(2.0*t);\n            vec2 o = 0.40 * vec2(x , y );\n            float r = fract(x);\n            float g = 1.0 - r;\n            color += 0.003 / (length(vUv - o)) * vec3(r, g, 0.9);\n        }\n\n        float numLabel = label(t);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function MO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:SO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdEight(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    // Octahedron - exact\n    float octahedronSDF(vec3 p,float s) {\n    p=abs(p);\n    float m=p.x+p.y+p.z-s;\n    vec3 q;\n    if(3.*p.x<m)q=p.xyz;\n    else if(3.*p.y<m)q=p.yzx;\n    else if(3.*p.z<m)q=p.zxy;\n    else return m*.57735027;\n \n    float k=clamp(.5*(q.z-q.y+s),0.,s);\n    return length(vec3(q.x,q.y-s+k,q.z-k));\n}\n\n    vec4 GetDist(vec3 p)\n    {\n        //octahedron\n\n        vec3 op = vec3(0, 2.5, 0);\n        op = p - op;\n        op.xy *= Rotate(-u_time);\n        op.xz *= Rotate(-u_time);\n\n        float r = fract(BoxColor.b);\n        float g = 1.0 - r;\n        vec4 o = vec4(BoxColor.rgb + vec3(r * cos(u_time), g * sin(u_time), 0.9 * sin(u_time)), octahedronSDF(op, 1.));\n\n        vec4 scene = vec4(0);\n\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n        scene = unionSDF(p0, o);\n        \n        \n    \n        return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var CO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = sdFive(vec2(p.x + 0.35, p.y));\n        float center = sdFive(vec2(p.x -0.03, p.y));\n        float right = sdNine(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    // float sdNumHorizontal(vec2 p)\n    // {\n    //     vec2 newUv = p;\n    //     newUv.x += 0.125;\n    //     newUv.y -= 0.25;\n    //     vec2 uv1 = newUv;\n    //     vec2 uv2 = newUv;\n    //     uv1 = Rot(uv1, PI * 0.5);\n    //     uv1 /= .5;\n    //     uv1 -= 1.;\n\n    //     uv2 = Rot(uv2, -PI* .5);\n    //     uv2 /= .5;\n    //     uv2 -= 1.;\n    //     float shape1 = sdEqTriangle(uv1, 0.15);\n    //     shape1 = 1. - smoothstep(0.1, 0.11, shape1);\n\n    //     float shape2 = sdBox(vec2(uv1.x + 0.5, uv1.y+0.75), vec2(0.33, 0.2815));\n    //     shape2 = 1. - smoothstep(0.1, 0.11, shape2);\n\n    //     float shape3 = sdEqTriangle(vec2(uv2.x, uv2.y-0.5), 0.15);\n    //     shape3 = 1. - smoothstep(0.1, 0.11, shape3);\n\n    //     return shape1 + shape2 + shape3;\n    // }\n\n    // float sdNumVertical(vec2 p){\n    //     vec2 newUv = p;\n    //     newUv.x += 0.125;\n    //     newUv.y -= 0.25;\n    //     vec2 uv1 = newUv;\n    //     vec2 uv3 = newUv;\n    //     vec2 uv4 = newUv;\n    //     uv1 = Rot(uv1, PI * 0.5);\n    //     uv1 /= .5;\n    //     uv1 -= 1.;\n\n    //     uv3 = Rot(uv3, PI * 1.5);\n    //     uv3 /= .5;\n    //     uv3 -= 1.;\n    //     uv3.x -= 0.2;\n    //     uv3.y += 0.1;\n\n    //     uv4 = Rot(uv4, PI * 1.5);\n    //     uv4 /= .5;\n    //     uv4 -= 1.;\n    //     uv4.y += 0.1;\n    //     uv4.x -= 0.52;\n\n    //     float shape1 = sdEqTriangle(vec2(uv1.x + 0.36125, uv1.y-0.01), 0.125);\n    //     shape1 = 1. - smoothstep(0.1, 0.11, shape1);\n\n    //     float shape4 = sdEqTriangle(vec2(uv3.x, uv3.y), 0.14);\n    //     shape4 = 1. - smoothstep(0.1, 0.11, shape4);\n\n    //     float shape5 = sdBox(vec2(uv1.x + 0.859, uv1.y+0.442), vec2(0.35, 0.325));\n    //     shape5 = 1. - smoothstep(0.1, 0.11, shape5);\n\n    //     float shape6 = sdEqTriangle(vec2(uv4), 0.14);\n    //     shape6 = 1. - smoothstep(0.1, 0.11, shape6);\n\n    //     float tri = ((shape4 + shape6 + shape1 ) );\n    //     float sq = sdBox(vec2(uv1.x + 0.859, uv1.y +0.442), vec2(0.3));\n    //     sq = 1. - smoothstep(0.1, 0.11, sq);\n    //     float shape7 = sdBox(vec2(uv1.x + 0.859, uv1.y+0.442), vec2(0.3));\n    //     shape7 = 1. - smoothstep(0.1, 0.11, shape7);\n\n    //     return tri ;\n    // }\n\n   \n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float z = sdZero(vUv);\n        // color += z;\n\n        float zero = numZero(vUv);\n        // color += zero;\n        \n        float one = numOne(vUv);\n        color += one;\n\n        float two = numTwo(vUv);\n        // color += two;\n\n        float three = numThree(vUv);\n        // color += three;\n\n        float four = numFour(vUv);\n        // color += four;\n\n        float five = numFive(vUv);\n        // color += five;\n\n        float six = numSix(vUv);\n        // color += six;\n\n        float seven = numSeven(vUv);\n        // color += seven;\n\n        float eight = numEight(vUv);\n        // color += eight;\n        \n        float nine = numNine(vUv);\n        // color += nine;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function TO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:CO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var RO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n  \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        float zero = numZero(vUv);\n        float one = numOne(vUv);\n        float two = numTwo(vUv);\n        float three = numThree(vUv);\n        float four = numFour(vUv);\n        float five = numFive(vUv);\n        float six = numSix(vUv);\n        float seven = numSeven(vUv);\n        float eight = numEight(vUv);\n        float nine = numNine(vUv);\n        // color += zero;\n\n        \n        // color += one;\n\n        float t = u_time;\n        t = t * 0.5;\n\n        if(fract(t) < 0.1)\n        {\n            color += zero;\n        }\n        if(fract(t) <= 0.2)\n        {\n            if(fract(t) > 0.1)\n            {\n                color += one;\n            }\n            \n        }\n        if(fract(t) <= 0.3)\n        {\n            if(fract(t) > 0.2)\n            {\n                color += two;\n            }\n        }\n        if(fract(t) <= 0.4)\n        {\n            if(fract(t) > 0.3)\n            {\n                color += three;\n            }\n        }\n        if(fract(t) <= 0.5)\n        {\n            if(fract(t) > 0.4)\n            {\n                color += four;\n            }\n        }\n        if(fract(t) <= 0.6)\n        {\n            if(fract(t) > 0.5)\n            {\n                color += five;\n            }\n        }\n        if(fract(t) <= 0.7)\n        {\n            if(fract(t) > 0.6)\n            {\n                color += six;\n            }\n        }\n        if(fract(t) <= 0.8)\n        {\n            if(fract(t) > 0.7)\n            {\n                color += seven;\n            }\n        }\n        if(fract(t) <= 0.9)\n        {\n            if(fract(t) > 0.8)\n            {\n                color += eight;\n            }\n        }\n        if(fract(t) <= 1.)\n        {\n            if(fract(t) > 0.9)\n            {\n                color += nine;\n            }\n        }\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function DO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:RO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var PO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right;\n    }\n\n    float tile(vec2 uv, float zoom)\n    {\n        uv *= zoom;\n\n        float index = 0.;\n        index += step(1., mod(uv.x, 3.));\n        index += step(1., mod(uv.y, 3.)) * 2.;\n        \n        uv = fract(uv);\n        float c;\n        float zero = numZero(uv);\n        float one = numOne(uv);\n        float two = numTwo(uv);\n        float three = numThree(uv);\n        float four = numFour(uv);\n        float five = numFive(uv);\n        float six = numSix(uv);\n        float seven = numSeven(uv);\n        float eight = numEight(uv);\n        float nine = numNine(uv);\n\n        float t = u_time;\n        t = t / 2.;\n\n        if(index == 0.)\n        {\n            c = zero;\n        } else if (index == 1.){\n            if(fract(t) < 0.1)\n            {\n                c += zero;\n            }\n            if(fract(t) <= 0.2)\n            {\n                if(fract(t) > 0.1)\n                {\n                    c += one;\n                }\n                \n            }\n            if(fract(t) <= 0.3)\n            {\n                if(fract(t) > 0.2)\n                {\n                    c += two;\n                }\n            }\n            if(fract(t) <= 0.4)\n            {\n                if(fract(t) > 0.3)\n                {\n                    c += three;\n                }\n            }\n            if(fract(t) <= 0.5)\n            {\n                if(fract(t) > 0.4)\n                {\n                    c += four;\n                }\n            }\n            if(fract(t) <= 0.6)\n            {\n                if(fract(t) > 0.5)\n                {\n                    c += five;\n                }\n            }\n            if(fract(t) <= 0.7)\n            {\n                if(fract(t) > 0.6)\n                {\n                    c += six;\n                }\n            }\n            if(fract(t) <= 0.8)\n            {\n                if(fract(t) > 0.7)\n                {\n                    c += seven;\n                }\n            }\n            if(fract(t) <= 0.9)\n            {\n                if(fract(t) > 0.8)\n                {\n                    c += eight;\n                }\n            }\n            if(fract(t) <= 1.)\n            {\n                if(fract(t) > 0.9)\n                {\n                    c += nine;\n                }\n            }\n        } else if (index == 2.){\n            c = two;\n        } else if (index == 3.){\n            c = three;\n        } else if (index == 4.){\n            c = four;\n        }else if (index == 5.){\n            c = five;\n        } else if (index == 6.){\n            c = six;\n        }\n\n        return c;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        float x = tile(uv2, 3.);\n        color += x;\n\n        float count = numZero(vec2(uv2.x + 0.2, uv2.y)) + numZero(vec2(uv2.x-0.2, uv2.y));\n\n        // color += count;\n        \n        // float zero = numZero(uv2);\n        // float one = numOne(uv2);\n        // float two = numTwo(uv2);\n        // float three = numThree(uv2);\n        // float four = numFour(uv2);\n        // float five = numFive(uv2);\n        // float six = numSix(uv2);\n        // float seven = numSeven(uv2);\n        // float eight = numEight(uv2);\n        // float nine = numNine(uv2);\n        // color += zero;\n\n        \n        // color += one;\n\n        // float t = u_time;\n        // t = t / 2.;\n\n        // if(fract(t) < 0.1)\n        // {\n        //     color += zero;\n        // }\n        // if(fract(t) <= 0.2)\n        // {\n        //     if(fract(t) > 0.1)\n        //     {\n        //         color += one;\n        //     }\n            \n        // }\n        // if(fract(t) <= 0.3)\n        // {\n        //     if(fract(t) > 0.2)\n        //     {\n        //         color += two;\n        //     }\n        // }\n        // if(fract(t) <= 0.4)\n        // {\n        //     if(fract(t) > 0.3)\n        //     {\n        //         color += three;\n        //     }\n        // }\n        // if(fract(t) <= 0.5)\n        // {\n        //     if(fract(t) > 0.4)\n        //     {\n        //         color += four;\n        //     }\n        // }\n        // if(fract(t) <= 0.6)\n        // {\n        //     if(fract(t) > 0.5)\n        //     {\n        //         color += five;\n        //     }\n        // }\n        // if(fract(t) <= 0.7)\n        // {\n        //     if(fract(t) > 0.6)\n        //     {\n        //         color += six;\n        //     }\n        // }\n        // if(fract(t) <= 0.8)\n        // {\n        //     if(fract(t) > 0.7)\n        //     {\n        //         color += seven;\n        //     }\n        // }\n        // if(fract(t) <= 0.9)\n        // {\n        //     if(fract(t) > 0.8)\n        //     {\n        //         color += eight;\n        //     }\n        // }\n        // if(fract(t) <= 1.)\n        // {\n        //     if(fract(t) > 0.9)\n        //     {\n        //         color += nine;\n        //     }\n        // }\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function FO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:PO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.0005,0.25); //box size\n    vec3 b0p = vec3(0.,1.5,-0.4 ); // box position\n    b0p = p-b0p;\n    // b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.045 + sin(u_time)/8. + 0.2)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.175); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    // b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    // b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n\n    //smile\n    vec3 b4s = vec3(.5);\n    vec3 b4p = vec3(0.,2.,-0.65 ); // box position\n    b4p = p-b4p;\n    b4p.zy *=Rotate(PI);\n    vec4 b4 = vec4(BoxColor1.rgb, cappedTorusSDF(b4p, vec2(.65 + abs(sin(u_time))/5., 0.5), 0.8, 0.075 ));\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.1,-0.45);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p, 0.35));\n\n     // Sphere.\n     vec3 s2p=vec3(-0.5,2.5,-0.5);\n     s2p=p-s2p;\n    //  s2p.xz *=Rotate(u_time * .4);\n     vec4 s2 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s2p, 0.35));\n\n     // Sphere.\n     vec3 s3p=vec3(0.5,2.5,-0.5);\n     s3p=p-s3p;\n     vec4 s3 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s3p, 0.35));\n\n      // Sphere.\n      vec3 s4p=vec3(-0.65,2.5,-0.15);\n      s4p=p-s4p;\n     //  s2p.xz *=Rotate(u_time * .4);\n      vec4 s4 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s4p, 0.25));\n \n      // Sphere.\n      vec3 s5p=vec3(0.65,2.5,-0.15);\n      s5p=p-s5p;\n      vec4 s5 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s5p, 0.25));\n\n      // Sphere.\n      vec3 s6p=vec3(-0.15,2.,-0.75);\n      s6p=p-s6p;\n      vec4 s6 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s6p, 0.012525));\n\n      vec3 s7p=vec3(0.15,2.,-0.75);\n      s7p=p-s7p;\n      vec4 s7 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s7p, 0.012525));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0), csg6 = vec4(0), csg7 = vec4(0), csg8 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b4, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.125);\n\n    csg3 = smoothDifferenceSDF(csg2, s2, 0.5);\n\n    csg4 = smoothDifferenceSDF(csg3, s3, 0.5);\n\n    csg5 = smoothUnionSDF(csg4, s4, 0.15);\n\n    csg6 = smoothUnionSDF(csg5, s5, 0.15);\n\n    csg7 = smoothDifferenceSDF(csg6, s6, 0.15);\n\n    csg8 = smoothDifferenceSDF(csg7, s7, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg8, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function IO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    // const vec4 uvColor = vec4(vUv.x, vUv.y, 0., 1.);\n    const vec4 SphereColor = vec4(0,0,1,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    // float dot2( in vec2 v ) { return dot(v,v); }\n    // float dot2( in vec3 v ) { return dot(v,v); }\n    // float ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.0005,0.25); //box size\n    vec3 b0p = vec3(0.,1.5,-0.4 ); // box position\n    b0p = p-b0p;\n    // b0p.xz *=Rotate(0.1 + (u_time));\n    vec4 b0 = vec4(BoxColor.rgb,roundedBoxSDF(b0p,b0s, 0.045 + sin(u_time)/8. + 0.2)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.5,0.5,.175); //box size\n    vec3 b1p = vec3(0.,1.,1.); // box position\n    b1p = p-b1p;\n    // b1p.xz *=Rotate(u_time * .4);\n    vec4 b1 = vec4(vec3(vUv.x, vUv.y, 0.),roundedBoxSDF(b1p,b1s, 0.25)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(1.5,.5,0.75); //box size\n    vec3 b2p = vec3(0.,1.,1.); // box position\n    b2p = p-b2p;\n    // b2p.xz *=Rotate(u_time * .4);\n    vec4 b2 = vec4(vec3(vUv.x, vUv.y, 0.),boxSDF(b2p,b2s)); // Box Color, box distance \n\n    //boxframe\n    vec3 b3s = vec3(.5);\n    vec3 b3p = vec3(0, 1, 2);\n    vec4 b3 = vec4(BoxColor1.rgb, boxFrameSDF(b3p, b3s, 0.025));\n\n    // p.xz *=Rotate(u_time * .2);\n\n    //smile\n    vec3 b4s = vec3(.5);\n    vec3 b4p = vec3(0.,2.,-0.65 ); // box position\n    b4p = p-b4p;\n    b4p.zy *=Rotate(PI);\n    vec4 b4 = vec4(BoxColor1.rgb, cappedTorusSDF(b4p, vec2(.65 + abs(sin(u_time))/5., 0.5), 0.8, 0.075 ));\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    s0p=p-s0p;\n    vec4 s0 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s0p,1.5));\n\n     // Sphere.\n     vec3 s1p=vec3(0.,2.1,-0.45);\n     s1p=p-s1p;\n     vec4 s1 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s1p, 0.35));\n\n     // Sphere.\n     vec3 s2p=vec3(-0.5,2.5,-0.5);\n     s2p=p-s2p;\n    //  s2p.xz *=Rotate(u_time * .4);\n     vec4 s2 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s2p, 0.35));\n\n     // Sphere.\n     vec3 s3p=vec3(0.5,2.5,-0.5);\n     s3p=p-s3p;\n     vec4 s3 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s3p, 0.35));\n\n      // Sphere.\n      vec3 s4p=vec3(-0.65,2.5,-0.15);\n      s4p=p-s4p;\n     //  s2p.xz *=Rotate(u_time * .4);\n      vec4 s4 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s4p, 0.25));\n \n      // Sphere.\n      vec3 s5p=vec3(0.65,2.5,-0.15);\n      s5p=p-s5p;\n      vec4 s5 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s5p, 0.25));\n\n      // Sphere.\n      vec3 s6p=vec3(-0.15,2.,-0.75);\n      s6p=p-s6p;\n      vec4 s6 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s6p, 0.012525));\n\n      vec3 s7p=vec3(0.15,2.,-0.75);\n      s7p=p-s7p;\n      vec4 s7 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s7p, 0.012525));\n\n      // Sphere.\n      vec3 s8p=vec3(0.65,2.5,-0.35);\n      s8p=p-s8p;\n      vec4 s8 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s8p, 0.125));\n\n      vec3 s9p=vec3(-0.65,2.5,-0.35);\n      s9p=p-s9p;\n      vec4 s9 = vec4(vec3(vUv.x, vUv.y, 0.),sphereSDF(s9p, 0.125));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0), csg5 = vec4(0), csg6 = vec4(0), csg7 = vec4(0), csg8 = vec4(0), csg9 = vec4(0), csg10 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, b4, 0.125);\n     \n    csg2 = smoothUnionSDF(csg1, s1, 0.125);\n\n    csg3 = smoothDifferenceSDF(csg2, s2, 0.5);\n\n    csg4 = smoothDifferenceSDF(csg3, s3, 0.5);\n\n    csg5 = smoothUnionSDF(csg4, s4, 0.15);\n\n    csg6 = smoothUnionSDF(csg5, s5, 0.15);\n\n    csg7 = smoothDifferenceSDF(csg6, s6, 0.15);\n\n    csg8 = smoothDifferenceSDF(csg7, s7, 0.15);\n     \n    csg9 = smoothDifferenceSDF(csg8, s8, 0.15);\n    csg10 = smoothDifferenceSDF(csg9, s9, 0.15);\n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = smoothUnionSDF(csg10, p0, 0.025);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        // rd.xz *= Rotate(.125);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function OO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:EO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    float displacement =  sin(2.0 * p.x + (u_time)/1.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/1.) * 0.37525;\n    s0p=p-s0p + displacement;\n    \n    // s0p=p-s0p - displacement;\n    // s0p += displacement;\n    // s0p.z += sin(u_time);\n    float distortedSphere = distortSphere(p);\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 1.));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect \n\n    scene = smoothUnionSDF(s0, p0, 0.15);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,3.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:AO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    float displacement =  sin(2.0 * p.x + (u_time)/1.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/1.) * 0.37525;\n    s0p=p-s0p + displacement;\n    \n    // s0p=p-s0p - displacement;\n    // s0p += displacement;\n    // s0p.z += sin(u_time);\n    float distortedSphere = distortSphere(p);\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 1.));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n    float p1 = dot(p, normalize(vec3(1.5, 1.0,0.)));\n    vec4 plane = vec4(ColorRed.rgb, p1);\n\n    float b1 = boxSDF(p - vec3(-1.5,1.5,0), vec3(1));\n    vec4 box = vec4(ColorRed.rgb, b1 );\n    //shell\n    box = abs(box)-.1 + (sin(u_time * 0.5)/6.)-0.15;\n    // box.a += displacement;\n \n    vec4 scene = vec4(0), csg0 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(s0, p0, 0.125); // Intersect \n\n    scene = smoothIntersectSDF(box, plane, 0.15);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(4.9,4.5,-4.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.zx *= Rotate(PI*-.3 );\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function NO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:GO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var BO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(0.,1.75,0.75);\n    float displacement =  sin(2.0 * p.x + (u_time)/1.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/1.) * 0.37525;\n    s0p=p-s0p + displacement;\n    \n    // s0p=p-s0p - displacement;\n    // s0p += displacement;\n    // s0p.z += sin(u_time);\n    float distortedSphere = distortSphere(p);\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 1.));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n    float p1 = dot(p, normalize(vec3(1.5 + sin(u_time), 1.0 + sin(u_time),0.)));\n    vec4 plane = vec4(ColorRed.rgb, p1);\n    vec3 b1p = vec3(-1.5,1.5,0);\n    // b1p.yz *= Rotate((u_time));\n    float b1 = boxSDF(p - b1p, vec3(1));\n    vec4 box = vec4(ColorRed.rgb, b1 );\n    //shell\n    box = abs(box)-.1;\n    // box.xy *= Rotate(sin(u_time)); \n    // box.a += displacement;\n \n    vec4 scene = vec4(0), csg0 = vec4(0);\n     \n    csg0 = smoothIntersectSDF(box, plane, 0.125); // Intersect \n\n    scene = unionSDF(csg0, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(4.9,4.5,-4.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.zx *= Rotate(PI*-.3);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:BO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var VO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(-1.5,1.5,0);\n    float displacement =  sin(2.0 * p.x + (u_time)/2.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/2.) * 0.37525;\n    // s0p=p-s0p + displacement;\n    \n    // s0p=p-s0p - displacement;\n    // s0p += displacement;\n    // s0p.z += sin(u_time);\n    float distortedSphere = distortSphere(p);\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 0.15));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n    float p1 = dot(p, normalize(vec3(1.5 + sin(u_time), 1.0 + sin(u_time),0.)));\n    vec4 plane = vec4(ColorRed.rgb, p1);\n    vec3 b1p = vec3(-1.5,1.5,0);\n    // b1p.yz *= Rotate((u_time));\n    float b1 = boxSDF(p - b1p + displacement, vec3(1.25));\n    vec4 box = vec4(ColorRed.rgb, b1 );\n    //shell\n    box = abs(box)-.1;\n    // box.xy *= Rotate(sin(u_time)); \n    // box.a += displacement;\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0);\n     \n    csg0 = smoothUnionSDF(box, p0, 0.125);\n    csg1 = smoothUnionSDF(csg0, s0, 0.125); \n\n    scene = smoothUnionSDF(box, p0, 0.25);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n        lightPos.zx *= Rotate(PI * 1.75);\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(4.9 ,4.5,-4.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.zx *= Rotate(PI*-.3);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function WO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:VO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var HO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(.0,1.5,0);\n    float displacement =  sin(3.0 * p.x + (u_time)/2.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/2.) * 0.137525;\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 0.05));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n    float p1 = dot(p, normalize(vec3(1.5 + sin(u_time), 1.0 + sin(u_time),0.)));\n    vec4 plane = vec4(ColorRed.rgb, p1);\n    vec3 b1p = vec3(-.5,1.5,0);\n    b1p.xz *= Rotate((u_time));\n    \n    float s1 = sphereSDF(p - s0p + displacement, 1.75);\n    float s2 = sphereSDF(p - s0p + displacement, 0.5);\n    float b1 = boxSDF(p - b1p , vec3(1.25));\n    vec4 box = vec4(ColorRed.rgb, b1 );\n    \n    vec4 sphere = vec4(ColorRed.rgb, s1);\n    vec4 sphere2 = vec4(ColorRed.rgb, s2);\n    //shell\n    box = abs(box)-.1;\n    // box.xy *= Rotate(sin(u_time)); \n    // box.a += displacement;\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0);\n     \n    csg0 = smoothUnionSDF(box, p0, 0.125);\n    csg1 = smoothDifferenceSDF(csg0, sphere, 0.125); \n    csg2 = smoothUnionSDF(csg1, sphere2, 0.125);\n    scene = smoothUnionSDF(csg2, p0, 0.25);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n        lightPos.zx *= Rotate(PI * 1.75);\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(4.9 ,4.5,-4.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.zx *= Rotate(PI*-.3);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function XO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:HO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var YO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSix(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 ColorRed = vec4(1,0,0,1);\n    const vec4 GroundColor = vec4(vec3(0.6), 1.);\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        \n        return (length(p)-s);\n    }\n\n    float distortSphere(vec3 p)\n    {\n        float displacement = sin(5.0 * p.x) * sin(2.0 * p.y) * sin(5.0 * p.z) * 0.25;\n        float sphere_0 = sphereSDF(p, .25);\n\n        return sphere_0 + displacement;\n    }\n\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    // Rounded Box - exact\n    float roundedBoxSDF( vec3 p, vec3 b, float r ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n    }\n\n    //box frame\n    float boxFrameSDF( vec3 p, vec3 b, float e )\n    {\n           p = abs(p  )-b;\n      vec3 q = abs(p+e)-e;\n      return min(min(\n          length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n          length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n          length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n\n    float dot2( in vec3 v ) { return dot(v,v); }\n    float sdBoxFrame( vec3 p, vec3 b, float e){\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n                +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                max(p.y,max(q.z,q.x))),\n                max(p.z,max(q.x,q.y))));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    //capped torus\n    float cappedTorusSDF(vec3 p, vec2 sc, float ra, float rb ){\n        p.x = abs(p.x);\n        float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n        return sqrt(dot(p,p) + ra*ra - 2.0 * ra * k ) - rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n    // Sphere.\n    vec3 s0p=vec3(.0,1.5,0);\n    float displacement =  sin(3.0 * p.x + (u_time)/2.) * sin(2.0 * p.y + (u_time)/2.) * sin(2.0 * p.z + (u_time)/2.) * 0.137525;\n    vec4 s0 = vec4(vec3(ColorRed),sphereSDF(s0p, 0.05));\n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n\n    float p1 = dot(p, normalize(vec3(1.5 + sin(u_time), 1.0 + sin(u_time),0.)));\n    vec4 plane = vec4(ColorRed.rgb, p1);\n    vec3 b1p = vec3(-0.5,1.5,0) ;\n    // b1p.xz *= Rotate((u_time));\n    float b1 = boxSDF(p - b1p * displacement , vec3(1.25 + sin(u_time * 0.25), .525 , 1.25 + cos(u_time * 0.25)));\n    vec4 box = vec4(ColorRed.rgb, b1 );\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0);\n     \n    csg0 = smoothUnionSDF(box, p0, 0.125);\n    scene = smoothUnionSDF(csg0, p0, 0.25);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,6.,-5.);// Light Position\n        lightPos.zx *= Rotate(PI * 1.75);\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(4.9 ,4.5,-4.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        rd.zx *= Rotate(PI*-.3);\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ZO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:YO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(1.0, 1.0, 1.0);\n        vec3 d = vec3(0.263,0.416 * u_time,0.557);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, u_time *0.25);\n        uv2 -= 0.5;\n        vec2 uv3 = uv2;\n\n        \n        float d;\n        vec3 c;\n\n        for (float i = 0.; i < 4.; i++)\n        {\n            uv2 = fract(uv2 * 1.) - 0.5;\n            d = length(uv3) * exp(-length(uv2));\n            c = palette(length(uv2) + i * .4 + u_time * .4);\n            d = sin(d * 20. + u_time) / 8.;\n            d = abs(d);\n            d = pow(0.01/d, 1.2);\n            color += c * d;\n        }\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function JO(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:QO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KO=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        // uv2 = Rot(uv2, u_time * 0.25);\n        uv2 -= 0.5;\n        vec2 uv3 = uv2;\n\n        \n        float d;\n        vec3 c;\n\n        for (float i = 0.; i < 4.; i++)\n        {\n            uv2 = fract(uv2 * (1.5 + sin(u_time * 0.25)/15.)) - 0.5;\n            d = length(uv3) * (-length(uv2));\n            c = palette(length(uv2) + i * .4 + u_time * .4);\n            d = sin(d * 15. + sin(u_time)) / 5.;\n            d = abs(d);\n            d = pow(0.01/d, 1.);\n            color += c * d;\n        }\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $O(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:KO,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 = Rot(uv2, u_time * 0.25);\n        uv2 -= 0.5;\n        vec2 uv3 = uv2;\n\n        \n        float d;\n        float d2;\n        vec3 c;\n\n        for (float i = 0.; i < 4.; i++)\n        {\n            uv2 = fract(uv2 * (1.5 + sin(u_time * 0.25)/15.)) - 0.5;\n            d = length(uv3) * (length(uv2));\n            c = palette(length(uv2) + i * .4 + u_time * .4);\n            d2 = d;\n            d = sin(d * 5. + (u_time * 0.5)) / 5.;\n            d2 = tan(d * 5. + (u_time * 0.5)) / 5.;\n            d = abs(d);\n            d2 = abs(d2);\n            d = pow(0.005/d, 1.);\n            d2 = pow(0.002/d2, 1.);\n            color += c * d + d2;\n        }\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function eA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    float variation(vec2 v1, vec2 v2, float strength, float speed) {\n        return sin(\n            dot(normalize(v1), normalize(v2)) * strength + u_time * speed\n        ) / 100.0;\n    }\n    \n    vec3 paintCircle (vec2 uv, vec2 center, float rad, float width) {\n        \n        vec2 diff = center-uv;\n        float len = length(diff);\n    \n        len += variation(diff, vec2(0.0, 1.0), 5.0, 2.0);\n        len -= variation(diff, vec2(1.0, 0.0), 5.0, 2.0);\n        \n        float circle = smoothstep(rad-width, rad, len) - smoothstep(rad, rad+width, len);\n\n        float segment = sdSegment(uv, vec2(0.), vec2(0.5));\n\n        return vec3(circle);\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        // uv2 = Rot(uv2, u_time * 0.25);\n        float m = 0.;\n        vec3 d;\n        uv2 -= 0.5;\n        float t = u_time * 0.05;\n        for(float i =0.; i <1.; i+= 1./2.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(.5, .05, z);\n            float fade = S(0.0, 0.5, z) * S(.0, 1., z) ;\n            \n            \n            vec3 cir = paintCircle(uv2 , vec2(0.0) ,  fade  + 0.15 * 1.25 , 0.01 );\n            vec3 cir2 = paintCircle(uv2, vec2(0.0) ,  fade + 0.15 * 1.25, 0.04 );\n\n            vec3 cir3 = paintCircle(uv2, vec2(0.0) ,  fade + 0.1 * 1.25, 0.01);\n            vec3 cir4 = paintCircle(uv2, vec2(0.0) ,  fade + 0.1 * 1.25, 0.04);\n\n            vec3 cir5 = paintCircle(uv2, vec2(0.0) ,  fade + 0.05 * 1.25, 0.01);\n            vec3 cir6 = paintCircle(uv2, vec2(0.0) ,  fade + 0.05 * 1.25, 0.04 );\n\n            vec3 cir7 = paintCircle(uv2, vec2(0.0) ,  fade - 0.0 * 1.25, 0.01);\n            vec3 cir8 = paintCircle(uv2, vec2(0.0) ,  fade - 0.0 * 1.25, 0.04);\n\n            vec3 cir9 = paintCircle(uv2, vec2(0.0) ,  fade - 0.05 * 1.25, 0.01);\n            vec3 cir10 = paintCircle(uv2, vec2(0.0) ,  fade - 0.05 * 1.25, 0.04);\n\n            vec3 cir11 = paintCircle(uv2, vec2(0.0) , fade - 0.1 * 1.25, 0.01);\n            vec3 cir12 = paintCircle(uv2, vec2(0.0) , fade - 0.1 * 1.25, 0.04);\n\n            vec3 cir13 = paintCircle(uv2, vec2(0.0) , fade - 0.15  * 1.25, 0.01 );\n            vec3 cir14 = paintCircle(uv2, vec2(0.0) ,  fade - 0.15 * 1.25, 0.04);\n\n            cir += cir2;\n            color += cir2 * vec3(0.9, 0., 0.);\n            // m += Layer(uv2 * size + i * 20.) * fade;\n\n            cir3 += cir4;\n            color += cir4 * vec3(0.9, 0.5, 0.0);\n\n            cir5 += cir6;\n            color += cir6 * vec3(1., 1., 0.0);\n\n            cir7 += cir8;\n            color += cir8 * vec3(0., 1., 0.0);\n\n            cir9 += cir10;\n            color += cir10 * vec3(0., 0., 1.0);\n\n            cir11 += cir12;\n            color += cir12 * vec3(0.29, 0., 0.51);\n\n            cir13 += cir14;\n            color += cir14 * vec3(0.93, 0.51, 0.93);\n        }\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function oA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:tA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n        uv2.y -= 0.065;\n\n        float one = 1. - sdBox(vec2(uv2.x, uv2.y + (1./7.)), vec2(2.5, 1./7.));\n        float two = 1. - sdBox(vec2(uv2.x, uv2.y + (2./7.)), vec2(2.5, 1./7.));\n        float three = 1. - sdBox(vec2(uv2.x, uv2.y + 3./7.), vec2(2.5, 1./7.));\n        float four = 1. - sdBox(vec2(uv2.x, uv2.y + 4./7.), vec2(2.5, 1./7.));\n        float five = 1. - sdBox(vec2(uv2.x, uv2.y + 5./7.), vec2(2.5, 1./7.));\n        float six = 1. - sdBox(vec2(uv2.x, uv2.y + 6./7.), vec2(2.5, 1./7.));\n        float seven = 1. - sdBox(vec2(uv2.x, uv2.y + 7./7.), vec2(2.5, 1./7.));\n\n        color += one * vec3(0.9, 0., 0.);\n        color += two * vec3(0.9, 0.5, 0.0);\n        color += three * vec3(1., 1., 0.0);\n        color += four * vec3(0., 1., 0.0);\n        color += five * vec3(0., 0., 1.0);\n        color += six * vec3(0.29, 0., 0.51);\n        color += seven * vec3(0.93, 0.51, 0.93);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function aA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:rA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, - uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (TWO_PI * 2.0) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), 4.0);\n    \n    return radialUv;\n    }\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        vec2 uv3 = uv2;\n        vec2 uv4 = vUv;\n        uv4 -= 0.5;\n        uv4 = getRadialUv(uv4);\n        uv2 -= .5;\n        uv3 = Rot(uv3, PI * 2.);\n        uv3 -= 0.5;\n        \n\n        float an = -u_time * 0.15;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2);\n        float a = atan(uv2.y, uv2.x);\n        uv2 = vec2(0.3/r1 + 0.5 * u_time , a);\n        float r2 = length(uv3);\n        float a2 = atan(uv3.y, uv3.x);\n        uv3 = vec2(0.3/r2 + 0.5 * u_time, a2);\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv4 + 0.00*u_time);\n        q.y = fbm( uv4 + vec2(1.0));\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv4 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv4 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r);\n        float f2 = fbm(uv3+r);\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.101961,0.619608,0.666667),\n                    vec3(0.666667,0.666667,0.498039),\n                    clamp((f*f)*4.0,0.0,1.0));\n\n        c = mix(color,\n                    vec3(0,0,0.164706),\n                    clamp(length(q),0.0,1.0));\n\n        c = mix(color,\n                    vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n\n        c *= f*f*f+.6*f *f + .5 *f * c ;\n        // c *= f2*f2*f2+.6*f2 *f2 + .5 *f2 * c ;\n\n        color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:iA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    // radialUv.x = angle / (PI) + 0.5;\n    // radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) + 0.0005 * u_time, angle );\n    \n    return radialUv;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n        \n        \n\n        float an = -u_time * 0.15;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2) ;\n        r1 = abs(r1);\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a);\n        uv2 = vec2(0.3/r1 + .95 * u_time , a);\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.00*u_time);\n        q.y = fbm( uv2 + vec2(1.0));\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.101961,0.619608,0.666667),\n                    vec3(0.666667,0.666667,0.498039),\n                    clamp((f*f)*4.0,0.0,1.0));\n\n        c = mix(color,\n                    vec3(0,0,0.164706),\n                    clamp(length(q),0.0,1.0));\n\n        c = mix(color,\n                    vec3(0.666667,1,1),\n                clamp(length(r.x),0.0,1.0));\n\n        c *= f*f*f+.6*f *f + .25 *f * c* f * c ;\n\n        color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:cA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (PI) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) * u_time, angle );\n    \n    return radialUv;\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.15;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * 0.5) ;\n        r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.3/r1 + .95 - u_time * 1.25 , a);\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + vec2(50.01));\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.619608,0.666667),\n                    vec3(0.666667,0.666667,0.498039),\n                    clamp((f*f)*5.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.9,0,0.164706),\n                    clamp(length(q),0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.966667,1,1),\n                clamp(length(r.x),0.0,1.0));\n\n        c *= f*f*f+.6*f *f + .25 *f * c* f * f ;\n\n        float cir = sdCircle(vUv, 0.0525);\n        \n\n        color += c * 2. * 2. + c;\n        color *=  c - cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:lA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (PI) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) * u_time, angle );\n    \n    return radialUv;\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.15;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * 0.5) ;\n        r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.3/r1 + .95 + u_time * 2.25 , a);\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + vec2(50.01));\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.9666667,0.9666667,0.998039),\n                    clamp((f*f)*1.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.099,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,1),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color,\n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        c *= f ;\n\n        float cir = sdCircle(vUv, 0.125 * sin(1. /u_time));\n        \n\n        color += c * 2. * 2. + c;\n        color *=  c - cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:fA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numSeven(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (PI) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) * u_time, angle );\n    \n    return radialUv;\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1 + sin(u_time), a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color,\n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        c *= f * f * 2.;\n\n        float cir = sdCircle(vUv, 0.125 ) * 0.65;\n        \n\n        color += c * 2. ;\n        color *=  c - cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:mA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1 + sin(u_time), a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color,\n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        // c *= f * f * 2.;\n\n        float cir = sdCircle(vUv, 0.125 );\n        \n        vec3 s = voronoi(uv2);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        \n        color.rgb+= smoothstep(0.02 * 2., 0.031 * 2., s.x);\n        //color.g+= 1. - smoothstep(0.0075 * 2., (0.021-0.0025) * 2., s2.x);\n        //color.b+= 1. - smoothstep(0.005 * 2., (0.021 -0.005) * 2., s3.x);\n        // color += c * 2. ;\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:hA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1 + sin(u_time), a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color, \n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        // c *= f * f * 2.;\n\n        float cir = sdCircle(vUv, 0.125 );\n        \n        vec3 s = voronoi(uv2 * 0.25);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        \n        color.rgb+= smoothstep(0.02 * 2., 0.031 * 2., s.x * f * f);\n        //color.g+= 1. - smoothstep(0.0075 * 2., (0.021-0.0025) * 2., s2.x);\n        //color.b+= 1. - smoothstep(0.005 * 2., (0.021 -0.005) * 2., s3.x);\n        // color += c * 2. ;\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:gA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1, a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color, \n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        // c *= f * f * 2.;\n\n        float cir = sdCircle(vUv, 0.0125 );\n        \n        vec3 s = voronoi(uv2 * 0.25);\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        \n        color.rgb += smoothstep(0.02 * 2., 0.031 * 2., s.x * f * f + s2.x);\n        color.g+= 1. - smoothstep(0.0075 * 2., (0.021-0.0025) * 2., s2.x);\n        color.b+= 1. - smoothstep(0.005 * 2., (0.021 -0.005) * 2., s3.x);\n        // color += c * 2. ;\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:bA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _A=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n\n    vec2 tile(vec2 uv, float zoom, float speed){\n        uv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > 0.5)\n        {\n            if(fract(uv.y * 0.5) > 0.5){\n                uv.x += fract(t) * 2.;\n            } else {\n                uv.x -= fract(t) * 2.;\n            }\n        } else {\n            if(fract(uv.x * 0.5) > 0.5)\n            {\n                uv.y += fract(t) * 2.;\n            } else {\n                uv.y -= fract(t) * 2.;\n            }\n        }\n        return fract(uv);\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1, a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color, \n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        // c *= f * f * 2.;\n\n        vec2 pattern = tile(uv2, 1., 0.5);\n        float x = numZero(pattern);\n        color.g += x;\n\n        float cir = sdCircle(vUv, 0.0125 );\n        \n        vec3 s = voronoi(uv2 );\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        \n        // color.rgb += 1. - smoothstep(0.02 * 2., 0.031 * 2., s.x * f * f + s.x);\n        // color.g+= smoothstep(0.0075 * 2., (0.021-0.0025) * 2., s2.x);\n        // color.b+= smoothstep(0.005 * 2., (0.021 -0.005) * 2., s3.x);\n        // color += c * 2. ;\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:_A,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var SA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 random2( vec2 p ) {\n        return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    }\n\n    vec3 voronoi(vec2 x)\n    {\n        vec2 n=floor(x);\n        vec2 f=fract(x);\n        \n        vec2 mg,mr;\n        float md=1.5;\n        \n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                float d=dot(r,r);\n                \n                if(d<md){\n                    md=d;\n                    mr=r;\n                    mg=g;\n                }\n                \n            }\n        }\n        md=1.;\n        for(int i=-1;i<=1;i++){\n            for(int j=-1;j<=1;j++){\n                vec2 g=vec2(float(j),float(i));\n                vec2 o=random2(n+g);\n                o=.5+.5*sin((u_time * 0.5)+TWO_PI*o);\n                \n                vec2 r=g+o-f;\n                if(dot(mr-r,mr-r)>.005){\n                    md=min(md,dot(.5*(mr+r),normalize(r-mr)));\n                    \n                }\n                \n            }\n        }\n        return vec3(md, mr);\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n\n    vec2 tile(vec2 uv, float zoom, float speed){\n        uv *= zoom;\n        float t = u_time * speed;\n        if(fract(t) > 0.5)\n        {\n            if(fract(uv.y * 0.5) > 0.5){\n                uv.x += fract(t) * 2.;\n            } else {\n                uv.x -= fract(t) * 2.;\n            }\n        } else {\n            if(fract(uv.x * 0.5) > 0.5)\n            {\n                uv.y += fract(t) * 2.;\n            } else {\n                uv.y -= fract(t) * 2.;\n            }\n        }\n        return fract(uv);\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        // uv2 = getRadialUv(uv2 );\n\n        float an = -u_time * 0.5;\n        uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 + u_time * 1.25 + r1, a );\n\n        // uv2 = vec2(position(uv2.x) * position(uv2.y));\n\n        vec2 q = vec2(0.);\n        q.x = fbm( uv2 + 0.2*u_time);\n        q.y = fbm( uv2 + u_time * 0.4);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * 2.));\n\n        vec3 c = vec3(0.);\n        c = mix(vec3(0.91961,0.919608,0.966667),\n                    vec3(0.06667,0.666667,0.998039),\n                    clamp((f*f)*2.0,0.0,1.0));\n\n        c *= mix(color,\n                    vec3(0.299,0.50,0.964706),\n                    clamp(length(q),0.,1.0));\n\n        c *= mix(color,\n                    vec3(0.996667,0.9,0.),\n                clamp(length(r.y),0.0,1.0));\n\n        c += mix(color, \n            vec3(0.95,0.95,1.),\n        clamp(length(r.x),0.0, .25));\n\n        // c *= f * f * 2.;\n\n        vec2 pattern = tile(uv2, 1., 0.5);\n        float x = numTwo(pattern);\n        color.r += x;\n\n        \n        float cir = sdCircle(vUv, 0.0125 );\n        vec3 s = voronoi(uv2 );\n        vec3 s2 = voronoi(vec2(uv2.x  + sin(u_time)/8., uv2.y  + sin(u_time)/8.));\n        vec3 s3 = voronoi(vec2(uv2.x  + sin(u_time)/16., uv2.y  + sin(u_time)/16.));\n        \n        // color.rgb += 1. - smoothstep(0.02 * 2., 0.031 * 2., s.x * f * f + s.x);\n        // color.g+= smoothstep(0.0075 * 2., (0.021-0.0025) * 2., s2.x);\n        // color.b+= smoothstep(0.005 * 2., (0.021 -0.005) * 2., s3.x);\n        // color += c * 2. ;\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function MA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:SA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        newUv -= 0.5;\n\n        float x = sdSpiral(newUv, 0.525, 2.525 + sin(u_time));\n        color += x;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:kA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var CA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        newUv *= 0.25 + 0.75;\n        newUv = Rot(newUv, u_time * 4.5 + sin(u_time));\n        newUv -= 0.5;\n\n        float x;\n        for(float i=0.; i<2.; i++){\n            newUv*= 0.165;\n\n            x = sdSpiral(newUv, 0.82, 3.525 + sin(u_time + i/2. ));\n            color += x;\n\n            vec3 c = palette(x * i);\n            color -= c.xyz;\n        }\n\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function TA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:CA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var RA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        newUv *= 0.25 + 0.75;\n        newUv = Rot(newUv, u_time * 4.5 + sin(u_time));\n        newUv -= 0.5;\n\n        float x;\n        for(float i=0.; i<6.; i++){\n            newUv*= 0.165;\n\n            x = sdSpiral(vec2(newUv.x * 55.5 * i, newUv.y * 55.5 * i), i, 3.525 + sin(u_time + i/2. ));\n            color += x;\n\n            vec3 c = palette(x * i);\n            color -= c.xyz;\n        }\n\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function DA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:RA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var PA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        // newUv *= 0.25 + 0.75;\n        // newUv = Rot(newUv, u_time * 4.5 + sin(u_time));\n        // newUv -= 0.5;\n\n        float line = 0.;\n        // float x = plot(newUv, line, 0.02 );\n        float x = circle(newUv, 1.025);\n        float x1 = circle(vec2(newUv.x + sin(u_time)/4., newUv.y + cos(u_time)/4.), 0.275);\n        float x2 = circle(vec2(newUv.x + sin(u_time)/8., newUv.y + cos(u_time)/8.), 0.075);\n        float x3 = circle(vec2(newUv.x + sin(u_time)/16. , newUv.y + cos(u_time)/16.) , 0.022);\n        float x4 = circle(vec2(newUv.x + sin(u_time)/32. , newUv.y + cos(u_time)/32.) , 0.006);\n        float x5 = circle(vec2(newUv.x + sin(u_time)/64. , newUv.y + cos(u_time)/64.) , 0.002);\n\n        color.rgb += x;\n        color.rgb -= x1;\n        color.rgb += x2;\n        color.rgb -= x3;\n        color.rgb += x4;\n        color.rgb -= x5;\n        // color.rb -= x2;\n\n        \n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function FA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:PA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numEight(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    float flower(vec2 vUv, float n, float zoom)\n    {\n        vec2 pos = vec2(0.5) - vUv;\n        float r = length(pos) * zoom;\n        float a = atan(pos.y, pos.x);\n        float f = cos(a * n );\n        return smoothstep(f, f + 0.25, r );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        // newUv *= 0.25 + 0.75;\n        vec2 newUv2 = newUv;\n        vec2 newUv3 = newUv;\n        newUv = Rot(newUv, u_time * 1.5 + sin(u_time));\n        newUv2 = Rot(newUv2, u_time * 1.5 + cos(u_time));\n        newUv3 = Rot(newUv2, u_time * 1. + cos(u_time));\n        // newUv -= 0.5;\n        // newUv2.x -= 0.2;\n\n        float line = 0.;\n        // float x = plot(newUv, line, 0.02 );\n        float x = flower(newUv, 5., 2.);\n        float x2 = flower(newUv2, 5., 2.);\n        float x3 = flower(newUv3, 5., 2.);\n        color += 1. - palette(x * 0.5);\n        color += 1. - palette(x2 * 0.25);\n        color += 1. - palette(x3 * 0.15);\n\n        // color.rb -= x2;\n\n        \n\n        float numLabel = label(vUv);\n        color *= 1. - numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function IA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:jA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var EA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 3.28318*(c*t+d) * abs(sin(u_time/8. )- 0.25));\n    }\n\n    float flower(vec2 vUv, float n, float zoom)\n    {\n        vec2 pos = vec2(0.5) - vUv;\n        float r = length(pos) * zoom;\n        float a = atan(pos.y, pos.x);\n        float f = cos(a * n );\n        return smoothstep(f, f + 0.25, r );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        // newUv *= 0.25 + 0.75;\n        vec2 newUv2 = newUv;\n        vec2 newUv3 = newUv;\n        vec2 newUv4 = newUv;\n        vec2 newUv5 = newUv;\n        vec2 newUv6 = newUv;\n        vec2 newUv7 = newUv;\n        vec2 newUv8 = newUv;\n\n        newUv = Rot(newUv, u_time * 2.25 + cos(u_time));\n        newUv2 = Rot(newUv2, u_time * 2.0 + cos(u_time));\n        newUv3 = Rot(newUv3, u_time * 1.75 + cos(u_time));\n        newUv4 = Rot(newUv4, u_time * 1.5 + cos(u_time));\n        newUv5 = Rot(newUv5, u_time * 1.25 + cos(u_time));\n        newUv6 = Rot(newUv6, u_time * 1. + cos(u_time));\n        newUv7 = Rot(newUv7, u_time * 0.75 + cos(u_time));\n        newUv8 = Rot(newUv8, u_time * 0.5 + cos(u_time));\n        // newUv -= 0.5;\n        // newUv2.x -= 0.2;\n\n        float x = sdPolygonOutline(newUv, 6, 0.8); \n        float x2 = sdPolygonOutline(newUv2, 6, 0.7);\n        float x3 = sdPolygonOutline(newUv3, 6, 0.6); \n        float x4 = sdPolygonOutline(newUv4, 6, 0.5); \n        float x5 = sdPolygonOutline(newUv5, 6, 0.4); \n        float x6 = sdPolygonOutline(newUv6, 6, 0.3);\n        float x7 = sdPolygonOutline(newUv7, 6, 0.2); \n        float x8 = sdPolygonOutline(newUv8, 6, 0.1);  \n        \n        color += 1. - palette(x * 0.59);\n        color += 1. - palette(x2 * 0.58);\n        color += 1. - palette(x3 * 0.57);\n        color += 1. - palette(x4 * 0.56);\n        color += 1. - palette(x5 * 0.55);\n        color += 1. - palette(x6 * 0.54);\n        color += 1. - palette(x7 * 0.53);\n        color += 1. - palette(x8 * 0.52);\n\n        color *= 2.;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function OA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:EA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var AA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 3.28318*(c*t+d) * abs(sin(u_time/8. )- 0.25));\n    }\n\n    float flower(vec2 vUv, float n, float zoom)\n    {\n        vec2 pos = vec2(0.5) - vUv;\n        float r = length(pos) * zoom;\n        float a = atan(pos.y, pos.x);\n        float f = cos(a * n );\n        return smoothstep(f, f + 0.25, r );\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        // newUv *= 0.25 + 0.75;\n        vec2 newUv2 = newUv;\n        vec2 newUv3 = newUv;\n        vec2 newUv4 = newUv;\n        vec2 newUv5 = newUv;\n        vec2 newUv6 = newUv;\n        vec2 newUv7 = newUv;\n        vec2 newUv8 = newUv;\n\n        newUv = Rot(newUv,   u_time/4. * 2.25 + cos(u_time));\n        newUv2 = Rot(newUv2, u_time/4. * 2.00 + cos(u_time));\n        newUv3 = Rot(newUv3, u_time/4. * 1.75 + cos(u_time));\n        newUv4 = Rot(newUv4, u_time/4. * 1.50 + cos(u_time));\n        newUv5 = Rot(newUv5, u_time/4. * 1.25 + cos(u_time));\n        newUv6 = Rot(newUv6, u_time/4. * 1.00 + cos(u_time));\n        newUv7 = Rot(newUv7, u_time/4. * 0.75 + cos(u_time));\n        newUv8 = Rot(newUv8, u_time/4. * 0.50 + cos(u_time));\n        // newUv -= 0.5;\n        // newUv2.x -= 0.2;\n\n        float x = sdPolygonOutline(newUv,   4, 0.8); \n        float x2 = sdPolygonOutline(newUv2, 4, 0.7);\n        float x3 = sdPolygonOutline(newUv3, 4, 0.6); \n        float x4 = sdPolygonOutline(newUv4, 4, 0.5); \n        float x5 = sdPolygonOutline(newUv5, 4, 0.4); \n        float x6 = sdPolygonOutline(newUv6, 4, 0.3);\n        float x7 = sdPolygonOutline(newUv7, 4, 0.2); \n        float x8 = sdPolygonOutline(newUv8, 4, 0.1);  \n        \n        color += 1. - palette(x  * 0.59 * 2.2 * abs(sin(u_time) + 0.1));\n        color += 1. - palette(x2 * 0.58 * 2.2 * abs(cos(u_time) + 0.2));\n        color += 1. - palette(x3 * 0.57 * 2.2 * abs(sin(u_time) + 0.3));\n        color += 1. - palette(x4 * 0.56 * 2.2 * abs(cos(u_time) + 0.4));\n        color += 1. - palette(x5 * 0.55 * 2.2 * abs(sin(u_time) + 0.5));\n        color += 1. - palette(x6 * 0.54 * 2.2 * abs(cos(u_time) + 0.6));\n        color += 1. - palette(x7 * 0.53 * 2.2 * abs(sin(u_time) + 0.7));\n        color += 1. - palette(x8 * 0.52 * 2.2 * abs(cos(u_time) + 0.8));\n\n        // color *= 2.;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function LA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:AA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var GA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://iquilezles.org/articles/palettes/\n    vec3 palette( float t ) {\n        vec3 a = vec3(0.5, 0.5, 0.5);\n        vec3 b = vec3(0.5, 0.5, 0.5);\n        vec3 c = vec3(.9, .5, .0);\n        vec3 d = vec3(0.03,0.06,0.);\n\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    float randFloat(float x){\n        return fract(sin(x) * 4748393.7585);\n    }\n    \n    float randVec2(vec2 vUv){\n        return fract(sin(dot(vUv.yx, vec2(48.48929, 76.83929))) * 727827.3738);\n    }\n    \n    vec3 matrix(vec2 vUv){\n        float rows = 15.0;\n        vec2 a = floor(vUv * rows);\n        a += vec2(1.0, floor(u_time * 5. * randFloat(a.x)));\n        vec2 b = fract(vUv * rows);\n        vec2 newUv = 0.5 - b;\n        float str = randVec2(a);\n        float one = sdOne(b);\n        float zero = sdZero(b);\n        float two = sdTwo(b);\n        float three = sdThree(b);\n        float four = sdFour(b);\n        float five = sdFive(b);\n        float six = sdSix(b);\n        float seven = sdSeven(b);\n        float eight = sdEight(b);\n        float nine = sdNine(b);\n        float shape;\n        if(str > .9 )\n        {\n            shape = smoothstep(0.01, 0.011, zero);\n        } else if(str > .8){\n            shape = smoothstep(0.01, 0.011, one);\n        } else if(str > .7){\n            shape = smoothstep(0.01, 0.011, two);\n        } else if(str > .6){\n            shape = smoothstep(0.01, 0.011, three);\n        } else if(str > .5){\n            shape = smoothstep(0.01, 0.011, four);\n        } else if(str > .4){\n            shape = smoothstep(0.01, 0.011, five);\n        } else if(str > .3){\n            shape = smoothstep(0.01, 0.011, six);\n        } else if(str > .2){\n            shape = smoothstep(0.01, 0.011, seven);\n        } else if(str > .1){\n            shape = smoothstep(0.01, 0.011, eight);\n        } else {\n            shape = smoothstep(0.01, 0.011, nine);\n        }\n        \n        return vec3(shape * str );\n    }\n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        newUv -= 0.5;\n    \n        float an = -u_time * 0.5;\n        // newUv = mat2(cos(an),-sin(an),sin(an),cos(an)) * newUv;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(newUv) ;\n        // r1 = abs(r1 );\n        float a = -atan(newUv.x, newUv.y) * 0.425;\n        // a = abs(a * 0.85);\n        newUv = vec2(0.5/r1 + .95 + u_time * 0.25 + r1, a );\n\n        vec3 mat = matrix(vec2(newUv.y, newUv.x));\n\n        color.g += mat.g;\n\n        float cir = sdCircle(vUv, 0.125 );\n        color *=  1.- cir;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function NA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:GA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var BA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float cloudscale = 1.1;\n    float speed = 0.03;\n    float clouddark = 0.5;\n    float cloudlight = 0.3;\n    float cloudcover = 0.2;\n    float cloudalpha = 8.0;\n    float skytint = 0.5;\n    vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\n    vec3 skycolour2 = vec3(1.4, 0.7, 1.0);\n\n    const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\n    vec2 hash( vec2 p ) {\n        p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n        return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    }\n    \n    float noise( in vec2 p ) {\n        const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n        const float K2 = 0.211324865; // (3-sqrt(3))/6;\n        vec2 i = floor(p + (p.x+p.y)*K1);\t\n        vec2 a = p - i + (i.x+i.y)*K2;\n        vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n        vec2 b = a - o + K2;\n        vec2 c = a - 1.0 + 2.0*K2;\n        vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n        vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n        return dot(n, vec3(70.0));\t\n    }\n    \n    float fbm(vec2 n) {\n        float total = 0.0, amplitude = 0.1;\n        for (int i = 0; i < 7; i++) {\n            total += noise(n) * amplitude;\n            n = m * n;\n            amplitude *= 0.4;\n        }\n        return total;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 newUv = vUv;\n        // newUv = newUv*vec2(u_resolution.x/u_resolution.y,1.0);\n        newUv -= 0.5;\n        // newUv *= 20.5;\n        float t = u_time * speed;\n        float q = fbm(newUv * cloudscale * 0.5);\n\n        float r = 0.;\n        newUv *= cloudscale;\n        newUv -= q - t;\n        float weight = 0.8;\n        for(int i = 0; i < 8; i++){\n            r += abs(weight*noise(newUv));\n            newUv = m*newUv + t;\n            weight *= 0.7;\n        }\n        float f = 0.0;\n        // newUv = newUv*vec2(u_resolution.x/u_resolution.y,1.0);\n        newUv *= cloudscale;\n        newUv -= q - t;\n        weight = 0.7;\n        for (int i=0; i<8; i++){\n            f += weight*noise( newUv );\n            newUv = m*newUv + t;\n            weight *= 0.6;\n    }\n        f *= r + f;\n        float c = 0.0;\n        t = u_time * speed * 2.0;\n        // newUv = newUv*vec2(u_resolution.x/u_resolution.y,1.0);\n        newUv *= cloudscale*2.0;\n        newUv -= q - t;\n        weight = 0.4;\n        for (int i=0; i<7; i++){\n            c += weight*noise( newUv );\n            newUv = m*newUv + t;\n            weight *= 0.6;\n        }\n        float c1 = 0.0;\n        t = u_time * speed * 3.0;\n        // newUv = newUv*vec2(u_resolution.x/u_resolution.y,1.0);\n        newUv *= cloudscale*3.0;\n        newUv -= q - t;\n        weight = 0.4;\n        for (int i=0; i<7; i++){\n            c1 += abs(weight*noise( newUv ));\n            newUv = m*newUv + t;\n            weight *= 0.6;\n        }\n\n        c += c1;\n        \n        vec3 skycolour = mix(skycolour2, skycolour1, vUv.x);\n        vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n    \n        f = cloudcover + cloudalpha*f*r;\n\n        vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n    \n        color += result;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function qA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:BA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var VA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.52;\n        uv2 *= 2.9;\n        uv2.x += u_time*0.1;\n        \n        vec2 q = vec2(0.);\n        q.y = fbm( uv2 + 0.2*u_time);\n        q.x = fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r ));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f),0.0,1.0));\n        color += c;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function WA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:VA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var HA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.52;\n        uv2 *= 3.9;\n        uv2.x += u_time*0.1;\n        uv2.y += u_time * 0.1;\n        \n        vec2 q = vec2(0.);\n        q.y = fbm( uv2 + 0.2*u_time);\n        q.x = fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f*f + f * 0.85),0.0,1.0));\n        color += c;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function XA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:HA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var YA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    // Helper functions:\n    float slopeFromT (float t, float A, float B, float C){\n        float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n        return dtdx;\n    }\n    float xFromT (float t, float A, float B, float C, float D){\n        float x = A*(t*t*t) + B*(t*t) + C*t + D;\n        return x;\n    }\n    float yFromT (float t, float E, float F, float G, float H){\n        float y = E*(t*t*t) + F*(t*t) + G*t + H;\n        return y;\n    }\n    float B0 (float t){\n        return (1.0-t)*(1.0-t)*(1.0-t);\n    }\n    float B1 (float t){\n        return  3.0*t*(1.0-t)*(1.0-t);\n    }\n    float B2 (float t){\n        return 3.0*t*t* (1.0-t);\n    }\n    float B3 (float t){\n        return t*t*t;\n    }\n    float  findx (float t, float x0, float x1, float x2, float x3){\n        return x0*B0(t) + x1*B1(t) + x2*B2(t) + x3*B3(t);\n    }\n    float  findy (float t, float y0, float y1, float y2, float y3){\n        return y0*B0(t) + y1*B1(t) + y2*B2(t) + y3*B3(t);\n    }\n    \n    float cubicBezier(float x, vec2 a, vec2 b){\n        float y0a = 0.0; // initial y\n        float x0a = 0.0; // initial x \n        float y1a = a.y;    // 1st influence y   \n        float x1a = a.x;    // 1st influence x \n        float y2a = b.y;    // 2nd influence y\n        float x2a = b.x;    // 2nd influence x\n        float y3a = 1.0; // final y \n        float x3a = 1.0; // final x \n    \n        float A =   x3a - 3.0*x2a + 3.0*x1a - x0a;\n        float B = 3.0*x2a - 6.0*x1a + 3.0*x0a;\n        float C = 3.0*x1a - 3.0*x0a;   \n        float D =   x0a;\n    \n        float E =   y3a - 3.0*y2a + 3.0*y1a - y0a;    \n        float F = 3.0*y2a - 6.0*y1a + 3.0*y0a;             \n        float G = 3.0*y1a - 3.0*y0a;             \n        float H =   y0a;\n    \n        // Solve for t given x (using Newton-Raphelson), then solve for y given t.\n        // Assume for the first guess that t = x.\n        float currentt = x;\n        for (int i=0; i < 5; i++){\n        float currentx = xFromT (currentt, A,B,C,D); \n        float currentslope = slopeFromT (currentt, A,B,C);\n        currentt -= (currentx - x)*(currentslope);\n            currentt = clamp(currentt,0.0,1.0); \n        } \n    \n        float y = yFromT (currentt,  E,F,G,H);\n        return y;\n    }\n    \n    float cubicBezierNearlyThroughTwoPoints(float x, vec2 a, vec2 b){\n    \n        float y = 0.0;\n        float epsilon = 0.00001;\n        float min_param_a = 0.0 + epsilon;\n        float max_param_a = 1.0 - epsilon;\n        float min_param_b = 0.0 + epsilon;\n        float max_param_b = 1.0 - epsilon;\n        a.x = max(min_param_a, min(max_param_a, a.x));\n        a.y = max(min_param_b, min(max_param_b, a.y));\n    \n        float x0 = 0.0;  \n        float y0 = 0.0;\n        float x4 = a.x;  \n        float y4 = a.y;\n        float x5 = b.x;  \n        float y5 = b.y;\n        float x3 = 1.0;  \n        float y3 = 1.0;\n        float x1,y1,x2,y2; // to be solved.\n    \n        // arbitrary but reasonable \n        // t-values for interior control points\n        float t1 = 0.3;\n        float t2 = 0.7;\n    \n        float B0t1 = B0(t1);\n        float B1t1 = B1(t1);\n        float B2t1 = B2(t1);\n        float B3t1 = B3(t1);\n        float B0t2 = B0(t2);\n        float B1t2 = B1(t2);\n        float B2t2 = B2(t2);\n        float B3t2 = B3(t2);\n    \n        float ccx = x4 - x0*B0t1 - x3*B3t1;\n        float ccy = y4 - y0*B0t1 - y3*B3t1;\n        float ffx = x5 - x0*B0t2 - x3*B3t2;\n        float ffy = y5 - y0*B0t2 - y3*B3t2;\n    \n        x2 = (ccx - (ffx*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        y2 = (ccy - (ffy*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        x1 = (ccx - x2*B2t1) / B1t1;\n        y1 = (ccy - y2*B2t1) / B1t1;\n    \n        x1 = max(0.0+epsilon, min(1.0-epsilon, x1));\n        x2 = max(0.0+epsilon, min(1.0-epsilon, x2));\n    \n        y = cubicBezier (x, vec2(x1,y1), vec2(x2,y2));\n        y = max(0.0, min(1.0, y));\n        return y;\n    }\n\n    \n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        \n\n        // float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(1.83/r1 + .95 + u_time * 0.025 + r1, a );\n        uv2 -= 0.52;\n        uv2 *= 2.9;\n        uv2.x -= u_time*0.1;\n        uv2.y += u_time * 0.2;\n\n        vec2 uv3 = vUv;\n        uv3 *= 1.2;\n        uv3.y += 2.5;\n        uv3.x += 0.5;\n\n        vec2 uv4 = uv3;\n        float rand = random(uv4);\n        uv4 = uv4 * rand;\n        \n        vec2 q = vec2(0.);\n        q.y = -fbm( uv2 + 0.2*u_time);\n        q.x = -fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        vec2 r2 = vec2(0.);\n        r2.x = fbm( uv2 + 1.0*q - vec2(1.7,0.2)+ 0.1*u_time );\n        r2.y = fbm( uv2 + 1.0*q - vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f*f + f * 0.85),0.0,1.0));\n        color += c;\n\n        vec2 cp0 = vec2(-0.5, 1.95);\n        vec2 cp1 = vec2(0.75, 0.5);\n        vec2 cp3 = vec2(0.5, 0.5);\n        float l = cubicBezierNearlyThroughTwoPoints(uv3.x*0.25, cp0, cp1);\n        float l2 = cubicBezierNearlyThroughTwoPoints(uv4.y*0.25, cp0, cp3);\n        float px = 1. / vUv.y;\n\n        float t1 = uv3.x*7.-2.*u_time+uv3.y*3.;\n        uv3.y += sin(t1) * 0.05;\n        float x = .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        float y = fbm(uv4 + r2 * fbm(uv4 + r2));\n        // color *= .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        \n        color *= vec3( smoothstep(l, l+0.025, vUv.y+0.6));\n        color.g += (1. - smoothstep(l, l+0.025, vUv.y+0.6))* 0.72 * x* y;\n        \n        // color -= vec3(1. - smoothstep(l2, l2, vUv.y+0.5));\n\n        \n        \n        // color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ZA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:YA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var QA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    // Helper functions:\n    float slopeFromT (float t, float A, float B, float C){\n        float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n        return dtdx;\n    }\n    float xFromT (float t, float A, float B, float C, float D){\n        float x = A*(t*t*t) + B*(t*t) + C*t + D;\n        return x;\n    }\n    float yFromT (float t, float E, float F, float G, float H){\n        float y = E*(t*t*t) + F*(t*t) + G*t + H;\n        return y;\n    }\n    float B0 (float t){\n        return (1.0-t)*(1.0-t)*(1.0-t);\n    }\n    float B1 (float t){\n        return  3.0*t*(1.0-t)*(1.0-t);\n    }\n    float B2 (float t){\n        return 3.0*t*t* (1.0-t);\n    }\n    float B3 (float t){\n        return t*t*t;\n    }\n    float  findx (float t, float x0, float x1, float x2, float x3){\n        return x0*B0(t) + x1*B1(t) + x2*B2(t) + x3*B3(t);\n    }\n    float  findy (float t, float y0, float y1, float y2, float y3){\n        return y0*B0(t) + y1*B1(t) + y2*B2(t) + y3*B3(t);\n    }\n    \n    float cubicBezier(float x, vec2 a, vec2 b){\n        float y0a = 0.0; // initial y\n        float x0a = 0.0; // initial x \n        float y1a = a.y;    // 1st influence y   \n        float x1a = a.x;    // 1st influence x \n        float y2a = b.y;    // 2nd influence y\n        float x2a = b.x;    // 2nd influence x\n        float y3a = 1.0; // final y \n        float x3a = 1.0; // final x \n    \n        float A =   x3a - 3.0*x2a + 3.0*x1a - x0a;\n        float B = 3.0*x2a - 6.0*x1a + 3.0*x0a;\n        float C = 3.0*x1a - 3.0*x0a;   \n        float D =   x0a;\n    \n        float E =   y3a - 3.0*y2a + 3.0*y1a - y0a;    \n        float F = 3.0*y2a - 6.0*y1a + 3.0*y0a;             \n        float G = 3.0*y1a - 3.0*y0a;             \n        float H =   y0a;\n    \n        // Solve for t given x (using Newton-Raphelson), then solve for y given t.\n        // Assume for the first guess that t = x.\n        float currentt = x;\n        for (int i=0; i < 5; i++){\n        float currentx = xFromT (currentt, A,B,C,D); \n        float currentslope = slopeFromT (currentt, A,B,C);\n        currentt -= (currentx - x)*(currentslope);\n            currentt = clamp(currentt,0.0,1.0); \n        } \n    \n        float y = yFromT (currentt,  E,F,G,H);\n        return y;\n    }\n    \n    float cubicBezierNearlyThroughTwoPoints(float x, vec2 a, vec2 b){\n    \n        float y = 0.0;\n        float epsilon = 0.00001;\n        float min_param_a = 0.0 + epsilon;\n        float max_param_a = 1.0 - epsilon;\n        float min_param_b = 0.0 + epsilon;\n        float max_param_b = 1.0 - epsilon;\n        a.x = max(min_param_a, min(max_param_a, a.x));\n        a.y = max(min_param_b, min(max_param_b, a.y));\n    \n        float x0 = 0.0;  \n        float y0 = 0.0;\n        float x4 = a.x;  \n        float y4 = a.y;\n        float x5 = b.x;  \n        float y5 = b.y;\n        float x3 = 1.0;  \n        float y3 = 1.0;\n        float x1,y1,x2,y2; // to be solved.\n    \n        // arbitrary but reasonable \n        // t-values for interior control points\n        float t1 = 0.3;\n        float t2 = 0.7;\n    \n        float B0t1 = B0(t1);\n        float B1t1 = B1(t1);\n        float B2t1 = B2(t1);\n        float B3t1 = B3(t1);\n        float B0t2 = B0(t2);\n        float B1t2 = B1(t2);\n        float B2t2 = B2(t2);\n        float B3t2 = B3(t2);\n    \n        float ccx = x4 - x0*B0t1 - x3*B3t1;\n        float ccy = y4 - y0*B0t1 - y3*B3t1;\n        float ffx = x5 - x0*B0t2 - x3*B3t2;\n        float ffy = y5 - y0*B0t2 - y3*B3t2;\n    \n        x2 = (ccx - (ffx*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        y2 = (ccy - (ffy*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        x1 = (ccx - x2*B2t1) / B1t1;\n        y1 = (ccy - y2*B2t1) / B1t1;\n    \n        x1 = max(0.0+epsilon, min(1.0-epsilon, x1));\n        x2 = max(0.0+epsilon, min(1.0-epsilon, x2));\n    \n        y = cubicBezier (x, vec2(x1,y1), vec2(x2,y2));\n        y = max(0.0, min(1.0, y));\n        return y;\n    }\n\n    \n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        \n\n        // float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(1.83/r1 + .95 + u_time * 0.025 + r1, a );\n        uv2 -= 0.52;\n        uv2 *= 2.9;\n        // uv2.x -= u_time*0.1;\n        // uv2.y += u_time * 0.2;\n\n        vec2 uv3 = vUv;\n        uv3 *= 1.2;\n        uv3.y += 2.5;\n        uv3.x += 0.5;\n\n        vec2 uv4 = uv3;\n        float rand = random(uv4);\n        uv4 = uv4 * rand;\n        \n        vec2 q = vec2(0.);\n        q.y = -fbm( uv2 + 0.2*u_time);\n        q.x = -fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        vec2 r2 = vec2(0.);\n        r2.x = fbm( uv2 + 1.0*q - vec2(1.7,0.2)+ 0.1*u_time );\n        r2.y = fbm( uv2 + 1.0*q - vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f*f + f * 0.85),0.0,1.0));\n        color += c;\n\n        vec2 cp0 = vec2(-0.5, 1.95);\n        vec2 cp1 = vec2(0.75, 0.5);\n        vec2 cp3 = vec2(0.5, 0.5);\n        float l = cubicBezierNearlyThroughTwoPoints(uv3.x*0.25, cp0, cp1);\n        float l2 = cubicBezierNearlyThroughTwoPoints(uv4.y*0.25, cp0, cp3);\n        float px = 1. / vUv.y;\n\n        float t1 = uv3.x*7.-2.*u_time+uv3.y*3.;\n        uv3.y += sin(t1) * 0.05;\n        float x = .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        float y = fbm(uv4 + r2 * fbm(uv4 + r2));\n        color *= .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        \n        color *= vec3( smoothstep(l, l+0.025, vUv.y+0.6));\n        color.g += (1. - smoothstep(l, l+0.025, vUv.y+0.6))* 0.72 * x* y;\n        \n        // color -= vec3(1. - smoothstep(l2, l2, vUv.y+0.5));\n\n        \n        \n        // color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function JA(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:QA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var KA=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    uniform sampler2D u_texture;\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    // Helper functions:\n    float slopeFromT (float t, float A, float B, float C){\n        float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n        return dtdx;\n    }\n    float xFromT (float t, float A, float B, float C, float D){\n        float x = A*(t*t*t) + B*(t*t) + C*t + D;\n        return x;\n    }\n    float yFromT (float t, float E, float F, float G, float H){\n        float y = E*(t*t*t) + F*(t*t) + G*t + H;\n        return y;\n    }\n    float B0 (float t){\n        return (1.0-t)*(1.0-t)*(1.0-t);\n    }\n    float B1 (float t){\n        return  3.0*t*(1.0-t)*(1.0-t);\n    }\n    float B2 (float t){\n        return 3.0*t*t* (1.0-t);\n    }\n    float B3 (float t){\n        return t*t*t;\n    }\n    float  findx (float t, float x0, float x1, float x2, float x3){\n        return x0*B0(t) + x1*B1(t) + x2*B2(t) + x3*B3(t);\n    }\n    float  findy (float t, float y0, float y1, float y2, float y3){\n        return y0*B0(t) + y1*B1(t) + y2*B2(t) + y3*B3(t);\n    }\n    \n    float cubicBezier(float x, vec2 a, vec2 b){\n        float y0a = 0.0; // initial y\n        float x0a = 0.0; // initial x \n        float y1a = a.y;    // 1st influence y   \n        float x1a = a.x;    // 1st influence x \n        float y2a = b.y;    // 2nd influence y\n        float x2a = b.x;    // 2nd influence x\n        float y3a = 1.0; // final y \n        float x3a = 1.0; // final x \n    \n        float A =   x3a - 3.0*x2a + 3.0*x1a - x0a;\n        float B = 3.0*x2a - 6.0*x1a + 3.0*x0a;\n        float C = 3.0*x1a - 3.0*x0a;   \n        float D =   x0a;\n    \n        float E =   y3a - 3.0*y2a + 3.0*y1a - y0a;    \n        float F = 3.0*y2a - 6.0*y1a + 3.0*y0a;             \n        float G = 3.0*y1a - 3.0*y0a;             \n        float H =   y0a;\n    \n        // Solve for t given x (using Newton-Raphelson), then solve for y given t.\n        // Assume for the first guess that t = x.\n        float currentt = x;\n        for (int i=0; i < 5; i++){\n        float currentx = xFromT (currentt, A,B,C,D); \n        float currentslope = slopeFromT (currentt, A,B,C);\n        currentt -= (currentx - x)*(currentslope);\n            currentt = clamp(currentt,0.0,1.0); \n        } \n    \n        float y = yFromT (currentt,  E,F,G,H);\n        return y;\n    }\n    \n    float cubicBezierNearlyThroughTwoPoints(float x, vec2 a, vec2 b){\n    \n        float y = 0.0;\n        float epsilon = 0.00001;\n        float min_param_a = 0.0 + epsilon;\n        float max_param_a = 1.0 - epsilon;\n        float min_param_b = 0.0 + epsilon;\n        float max_param_b = 1.0 - epsilon;\n        a.x = max(min_param_a, min(max_param_a, a.x));\n        a.y = max(min_param_b, min(max_param_b, a.y));\n    \n        float x0 = 0.0;  \n        float y0 = 0.0;\n        float x4 = a.x;  \n        float y4 = a.y;\n        float x5 = b.x;  \n        float y5 = b.y;\n        float x3 = 1.0;  \n        float y3 = 1.0;\n        float x1,y1,x2,y2; // to be solved.\n    \n        // arbitrary but reasonable \n        // t-values for interior control points\n        float t1 = 0.3;\n        float t2 = 0.7;\n    \n        float B0t1 = B0(t1);\n        float B1t1 = B1(t1);\n        float B2t1 = B2(t1);\n        float B3t1 = B3(t1);\n        float B0t2 = B0(t2);\n        float B1t2 = B1(t2);\n        float B2t2 = B2(t2);\n        float B3t2 = B3(t2);\n    \n        float ccx = x4 - x0*B0t1 - x3*B3t1;\n        float ccy = y4 - y0*B0t1 - y3*B3t1;\n        float ffx = x5 - x0*B0t2 - x3*B3t2;\n        float ffy = y5 - y0*B0t2 - y3*B3t2;\n    \n        x2 = (ccx - (ffx*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        y2 = (ccy - (ffy*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        x1 = (ccx - x2*B2t1) / B1t1;\n        y1 = (ccy - y2*B2t1) / B1t1;\n    \n        x1 = max(0.0+epsilon, min(1.0-epsilon, x1));\n        x2 = max(0.0+epsilon, min(1.0-epsilon, x2));\n    \n        y = cubicBezier (x, vec2(x1,y1), vec2(x2,y2));\n        y = max(0.0, min(1.0, y));\n        return y;\n    }\n\n    \n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        \n        \n        // vec2 pic = texture2D(u_texture);\n\n        // float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * .75) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 2.5);\n        uv2 = vec2(1.83/r1 + .45 + -u_time * 0.125 + r1, a );\n        uv2 -= 0.52;\n        uv2 *= 1.9;\n        // uv2.x -= u_time*0.1;\n        // uv2.y += u_time * 0.2;\n\n        vec2 uv3 = vUv;\n        uv3 *= 1.2;\n        uv3.y += 2.5;\n        uv3.x += 0.5;\n\n        vec2 uv4 = uv3;\n        float rand = random(uv4);\n        uv4 = uv4 * rand;\n        \n        vec2 q = vec2(0.);\n        q.y = -fbm( uv2 + 0.2*u_time);\n        q.x = -fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        vec2 r2 = vec2(0.);\n        r2.x = fbm( uv2 + 1.0*q - vec2(1.7,0.2)+ 0.1*u_time );\n        r2.y = fbm( uv2 + 1.0*q - vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f*f + f * 0.85),0.0,1.0));\n        color += c;\n\n        vec2 cp0 = vec2(-0.65, 1.95);\n        vec2 cp1 = vec2(0.85, 0.4);\n        vec2 cp3 = vec2(0.5, 0.5);\n        float l = cubicBezierNearlyThroughTwoPoints(uv3.x*0.25, cp0, cp1);\n        float l2 = cubicBezierNearlyThroughTwoPoints(uv4.y*0.25, cp0, cp3);\n        float px = 1. / vUv.y;\n\n        float t1 = uv3.x*7.-2.*u_time+uv3.y*3.;\n        uv3.y += sin(t1) * 0.05;\n        float x = .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        float y = fbm(uv4 + r2 * fbm(uv4 + r2));\n        // color *= .7 + cos(t1) * .3 + noise(uv4 + u_time) * 0.5;\n        \n        color *= vec3( smoothstep(l, l+0.025, vUv.y+0.6));\n        // color.g += (1. - smoothstep(l, l+0.025, vUv.y+0.6))* 0.72 * x* y;\n        \n        // color -= vec3(1. - smoothstep(l2, l2, vUv.y+0.5));\n\n        \n        // color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        vec4 col = texture2D(u_texture, vec2(vUv.x, vUv.y + 0.305));\n        \n        col.xyz += color;\n        gl_FragColor = vec4(color, 1.);\n        // gl_FragColor = texture2D(u_texture, vUv);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function $A(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:KA,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var nL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n   \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numFive(vec2(p.x + 0.35, p.y));\n        float center = numNine(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.0, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    // Helper functions:\n    float slopeFromT (float t, float A, float B, float C){\n        float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n        return dtdx;\n    }\n    float xFromT (float t, float A, float B, float C, float D){\n        float x = A*(t*t*t) + B*(t*t) + C*t + D;\n        return x;\n    }\n    float yFromT (float t, float E, float F, float G, float H){\n        float y = E*(t*t*t) + F*(t*t) + G*t + H;\n        return y;\n    }\n    float B0 (float t){\n        return (1.0-t)*(1.0-t)*(1.0-t);\n    }\n    float B1 (float t){\n        return  3.0*t*(1.0-t)*(1.0-t);\n    }\n    float B2 (float t){\n        return 3.0*t*t* (1.0-t);\n    }\n    float B3 (float t){\n        return t*t*t;\n    }\n    float  findx (float t, float x0, float x1, float x2, float x3){\n        return x0*B0(t) + x1*B1(t) + x2*B2(t) + x3*B3(t);\n    }\n    float  findy (float t, float y0, float y1, float y2, float y3){\n        return y0*B0(t) + y1*B1(t) + y2*B2(t) + y3*B3(t);\n    }\n    \n    float cubicBezier(float x, vec2 a, vec2 b){\n        float y0a = 0.0; // initial y\n        float x0a = 0.0; // initial x \n        float y1a = a.y;    // 1st influence y   \n        float x1a = a.x;    // 1st influence x \n        float y2a = b.y;    // 2nd influence y\n        float x2a = b.x;    // 2nd influence x\n        float y3a = 1.0; // final y \n        float x3a = 1.0; // final x \n    \n        float A =   x3a - 3.0*x2a + 3.0*x1a - x0a;\n        float B = 3.0*x2a - 6.0*x1a + 3.0*x0a;\n        float C = 3.0*x1a - 3.0*x0a;   \n        float D =   x0a;\n    \n        float E =   y3a - 3.0*y2a + 3.0*y1a - y0a;    \n        float F = 3.0*y2a - 6.0*y1a + 3.0*y0a;             \n        float G = 3.0*y1a - 3.0*y0a;             \n        float H =   y0a;\n    \n        // Solve for t given x (using Newton-Raphelson), then solve for y given t.\n        // Assume for the first guess that t = x.\n        float currentt = x;\n        for (int i=0; i < 5; i++){\n        float currentx = xFromT (currentt, A,B,C,D); \n        float currentslope = slopeFromT (currentt, A,B,C);\n        currentt -= (currentx - x)*(currentslope);\n            currentt = clamp(currentt,0.0,1.0); \n        } \n    \n        float y = yFromT (currentt,  E,F,G,H);\n        return y;\n    }\n    \n    float cubicBezierNearlyThroughTwoPoints(float x, vec2 a, vec2 b){\n    \n        float y = 0.0;\n        float epsilon = 0.00001;\n        float min_param_a = 0.0 + epsilon;\n        float max_param_a = 1.0 - epsilon;\n        float min_param_b = 0.0 + epsilon;\n        float max_param_b = 1.0 - epsilon;\n        a.x = max(min_param_a, min(max_param_a, a.x));\n        a.y = max(min_param_b, min(max_param_b, a.y));\n    \n        float x0 = 0.0;  \n        float y0 = 0.0;\n        float x4 = a.x;  \n        float y4 = a.y;\n        float x5 = b.x;  \n        float y5 = b.y;\n        float x3 = 1.0;  \n        float y3 = 1.0;\n        float x1,y1,x2,y2; // to be solved.\n    \n        // arbitrary but reasonable \n        // t-values for interior control points\n        float t1 = 0.3;\n        float t2 = 0.7;\n    \n        float B0t1 = B0(t1);\n        float B1t1 = B1(t1);\n        float B2t1 = B2(t1);\n        float B3t1 = B3(t1);\n        float B0t2 = B0(t2);\n        float B1t2 = B1(t2);\n        float B2t2 = B2(t2);\n        float B3t2 = B3(t2);\n    \n        float ccx = x4 - x0*B0t1 - x3*B3t1;\n        float ccy = y4 - y0*B0t1 - y3*B3t1;\n        float ffx = x5 - x0*B0t2 - x3*B3t2;\n        float ffy = y5 - y0*B0t2 - y3*B3t2;\n    \n        x2 = (ccx - (ffx*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        y2 = (ccy - (ffy*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        x1 = (ccx - x2*B2t1) / B1t1;\n        y1 = (ccy - y2*B2t1) / B1t1;\n    \n        x1 = max(0.0+epsilon, min(1.0-epsilon, x1));\n        x2 = max(0.0+epsilon, min(1.0-epsilon, x2));\n    \n        y = cubicBezier (x, vec2(x1,y1), vec2(x2,y2));\n        y = max(0.0, min(1.0, y));\n        return y;\n    }\n\n    \n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        \n        uv2 -= 0.475;\n        // vec2 pic = texture2D(u_texture);\n\n        // float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * 2.75 +0.6) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(.000083/r1 + .45 + -u_time * 0.925 + r1, a );\n        // uv2.x -= 0.52;\n        // uv2 *= 1.9;\n        // uv2.x -= u_time*0.1;\n        // uv2.y += u_time * 0.2;\n\n        vec2 uv3 = vUv;\n        // uv3 *= 1.2;\n        // uv3.y += 2.5;\n        uv3.x += 0.5;\n\n        vec2 uv4 = uv3;\n        float rand = random(uv4);\n        uv4 = uv4 * rand;\n        \n        vec2 q = vec2(0.);\n        q.y = -fbm( uv2 + 0.2*u_time);\n        q.x = -fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        vec2 r2 = vec2(0.);\n        r2.x = fbm( uv2 + 1.0*q - vec2(1.7,0.2)+ 0.1*u_time );\n        r2.y = fbm( uv2 + 1.0*q - vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1, skycolour2, clamp((f*f*f + f * f * 0.8),0.0,1.0));\n\n        \n        color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        gl_FragColor = vec4(color, 1.);\n        // gl_FragColor = texture2D(u_texture, vUv);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function eL(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:nL,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var tL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n   \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    vec3 skycolour1 = vec3(0.5, 0.3, 0.8);\n    vec3 skycolour2 = vec3(0.8, 0.9, 1.0);\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 4\n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.55;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    // Helper functions:\n    float slopeFromT (float t, float A, float B, float C){\n        float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n        return dtdx;\n    }\n    float xFromT (float t, float A, float B, float C, float D){\n        float x = A*(t*t*t) + B*(t*t) + C*t + D;\n        return x;\n    }\n    float yFromT (float t, float E, float F, float G, float H){\n        float y = E*(t*t*t) + F*(t*t) + G*t + H;\n        return y;\n    }\n    float B0 (float t){\n        return (1.0-t)*(1.0-t)*(1.0-t);\n    }\n    float B1 (float t){\n        return  3.0*t*(1.0-t)*(1.0-t);\n    }\n    float B2 (float t){\n        return 3.0*t*t* (1.0-t);\n    }\n    float B3 (float t){\n        return t*t*t;\n    }\n    float  findx (float t, float x0, float x1, float x2, float x3){\n        return x0*B0(t) + x1*B1(t) + x2*B2(t) + x3*B3(t);\n    }\n    float  findy (float t, float y0, float y1, float y2, float y3){\n        return y0*B0(t) + y1*B1(t) + y2*B2(t) + y3*B3(t);\n    }\n    \n    float cubicBezier(float x, vec2 a, vec2 b){\n        float y0a = 0.0; // initial y\n        float x0a = 0.0; // initial x \n        float y1a = a.y;    // 1st influence y   \n        float x1a = a.x;    // 1st influence x \n        float y2a = b.y;    // 2nd influence y\n        float x2a = b.x;    // 2nd influence x\n        float y3a = 1.0; // final y \n        float x3a = 1.0; // final x \n    \n        float A =   x3a - 3.0*x2a + 3.0*x1a - x0a;\n        float B = 3.0*x2a - 6.0*x1a + 3.0*x0a;\n        float C = 3.0*x1a - 3.0*x0a;   \n        float D =   x0a;\n    \n        float E =   y3a - 3.0*y2a + 3.0*y1a - y0a;    \n        float F = 3.0*y2a - 6.0*y1a + 3.0*y0a;             \n        float G = 3.0*y1a - 3.0*y0a;             \n        float H =   y0a;\n    \n        // Solve for t given x (using Newton-Raphelson), then solve for y given t.\n        // Assume for the first guess that t = x.\n        float currentt = x;\n        for (int i=0; i < 5; i++){\n        float currentx = xFromT (currentt, A,B,C,D); \n        float currentslope = slopeFromT (currentt, A,B,C);\n        currentt -= (currentx - x)*(currentslope);\n            currentt = clamp(currentt,0.0,1.0); \n        } \n    \n        float y = yFromT (currentt,  E,F,G,H);\n        return y;\n    }\n    \n    float cubicBezierNearlyThroughTwoPoints(float x, vec2 a, vec2 b){\n    \n        float y = 0.0;\n        float epsilon = 0.00001;\n        float min_param_a = 0.0 + epsilon;\n        float max_param_a = 1.0 - epsilon;\n        float min_param_b = 0.0 + epsilon;\n        float max_param_b = 1.0 - epsilon;\n        a.x = max(min_param_a, min(max_param_a, a.x));\n        a.y = max(min_param_b, min(max_param_b, a.y));\n    \n        float x0 = 0.0;  \n        float y0 = 0.0;\n        float x4 = a.x;  \n        float y4 = a.y;\n        float x5 = b.x;  \n        float y5 = b.y;\n        float x3 = 1.0;  \n        float y3 = 1.0;\n        float x1,y1,x2,y2; // to be solved.\n    \n        // arbitrary but reasonable \n        // t-values for interior control points\n        float t1 = 0.3;\n        float t2 = 0.7;\n    \n        float B0t1 = B0(t1);\n        float B1t1 = B1(t1);\n        float B2t1 = B2(t1);\n        float B3t1 = B3(t1);\n        float B0t2 = B0(t2);\n        float B1t2 = B1(t2);\n        float B2t2 = B2(t2);\n        float B3t2 = B3(t2);\n    \n        float ccx = x4 - x0*B0t1 - x3*B3t1;\n        float ccy = y4 - y0*B0t1 - y3*B3t1;\n        float ffx = x5 - x0*B0t2 - x3*B3t2;\n        float ffy = y5 - y0*B0t2 - y3*B3t2;\n    \n        x2 = (ccx - (ffx*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        y2 = (ccy - (ffy*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);\n        x1 = (ccx - x2*B2t1) / B1t1;\n        y1 = (ccy - y2*B2t1) / B1t1;\n    \n        x1 = max(0.0+epsilon, min(1.0-epsilon, x1));\n        x2 = max(0.0+epsilon, min(1.0-epsilon, x2));\n    \n        y = cubicBezier (x, vec2(x1,y1), vec2(x2,y2));\n        y = max(0.0, min(1.0, y));\n        return y;\n    }\n\n    \n\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        \n        uv2 -= 0.475;\n        // vec2 pic = texture2D(u_texture);\n\n        // float an = -u_time * 0.5;\n        // uv2 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv2;\n        // uv3 = mat2(cos(an),-sin(an),sin(an),cos(an)) * uv3;\n        float r1 = length(uv2 * 2.75 +0.6) ;\n        // r1 = abs(r1 );\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 8.5);\n        uv2 = vec2(.003/r1 + u_time * 0.925 + r1, a );\n        // uv2.x -= 0.52;\n        // uv2 *= 1.9;\n        // uv2.x -= u_time*0.1;\n        // uv2.y += u_time * 0.2;\n\n        vec2 uv3 = vUv;\n        // uv3 *= 1.2;\n        // uv3.y += 2.5;\n        uv3.x += 0.5;\n\n        vec2 uv4 = uv3;\n        float rand = random(uv4);\n        uv4 = uv4 * rand;\n        \n        vec2 q = vec2(0.);\n        q.y = -fbm( uv2 + 0.2*u_time);\n        q.x = -fbm( uv2 + u_time * 0.2);\n\n        vec2 r = vec2(0.);\n        r.x = fbm( uv2 + 1.0*q + vec2(1.7,0.2)+ 0.1*u_time );\n        r.y = fbm( uv2 + 1.0*q + vec2(0.3,0.8)+ 0.1*u_time);\n\n        vec2 r2 = vec2(0.);\n        r2.x = fbm( uv2 + 1.0*q - vec2(1.7,0.2)+ 0.1*u_time );\n        r2.y = fbm( uv2 + 1.0*q - vec2(0.3,0.8)+ 0.1*u_time);\n\n        float f = fbm(uv2+r * fbm(uv2 + r * fbm(uv2 + r)));\n        vec3 c = vec3(0.);\n        c = mix(skycolour1 + cos(u_time * 0.3), skycolour2 + abs(sin(u_time * 0.1)/5.) - 0.5, clamp((f*f*f + f * f * 0.8),0.,.8));\n\n        \n        color += c;\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        gl_FragColor = vec4(color, 1.);\n        // gl_FragColor = texture2D(u_texture, vUv);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function oL(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:n,material:tL,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var rL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n/////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n// Primitives\n///////////////////////\n \n// Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n    // Box0\n    vec3 b0s = vec3(.75,.75,.75); //box size\n    vec3 b0p = vec3(0.,1.2,1.); // box position\n    b0p = p-b0p;\n    b0p.yz *=Rotate(u_time * .2);\n    b0p.xz *=Rotate(u_time * .2);\n    vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n    //Box1\n    vec3 b1s = vec3(.85,.5,.5); //box size\n    vec3 b1p = vec3(0.,1.2,1.); // box position\n    b1p = p-b1p;\n    b1p.yz *=Rotate(u_time * .2);\n    b1p.xz *=Rotate(u_time * .2);\n    vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n    //Box2\n    vec3 b2s = vec3(.5,.5,.85); //box size\n    vec3 b2p = vec3(0.,1.2,1.); // box position\n    b2p = p-b2p;\n    b2p.yz *=Rotate(u_time * .2);\n    b2p.xz *=Rotate(u_time * .2);\n    vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n    // p.xz *=Rotate(u_time * .2);\n   \n    // Sphere.\n    vec3 s0p=vec3(0.,2.,1.);\n    s0p=p-s0p;\n    vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n    vec3 s1p=vec3(0.,0.5,1.);\n    s1p=p-s1p;\n    vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.5));\n     \n    // Cylinders\n    float c0h = 1.,c0r = .55; // Cylinder height, radius.\n    vec3 c0p = p - vec3 (0,1,2.); // Position\n    vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n     \n    float c1h = 1.,c1r = .55; \n    vec3 c1p = p - vec3 (0,1,0); \n    c1p.xy *= Rotate(PI*.5);  // Rotate\n    vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n     \n    float c2h = 1.,c2r = .55; \n    vec3 c2p = p - vec3 (0,1,0);\n    c2p.xy *= Rotate(PI*.5);  \n    c2p.yz *= Rotate(PI*.5);  \n    vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n   \n    // Plane\n    vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n \n    vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n     \n    csg0 = smoothDifferenceSDF(b0, b1, 0.15); // Intersect box with sphere creating a CSG object.\n\n    csg1 = smoothDifferenceSDF(csg0, s0, 0.15 + sin(u_time * 1.5)/8.);\n     \n    csg2 = smoothDifferenceSDF(csg1, s1, 0.15 + cos(u_time * 1.5)/8.);\n\n    csg3 = smoothDifferenceSDF(csg0, b2, 0.15);\n     \n    // csg0 = differenceSDF(csg0,csg1); // Subtract cylinders from boxsphere\n     \n    // scene = unionSDF(csg0,p0); // Use Union(min) on the CSG and the ground plane \n\n    scene = unionSDF(csg3, p0);\n \n    return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.,-2.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function aL(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:n,material:rL,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var iL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    /////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n    // Primitives\n    ///////////////////////\n    \n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n        // Box0\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n        //Box1\n        vec3 b1s = vec3(.85,.5,.5); //box size\n        vec3 b1p = vec3(0.,1.2,1.); // box position\n        b1p = p-b1p;\n        b1p.yz *=Rotate(u_time * .2);\n        b1p.xz *=Rotate(u_time * .2);\n        vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n        //Box2\n        vec3 b2s = vec3(.5,.5,.85); //box size\n        vec3 b2p = vec3(0.,1.2,1.); // box position\n        b2p = p-b2p;\n        b2p.yz *=Rotate(u_time * 1.5);\n        b2p.xz *=Rotate(u_time * 1.5);\n        vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n        // p.xz *=Rotate(u_time * .2);\n    \n        // Sphere.\n        vec3 s0p=vec3(0.,2.,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n        vec3 s1p=vec3(0.,2.2,1.);\n        s1p=p-s1p;\n        s1p.yz *=Rotate(u_time * .2);\n        s1p.xz *=Rotate(u_time * .2);\n        vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.75));\n        \n        // Cylinders\n        float c0h = 1.,c0r = .55; // Cylinder height, radius.\n        vec3 c0p = p - vec3 (0,1,2.); // Position\n        vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n        \n        float c1h = 1.,c1r = .55; \n        vec3 c1p = p - vec3 (0,1,0); \n        c1p.xy *= Rotate(PI*.5);  // Rotate\n        vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n        \n        float c2h = 1.,c2r = .55; \n        vec3 c2p = p - vec3 (0,1,0);\n        c2p.xy *= Rotate(PI*.5);  \n        c2p.yz *= Rotate(PI*.5);  \n        vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n    \n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothDifferenceSDF(b0, s1, 0.15); // Intersect box with sphere creating a CSG object.\n\n        scene = unionSDF(csg0, p0);\n    \n        return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function vL(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:n,material:iL,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var cL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    //https://timcoster.com/2020/03/05/raymarching-shader-pt5-colors/\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 BoxColor1 = vec4(0,0,1,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 CylinderColor = vec4(0,0,1,1);\n    const vec4 GroundColor = vec4(1);\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    vec3 rotateY(vec3 p, float a)\n    {\n\n        float c = cos(a);\n        float s = sin(a);\n        p = mat3(\n            vec3(c, 0, s),\n            vec3(0, 1, 0),\n            vec3(-s, 0, c)\n        ) * p ;\n        \n        return p ;\n    }\n\n    vec3 rotateX(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          1.0, 0.0, 0.0,\n          0.0, c, s,\n          0.0, -s, c\n        ) * p;\n    }\n\n    vec3 rotateZ(vec3 p, float angle) {\n        float s = sin(angle);\n        float c = cos(angle);\n      \n        return mat3(\n          c, s, 0.0,\n          -s, c, 0.0,\n          0.0, 0.0, 1.0\n        ) * p;\n    }\n\n    ///////////////////////\n    // Boolean Operators\n    ///////////////////////\n    \n    vec4 intersectSDF(vec4 a, vec4 b) {\n        return a.w > b.w ? a : b;\n    }\n      \n    vec4 unionSDF(vec4 a, vec4 b) {\n        return a.w < b.w? a : b;\n    }\n     \n    vec4 differenceSDF(vec4 a, vec4 b) {\n        return a.w > -b.w? a : vec4(b.rgb,-b.w);\n    }\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    /////////////////////////\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    ///////////////////////\n    // Primitives\n    ///////////////////////\n    \n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n    \n    // Triangular Prism - exact\n    float triPrismSDF(vec3 p,vec2 h) {\n        const float k=sqrt(3.);\n        h.x*=.5*k;\n        p.xy/=h.x;\n        p.x=abs(p.x)-1.;\n        p.y=p.y+1./k;\n        if(p.x+k*p.y>0.)p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.;\n        p.x-=clamp(p.x,-2.,0.);\n        float d1=length(p.xy)*sign(-p.y)*h.x;\n        float d2=abs(p.z)-h.y;\n        return length(max(vec2(d1,d2),0.))+min(max(d1,d2),0.);\n    }\n    \n    // Rounded Cylinder - exact\n    float roundedCylinderSDF(vec3 p,float ra,float rb,float h){\n        vec2 d=vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n        return min(max(d.x,d.y),0.)+length(max(d,0.))-rb;\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Rotate the whole scene\n    \n   \n        // Box0\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n        //Box1\n        vec3 b1s = vec3(.85,.5,.5); //box size\n        vec3 b1p = vec3(0.,2.2 + sin(u_time) * 2.,1.); // box position\n        b1p = p-b1p;\n        b1p.yz *=Rotate(u_time * 1.2);\n        b1p.xz *=Rotate(u_time * 1.2);\n        vec4 b1 = vec4(BoxColor1.rgb,boxSDF(b1p,b1s)); // Box Color, box distance \n\n        //Box2\n        vec3 b2s = vec3(.5,.5,.85); //box size\n        vec3 b2p = vec3(0.,1.2,1.); // box position\n        b2p = p-b2p;\n        b2p.yz *=Rotate(u_time * 1.5);\n        b2p.xz *=Rotate(u_time * 1.5);\n        vec4 b2 = vec4(BoxColor1.rgb,boxSDF(b2p,b2s)); // Box Color, box distance \n\n        // p.xz *=Rotate(u_time * .2);\n    \n        // Sphere.\n        vec3 s0p=vec3(0.,2.,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.5));\n\n        vec3 s1p=vec3(0.,2.2,1.);\n        s1p=p-s1p;\n        s1p.yz *=Rotate(u_time * .2);\n        s1p.xz *=Rotate(u_time * .2);\n        vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.75));\n        \n        // Cylinders\n        float c0h = 1.,c0r = .55; // Cylinder height, radius.\n        vec3 c0p = p - vec3 (0,1,2.); // Position\n        vec4 c0 = vec4(CylinderColor.rgb,cappedCylinderSDF(c0p,c0h,c0r)); \n        \n        float c1h = 1.,c1r = .55; \n        vec3 c1p = p - vec3 (0,1,0); \n        c1p.xy *= Rotate(PI*.5);  // Rotate\n        vec4 c1 = vec4(CylinderColor.rgb,cappedCylinderSDF(c1p,c1h,c1r)); \n        \n        float c2h = 1.,c2r = .55; \n        vec3 c2p = p - vec3 (0,1,0);\n        c2p.xy *= Rotate(PI*.5);  \n        c2p.yz *= Rotate(PI*.5);  \n        vec4 c2 = vec4(CylinderColor.rgb,cappedCylinderSDF(c2p,c2h,c2r)); \n    \n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothDifferenceSDF(b0, s1, 0.15); // difference box with sphere creating a CSG object.\n\n        csg1 = smoothUnionSDF(csg0, b1, 0.15); //intersect\n\n        scene = unionSDF(csg1, p0);\n    \n        return scene;\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n    \n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    \n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        // d /= 6.;\n        // color = vec3(d);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function sL(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:n,material:cL,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var lL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //Box2\n        vec3 b1s = vec3(0.25);\n        vec3 b1p = vec3(0., 2.2, 1.);\n        b1p = p - b1p;\n        b1p.yz *=Rotate(-u_time * 2.2);\n        b1p.xz *=Rotate(-u_time * 2.2);\n        vec4 b1 = vec4(BoxColor.rgb, boxSDF(b1p, b1s));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothDifferenceSDF(b0, s0, 0.15); // difference box with sphere creating a CSG object.\n\n        csg1 = smoothUnionSDF(csg0, b1, 0.15);\n\n        scene = smoothUnionSDF(csg1, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function uL(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:n,material:lL,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var fL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //Box2\n        vec3 b1s = vec3(0.25);\n        vec3 b1p = vec3(0., 2. + sin(u_time * 1.5) + 0.75 * 1.5, 1.);\n        b1p = p - b1p;\n        b1p.yz *=Rotate(-u_time * 2.2);\n        b1p.xz *=Rotate(-u_time * 2.2);\n        vec4 b1 = vec4(BoxColor.rgb, boxSDF(b1p, b1s));\n\n        //Box3\n        vec3 b2s = vec3(0.25);\n        vec3 b2p = vec3(0. + cos(u_time * 1.5) * 2.25, 2. + sin(u_time * 1.5) * 0.5, 1.);\n        b2p = p - b2p;\n        b2p.yz *=Rotate(u_time * 2.2);\n        b2p.xz *=Rotate(u_time * 2.2);\n        vec4 b2 = vec4(BoxColor.rgb, boxSDF(b2p, b2s));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothDifferenceSDF(b0, s0, 0.15); // difference box with sphere creating a CSG object.\n\n        csg1 = smoothUnionSDF(csg0, b1, 0.15);\n\n        csg2 = smoothUnionSDF(csg1, b2, 0.15);\n\n        scene = smoothUnionSDF(csg2, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        #ifdef ANTIALIASING\n        vec3 oh = vec3(0.0);\n        vec4 tmp = vec4(0.0);\n        #endif\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function pL(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:n,material:fL,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var mL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n\n        //Box2\n        vec3 b1s = vec3(0.25);\n        vec3 b1p = vec3(0. + sin(u_time * 1.5) * 2.25, 2. + cos(u_time * 1.5) * 0.5, 1.);\n        b1p = p - b1p;\n        b1p.yz *=Rotate(-u_time * 2.2);\n        b1p.xz *=Rotate(-u_time * 2.2);\n        vec4 b1 = vec4(BoxColor.rgb, boxSDF(b1p, b1s));\n\n        //Box3\n        vec3 b2s = vec3(0.25);\n        vec3 b2p = vec3(0. + cos(u_time * 1.5) * 2.25, 2. + sin(u_time * 1.5) * 0.5, 1.);\n        b2p = p - b2p;\n        b2p.yz *=Rotate(u_time * 2.2);\n        b2p.xz *=Rotate(u_time * 2.2);\n        vec4 b2 = vec4(BoxColor.rgb, boxSDF(b2p, b2s));\n        \n            \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        vec3 s1p=vec3(0. + sin(u_time * 1.5) * 2.25, 2. + cos(u_time * 1.5) * 0.5, 1.);\n        s1p=p-s1p;\n        vec4 s1 = vec4(SphereColor.rgb,sphereSDF(s1p,.25));\n\n        vec3 s2p=vec3(0. + cos(u_time * 1.5) * 2.25, 2. + sin(u_time * 1.5) * 0.5, 1.);\n        s2p=p-s2p;\n        vec4 s2 = vec4(SphereColor.rgb,sphereSDF(s2p,.25));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0), csg4 = vec4(0);\n        \n        csg0 = smoothDifferenceSDF(b0, s0, 0.15); // difference box with sphere creating a CSG object.\n\n        csg1 = smoothUnionSDF(csg0, b1, 0.15);\n\n        csg2 = smoothUnionSDF(csg1, b2, 0.15);\n\n        csg3 = smoothDifferenceSDF(csg2, s1, 0.15);\n\n        csg4 = smoothDifferenceSDF(csg3, s2, 0.15);\n\n        scene = smoothUnionSDF(csg4, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    vec4 fC(vec2 vUv){\n        vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-6.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        float numLabel = label(vUv);\n        color += numLabel;\n\n        return vec4(color, 1.);\n    }\n\n    void main()\n    {\n        //https://www.shadertoy.com/view/wtjfRV\n        //anti-alias\n        gl_FragColor = vec4(0.);\n        float A = 4.;  // Change A to define the level of anti-aliasing (1 to 16) ... higher numbers are REALLY slow!  \n        float s = 1./A, x, y;\n        for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) gl_FragColor += min ( fC(vec2(vUv.x,vUv.y)), 1.0);\n        gl_FragColor /= A*A;\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function dL(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:n,material:mL,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var hL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(.75,.75,.75); //box size\n        vec3 bfp = vec3(0.,2.2,1.); // box position\n        bfp = p - bfp;\n        bfp.yz *=Rotate(u_time * 1.2);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.025));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        // csg0 = smoothDifferenceSDF(bf, s0, 0.15); \n\n        scene = smoothUnionSDF(bf, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        #ifdef ANTIALIASING\n        vec3 oh = vec3(0.0);\n        vec4 tmp = vec4(0.0);\n        #endif\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,4.5,-5.0); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.1); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function xL(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:n,material:hL,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var gL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(1.5,1.5,1.5); //box size\n        vec3 bfp = vec3(0.,2.2,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time + 0.5) * 1.25);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.05));\n\n        //box frame\n        vec3 bfs2 = vec3(.75,.75,.75); //box size\n        vec3 bfp2 = vec3(0.,2.2,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time + 0.25) * 1.25);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.05));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time) * 1.25);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.05));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(bf, bf2, 0.15); \n\n        scene = smoothUnionSDF(csg0, bf3, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,4.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n       \n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,5.,-8.0 + sin(u_time) + .45 * 15.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        rd.zy *= Rotate(PI*-.3); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function yL(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:n,material:gL,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var bL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numZero(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(1.5,1.5,1.5); //box size\n        vec3 bfp = vec3(0.,2.2,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.075));\n\n        //box frame\n        vec3 bfs2 = vec3(.75,.75,.75); //box size\n        vec3 bfp2 = vec3(0.,2.2,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time * 1.125) * 1.5);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.075));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time * 1.) * 1.5);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.075));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(bf, bf2, 0.15); \n\n        csg1 = smoothUnionSDF(csg0, bf3, 0.15);\n\n        scene = smoothUnionSDF(csg1, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,6.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n       \n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-4. + sin(u_time * 0.25 + 0.5)  * 5.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // rd.zy *= Rotate(PI*-.2); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function UL(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:n,material:bL,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var _L=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //https://www.shadertoy.com/view/llcXWM\n    vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n        return a + b*cos( 6.28318*(c*t+d) );\n    }\n\n    vec3 spectrum(float n) {\n        return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(0.75 * cos(u_time)/ 2. + 0.75); //box size\n        vec3 bfp = vec3(0.,2.2 + abs(cos(u_time * 0.25)) * 2. ,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.095));\n\n        //box frame\n        vec3 bfs2 = vec3(0.75 * sin(u_time)/2. + 0.75); //box size\n        vec3 bfp2 = vec3(0.,2.2 + abs(sin(u_time * 0.25)) * 2.,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.095));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time * 1.) * 1.5);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.075));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(bf, bf2, 0.15); \n\n        scene = smoothUnionSDF(csg0, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8.,-2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 2.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n       \n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-5.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // rd.zy *= Rotate(PI*-.2); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function wL(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:n,material:_L,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var SL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //hex prism\n    float sdHexPrism( vec3 p, vec2 h )\n    {\n        const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        p = abs(p);\n        p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n        vec2 d = vec2(\n            length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n            p.z-h.y );\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(0.75 * cos(u_time)/ 2. + 0.75); //box size\n        vec3 bfp = vec3(0.,2.2 + abs(cos(u_time * 0.25)) * 2. ,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.095));\n\n        //hex prism\n        vec2 hexPrismSize = vec2(0.5);\n        vec3 hexPrismPosition = vec3(0., 2., 0.);\n        hexPrismPosition = p - hexPrismPosition;\n        hexPrismPosition.yz *=Rotate(u_time * 1.2);\n        hexPrismPosition.xz *=Rotate(u_time * 1.2);\n        vec4 hexPrism = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition, hexPrismSize));\n\n        //box frame\n        vec3 bfs2 = vec3(0.75 * sin(u_time)/2. + 0.75); //box size\n        vec3 bfp2 = vec3(0.,2.2 + abs(sin(u_time * 0.25)) * 2.,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.095));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time * 1.) * 1.5);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.075));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        // csg0 = smoothUnionSDF(hexPrism, bf2, 0.15); \n\n        scene = smoothUnionSDF(hexPrism, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8., -2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 1.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n       \n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-5.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // ro.zx *= Rotate(sin(u_time)); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function ML(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:n,material:SL,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var kL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //hex prism\n    float sdHexPrism( vec3 p, vec2 h )\n    {\n        const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        p = abs(p);\n        p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n        vec2 d = vec2(\n            length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n            p.z-h.y );\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.2,1.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(0.75 * cos(u_time)/ 2. + 0.75); //box size\n        vec3 bfp = vec3(0.,2.2 + abs(cos(u_time * 0.25)) * 2. ,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.095));\n\n        //hex prism\n        vec2 hexPrismSize = vec2(0.5, 0.9 + (sin(u_time)/2.) + 0.75);\n        vec3 hexPrismPosition = vec3(0., 2., 0.);\n        hexPrismPosition = p - hexPrismPosition;\n        hexPrismPosition.yz *=Rotate(cos(u_time * 1.2));\n        hexPrismPosition.xz *=Rotate(sin(u_time * 1.2));\n        vec4 hexPrism = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition, hexPrismSize));\n\n        //hex prism2\n        vec2 hexPrismSize2 = vec2(0.5, 0.9 + (sin(u_time)/2. )+ 0.75);\n        vec3 hexPrismPosition2 = vec3(0., 2., 0.);\n        hexPrismPosition2 = p - hexPrismPosition2;\n        hexPrismPosition2.yz *=Rotate(sin(u_time * 1.2));\n        hexPrismPosition2.xz *=Rotate(cos(u_time * 1.2));\n        vec4 hexPrism2 = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition2, hexPrismSize2));\n\n        //hex prism3\n        vec2 hexPrismSize3 = vec2(0.5, 0.9 + (sin(u_time)/2. )+ 0.75);\n        vec3 hexPrismPosition3 = vec3(0., 2., 0.);\n        hexPrismPosition3 = p - hexPrismPosition3;\n        hexPrismPosition3.yz *=Rotate(sin(u_time * 1.2));\n        hexPrismPosition3.xy *=Rotate(cos(u_time * 1.2));\n        vec4 hexPrism3 = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition3, hexPrismSize3));\n\n        //box frame\n        vec3 bfs2 = vec3(0.75 * sin(u_time)/2. + 0.75); //box size\n        vec3 bfp2 = vec3(0.,2.2 + abs(sin(u_time * 0.25)) * 2.,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.095));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time * 1.) * 1.5);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.075));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(hexPrism, hexPrism2, 0.15); \n\n        csg1 = smoothUnionSDF(csg0, hexPrism3, 0.15);\n\n        scene = smoothUnionSDF(csg1, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8., -2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 1.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n       \n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-8.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // ro.zx *= Rotate(sin(u_time)); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function zL(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:n,material:kL,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var CL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //hex prism\n    float sdHexPrism( vec3 p, vec2 h )\n    {\n        const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        p = abs(p);\n        p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n        vec2 d = vec2(\n            length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n            p.z-h.y );\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.75,.75,.75); //box size\n        vec3 b0p = vec3(0.,2.2,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.,0.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //box frame\n        vec3 bfs = vec3(0.75 * cos(u_time)/ 2. + 0.75); //box size\n        vec3 bfp = vec3(0.,2.2 + abs(cos(u_time * 0.25)) * 2. ,1.); // box position\n        bfp = p - bfp;\n        bfp.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf = vec4(BoxColor.rgb, sdBoxFrame(bfp, bfs, 0.095));\n\n        //hex prism\n        vec2 hexPrismSize = vec2(0.5, 0.9 + (sin(u_time)/4.) + 0.75);\n        vec3 hexPrismPosition = vec3(0., 2., 0.);\n        hexPrismPosition = p - hexPrismPosition;\n        hexPrismPosition.yz *=Rotate(cos(u_time * 1.2));\n        hexPrismPosition.xz *=Rotate(sin(u_time * 1.2));\n        vec4 hexPrism = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition, hexPrismSize));\n\n        //hex prism2\n        vec2 hexPrismSize2 = vec2(0.5, 0.9 + (sin(u_time)/4. )+ 0.75);\n        vec3 hexPrismPosition2 = vec3(0., 2., 0.);\n        hexPrismPosition2 = p - hexPrismPosition2;\n        hexPrismPosition2.yz *=Rotate(sin(u_time * 1.2));\n        hexPrismPosition2.xz *=Rotate(cos(u_time * 1.2));\n        vec4 hexPrism2 = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition2, hexPrismSize2));\n\n        //hex prism3\n        vec2 hexPrismSize3 = vec2(0.5, 0.9 + (sin(u_time)/4. )+ 0.75);\n        vec3 hexPrismPosition3 = vec3(0., 2., 0.);\n        hexPrismPosition3 = p - hexPrismPosition3;\n        hexPrismPosition3.yz *=Rotate(sin(u_time * 1.2));\n        hexPrismPosition3.xy *=Rotate(cos(u_time * 1.2));\n        vec4 hexPrism3 = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition3, hexPrismSize3));\n\n        //box frame\n        vec3 bfs2 = vec3(0.75 * sin(u_time)/2. + 0.75); //box size\n        vec3 bfp2 = vec3(0.,2.2 + abs(sin(u_time * 0.25)) * 2.,1.); // box position\n        bfp2 = p - bfp2;\n        bfp2.xz *=Rotate(sin(u_time * 1.15) * 1.5);\n        vec4 bf2 = vec4(BoxColor.rgb, sdBoxFrame(bfp2, bfs2, 0.095));\n\n        //box frame\n        vec3 bfs3 = vec3(.325,.325,.325); //box size\n        vec3 bfp3 = vec3(0.,2.2,1.); // box position\n        bfp3 = p - bfp3;\n        bfp3.xz *=Rotate(sin(u_time * 1.) * 1.5);\n        vec4 bf3 = vec4(BoxColor.rgb, sdBoxFrame(bfp3, bfs3, 0.075));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(hexPrism, hexPrism2, 0.15); \n\n        csg1 = smoothUnionSDF(csg0, hexPrism3, 0.15);\n\n        csg2 = smoothDifferenceSDF(csg1, s0, 0.15);\n\n        scene = smoothUnionSDF(csg2, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8., -2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 1.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-8.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // ro.zx *= Rotate(sin(u_time)); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function TL(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:n,material:CL,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var RL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //hex prism\n    float sdHexPrism( vec3 p, vec2 h )\n    {\n        const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        p = abs(p);\n        p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n        vec2 d = vec2(\n            length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n            p.z-h.y );\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.25); //box size\n        vec3 b0p = vec3(0.,2.0,1.); // box position\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        vec4 b0 = vec4(BoxColor.rgb,boxSDF(b0p,b0s)); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.,0.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //hex prism\n        vec2 hexPrismSize = vec2(0.5, 0.9 + (sin(u_time)/4.) + 0.75);\n        vec3 hexPrismPosition = vec3(0., 2., 0.);\n        hexPrismPosition = p - hexPrismPosition;\n        hexPrismPosition.yz *=Rotate(cos(u_time * 1.2));\n        hexPrismPosition.xz *=Rotate(sin(u_time * 1.2));\n        vec4 hexPrism = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition, hexPrismSize));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(hexPrism, hexPrism, 0.15); \n\n        csg1 = smoothDifferenceSDF(csg0, s0, 0.15);\n\n        csg2 = smoothUnionSDF(csg1, b0, 0.15);\n\n        scene = smoothUnionSDF(csg2, csg2, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8., -2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 1.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.2,-8.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // ro.zx *= Rotate(sin(u_time)); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function DL(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:n,material:RL,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var PL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    #define ANTIALIASING\n\n    const vec4 BoxColor = vec4(1,0,0,1);\n    const vec4 SphereColor = vec4(0,1,0,1);\n    const vec4 GroundColor = vec4(1);\n\n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    float opOnion( in float sdf, in float thickness )\n    {\n        return abs(sdf)-thickness;\n    }\n    \n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n\n    mat2 Rotate(float a) {\n        float s=sin(a); float c=cos(a);\n        return mat2(c,-s,s,c);\n    }\n\n    // Sphere - exact\n    float sphereSDF( vec3 p, float s ) {\n        return length(p)-s;\n    }\n    \n    // Box - exact\n    float boxSDF( vec3 p, vec3 b ) {\n        float n = cnoise(p + (u_time)) * 0.1;\n        p.x += n;\n        p.y += n * 2.;\n        p.z += n * 5.;\n        vec3 q = abs(p) - b;\n        \n        \n        return length(max(q ,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    //Box frame -exact\n    float sdBoxFrame( vec3 p, vec3 b, float e )\n    {\n        p = abs(p  )-b;\n        vec3 q = abs(p+e)-e;\n        return min(min(\n            length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n            length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n            length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n    }\n    \n    float cappedCylinderSDF( vec3 p, float h, float r ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n    \n    // Plane - exact\n    float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    //hex prism\n    float sdHexPrism( vec3 p, vec2 h )\n    {\n        const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n        p = abs(p);\n        p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n        vec2 d = vec2(\n            length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n            p.z-h.y );\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    vec4 GetDist(vec3 p)\n    {\n        // Box\n        vec3 b0s = vec3(.25); //box size\n        vec3 b0p = vec3(0.,2.0,1.); // box position\n        // float n = cnoise(b0s) + sin(u_time);\n        // b0s += n;\n        b0p = p-b0p;\n        b0p.yz *=Rotate(u_time * 1.2);\n        b0p.xz *=Rotate(u_time * 1.2);\n        float box = boxSDF(b0p, b0s);\n        vec4 b0 = vec4(BoxColor.rgb, box); // Box Color, box distance field\n    \n        // Sphere\n        vec3 s0p=vec3(0.,2.,0.);\n        s0p=p-s0p;\n        vec4 s0 = vec4(SphereColor.rgb,sphereSDF(s0p,.95));\n\n        //hex prism\n        vec2 hexPrismSize = vec2(0.5, 0.9 + (sin(u_time)/4.) + 0.75);\n        vec3 hexPrismPosition = vec3(0., 2., 0.);\n        hexPrismPosition = p - hexPrismPosition;\n        hexPrismPosition.yz *=Rotate(cos(u_time * 1.2));\n        hexPrismPosition.xz *=Rotate(sin(u_time * 1.2));\n        vec4 hexPrism = vec4(BoxColor.rgb, sdHexPrism(hexPrismPosition, hexPrismSize));\n\n        // Plane\n        vec4 p0 = vec4(GroundColor.rgb,planeSDF(p,vec4(0,1,0,0)));\n    \n        vec4 scene = vec4(0), csg0 = vec4(0), csg1 = vec4(0), csg2 = vec4(0), csg3 = vec4(0);\n        \n        csg0 = smoothUnionSDF(b0, p0, 0.15); \n\n        csg1 = smoothDifferenceSDF(csg0, s0, 0.15);\n\n        csg2 = smoothUnionSDF(csg1, b0, 0.15);\n\n        scene = smoothUnionSDF(csg0, p0, 0.15);\n    \n        return scene;\n    }\n\n    vec3 GetNormal(vec3 p)\n    {\n        float d=GetDist(p).w;// Distance\n        vec2 e=vec2(.01,0);// Epsilon\n        \n        vec3 n=d-vec3(\n            GetDist(p-e.xyy).w,// e.xyy is the same as vec3(.01,0,0). The x of e is .01. this is called a swizzle\n            GetDist(p-e.yxy).w,\n            GetDist(p-e.yyx).w);\n            \n        return normalize(n);\n    }\n\n    float RayMarch(vec3 ro,vec3 rd, inout vec3 dColor)\n    {\n        float dO=0.;//Distane Origin\n        for(int i=0;i<MAX_STEPS;i++)\n        {\n            if(dO>MAX_DIST)\n                break;\n    \n            vec3 p=ro+rd*dO;\n            vec4 ds=GetDist(p);// ds is Distance Scene\n    \n            if(ds.w<SURF_DIST)\n            {\n                dColor = ds.rgb;\n                break;\n            }\n            dO+=ds.w;\n            \n        }\n        return dO;\n    }\n\n    \n\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(2.,8., -2.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n * 1.,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,difColor);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3(0,2.,-2.); // Ray Origin/Camera position\n        vec3 rd = normalize(vec3(uv2.x,uv2.y,1)); // Ray Direction\n\n        // ro.zx *= Rotate(sin(u_time)); // Rotate camera down on the x-axis\n        \n        float d=RayMarch(ro,rd,difColor);// Distance\n\n        vec3 p=ro+rd*d;\n        vec3 dif=GetLight(p,difColor);// Diffuse lighting\n        color  = vec3(dif);\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function FL(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:n,material:PL,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var jL=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n    #define S smoothstep\n    #define T u_time\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float GetDist(vec3 p){\n        float d = sdBox(p, vec3(1.));\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.001, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy/u_resolution.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3);\n        ro.yz *= Rot(-T*PI + 1. * 0.125);\n        ro.xz *= Rot(-T*TWO_PI * 0.125);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        vec3 col = vec3(0.);\n\n        float d = RayMarch(ro, rd);\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d;\n            vec3 n = GetNormal(p);\n            vec3 r = reflect(rd, n);\n\n            float dif = dot(n , normalize(vec3(1., 2., 3.))) * .5 + .5;\n            col = vec3(dif);\n            color += col;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function IL(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),addEventListener("mousemove",(function(n){n.clientX,window.innerWidth,n.clientY,window.innerHeight})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:n,material:jL,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function EL(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 100\n    #define MAX_DIST 100.\n    #define SURF_DIST .01\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float GetDist(vec3 p){\n        float d = sdBox(p, vec3(1.));\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.001, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3);\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, rd).rgb;\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 reflectDir = reflect(rd, n);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n\n            vec3 reflTex = texture(u_cubemap, rdOut).rgb;\n\n            col = vec3(reflTex);\n            color += col;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function OL(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float GetDist(vec3 p){\n\n        p.xz *= Rot(u_time * .1);\n\n        float d = sdBox(p, vec3(1.));\n\n        float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        vec3 n = vec3(-0.5, -c, s);\n        p = abs(p);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, rd).rgb;\n        // vec3 col = vec3(0.);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            //col = n * .5 + .5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function AL(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numOne(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        vec3 p1 = p;\n        vec3 p2 = p;\n        // p1.x -= 0.65;\n        p2.x += sin(u_time) * 1.5;\n\n        p2.xy *= Rot(u_time * .4);\n        p2.yz *= Rot(u_time * .4);\n        p2.xz *= Rot(u_time * .4);\n\n        p1.xy *= Rot(u_time * .4);\n        p1.yz *= Rot(u_time * .4);\n        p1.xz *= Rot(u_time * .4);\n\n        float d1 = sdTorus(p2, vec2(0.5, 0.2));\n\n        float d2 = sdBox(p1, vec3(0.5));\n\n        float d = opSmoothUnion(d1, d2, 0.15);\n\n        // float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        // vec3 n = vec3(-0.5, -c, s);\n        // p = abs(p);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, rd).rgb;\n        // vec3 col = vec3(.6);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            //col = n * .5 + .5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function LL(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        vec3 p1 = p;\n        vec3 p2 = p;\n        // p1.x -= 0.65;\n        // p2.x += sin(u_time) * 1.5;\n\n        p2.xy *= Rot(u_time * .4);\n        p2.yz *= Rot(u_time * .4);\n        p2.xz *= Rot(u_time * .4);\n\n        p1.xy *= Rot(u_time * .4);\n        p1.yz *= Rot(u_time * .4);\n        p1.xz *= Rot(u_time * .4);\n\n        float d1 = sdTorus(p2, vec2(0.5, 0.2));\n\n        float d2 = sdBox(p1, vec3(0.5));\n\n        float d = opSmoothSubtraction(d1, d2, 0.15);\n\n        \n\n        for(int i = 0; i < 4; i++){\n            float c = cos(PI/5.), s = sqrt(0.75-c*c);\n            vec3 n = vec3(-0.5, -c, s);\n            p1.xy = abs(p.xy);\n            p1 -= 2. * min(0., dot(p1, n)) * n;\n        }\n        // p = abs(p);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        // vec3 col = vec3(.6);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            //col = n * .5 + .5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function GL(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        vec3 p1 = p;\n        vec3 p2 = p;\n        // p1.x -= 0.65;\n        // p2.x += sin(u_time) * 1.5;\n\n        p2.xy *= Rot(u_time * .4);\n        p2.yz *= Rot(u_time * .4);\n        p2.xz *= Rot(u_time * .4);\n\n        p1.xy *= Rot(u_time * .4);\n        p1.yz *= Rot(u_time * .4);\n        p1.xz *= Rot(u_time * .4);\n\n        float d1 = sdTorus(p2, vec2(0.5, 0.2));\n\n        float d2 = sdBox(p1, vec3(0.5));\n\n        // float d = opSmoothUnion(d1, d2, 0.15);\n\n        float d = d1;\n        \n\n        for(int i = 0; i < 4; i++){\n            float c = cos(PI/5.), s = sqrt(0.75-c*c);\n            vec3 n = vec3(-0.5, -c, s);\n            p1.xy = abs(p.xy);\n            p1 -= 2. * min(0., dot(p1, n)) * n;\n        }\n        // p = abs(p);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        // vec3 col = vec3(.6);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            //col = n * .5 + .5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function NL(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        p.xz *= Rot(u_time * .1);\n\n        float d = sdBox(p, vec3(1.));\n\n        float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        vec3 n = vec3(-0.5, -c, s);\n        p = abs(p);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.5);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            // vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            // col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function BL(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        p.xz *= Rot(u_time * .1);\n\n        float d = sdBox(p, vec3(1.));\n\n        float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        vec3 n = vec3(-0.5, -c, s);\n        p = abs(p);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        p.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p, n)) * n;\n\n        d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(4.,5.,0.);// Light Position\n    \n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        \n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.5);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            // vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            // col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * .5 + .5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        color  = vec3(dif * col);\n\n        // color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function qL(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        p.xz *= Rot(u_time * .1);\n\n        float d = sdBox(p, vec3(1.));\n\n        float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        vec3 n = vec3(-0.5, -c, s);\n        // p = abs(p);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // d = p.z - 1.;\n\n        return d;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,4.,0.);// Light Position\n        vec3 lightPos2=vec3(2.,4.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 l2=normalize(lightPos2-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        float dif2=dot(n,l2);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        dif2=clamp(dif2,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.5);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            vec3 refOutside = texture(u_cubemap, r ).rgb;\n            // vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            // col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.25 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif * col);\n\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function VL(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    // uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        \n        p.xy *= Rot(u_time * .1);\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p, vec2(0.5, 0.15));\n\n        float c = cos(PI/5.), s = sqrt(0.75-c*c);\n        vec3 n = vec3(-0.5, -c, s);\n        // p = abs(p);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // p.xy = abs(p.xy);\n        // p -= 2. * min(0., dot(p, n)) * n;\n\n        // d = p.z - 1.;\n\n        return d2;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,4.,0.);// Light Position\n        vec3 lightPos2=vec3(2.,4.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 l2=normalize(lightPos2-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        float dif2=dot(n,l2);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        dif2=clamp(dif2,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.yx *= Rot(-m.x*PI + 1.);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif * col);\n        // float m = 0.;\n        float t = u_time;\n        for (float i = 0.; i <=1.; i+= 1./4.){\n            float z = fract(i + t);\n            float size = mix(10., .5, z);\n            ro.z *= size;\n            color += col;\n        }\n        // color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function WL(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    // uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p2 = p;\n        vec3 p3 = p;\n        p.xy *= Rot(u_time * .3);\n        p2.xy *= Rot(u_time * .5);\n        p3.xy *= Rot(u_time * .7);\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p, vec2(0.75, 0.15));\n\n        float d3 = sdTorus(p, vec2(1.25, 0.15));\n\n        float total = sdTorus(vec3(p2), vec2(0.25, 0.15));\n        total = opSmoothUnion(total, d2, 0.15);\n        total = opSmoothUnion(total, d3, 0.15);\n        return total;\n        \n\n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,4.,0.);// Light Position\n        vec3 lightPos2=vec3(2.,4.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 l2=normalize(lightPos2-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        float dif2=dot(n,l2);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        dif2=clamp(dif2,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.yx *= Rot(-m.x*PI + 1.);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        color  = vec3(dif * col);\n        // float m = 0.;\n        // float t = u_time;\n        // for (float i = 0.; i <=1.; i+= 1./4.){\n        //     float z = fract(i + t);\n        //     float size = mix(10., .5, z);\n        //     ro.z *= size;\n        //     color += col;\n        // }\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function HL(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=((new vf).load(o),new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .00001\n    #define S smoothstep\n    #define T u_time\n\n    // uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p2 = p;\n        vec3 p3 = p;\n        p.xy *= Rot(u_time * 1.3);\n        p.yz *= Rot(u_time * 1.7);\n        p2.xy *= Rot(u_time * 1.5);\n        p2.xz *= Rot(u_time * 1.5);\n        p3.xy *= Rot(u_time * 1.7);\n        p3.yz *= Rot(u_time * 1.7);\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p2, vec2(0.75, 0.15));\n\n        float d3 = sdTorus(p3, vec2(1.25, 0.15));\n\n        float total = sdTorus(vec3(p), vec2(0.25, 0.15));\n\n        total = opSmoothUnion(total, d2, 0.15);\n        total = opSmoothUnion(total, d3, 0.15);\n        return total;\n        \n\n        \n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(-2.,4.,0.);// Light Position\n        vec3 lightPos2=vec3(2.,4.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 l2=normalize(lightPos2-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n        float dif2=dot(n,l2);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        dif2=clamp(dif2,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        // ro.yx *= Rot(-m.x*PI + 1.);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        color  = vec3(dif * col);\n        // float m = 0.;\n        // float t = u_time;\n        // for (float i = 0.; i <=1.; i+= 1./4.){\n        //     float z = fract(i + t);\n        //     float size = mix(10., .5, z);\n        //     ro.z *= size;\n        //     color += col;\n        // }\n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}})),a=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=a.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[a.current]),Nd((function(t){var o=t.clock;a.current.material.uniforms.u_time.value=o.elapsedTime,a.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:a,material:r,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function XL(){var n,e,t="https://threejs.org/examples/textures/cube/Bridge2/",o=[t+"posx.jpg",t+"negx.jpg",t+"posy.jpg",t+"negy.jpg",t+"posz.jpg",t+"negz.jpg"],r=((new vf).load(o),new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    // uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p2 = p;\n        vec3 p3 = p;\n        // p.xy *= Rot(u_time * 1.3);\n        // p.yz *= Rot(u_time * 1.7);\n        p2.xy *= Rot(u_time * 1.5);\n        p2.xz *= Rot(u_time * 1.5);\n        p3.xy *= Rot(u_time * 1.7);\n        p3.yz *= Rot(u_time * 1.7);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p2, vec2(0.75, 0.15));\n\n        float d3 = sdTorus(p3, vec2(1.25, 0.15));\n\n        float total = sdTorus(vec3(p), vec2(0.25, 0.15));\n\n        total = opSmoothUnion(total, d2, 0.15);\n        total = opSmoothUnion(total, d3, 0.15);\n        total = opSmoothUnion(total, plane, 0.15);\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,5.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        // ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // rd.y += sin(u_time)/3. - 0.5;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n            reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n            reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        color  = vec3(dif * col);\n       \n        // color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}})),a=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=a.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[a.current]),Nd((function(t){var o=t.clock;a.current.material.uniforms.u_time.value=o.elapsedTime,a.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:a,material:r,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function YL(){var n,e,t=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numTwo(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    // uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        p.xz *= Rot(PI * 0.5);\n        p1.xy *= Rot(u_time * 1.5);\n        p1.yz *= Rot(u_time * 1.5);\n        p2.xy *= Rot(u_time * 1.5);\n        p2.xz *= Rot(u_time * 1.5);\n        p3.xy *= Rot(u_time * 1.7);\n        p3.yz *= Rot(u_time * 1.7);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p2, vec2(0.75, 0.15));\n\n        float d3 = sdTorus(p3, vec2(1.25, 0.15));\n\n        float total = sdTorus(vec3(p1), vec2(0.25, 0.15));\n\n        total = opSmoothUnion(total, d2, 0.15);\n        total = opSmoothUnion(total, d3, 0.15);\n        total = opSmoothUnion(total, plane, 0.15);\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        // ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // rd.y += sin(u_time)/3. - 0.5;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.r = texture(u_cubemap, rdOut).r;\n            reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.g = texture(u_cubemap, rdOut).g;\n            reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            // reflTex.b = texture(u_cubemap, rdOut).b;\n            reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        color  = vec3(dif + col);\n       \n        // color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}}),o=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=o.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[o.current]),Nd((function(t){var r=t.clock;o.current.material.uniforms.u_time.value=r.elapsedTime,o.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:o,material:t,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function ZL(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        p.xz *= Rot(PI * 0.5);\n        p1.xy *= Rot(u_time * 1.5);\n        p1.yz *= Rot(u_time * 1.5);\n        p2.xy *= Rot(u_time * 1.5);\n        p2.xz *= Rot(u_time * 1.5);\n        p3.xy *= Rot(u_time * 1.7);\n        p3.yz *= Rot(u_time * 1.7);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float d = sdBox(p, vec3(1.));\n\n        float d2 = sdTorus(p2, vec2(0.75, 0.15));\n\n        float d3 = sdTorus(p3, vec2(1.25, 0.15));\n\n        float total = sdTorus(vec3(p1), vec2(0.25, 0.15));\n\n        total = opSmoothUnion(total, d2, 0.15);\n        total = opSmoothUnion(total, d3, 0.15);\n        // total = opSmoothUnion(total, plane, 0.15);\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // rd.y += sin(u_time)/3. - 0.5;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function QL(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n\n        p2.zy *= Rot(PI * 0.5);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float total = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 0.75);\n\n        total = opSmoothSubtraction(total, d2, 0.15);\n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // rd.y += sin(u_time)/3. - 0.5;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function JL(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n\n        p2.zy *= Rot(PI * 0.5 + u_time);\n        p2.xy *= Rot(PI * 0.5 + u_time);\n        p2.zx *= Rot(PI * 0.5 + u_time);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 0.75);\n\n        float total = opSmoothSubtraction(d1, d2, 0.15);\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // rd.y += sin(u_time)/3. - 0.5;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function KL(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n\n        p2.zy *= Rot(PI * 0.5 + u_time);\n        p2.xy *= Rot(PI * 0.5 + u_time);\n        p2.zx *= Rot(PI * 0.5 + u_time);\n\n        float plane = planeSDF(p,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5 + sin(u_time)/4. + 0.2));\n\n        float d2 = sdSphere(p, 0.75 + sin(u_time)/4. + 0.2);\n\n        float total = opSmoothSubtraction(d1, d2, 0.15);\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        // ro.yz *= Rot(PI * 0.5);\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap, rd).rgb;\n        // vec3 col = vec3(.0);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function $L(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        // p.y += 1.;\n\n        \n        p2.zy *= Rot(PI * 0.5 + u_time);\n        p2.xy *= Rot(PI * 0.5 + u_time);\n        p2.zx *= Rot(PI * 0.5 + u_time);\n\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 0.75 + sin(u_time)/4. + 0.2);\n\n        float total = d1;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        // ro.yz *= Rot(PI * 0.5);\n        ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.8);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        // col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function nG(){var n="https://threejs.org/examples/textures/cube/Bridge2/",e=[n+"posx.jpg",n+"negx.jpg",n+"posy.jpg",n+"negy.jpg",n+"posz.jpg",n+"negz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        // p.y += 1.;\n\n        \n        // p.zy *= Rot(PI * 0.5 + u_time);\n        p.xy *= Rot(PI * 0.5 + u_time);\n        p.zx *= Rot(PI * 0.5 + u_time);\n\n        p.xz *= Rot(PI * 0.5);\n\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 1.75);\n\n        float total = d2;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yx *= Rot(PI * 0.5);\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        rd.y *= -1.;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.8);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function eG(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        // p.y += 1.;\n\n        \n        // p.zy *= Rot(PI * 0.5 + u_time);\n        p.xy *= Rot(PI * 0.5 + u_time);\n        p.zx *= Rot(PI * 0.5 + u_time);\n\n        p.xz *= Rot(PI * 0.5);\n\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 1.75);\n\n        float total = d2;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        vec3 ro = vec3 (0., 3., -3) * .9;\n        ro.yx *= Rot(PI * 0.5);\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n        \n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        rd.y *= -1.;\n\n        // vec3 col = vec3(0.);\n        // vec3 col = texture(u_cubemap, rd).rgb;\n        vec3 col = vec3(.3);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function tG(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numSeven(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        \n\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 1.75);\n\n        float total = d2;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        \n\n        vec3 ro = vec3 (0., 3., -4) * .9;\n        ro.yx *= Rot(PI * 0.5);\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        rd.y *= -1.;\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap,-rd).rgb;\n        // vec3 col = vec3(.3);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            \n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function oG(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numEight(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        \n        p += cnoise(p) * (0.2 * sin(u_time));\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p, 1.75);\n\n        float total = d2;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        \n\n        vec3 ro = vec3 (0., 3., -4) * .9;\n        ro.yx *= Rot(PI * 0.5);\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        rd.y *= -1.;\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap,-rd).rgb;\n        // vec3 col = vec3(.3);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            // p += cnoise(p) * 0.1;\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            // reflTex.r += cnoise(reflTex);\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function rG(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new vf).load(e);console.log(t);var o,r,a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numThree(vec2(p.x -0.03, p.y));\n        float right = numNine(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n    \n    #define MAX_STEPS 1000\n    #define MAX_DIST 1000.\n    #define SURF_DIST .000001\n    #define S smoothstep\n    #define T u_time\n\n    uniform samplerCube u_cubemap;\n\n    /////////////////////////////\n    // Smooth blending operators\n    /////////////////////////////\n    \n    vec4 smoothIntersectSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 - 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w,b.w,h) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothUnionSDF(vec4 a, vec4 b, float k ) \n    {\n        float h = clamp(0.5 + 0.5*(a.w-b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, b.w, h) - k*h*(1.-h); \n        \n        return vec4(c,d);\n    }\n    \n    vec4 smoothDifferenceSDF(vec4 a, vec4 b, float k) \n    {\n        float h = clamp(0.5 - 0.5*(a.w+b.w)/k, 0., 1.);\n        vec3 c = mix(a.rgb,b.rgb,h);\n        float d = mix(a.w, -b.w, h ) + k*h*(1.-h);\n        \n        return vec4(c,d);\n    }\n\n    mat2 Rot(float a){\n        float s = sin(a), c=cos(a);\n        return mat2(c, -s, s, c);\n    }\n\n    float sdBox(vec3 p, vec3 s){\n        p = abs(p) - s;\n        float noise = cnoise(p) * 0.5 * sin(u_time);\n        p.x += noise;\n        p.y += noise;\n        return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n    }\n\n    float sdTorus(vec3 p, vec2 t){\n        vec2 q = vec2(length(p.xz) - t.x, p.y);\n        return length(q) - t.y;\n    }\n\n     // Plane - exact\n     float planeSDF(vec3 p,vec4 n) {\n        // n must be normalized\n        return dot(p,n.xyz)+n.w;\n    }\n\n    float sdSphere( vec3 p, float s )\n    {\n    return length(p)-s;\n    }\n\n    float opSmoothUnion( float d1, float d2, float k ) {\n        float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n        return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n    float opSmoothSubtraction( float d1, float d2, float k ) {\n        float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n        return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n    float GetDist(vec3 p){\n\n        vec3 p1 = p;\n        vec3 p2 = p;\n        vec3 p3 = p;\n        \n        p1 += (cnoise(p1 + sin(u_time)) * 0.1) * (sin(u_time) / 10. + 1.);\n        float plane = planeSDF(p ,vec4(0,1,0,0));\n\n        float d1 = sdBox(p2, vec3(0.5));\n\n        float d2 = sdSphere(p1, 1.75);\n\n        float total = d2;\n\n        \n\n        return total;\n    }\n\n    float RayMarch(vec3 ro, vec3 rd, float side){\n        float dO = 0.;\n        for(int i = 0; i < MAX_STEPS; i++){\n            vec3 p = ro + rd * dO;\n            float dS = GetDist(p) * side;\n            dO += dS;\n            if(dO > MAX_DIST || abs(dS)<SURF_DIST) break;\n        }\n        return dO;\n    }\n\n    vec3 GetNormal(vec3 p){\n        vec2 e = vec2(.01, 0);\n        vec3 n = GetDist(p) - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n        return normalize(n);\n    }\n\n    vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z){\n        vec3 \n            f = normalize(l - p),\n            r = normalize(cross(vec3(0., 1., 0.), f)),\n            u = cross(f, r),\n            c = f * z,\n            i = c + uv.x*r + uv.y*u;\n        \n        return normalize(i);\n    }\n\n    float colorIntensity = 1.;\n    vec3 difColor = vec3(1.0, 1.0, 1.0); // Diffuse Color\n    vec3 GetLight(vec3 p, vec3 c)\n    {\n        // Diffuse Color\n        vec3 color = c.rgb * colorIntensity;\n    \n        // Directional light\n        vec3 lightPos=vec3(0.,0.,0.);// Light Position\n        vec3 l=normalize(lightPos-p);// Light Vector\n        vec3 n=GetNormal(p);// Normal Vector\n        \n        float dif=dot(n,l);// Diffuse light\n\n        dif=clamp(dif,0.,1.);// Clamp so it doesnt go below 0\n        // Shadows\n        float d=RayMarch(p+n*SURF_DIST*2.,l,1.);\n        \n        if(d<length(lightPos-p))dif*=.1;\n        \n        return color * dif ;\n    }\n\n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n\n        vec2 m = u_mouse.xy;\n\n        vec2 uv2 = vUv;\n        uv2 -= 0.5;\n\n        \n\n        vec3 ro = vec3 (0., 3., -4) * .9;\n        ro.yx *= Rot(PI * 0.5);\n        // ro.yz *= Rot(-m.y*PI + 1.);\n        ro.xz *= Rot(-m.x*TWO_PI);\n        // ro.z *= sin(u_time);\n\n        vec3 rd = GetRayDir(uv2, ro, vec3(0.), 1.);\n        rd.y *= -1.;\n\n        // vec3 col = vec3(0.);\n        vec3 col = texture(u_cubemap,-rd).rgb;\n        // vec3 col = vec3(.3);\n\n        float d = RayMarch(ro, rd, 1.); //outside of obj\n\n        float IOR = 1.45;\n\n        if(d < MAX_DIST){\n            vec3 p = ro + rd * d; //3d hit position\n            vec3 n = GetNormal(p); //normal of surface orientation\n            // p += cnoise(p) * 0.1;\n            vec3 r = reflect(rd, n);\n\n            // vec3 refOutside = texture(u_cubemap, r ).rgb;\n            vec3 refOutside = vec3(1.);\n\n            vec3 rdIn = refract(rd, n, 1. /IOR);//ray dir entering\n\n            vec3 pEnter = p - n * SURF_DIST * 3.;\n            float dIn = RayMarch(pEnter, rdIn, -1.); //inside of obj\n            vec3 pExit = pEnter + rdIn * dIn; //3d position of exit\n            vec3 nExit = -GetNormal(pExit); //normal of exit\n            vec3 reflTex = vec3(0.);\n            vec3 rdOut = vec3(0.);\n\n            float abb = .01;\n\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(u_cubemap, rdOut).r;\n            reflTex.r += cnoise(reflTex) * 0.5;\n            // reflTex.r = 1.;\n\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(u_cubemap, rdOut).g;\n            reflTex.g += cnoise(reflTex) * 0.2;\n            // reflTex.g = .5;\n\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(u_cubemap, rdOut).b;\n            reflTex.b += cnoise(reflTex) * 0.2;\n            // reflTex.b = .5;\n\n            float dens = 0.1;\n            float optDist = exp(-dIn * dens);\n\n            col = reflTex * optDist;\n\n            float fresnel = pow(1. + dot(rd, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n            color += col;\n\n            // col = n * 0.5 + 0.5;\n        }\n\n        col = pow(col, vec3(.4545));\n\n        vec3 dif=GetLight(col,difColor);// Diffuse lighting\n        // color  = vec3(dif + col);\n       \n        color += col;\n\n        \n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t}}}),i=(0,Am.useRef)();return(0,Am.useEffect)((function(){var n=i.current.geometry;n.computeBoundingBox(),console.log(n.boundingBox)}),[i.current]),Nd((function(n){var e=n.clock;i.current.material.uniforms.u_time.value=e.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(o,r)})),addEventListener("mousemove",(function(n){o=n.clientX/window.innerWidth,r=-n.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(n){o=n.changedTouches[0].clientX/window.innerWidth,r=-n.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var aG=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numZero(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (PI) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) * u_time, angle );\n    \n    return radialUv;\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n\n    #define S(a, b, t) smoothstep(a, b, t)\n\n    float DistLine(vec2 p, vec2 a, vec2 b)\n    {\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n        return length(pa - ba * t);\n    }\n\n    float N21(vec2 p)\n    {\n        p = fract(p * vec2(445.23, 789.92));\n        p += dot(p, p + 54.23 );\n        return fract(p.x * p.y);\n    }\n\n    vec2 N22(vec2 p)\n    {\n        float n = N21(p);\n        return vec2(n, N21(p + n));\n    }\n\n    vec2 GetPos(vec2 id, vec2 offset)\n    {\n        vec2 n = N22(id+offset) * u_time;\n        // float x = sin(u_time* n.x);\n        // float y = cos(u_time*n.y);\n        return offset + sin(n) * .4;\n    }\n\n    float Line(vec2 p, vec2 a, vec2 b)\n    {\n        float d = DistLine(p, a, b);\n        float m = S(.03, 0.01, d);\n        float d2 = length(a - b);\n        m *= S(1.2, .8, d2) * .5 + S(.05, .03, abs(d2-.75));\n        return m;\n    }\n\n    float Layer(vec2 uv2)\n    {\n        float m;\n        vec2 gv = fract(uv2) - 0.5;\n        vec2 id = floor(uv2);\n\n        // vec2 p = N22(id) - 0.5;\n\n        vec2 p[9];\n\n        // vec2 p = GetPos(id);\n        // float d = length(gv - p);\n        // m = S(0.1, 0.05, d);\n\n        int i = 0;\n        for(float y=-1.; y <=1.; y++)\n        {\n            for(float x=-1.; x<=1.; x++)\n            {\n                p[i++]= GetPos(id, vec2(x, y));\n            }\n        }\n\n        float t = u_time * 10.;\n\n        for(int i=0; i < 9; i++)\n        {\n            m += Line(gv, p[4], p[i]);\n            \n            vec2 j = (p[i] - gv) * 40.;\n            float sparkle = 1. / dot(j, j);\n\n            m += sparkle * (sin(t+fract(p[i].x) * 10.) * .5 + .5);\n        }\n        m += Line(gv, p[1], p[3]);\n        m += Line(gv, p[1], p[5]);\n        m += Line(gv, p[7], p[3]);\n        m += Line(gv, p[7], p[5]);\n\n        return m;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        \n\n        float an = -u_time * 0.5;\n        float r1 = length(uv2 * 3.5) ;\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.5);\n        uv2 = vec2(0.53/r1 + .95 * 1.25 + r1, a );\n\n        float m = 0.;\n        float t = u_time * 0.05;\n        \n        for(float i =0.; i <1.; i+= 1./4.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(10., .1, z);\n            float fade = S(0., 0.5, z) * S(1., 0.8, z);\n            m += Layer(uv2 * size + i * 20.) * fade;\n        }\n\n        vec3 base = sin(t * vec3(.345, .456, .678)) * .4 + .6;\n        vec3 col = m * base;\n        // col += uv2.y * base * 0.2;\n        // col -= uv2.x  * base * 0.2;\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function iG(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:aG,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var vG=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numOne(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float random (in vec2 _st) {\n        return fract(sin(dot(_st.xy,\n                             vec2(12.9898,78.233)))*\n            43758.5453123);\n    }\n\n    // Based on Morgan McGuire @morgan3d\n    // https://www.shadertoy.com/view/4dS3Wd\n    float noise (in vec2 _st) {\n        vec2 i = floor(_st);\n        vec2 f = fract(_st);\n\n        // Four corners in 2D of a tile\n        float a = random(i);\n        float b = random(i + vec2(1.0, 0.0));\n        float c = random(i + vec2(0.0, 1.0));\n        float d = random(i + vec2(1.0, 1.0));\n\n        vec2 u = f * f * (3.0 - 2.0 * f);\n\n        return mix(a, b, u.x) +\n                (c - a)* u.y * (1.0 - u.x) +\n                (d - b) * u.x * u.y;\n    }\n\n    #define NUM_OCTAVES 5\n\n    \n\n    float fbm ( in vec2 _st) {\n        float v = 0.0;\n        float a = 0.65;\n        vec2 shift = vec2(100.0);\n        // Rotate to reduce axial bias\n        mat2 rot = mat2(cos(0.5), sin(0.5),\n                        -sin(0.5), cos(0.50));\n        for (int i = 0; i < NUM_OCTAVES; ++i) {\n            v += a * noise(_st);\n            _st = rot * _st * 2.0 + shift;\n            a *= 0.5;\n        }\n        return v;\n    }\n\n    vec2 getRadialUv(vec2 uv)\n    {\n    float angle = atan(uv.x, uv.y);\n    angle = abs(angle);\n    \n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (PI) + 0.5;\n    radialUv.y = 1.0 - pow(1.0 - length(uv), .2);\n    radialUv = vec2(0.3/length(uv) * u_time, angle );\n    \n    return radialUv;\n    }\n\n    vec2 position(float z) {\n        return vec2(\n            0.0 + sin(z * 0.1) * 1.0 + sin(cos(z * 0.031) * 4.0) * 1.0 + sin(sin(z * 0.0091) * 3.0) * 3.0,\n            0.0 + cos(z * 0.1) * 1.0 + cos(cos(z * 0.031) * 4.0) * 1.0 + cos(sin(z * 0.0091) * 3.0) * 3.0\n        ) * 1.0;\n    }\n\n    #define S(a, b, t) smoothstep(a, b, t)\n\n    float DistLine(vec2 p, vec2 a, vec2 b)\n    {\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n        return length(pa - ba * t);\n    }\n\n    float N21(vec2 p)\n    {\n        p = fract(p * vec2(445.23, 789.92));\n        p += dot(p, p + 54.23 );\n        return fract(p.x * p.y);\n    }\n\n    vec2 N22(vec2 p)\n    {\n        float n = N21(p);\n        return vec2(n, N21(p + n));\n    }\n\n    vec2 GetPos(vec2 id, vec2 offset)\n    {\n        vec2 n = N22(id+offset) * u_time;\n        // float x = sin(u_time* n.x);\n        // float y = cos(u_time*n.y);\n        return offset + sin(n) * .4;\n    }\n\n    float Line(vec2 p, vec2 a, vec2 b)\n    {\n        float d = DistLine(p, a, b);\n        float m = S(.03, 0.01, d);\n        float d2 = length(a - b);\n        m *= S(1.2, .8, d2) * .5 + S(.05, .03, abs(d2-.75));\n        return m;\n    }\n\n    float Layer(vec2 uv2)\n    {\n        float m;\n        vec2 gv = fract(uv2) - 0.5;\n        vec2 id = floor(uv2);\n\n        // vec2 p = N22(id) - 0.5;\n\n        vec2 p[9];\n\n        // vec2 p = GetPos(id);\n        // float d = length(gv - p);\n        // m = S(0.1, 0.05, d);\n\n        int i = 0;\n        for(float y=-1.; y <=1.; y++)\n        {\n            for(float x=-1.; x<=1.; x++)\n            {\n                p[i++]= GetPos(id, vec2(x, y));\n            }\n        }\n\n        float t = u_time * 10.;\n\n        for(int i=0; i < 9; i++)\n        {\n            m += Line(gv, p[4], p[i]);\n            \n            vec2 j = (p[i] - gv) * 40.;\n            float sparkle = 1. / dot(j, j);\n\n            m += sparkle * (sin(t+fract(p[i].x) * 10.) * .5 + .5);\n        }\n        m += Line(gv, p[1], p[3]);\n        m += Line(gv, p[1], p[5]);\n        m += Line(gv, p[7], p[3]);\n        m += Line(gv, p[7], p[5]);\n\n        return m;\n    }\n    \n    void main()\n    {\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n        \n        uv2 *= 1.5;\n\n        float an = -u_time * 0.5;\n        float r1 = length(uv2 * 1.75) ;\n        float a = atan(uv2.y, uv2.x);\n        a = abs(a * 1.25);\n        uv2 = vec2(0.053/r1 + .95 * .25 + r1, a * 0.15);\n\n        float m = 0.;\n        float t = u_time * 0.05;\n        \n        for(float i =0.; i <1.; i+= 1./4.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(10., .1, z);\n            float fade = S(0., 0.5, z) * S(1., 0.8, z);\n            m += Layer(uv2 * size + i * 20.) * fade;\n        }\n\n        vec3 base = sin(t * vec3(.345, .456, .678)) * .4 + .6;\n        vec3 col = m * base;\n        // col += uv2.y * base * 0.2;\n        // col -= uv2.x  * base * 0.2;\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao},u_mouse:{type:"v2",value:new ao}}});function cG(){var n=(0,Am.useRef)();return Nd((function(e){var t=e.clock;n.current.material.uniforms.u_time.value=t.elapsedTime})),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{ref:n,material:vG,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function sG(){var n,e,t="./Models/EnvMaps/0/",o=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numTwo(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    \n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(0.);\n        vec2 m = u_mouse.xy;\n        vec2 uv2 = vUv;\n        uv2 -= .5;\n\n        vec3 col = vec3((sin(u_time)/2.) + 0.5, 0.5, 0.);\n\n        float d = length(vUv - abs(u_mouse.xy)) - 0.2;\n        color += (step(0., -d)) * col;\n\n        float glow = 0.005/ d;\n        glow = clamp(glow, 0., 1.);\n        glow = glow * 15. * (sin(u_time)/10. + 0.75);\n\n        color += col * glow ;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Am.useRef)(),v=new Oo,c=new Oo(-1,-1,0),s=new Oo(1,-1,0);new Oo(-1,1,0),new Oo(1,1,0);(0,Am.useEffect)((function(){(new Go).setFromObject(i.current).getSize(v)}),[i.current]),Gd((function(n){var e=n.camera;c&&(v.project(e),c.project(e))}));v.x,window.innerWidth,v.y,window.innerHeight,c.x,window.innerWidth,c.y,window.innerHeight,s.x,window.innerWidth,s.y,window.innerHeight;return Nd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function lG(){var n,e,t="./Models/EnvMaps/0/",o=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numThree(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    \n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(0.);\n        vec2 m = u_mouse.xy;\n        vec2 uv2 = vUv;\n        uv2 += .5;\n\n        vec3 col = vec3((sin(u_time))/2. + 1., 0.3, 0.);\n\n        float n = noise2D(uv2 + u_time) * .5;\n        \n\n        float cir = circle(uv2 - abs(u_mouse.xy), 0.05) * n;\n        float d = length(vUv  - abs(u_mouse.xy) ) - 0.25 ;\n        color = (step(0., -d)) * col * n;\n        // color += cir * col;\n\n        \n\n        float glow = 0.001/ -d * n;\n        float glow2 = 0.01/ d * n;\n        glow = clamp(glow, 0., 1.);\n        glow2 = clamp(glow2, 0., 1.);\n        glow = glow * 15. * (sin(u_time * 1.)/10. + 0.75);\n        glow2 = glow2 * 15. * (sin(u_time * 1.)/10. + 0.75);\n\n        color += col * glow * 2.;\n        color += col * glow2 * 2.;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Am.useRef)(),v=new Oo,c=new Oo(-1,-1,0),s=new Oo(1,-1,0);new Oo(-1,1,0),new Oo(1,1,0);(0,Am.useEffect)((function(){(new Go).setFromObject(i.current).getSize(v)}),[i.current]),Gd((function(n){var e=n.camera;c&&(v.project(e),c.project(e))}));v.x,window.innerWidth,v.y,window.innerHeight,c.x,window.innerWidth,c.y,window.innerHeight,s.x,window.innerWidth,s.y,window.innerHeight;return Nd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function uG(){var n,e,t="./Models/EnvMaps/0/",o=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numFour(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    // float rand(vec2 n) { \n    //     return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    // }\n    \n    // float noise2D(vec2 p){\n    //     vec2 ip = floor(p);\n    //     vec2 u = fract(p);\n    //     u = u*u*(3.0-2.0*u);\n        \n    //     float res = mix(\n    //         mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n    //         mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    //     return res*res;\n    // }\n\n    float glow(vec2 uv2, vec2 m){\n        m = vec2(u_mouse.xy);\n        float n = noise2D(uv2 + u_time) * .5;\n        float d = length(vUv  - abs(u_mouse.xy) ) - 0.25 ;\n        //color = (step(0., -d)) * col * n;\n        //color += cir * col;\n\n        \n        float glow = 0.001/ -d * n;\n        float glow2 = 0.01/ d * n;\n        glow = clamp(glow, 0., 1.);\n        glow2 = clamp(glow2, 0., 1.);\n        glow = glow * 15. * (sin(u_time * 1.)/10. + 0.75);\n        glow2 = glow2 * 15. * (sin(u_time * 1.)/10. + 0.75);\n\n        return glow + glow2;\n    }\n\n    \n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n\n        vec3 colx = vec3((sin(u_time))/2. + 1., 0.3, 0.);\n\n        float x = 0.;\n        float t = u_time * 0.05;\n        \n        for(float i =0.; i <1.; i+= 1./4.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(10., .5, z);\n            float fade = S(0., 0.5, z) * S(1., 0.8, z);\n            x += glow(uv2 * size + i * 20., vec2(u_mouse.xy)) * fade;\n        }\n        \n        vec3 base = sin(t * vec3(.345, .456, .678)) * .4 + .6;\n        vec3 col = x * base;\n        col += uv2.y * base * 0.2;\n        col -= uv2.x  * base * 0.2;\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Am.useRef)(),v=new Oo,c=new Oo(-1,-1,0),s=new Oo(1,-1,0);new Oo(-1,1,0),new Oo(1,1,0);(0,Am.useEffect)((function(){(new Go).setFromObject(i.current).getSize(v)}),[i.current]),Gd((function(n){var e=n.camera;c&&(v.project(e),c.project(e))}));v.x,window.innerWidth,v.y,window.innerHeight,c.x,window.innerWidth,c.y,window.innerHeight,s.x,window.innerWidth,s.y,window.innerHeight;return Nd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}function fG(){var n,e,t="./Models/EnvMaps/0/",o=[t+"px.jpg",t+"nx.jpg",t+"py.jpg",t+"ny.jpg",t+"pz.jpg",t+"nz.jpg"],r=(new vf).load(o),a=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    \n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numFive(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    float glow(vec2 uv2, vec2 m){\n        m = vec2(u_mouse.xy);\n        float n = noise2D(uv2 + u_time) * .5;\n        float d = length(vUv  - abs(u_mouse.xy) ) - 0.25 ;\n        //color = (step(0., -d)) * col * n;\n        //color += cir * col;\n\n        \n        float glow = 0.001/ -d * n;\n        float glow2 = 0.0001/ d * n;\n        glow = clamp(glow, 0., 1.);\n        glow2 = clamp(glow2, 0., 1.);\n        glow = glow * 15. * (sin(u_time * 1.)/10. + 0.75);\n        glow2 = glow2 * 15. * (sin(u_time * 1.)/10. + 0.75);\n\n        return glow + glow2;\n    }\n\n    #define S(a, b, t) smoothstep(a, b, t)\n\n    float DistLine(vec2 p, vec2 a, vec2 b)\n    {\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        float t = clamp(dot(pa, ba)/ dot(ba, ba), 0., 1.);\n        return length(pa - ba * t);\n    }\n\n    float N21(vec2 p)\n    {\n        p = fract(p * vec2(445.23, 789.92));\n        p += dot(p, p + 54.23 );\n        return fract(p.x * p.y);\n    }\n\n    vec2 N22(vec2 p)\n    {\n        float n = N21(p);\n        return vec2(n, N21(p + n));\n    }\n\n    vec2 GetPos(vec2 id, vec2 offset)\n    {\n        vec2 n = N22(id+offset) * u_time;\n        // float x = sin(u_time* n.x);\n        // float y = cos(u_time*n.y);\n        return offset + sin(n) * .4;\n    }\n\n    float Line(vec2 p, vec2 a, vec2 b)\n    {\n        float d = DistLine(p, a, b);\n        float m = S(.03, 0.01, d);\n        float d2 = length(a - b);\n        m *= S(1.2, .8, d2) * .5 + S(.05, .03, abs(d2-.75));\n        return m;\n    }\n\n    float Layer(vec2 uv2)\n    {\n        float m;\n        vec2 gv = fract(uv2) - 0.5;\n        vec2 id = floor(uv2);\n\n        // vec2 p = N22(id) - 0.5;\n\n        vec2 p[9];\n\n        // vec2 p = GetPos(id);\n        // float d = length(gv - p);\n        // m = S(0.1, 0.05, d);\n\n        int i = 0;\n        for(float y=-1.; y <=1.; y++)\n        {\n            for(float x=-1.; x<=1.; x++)\n            {\n                p[i++]= GetPos(id, vec2(x, y));\n            }\n        }\n\n        float t = u_time * 10.;\n\n        for(int i=0; i < 9; i++)\n        {\n            // m += Line(gv, p[4], p[i]);\n            \n            vec2 j = (p[i] - gv) * 40.;\n            float sparkle = 1. / dot(j, j);\n\n            m += glow(uv2, vec2(u_mouse.xy));\n            m += sparkle * (sin(t+fract(p[i].x) * 10.) * .5 + .5);\n        }\n        return m;\n    }\n\n    \n\n    \n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(0.);\n        \n        vec2 uv2 = vUv;\n        uv2 -= .5;\n\n        vec3 colx = vec3((sin(u_time))/2. + 1., 0.3, 0.);\n\n        float x = 0.;\n        float t = u_time * 0.05;\n        \n        for(float i =0.; i <1.; i+= 1./4.)\n        {\n            float z = fract(i + t);//reuse layers\n            float size = mix(10., .5, z);\n            float fade = S(0., 0.5, z) * S(1., 0.8, z);\n            x += Layer(uv2 * size + i * 20.) * fade;\n        }\n        \n        vec3 base = sin(t * vec3(.345, .456, .678)) * .4 + .6;\n        vec3 col = x * base;\n        col += uv2.y * base * 0.2;\n        col -= uv2.x  * base * 0.2;\n        color += col;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:r}}}),i=(0,Am.useRef)(),v=new Oo,c=new Oo(-1,-1,0),s=new Oo(1,-1,0);new Oo(-1,1,0),new Oo(1,1,0);(0,Am.useEffect)((function(){(new Go).setFromObject(i.current).getSize(v)}),[i.current]),Gd((function(n){var e=n.camera;c&&(v.project(e),c.project(e))}));v.x,window.innerWidth,v.y,window.innerHeight,c.x,window.innerWidth,c.y,window.innerHeight,s.x,window.innerWidth,s.y,window.innerHeight;return Nd((function(t){var o=t.clock;i.current.material.uniforms.u_time.value=o.elapsedTime,i.current.material.uniforms.u_mouse.value=new ao(n,e)})),addEventListener("mousemove",(function(t){n=t.clientX/window.innerWidth,e=-t.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(t){n=t.changedTouches[0].clientX/window.innerWidth,e=-t.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1}),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsx)("mesh",{dispose:null,ref:i,material:a,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})})}var pG=["children","eps","style","className","prepend","center","fullscreen","portal","distanceFactor","sprite","transform","occlude","onOcclude","zIndexRange","calculatePosition","as","wrapperClass","pointerEvents"],mG=new Oo,dG=new Oo,hG=new Oo;function xG(n,e,t){var o=mG.setFromMatrixPosition(n.matrixWorld);o.project(e);var r=t.width/2,a=t.height/2;return[o.x*r+r,-o.y*a+a]}var gG=function(n){return Math.abs(n)<1e-10?0:n};function yG(n,e){for(var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",o="matrix3d(",r=0;16!==r;r++)o+=gG(e[r]*n.elements[r])+(15!==r?",":")");return t+o}var bG,UG=(bG=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],function(n){return yG(n,bG)}),_G=function(n,e){return yG(n,[1/(t=e),1/t,1/t,1,-1/t,-1/t,-1/t,-1,1/t,1/t,1/t,1,1,1,1,1],"translate(-50%,-50%)");var t},wG=Am.forwardRef((function(n,e){var t=n.children,r=n.eps,a=void 0===r?.001:r,i=n.style,v=n.className,s=n.prepend,l=n.center,f=n.fullscreen,p=n.portal,m=n.distanceFactor,d=n.sprite,h=void 0!==d&&d,x=n.transform,g=void 0!==x&&x,y=n.occlude,b=n.onOcclude,U=n.zIndexRange,_=void 0===U?[16777271,0]:U,w=n.calculatePosition,S=void 0===w?xG:w,M=n.as,k=void 0===M?"div":M,z=n.wrapperClass,C=n.pointerEvents,T=void 0===C?"auto":C,R=o(n,pG),D=Gd(),P=D.gl,F=D.camera,j=D.scene,I=D.size,E=D.raycaster,O=D.events,A=c(Am.useState((function(){return document.createElement(k)})),1)[0],L=Am.useRef(),G=Am.useRef(null),N=Am.useRef(0),B=Am.useRef([0,0]),q=Am.useRef(null),V=Am.useRef(null),W=(null==p?void 0:p.current)||O.connected||P.domElement.parentNode;Am.useLayoutEffect((function(){if(G.current){var n=L.current=jh.s(A);if(j.updateMatrixWorld(),g)A.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{var e=S(G.current,F,I);A.style.cssText="position:absolute;top:0;left:0;transform:translate3d(".concat(e[0],"px,").concat(e[1],"px,0);transform-origin:0 0;")}return W&&(s?W.prepend(A):W.appendChild(A)),function(){W&&W.removeChild(A),n.unmount()}}}),[W,g]),Am.useLayoutEffect((function(){z&&(A.className=z)}),[z]);var H=Am.useMemo((function(){return g?{position:"absolute",top:0,left:0,width:I.width,height:I.height,transformStyle:"preserve-3d",pointerEvents:"none"}:u(u({position:"absolute",transform:l?"translate3d(-50%,-50%,0)":"none"},f&&{top:-I.height/2,left:-I.width/2,width:I.width,height:I.height}),i)}),[i,l,f,I,g]),X=Am.useMemo((function(){return{position:"absolute",pointerEvents:T}}),[T]);Am.useLayoutEffect((function(){var n,o;g?null==(n=L.current)||n.render(Am.createElement("div",{ref:q,style:H},Am.createElement("div",{ref:V,style:X},Am.createElement("div",{ref:e,className:v,style:i,children:t})))):null==(o=L.current)||o.render(Am.createElement("div",{ref:e,style:H,className:v,children:t}))}));var Y=Am.useRef(!0);return Nd((function(){if(G.current){F.updateMatrixWorld(),G.current.updateWorldMatrix(!0,!1);var n=g?B.current:S(G.current,F,I);if(g||Math.abs(N.current-F.zoom)>a||Math.abs(B.current[0]-n[0])>a||Math.abs(B.current[1]-n[1])>a){var e=function(n,e){var t=mG.setFromMatrixPosition(n.matrixWorld),o=dG.setFromMatrixPosition(e.matrixWorld),r=t.sub(o),a=e.getWorldDirection(hG);return r.angleTo(a)>Math.PI/2}(G.current,F),t=!1;"boolean"===typeof y?!0===y&&(t=[j]):Array.isArray(y)&&(t=y.map((function(n){return n.current})));var o=Y.current;if(t){var r=function(n,e,t,o){var r=mG.setFromMatrixPosition(n.matrixWorld),a=r.clone();a.project(e),t.setFromCamera(a,e);var i=t.intersectObjects(o,!0);if(i.length){var v=i[0].distance;return r.distanceTo(t.ray.origin)<v}return!0}(G.current,F,E,t);Y.current=r&&!e}else Y.current=!e;if(o!==Y.current&&(b?b(!Y.current):A.style.display=Y.current?"block":"none"),A.style.zIndex="".concat(function(n,e,t){if(e instanceof Wa||e instanceof di){var o=mG.setFromMatrixPosition(n.matrixWorld),r=dG.setFromMatrixPosition(e.matrixWorld),a=o.distanceTo(r),i=(t[1]-t[0])/(e.far-e.near),v=t[1]-i*e.far;return Math.round(i*a+v)}}(G.current,F,_)),g){var i=I.width/2,v=I.height/2,c=F.projectionMatrix.elements[5]*v,s=F.isOrthographicCamera,l=F.top,u=F.left,f=F.bottom,p=F.right,d=UG(F.matrixWorldInverse),x=s?"scale(".concat(c,")translate(").concat(gG(-(p+u)/2),"px,").concat(gG((l+f)/2),"px)"):"translateZ(".concat(c,"px)"),U=G.current.matrixWorld;h&&((U=F.matrixWorldInverse.clone().transpose().copyPosition(U).scale(G.current.scale)).elements[3]=U.elements[7]=U.elements[11]=0,U.elements[15]=1),A.style.width=I.width+"px",A.style.height=I.height+"px",A.style.perspective=s?"":"".concat(c,"px"),q.current&&V.current&&(q.current.style.transform="".concat(x).concat(d,"translate(").concat(i,"px,").concat(v,"px)"),V.current.style.transform=_G(U,1/((m||10)/400)))}else{var w=void 0===m?1:function(n,e){if(e instanceof di)return e.zoom;if(e instanceof Wa){var t=mG.setFromMatrixPosition(n.matrixWorld),o=dG.setFromMatrixPosition(e.matrixWorld),r=e.fov*Math.PI/180,a=t.distanceTo(o);return 1/(2*Math.tan(r/2)*a)}return 1}(G.current,F)*m;A.style.transform="translate3d(".concat(n[0],"px,").concat(n[1],"px,0) scale(").concat(w,")")}B.current=n,N.current=F.zoom}}})),Am.createElement("group",oh({},R,{ref:G}))}));function SG(){var n="./Models/EnvMaps/0/",e=[n+"px.jpg",n+"nx.jpg",n+"py.jpg",n+"ny.jpg",n+"pz.jpg",n+"nz.jpg"],t=(new vf).load(e),o=Nh((function(n){return n.setSongOn})),r=Nh((function(n){return n.startSong})),a=Nh((function(n){return n.setSongOff})),i=null,v=null;Gd((function(n){i=n.camera,v=n.gl}));var s=c((0,Am.useState)(!1),2),l=s[0],u=s[1],f=v.capabilities.isWebGL2?he:fe,p=new Kf,m=(0,Am.useRef)(),d=(0,Am.useRef)(),h=new $f(p);i&&i.add(p);var x,g,y=new Lf,b=new qa({vertexShader:"\nvarying vec2 vUv;\n\nvoid main()\n{\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:qh+Vh+Bh+"\n\n    #define S(a, b, t) smoothstep(a, b, t)\n    uniform sampler2D u_audio;\n    float label(vec2 p)\n    {\n        p *= 10.;\n        p.x -= 0.25;\n        float left = numSix(vec2(p.x + 0.35, p.y));\n        float center = numFour(vec2(p.x -0.03, p.y));\n        float right = numSix(vec2(p.x - 0.42, p.y));\n        return left + center + right ;\n    }\n\n    void main()\n    {\n\n        vec2 vUv = vec2(vUv.x, vUv.y);\n        // vec2 vUv = gl_FragCoord.xy/u_resolution.xy;\n        vec3 color = vec3(.0, 0., 0.);\n        vec3 bckgdcl = vec3(0.825, 0.5, 0.6);\n        vec2 uv2 = vUv;\n        // uv2 -= .5;\n\n        float f = texture2D(u_audio, vec2(vUv.x, 0.)).r;\n        f = clamp(f, 0.1, 0.9);\n        float i = step( uv2.y, f ) * step( f - 0.0125, uv2.y );\n        \n        vec3 col = mix(color, bckgdcl, i);\n\n        color += col.g * i;\n\n        float numLabel = label(vUv);\n        color += numLabel;\n        gl_FragColor = vec4(color, 1.);\n    }\n",uniforms:{u_time:{type:"f",value:1},u_resolution:{type:"v2",value:new ao(1,1)},u_mouse:{type:"v2",value:new ao},u_cubemap:{value:t},u_audio:{value:d.current}}}),U=(0,Am.useRef)();Nd((function(n){var e=n.clock;m.current&&m.current.getFrequencyData(),U.current.material.uniforms.u_time.value=e.elapsedTime,U.current.material.uniforms.u_mouse.value=new ao(x,g),U.current.material.uniforms.u_audio.value&&(U.current.material.uniforms.u_audio.value.needsUpdate=!0),p.needsUpdate=!0})),addEventListener("mousemove",(function(n){x=n.clientX/window.innerWidth,g=-n.clientY/window.innerHeight+1})),addEventListener("contextmenu",(function(n){return n.preventDefault()})),addEventListener("touchmove",(function(n){x=n.changedTouches[0].clientX/window.innerWidth,g=-n.changedTouches[0].clientY/window.innerHeight+1}),{passive:!1});return(0,Wh.jsxs)(Wh.Fragment,{children:[!l&&(0,Wh.jsx)(wG,{children:(0,Wh.jsx)("div",{className:"play",children:(0,Wh.jsx)("button",{onClick:function(){y.load("./Audio/new-adventure-matrika.ogg",(function(n){h.setBuffer(n),h.setLoop(!0),h.setVolume(.5),console.log(h),h.play(),m.current=new ap(h,128),d.current=new ms(m.current.data,64,1,f),h.isPlaying&&(console.log("playing"),u(!0),o(),r()),h.onEnded((function(){console.log("ended"),u(!1),a()}))}))},style:{cursor:"pointer",color:"white",alignItems:"center",display:"inline-flex",justifyContent:"center",position:"absolute",left:"50%",top:"50%",transform:"translate(-50%, -50%)",backgroundColor:"#00000000",padding:"10px"},children:"Play"})})}),(0,Wh.jsx)("mesh",{dispose:null,ref:U,material:b,children:(0,Wh.jsx)("boxGeometry",{args:[2,2,.1]})})]})}function MG(){var n=Nh((function(n){return n.currentShader})),e=[(0,Wh.jsx)(Xh,{}),(0,Wh.jsx)(Zh,{}),(0,Wh.jsx)(Jh,{}),(0,Wh.jsx)($h,{}),(0,Wh.jsx)(ex,{}),(0,Wh.jsx)(ox,{}),(0,Wh.jsx)(ax,{}),(0,Wh.jsx)(vx,{}),(0,Wh.jsx)(sx,{}),(0,Wh.jsx)(ux,{}),(0,Wh.jsx)(px,{}),(0,Wh.jsx)(dx,{}),(0,Wh.jsx)(xx,{}),(0,Wh.jsx)(yx,{}),(0,Wh.jsx)(Ux,{}),(0,Wh.jsx)(wx,{}),(0,Wh.jsx)(Mx,{}),(0,Wh.jsx)(zx,{}),(0,Wh.jsx)(Tx,{}),(0,Wh.jsx)(Dx,{}),(0,Wh.jsx)(Fx,{}),(0,Wh.jsx)(Ix,{}),(0,Wh.jsx)(Ox,{}),(0,Wh.jsx)(Lx,{}),(0,Wh.jsx)(Nx,{}),(0,Wh.jsx)(qx,{}),(0,Wh.jsx)(Wx,{}),(0,Wh.jsx)(Xx,{}),(0,Wh.jsx)(Zx,{}),(0,Wh.jsx)(Jx,{}),(0,Wh.jsx)($x,{}),(0,Wh.jsx)(eg,{}),(0,Wh.jsx)(og,{}),(0,Wh.jsx)(ag,{}),(0,Wh.jsx)(vg,{}),(0,Wh.jsx)(sg,{}),(0,Wh.jsx)(ug,{}),(0,Wh.jsx)(pg,{}),(0,Wh.jsx)(dg,{}),(0,Wh.jsx)(xg,{}),(0,Wh.jsx)(yg,{}),(0,Wh.jsx)(Ug,{}),(0,Wh.jsx)(wg,{}),(0,Wh.jsx)(Mg,{}),(0,Wh.jsx)(zg,{}),(0,Wh.jsx)(Tg,{}),(0,Wh.jsx)(Dg,{}),(0,Wh.jsx)(Fg,{}),(0,Wh.jsx)(Ig,{}),(0,Wh.jsx)(Og,{}),(0,Wh.jsx)(Lg,{}),(0,Wh.jsx)(Ng,{}),(0,Wh.jsx)(qg,{}),(0,Wh.jsx)(Wg,{}),(0,Wh.jsx)(Xg,{}),(0,Wh.jsx)(Zg,{}),(0,Wh.jsx)(Jg,{}),(0,Wh.jsx)($g,{}),(0,Wh.jsx)(ey,{}),(0,Wh.jsx)(oy,{}),(0,Wh.jsx)(ay,{}),(0,Wh.jsx)(vy,{}),(0,Wh.jsx)(sy,{}),(0,Wh.jsx)(uy,{}),(0,Wh.jsx)(py,{}),(0,Wh.jsx)(dy,{}),(0,Wh.jsx)(xy,{}),(0,Wh.jsx)(yy,{}),(0,Wh.jsx)(Uy,{}),(0,Wh.jsx)(wy,{}),(0,Wh.jsx)(My,{}),(0,Wh.jsx)(zy,{}),(0,Wh.jsx)(Ty,{}),(0,Wh.jsx)(Dy,{}),(0,Wh.jsx)(Fy,{}),(0,Wh.jsx)(Iy,{}),(0,Wh.jsx)(Oy,{}),(0,Wh.jsx)(Ly,{}),(0,Wh.jsx)(Ny,{}),(0,Wh.jsx)(qy,{}),(0,Wh.jsx)(Wy,{}),(0,Wh.jsx)(Xy,{}),(0,Wh.jsx)(Zy,{}),(0,Wh.jsx)(Jy,{}),(0,Wh.jsx)($y,{}),(0,Wh.jsx)(eb,{}),(0,Wh.jsx)(ob,{}),(0,Wh.jsx)(ab,{}),(0,Wh.jsx)(vb,{}),(0,Wh.jsx)(sb,{}),(0,Wh.jsx)(ub,{}),(0,Wh.jsx)(pb,{}),(0,Wh.jsx)(db,{}),(0,Wh.jsx)(xb,{}),(0,Wh.jsx)(yb,{}),(0,Wh.jsx)(Ub,{}),(0,Wh.jsx)(wb,{}),(0,Wh.jsx)(Mb,{}),(0,Wh.jsx)(zb,{}),(0,Wh.jsx)(Tb,{}),(0,Wh.jsx)(Db,{}),(0,Wh.jsx)(Fb,{}),(0,Wh.jsx)(Ib,{}),(0,Wh.jsx)(Ob,{}),(0,Wh.jsx)(Lb,{}),(0,Wh.jsx)(Nb,{}),(0,Wh.jsx)(qb,{}),(0,Wh.jsx)(Wb,{}),(0,Wh.jsx)(Xb,{}),(0,Wh.jsx)(Zb,{}),(0,Wh.jsx)(Jb,{}),(0,Wh.jsx)($b,{}),(0,Wh.jsx)(eU,{}),(0,Wh.jsx)(oU,{}),(0,Wh.jsx)(aU,{}),(0,Wh.jsx)(vU,{}),(0,Wh.jsx)(sU,{}),(0,Wh.jsx)(uU,{}),(0,Wh.jsx)(pU,{}),(0,Wh.jsx)(dU,{}),(0,Wh.jsx)(xU,{}),(0,Wh.jsx)(yU,{}),(0,Wh.jsx)(UU,{}),(0,Wh.jsx)(wU,{}),(0,Wh.jsx)(MU,{}),(0,Wh.jsx)(zU,{}),(0,Wh.jsx)(TU,{}),(0,Wh.jsx)(DU,{}),(0,Wh.jsx)(FU,{}),(0,Wh.jsx)(IU,{}),(0,Wh.jsx)(OU,{}),(0,Wh.jsx)(LU,{}),(0,Wh.jsx)(NU,{}),(0,Wh.jsx)(qU,{}),(0,Wh.jsx)(WU,{}),(0,Wh.jsx)(XU,{}),(0,Wh.jsx)(ZU,{}),(0,Wh.jsx)(JU,{}),(0,Wh.jsx)($U,{}),(0,Wh.jsx)(e_,{}),(0,Wh.jsx)(o_,{}),(0,Wh.jsx)(a_,{}),(0,Wh.jsx)(v_,{}),(0,Wh.jsx)(s_,{}),(0,Wh.jsx)(u_,{}),(0,Wh.jsx)(p_,{}),(0,Wh.jsx)(d_,{}),(0,Wh.jsx)(x_,{}),(0,Wh.jsx)(y_,{}),(0,Wh.jsx)(U_,{}),(0,Wh.jsx)(w_,{}),(0,Wh.jsx)(M_,{}),(0,Wh.jsx)(z_,{}),(0,Wh.jsx)(T_,{}),(0,Wh.jsx)(D_,{}),(0,Wh.jsx)(F_,{}),(0,Wh.jsx)(I_,{}),(0,Wh.jsx)(O_,{}),(0,Wh.jsx)(L_,{}),(0,Wh.jsx)(N_,{}),(0,Wh.jsx)(q_,{}),(0,Wh.jsx)(W_,{}),(0,Wh.jsx)(X_,{}),(0,Wh.jsx)(Z_,{}),(0,Wh.jsx)(J_,{}),(0,Wh.jsx)($_,{}),(0,Wh.jsx)(ew,{}),(0,Wh.jsx)(ow,{}),(0,Wh.jsx)(aw,{}),(0,Wh.jsx)(vw,{}),(0,Wh.jsx)(sw,{}),(0,Wh.jsx)(uw,{}),(0,Wh.jsx)(pw,{}),(0,Wh.jsx)(dw,{}),(0,Wh.jsx)(xw,{}),(0,Wh.jsx)(yw,{}),(0,Wh.jsx)(Uw,{}),(0,Wh.jsx)(ww,{}),(0,Wh.jsx)(Mw,{}),(0,Wh.jsx)(zw,{}),(0,Wh.jsx)(Tw,{}),(0,Wh.jsx)(Dw,{}),(0,Wh.jsx)(Fw,{}),(0,Wh.jsx)(Iw,{}),(0,Wh.jsx)(Ow,{}),(0,Wh.jsx)(Lw,{}),(0,Wh.jsx)(Nw,{}),(0,Wh.jsx)(qw,{}),(0,Wh.jsx)(Ww,{}),(0,Wh.jsx)(Xw,{}),(0,Wh.jsx)(Zw,{}),(0,Wh.jsx)(Jw,{}),(0,Wh.jsx)($w,{}),(0,Wh.jsx)(eS,{}),(0,Wh.jsx)(oS,{}),(0,Wh.jsx)(aS,{}),(0,Wh.jsx)(vS,{}),(0,Wh.jsx)(sS,{}),(0,Wh.jsx)(uS,{}),(0,Wh.jsx)(pS,{}),(0,Wh.jsx)(dS,{}),(0,Wh.jsx)(xS,{}),(0,Wh.jsx)(yS,{}),(0,Wh.jsx)(US,{}),(0,Wh.jsx)(wS,{}),(0,Wh.jsx)(MS,{}),(0,Wh.jsx)(zS,{}),(0,Wh.jsx)(TS,{}),(0,Wh.jsx)(DS,{}),(0,Wh.jsx)(FS,{}),(0,Wh.jsx)(IS,{}),(0,Wh.jsx)(OS,{}),(0,Wh.jsx)(LS,{}),(0,Wh.jsx)(NS,{}),(0,Wh.jsx)(qS,{}),(0,Wh.jsx)(WS,{}),(0,Wh.jsx)(XS,{}),(0,Wh.jsx)(ZS,{}),(0,Wh.jsx)(JS,{}),(0,Wh.jsx)($S,{}),(0,Wh.jsx)(eM,{}),(0,Wh.jsx)(oM,{}),(0,Wh.jsx)(aM,{}),(0,Wh.jsx)(vM,{}),(0,Wh.jsx)(sM,{}),(0,Wh.jsx)(uM,{}),(0,Wh.jsx)(pM,{}),(0,Wh.jsx)(dM,{}),(0,Wh.jsx)(xM,{}),(0,Wh.jsx)(yM,{}),(0,Wh.jsx)(UM,{}),(0,Wh.jsx)(wM,{}),(0,Wh.jsx)(MM,{}),(0,Wh.jsx)(zM,{}),(0,Wh.jsx)(TM,{}),(0,Wh.jsx)(DM,{}),(0,Wh.jsx)(FM,{}),(0,Wh.jsx)(IM,{}),(0,Wh.jsx)(OM,{}),(0,Wh.jsx)(LM,{}),(0,Wh.jsx)(NM,{}),(0,Wh.jsx)(qM,{}),(0,Wh.jsx)(WM,{}),(0,Wh.jsx)(XM,{}),(0,Wh.jsx)(ZM,{}),(0,Wh.jsx)(JM,{}),(0,Wh.jsx)($M,{}),(0,Wh.jsx)(ek,{}),(0,Wh.jsx)(ok,{}),(0,Wh.jsx)(ak,{}),(0,Wh.jsx)(vk,{}),(0,Wh.jsx)(sk,{}),(0,Wh.jsx)(uk,{}),(0,Wh.jsx)(pk,{}),(0,Wh.jsx)(dk,{}),(0,Wh.jsx)(xk,{}),(0,Wh.jsx)(yk,{}),(0,Wh.jsx)(Uk,{}),(0,Wh.jsx)(wk,{}),(0,Wh.jsx)(Mk,{}),(0,Wh.jsx)(zk,{}),(0,Wh.jsx)(Tk,{}),(0,Wh.jsx)(Dk,{}),(0,Wh.jsx)(Fk,{}),(0,Wh.jsx)(Ik,{}),(0,Wh.jsx)(Ok,{}),(0,Wh.jsx)(Lk,{}),(0,Wh.jsx)(Nk,{}),(0,Wh.jsx)(qk,{}),(0,Wh.jsx)(Wk,{}),(0,Wh.jsx)(Xk,{}),(0,Wh.jsx)(Zk,{}),(0,Wh.jsx)(Jk,{}),(0,Wh.jsx)($k,{}),(0,Wh.jsx)(ez,{}),(0,Wh.jsx)(oz,{}),(0,Wh.jsx)(az,{}),(0,Wh.jsx)(vz,{}),(0,Wh.jsx)(sz,{}),(0,Wh.jsx)(uz,{}),(0,Wh.jsx)(pz,{}),(0,Wh.jsx)(dz,{}),(0,Wh.jsx)(xz,{}),(0,Wh.jsx)(yz,{}),(0,Wh.jsx)(Uz,{}),(0,Wh.jsx)(wz,{}),(0,Wh.jsx)(Mz,{}),(0,Wh.jsx)(zz,{}),(0,Wh.jsx)(Tz,{}),(0,Wh.jsx)(Dz,{}),(0,Wh.jsx)(Fz,{}),(0,Wh.jsx)(Iz,{}),(0,Wh.jsx)(Oz,{}),(0,Wh.jsx)(Lz,{}),(0,Wh.jsx)(Nz,{}),(0,Wh.jsx)(qz,{}),(0,Wh.jsx)(Wz,{}),(0,Wh.jsx)(Xz,{}),(0,Wh.jsx)(Zz,{}),(0,Wh.jsx)(Jz,{}),(0,Wh.jsx)($z,{}),(0,Wh.jsx)(eC,{}),(0,Wh.jsx)(oC,{}),(0,Wh.jsx)(aC,{}),(0,Wh.jsx)(vC,{}),(0,Wh.jsx)(sC,{}),(0,Wh.jsx)(uC,{}),(0,Wh.jsx)(pC,{}),(0,Wh.jsx)(dC,{}),(0,Wh.jsx)(xC,{}),(0,Wh.jsx)(yC,{}),(0,Wh.jsx)(UC,{}),(0,Wh.jsx)(wC,{}),(0,Wh.jsx)(MC,{}),(0,Wh.jsx)(zC,{}),(0,Wh.jsx)(TC,{}),(0,Wh.jsx)(DC,{}),(0,Wh.jsx)(FC,{}),(0,Wh.jsx)(IC,{}),(0,Wh.jsx)(OC,{}),(0,Wh.jsx)(LC,{}),(0,Wh.jsx)(NC,{}),(0,Wh.jsx)(qC,{}),(0,Wh.jsx)(WC,{}),(0,Wh.jsx)(XC,{}),(0,Wh.jsx)(ZC,{}),(0,Wh.jsx)(JC,{}),(0,Wh.jsx)($C,{}),(0,Wh.jsx)(eT,{}),(0,Wh.jsx)(oT,{}),(0,Wh.jsx)(aT,{}),(0,Wh.jsx)(vT,{}),(0,Wh.jsx)(sT,{}),(0,Wh.jsx)(uT,{}),(0,Wh.jsx)(pT,{}),(0,Wh.jsx)(dT,{}),(0,Wh.jsx)(xT,{}),(0,Wh.jsx)(yT,{}),(0,Wh.jsx)(UT,{}),(0,Wh.jsx)(wT,{}),(0,Wh.jsx)(MT,{}),(0,Wh.jsx)(zT,{}),(0,Wh.jsx)(TT,{}),(0,Wh.jsx)(DT,{}),(0,Wh.jsx)(FT,{}),(0,Wh.jsx)(IT,{}),(0,Wh.jsx)(OT,{}),(0,Wh.jsx)(LT,{}),(0,Wh.jsx)(NT,{}),(0,Wh.jsx)(qT,{}),(0,Wh.jsx)(WT,{}),(0,Wh.jsx)(XT,{}),(0,Wh.jsx)(ZT,{}),(0,Wh.jsx)(JT,{}),(0,Wh.jsx)($T,{}),(0,Wh.jsx)(eR,{}),(0,Wh.jsx)(oR,{}),(0,Wh.jsx)(aR,{}),(0,Wh.jsx)(vR,{}),(0,Wh.jsx)(sR,{}),(0,Wh.jsx)(uR,{}),(0,Wh.jsx)(pR,{}),(0,Wh.jsx)(dR,{}),(0,Wh.jsx)(xR,{}),(0,Wh.jsx)(yR,{}),(0,Wh.jsx)(UR,{}),(0,Wh.jsx)(wR,{}),(0,Wh.jsx)(MR,{}),(0,Wh.jsx)(zR,{}),(0,Wh.jsx)(TR,{}),(0,Wh.jsx)(DR,{}),(0,Wh.jsx)(FR,{}),(0,Wh.jsx)(IR,{}),(0,Wh.jsx)(OR,{}),(0,Wh.jsx)(LR,{}),(0,Wh.jsx)(NR,{}),(0,Wh.jsx)(qR,{}),(0,Wh.jsx)(WR,{}),(0,Wh.jsx)(XR,{}),(0,Wh.jsx)(ZR,{}),(0,Wh.jsx)(JR,{}),(0,Wh.jsx)($R,{}),(0,Wh.jsx)(eD,{}),(0,Wh.jsx)(oD,{}),(0,Wh.jsx)(aD,{}),(0,Wh.jsx)(vD,{}),(0,Wh.jsx)(sD,{}),(0,Wh.jsx)(uD,{}),(0,Wh.jsx)(pD,{}),(0,Wh.jsx)(dD,{}),(0,Wh.jsx)(xD,{}),(0,Wh.jsx)(yD,{}),(0,Wh.jsx)(UD,{}),(0,Wh.jsx)(wD,{}),(0,Wh.jsx)(MD,{}),(0,Wh.jsx)(zD,{}),(0,Wh.jsx)(TD,{}),(0,Wh.jsx)(DD,{}),(0,Wh.jsx)(FD,{}),(0,Wh.jsx)(ID,{}),(0,Wh.jsx)(OD,{}),(0,Wh.jsx)(LD,{}),(0,Wh.jsx)(ND,{}),(0,Wh.jsx)(qD,{}),(0,Wh.jsx)(WD,{}),(0,Wh.jsx)(XD,{}),(0,Wh.jsx)(ZD,{}),(0,Wh.jsx)(JD,{}),(0,Wh.jsx)($D,{}),(0,Wh.jsx)(eP,{}),(0,Wh.jsx)(oP,{}),(0,Wh.jsx)(aP,{}),(0,Wh.jsx)(vP,{}),(0,Wh.jsx)(sP,{}),(0,Wh.jsx)(uP,{}),(0,Wh.jsx)(pP,{}),(0,Wh.jsx)(dP,{}),(0,Wh.jsx)(xP,{}),(0,Wh.jsx)(yP,{}),(0,Wh.jsx)(UP,{}),(0,Wh.jsx)(wP,{}),(0,Wh.jsx)(MP,{}),(0,Wh.jsx)(zP,{}),(0,Wh.jsx)(TP,{}),(0,Wh.jsx)(DP,{}),(0,Wh.jsx)(FP,{}),(0,Wh.jsx)(IP,{}),(0,Wh.jsx)(OP,{}),(0,Wh.jsx)(LP,{}),(0,Wh.jsx)(NP,{}),(0,Wh.jsx)(qP,{}),(0,Wh.jsx)(WP,{}),(0,Wh.jsx)(XP,{}),(0,Wh.jsx)(ZP,{}),(0,Wh.jsx)(JP,{}),(0,Wh.jsx)($P,{}),(0,Wh.jsx)(eF,{}),(0,Wh.jsx)(oF,{}),(0,Wh.jsx)(aF,{}),(0,Wh.jsx)(vF,{}),(0,Wh.jsx)(sF,{}),(0,Wh.jsx)(uF,{}),(0,Wh.jsx)(pF,{}),(0,Wh.jsx)(dF,{}),(0,Wh.jsx)(xF,{}),(0,Wh.jsx)(yF,{}),(0,Wh.jsx)(UF,{}),(0,Wh.jsx)(wF,{}),(0,Wh.jsx)(MF,{}),(0,Wh.jsx)(zF,{}),(0,Wh.jsx)(TF,{}),(0,Wh.jsx)(DF,{}),(0,Wh.jsx)(FF,{}),(0,Wh.jsx)(IF,{}),(0,Wh.jsx)(OF,{}),(0,Wh.jsx)(LF,{}),(0,Wh.jsx)(NF,{}),(0,Wh.jsx)(qF,{}),(0,Wh.jsx)(WF,{}),(0,Wh.jsx)(XF,{}),(0,Wh.jsx)(ZF,{}),(0,Wh.jsx)(JF,{}),(0,Wh.jsx)($F,{}),(0,Wh.jsx)(ej,{}),(0,Wh.jsx)(oj,{}),(0,Wh.jsx)(aj,{}),(0,Wh.jsx)(vj,{}),(0,Wh.jsx)(sj,{}),(0,Wh.jsx)(uj,{}),(0,Wh.jsx)(pj,{}),(0,Wh.jsx)(dj,{}),(0,Wh.jsx)(xj,{}),(0,Wh.jsx)(yj,{}),(0,Wh.jsx)(Uj,{}),(0,Wh.jsx)(wj,{}),(0,Wh.jsx)(Mj,{}),(0,Wh.jsx)(zj,{}),(0,Wh.jsx)(Tj,{}),(0,Wh.jsx)(Dj,{}),(0,Wh.jsx)(Fj,{}),(0,Wh.jsx)(Ij,{}),(0,Wh.jsx)(Oj,{}),(0,Wh.jsx)(Lj,{}),(0,Wh.jsx)(Nj,{}),(0,Wh.jsx)(qj,{}),(0,Wh.jsx)(Wj,{}),(0,Wh.jsx)(Xj,{}),(0,Wh.jsx)(Zj,{}),(0,Wh.jsx)(Jj,{}),(0,Wh.jsx)($j,{}),(0,Wh.jsx)(eI,{}),(0,Wh.jsx)(oI,{}),(0,Wh.jsx)(aI,{}),(0,Wh.jsx)(vI,{}),(0,Wh.jsx)(sI,{}),(0,Wh.jsx)(uI,{}),(0,Wh.jsx)(pI,{}),(0,Wh.jsx)(dI,{}),(0,Wh.jsx)(xI,{}),(0,Wh.jsx)(yI,{}),(0,Wh.jsx)(UI,{}),(0,Wh.jsx)(wI,{}),(0,Wh.jsx)(MI,{}),(0,Wh.jsx)(zI,{}),(0,Wh.jsx)(TI,{}),(0,Wh.jsx)(DI,{}),(0,Wh.jsx)(FI,{}),(0,Wh.jsx)(II,{}),(0,Wh.jsx)(OI,{}),(0,Wh.jsx)(LI,{}),(0,Wh.jsx)(NI,{}),(0,Wh.jsx)(qI,{}),(0,Wh.jsx)(WI,{}),(0,Wh.jsx)(XI,{}),(0,Wh.jsx)(ZI,{}),(0,Wh.jsx)(JI,{}),(0,Wh.jsx)($I,{}),(0,Wh.jsx)(eE,{}),(0,Wh.jsx)(oE,{}),(0,Wh.jsx)(aE,{}),(0,Wh.jsx)(vE,{}),(0,Wh.jsx)(sE,{}),(0,Wh.jsx)(uE,{}),(0,Wh.jsx)(pE,{}),(0,Wh.jsx)(dE,{}),(0,Wh.jsx)(xE,{}),(0,Wh.jsx)(yE,{}),(0,Wh.jsx)(UE,{}),(0,Wh.jsx)(wE,{}),(0,Wh.jsx)(ME,{}),(0,Wh.jsx)(zE,{}),(0,Wh.jsx)(TE,{}),(0,Wh.jsx)(DE,{}),(0,Wh.jsx)(FE,{}),(0,Wh.jsx)(IE,{}),(0,Wh.jsx)(OE,{}),(0,Wh.jsx)(LE,{}),(0,Wh.jsx)(NE,{}),(0,Wh.jsx)(qE,{}),(0,Wh.jsx)(WE,{}),(0,Wh.jsx)(XE,{}),(0,Wh.jsx)(ZE,{}),(0,Wh.jsx)(JE,{}),(0,Wh.jsx)($E,{}),(0,Wh.jsx)(eO,{}),(0,Wh.jsx)(oO,{}),(0,Wh.jsx)(aO,{}),(0,Wh.jsx)(vO,{}),(0,Wh.jsx)(sO,{}),(0,Wh.jsx)(uO,{}),(0,Wh.jsx)(pO,{}),(0,Wh.jsx)(dO,{}),(0,Wh.jsx)(xO,{}),(0,Wh.jsx)(yO,{}),(0,Wh.jsx)(UO,{}),(0,Wh.jsx)(wO,{}),(0,Wh.jsx)(MO,{}),(0,Wh.jsx)(zO,{}),(0,Wh.jsx)(TO,{}),(0,Wh.jsx)(DO,{}),(0,Wh.jsx)(FO,{}),(0,Wh.jsx)(IO,{}),(0,Wh.jsx)(OO,{}),(0,Wh.jsx)(LO,{}),(0,Wh.jsx)(NO,{}),(0,Wh.jsx)(qO,{}),(0,Wh.jsx)(WO,{}),(0,Wh.jsx)(XO,{}),(0,Wh.jsx)(ZO,{}),(0,Wh.jsx)(JO,{}),(0,Wh.jsx)($O,{}),(0,Wh.jsx)(eA,{}),(0,Wh.jsx)(oA,{}),(0,Wh.jsx)(aA,{}),(0,Wh.jsx)(vA,{}),(0,Wh.jsx)(sA,{}),(0,Wh.jsx)(uA,{}),(0,Wh.jsx)(pA,{}),(0,Wh.jsx)(dA,{}),(0,Wh.jsx)(xA,{}),(0,Wh.jsx)(yA,{}),(0,Wh.jsx)(UA,{}),(0,Wh.jsx)(wA,{}),(0,Wh.jsx)(MA,{}),(0,Wh.jsx)(zA,{}),(0,Wh.jsx)(TA,{}),(0,Wh.jsx)(DA,{}),(0,Wh.jsx)(FA,{}),(0,Wh.jsx)(IA,{}),(0,Wh.jsx)(OA,{}),(0,Wh.jsx)(LA,{}),(0,Wh.jsx)(NA,{}),(0,Wh.jsx)(qA,{}),(0,Wh.jsx)(WA,{}),(0,Wh.jsx)(XA,{}),(0,Wh.jsx)(ZA,{}),(0,Wh.jsx)(JA,{}),(0,Wh.jsx)($A,{}),(0,Wh.jsx)(eL,{}),(0,Wh.jsx)(oL,{}),(0,Wh.jsx)(aL,{}),(0,Wh.jsx)(vL,{}),(0,Wh.jsx)(sL,{}),(0,Wh.jsx)(uL,{}),(0,Wh.jsx)(pL,{}),(0,Wh.jsx)(dL,{}),(0,Wh.jsx)(xL,{}),(0,Wh.jsx)(yL,{}),(0,Wh.jsx)(UL,{}),(0,Wh.jsx)(wL,{}),(0,Wh.jsx)(ML,{}),(0,Wh.jsx)(zL,{}),(0,Wh.jsx)(TL,{}),(0,Wh.jsx)(DL,{}),(0,Wh.jsx)(FL,{}),(0,Wh.jsx)(IL,{}),(0,Wh.jsx)(EL,{}),(0,Wh.jsx)(OL,{}),(0,Wh.jsx)(AL,{}),(0,Wh.jsx)(LL,{}),(0,Wh.jsx)(GL,{}),(0,Wh.jsx)(NL,{}),(0,Wh.jsx)(BL,{}),(0,Wh.jsx)(qL,{}),(0,Wh.jsx)(VL,{}),(0,Wh.jsx)(WL,{}),(0,Wh.jsx)(HL,{}),(0,Wh.jsx)(XL,{}),(0,Wh.jsx)(YL,{}),(0,Wh.jsx)(ZL,{}),(0,Wh.jsx)(QL,{}),(0,Wh.jsx)(JL,{}),(0,Wh.jsx)(KL,{}),(0,Wh.jsx)($L,{}),(0,Wh.jsx)(nG,{}),(0,Wh.jsx)(eG,{}),(0,Wh.jsx)(tG,{}),(0,Wh.jsx)(oG,{}),(0,Wh.jsx)(rG,{}),(0,Wh.jsx)(iG,{}),(0,Wh.jsx)(cG,{}),(0,Wh.jsx)(sG,{}),(0,Wh.jsx)(lG,{}),(0,Wh.jsx)(uG,{}),(0,Wh.jsx)(fG,{}),(0,Wh.jsx)(SG,{})];return(0,Wh.jsx)(Wh.Fragment,{children:e[n-1]})}var kG=Uint8Array,zG=Uint16Array,CG=Uint32Array,TG=new kG([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),RG=new kG([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),DG=new kG([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),PG=function(n,e){for(var t=new zG(31),o=0;o<31;++o)t[o]=e+=1<<n[o-1];var r=new CG(t[30]);for(o=1;o<30;++o)for(var a=t[o];a<t[o+1];++a)r[a]=a-t[o]<<5|o;return[t,r]},FG=PG(TG,2),jG=FG[0],IG=FG[1];jG[28]=258,IG[258]=28;for(var EG=PG(RG,0),OG=EG[0],AG=(EG[1],new zG(32768)),LG=0;LG<32768;++LG){var GG=(43690&LG)>>>1|(21845&LG)<<1;GG=(61680&(GG=(52428&GG)>>>2|(13107&GG)<<2))>>>4|(3855&GG)<<4,AG[LG]=((65280&GG)>>>8|(255&GG)<<8)>>>1}var NG=function(n,e,t){for(var o=n.length,r=0,a=new zG(e);r<o;++r)++a[n[r]-1];var i,v=new zG(e);for(r=0;r<e;++r)v[r]=v[r-1]+a[r-1]<<1;if(t){i=new zG(1<<e);var c=15-e;for(r=0;r<o;++r)if(n[r])for(var s=r<<4|n[r],l=e-n[r],u=v[n[r]-1]++<<l,f=u|(1<<l)-1;u<=f;++u)i[AG[u]>>>c]=s}else for(i=new zG(o),r=0;r<o;++r)n[r]&&(i[r]=AG[v[n[r]-1]++]>>>15-n[r]);return i},BG=new kG(288);for(LG=0;LG<144;++LG)BG[LG]=8;for(LG=144;LG<256;++LG)BG[LG]=9;for(LG=256;LG<280;++LG)BG[LG]=7;for(LG=280;LG<288;++LG)BG[LG]=8;var qG=new kG(32);for(LG=0;LG<32;++LG)qG[LG]=5;var VG=NG(BG,9,1),WG=NG(qG,5,1),HG=function(n){for(var e=n[0],t=1;t<n.length;++t)n[t]>e&&(e=n[t]);return e},XG=function(n,e,t){var o=e/8|0;return(n[o]|n[o+1]<<8)>>(7&e)&t},YG=function(n,e){var t=e/8|0;return(n[t]|n[t+1]<<8|n[t+2]<<16)>>(7&e)},ZG=function(n){return(n/8|0)+(7&n&&1)},QG=function(n,e,t){(null==e||e<0)&&(e=0),(null==t||t>n.length)&&(t=n.length);var o=new(n instanceof zG?zG:n instanceof CG?CG:kG)(t-e);return o.set(n.subarray(e,t)),o},JG=function(n,e,t){var o=n.length;if(!o||t&&!t.l&&o<5)return e||new kG(0);var r=!e||t,a=!t||t.i;t||(t={}),e||(e=new kG(3*o));var i=function(n){var t=e.length;if(n>t){var o=new kG(Math.max(2*t,n));o.set(e),e=o}},v=t.f||0,c=t.p||0,s=t.b||0,l=t.l,u=t.d,f=t.m,p=t.n,m=8*o;do{if(!l){t.f=v=XG(n,c,1);var d=XG(n,c+1,3);if(c+=3,!d){var h=n[(z=ZG(c)+4)-4]|n[z-3]<<8,x=z+h;if(x>o){if(a)throw"unexpected EOF";break}r&&i(s+h),e.set(n.subarray(z,x),s),t.b=s+=h,t.p=c=8*x;continue}if(1==d)l=VG,u=WG,f=9,p=5;else{if(2!=d)throw"invalid block type";var g=XG(n,c,31)+257,y=XG(n,c+10,15)+4,b=g+XG(n,c+5,31)+1;c+=14;for(var U=new kG(b),_=new kG(19),w=0;w<y;++w)_[DG[w]]=XG(n,c+3*w,7);c+=3*y;var S=HG(_),M=(1<<S)-1,k=NG(_,S,1);for(w=0;w<b;){var z,C=k[XG(n,c,M)];if(c+=15&C,(z=C>>>4)<16)U[w++]=z;else{var T=0,R=0;for(16==z?(R=3+XG(n,c,3),c+=2,T=U[w-1]):17==z?(R=3+XG(n,c,7),c+=3):18==z&&(R=11+XG(n,c,127),c+=7);R--;)U[w++]=T}}var D=U.subarray(0,g),P=U.subarray(g);f=HG(D),p=HG(P),l=NG(D,f,1),u=NG(P,p,1)}if(c>m){if(a)throw"unexpected EOF";break}}r&&i(s+131072);for(var F=(1<<f)-1,j=(1<<p)-1,I=c;;I=c){var E=(T=l[YG(n,c)&F])>>>4;if((c+=15&T)>m){if(a)throw"unexpected EOF";break}if(!T)throw"invalid length/literal";if(E<256)e[s++]=E;else{if(256==E){I=c,l=null;break}var O=E-254;if(E>264){var A=TG[w=E-257];O=XG(n,c,(1<<A)-1)+jG[w],c+=A}var L=u[YG(n,c)&j],G=L>>>4;if(!L)throw"invalid distance";c+=15&L;P=OG[G];if(G>3){A=RG[G];P+=YG(n,c)&(1<<A)-1,c+=A}if(c>m){if(a)throw"unexpected EOF";break}r&&i(s+131072);for(var N=s+O;s<N;s+=4)e[s]=e[s-P],e[s+1]=e[s+1-P],e[s+2]=e[s+2-P],e[s+3]=e[s+3-P];s=N}}t.l=l,t.p=I,t.b=s,l&&(v=1,t.m=f,t.d=u,t.n=p)}while(!v);return s==e.length?e:QG(e,0,s)},KG=new kG(0),$G=function(n){if(8!=(15&n[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)throw"invalid zlib data";if(32&n[1])throw"invalid zlib data: preset dictionaries not supported"};function nN(n,e){return JG(($G(n),n.subarray(2,-4)),e)}var eN="undefined"!=typeof TextDecoder&&new TextDecoder;try{eN.decode(KG,{stream:!0}),1}catch(IN){}function tN(n,e,t){var o=t.length-n-1;if(e>=t[o])return o-1;if(e<=t[n])return n;for(var r=n,a=o,i=Math.floor((r+a)/2);e<t[i]||e>=t[i+1];)e<t[i]?a=i:r=i,i=Math.floor((r+a)/2);return i}function oN(n,e,t,o){var r=[],a=[],i=[];r[0]=1;for(var v=1;v<=t;++v){a[v]=e-o[n+1-v],i[v]=o[n+v]-e;for(var c=0,s=0;s<v;++s){var l=i[s+1],u=a[v-s],f=r[s]/(l+u);r[s]=c+l*f,c=u*f}r[v]=c}return r}function rN(n,e){for(var t=1,o=2;o<=n;++o)t*=o;for(var r=1,a=2;a<=e;++a)r*=a;for(var i=2;i<=n-e;++i)r*=i;return t/r}function aN(n,e,t,o,r){var a=function(n,e,t,o,r){for(var a=r<n?r:n,i=[],v=tN(n,o,e),c=function(n,e,t,o,r){for(var a=[],i=0;i<=t;++i)a[i]=0;for(var v=[],c=0;c<=o;++c)v[c]=a.slice(0);for(var s=[],l=0;l<=t;++l)s[l]=a.slice(0);s[0][0]=1;for(var u=a.slice(0),f=a.slice(0),p=1;p<=t;++p){u[p]=e-r[n+1-p],f[p]=r[n+p]-e;for(var m=0,d=0;d<p;++d){var h=f[d+1],x=u[p-d];s[p][d]=h+x;var g=s[d][p-1]/s[p][d];s[d][p]=m+h*g,m=x*g}s[p][p]=m}for(var y=0;y<=t;++y)v[0][y]=s[y][t];for(var b=0;b<=t;++b){for(var U=0,_=1,w=[],S=0;S<=t;++S)w[S]=a.slice(0);w[0][0]=1;for(var M=1;M<=o;++M){var k=0,z=b-M,C=t-M;b>=M&&(w[_][0]=w[U][0]/s[C+1][z],k=w[_][0]*s[z][C]);for(var T=b-1<=C?M-1:t-b,R=z>=-1?1:-z;R<=T;++R)w[_][R]=(w[U][R]-w[U][R-1])/s[C+1][z+R],k+=w[_][R]*s[z+R][C];b<=C&&(w[_][M]=-w[U][M-1]/s[C+1][b],k+=w[_][M]*s[b][C]),v[M][b]=k;var D=U;U=_,_=D}}for(var P=t,F=1;F<=o;++F){for(var j=0;j<=t;++j)v[F][j]*=P;P*=t-F}return v}(v,o,n,a,e),s=[],l=0;l<t.length;++l){var u=t[l].clone(),f=u.w;u.x*=f,u.y*=f,u.z*=f,s[l]=u}for(var p=0;p<=a;++p){for(var m=s[v-n].clone().multiplyScalar(c[p][0]),d=1;d<=n;++d)m.add(s[v-n+d].clone().multiplyScalar(c[p][d]));i[p]=m}for(var h=a+1;h<=r+1;++h)i[h]=new To(0,0,0);return i}(n,e,t,o,r);return function(n){for(var e=n.length,t=[],o=[],r=0;r<e;++r){var a=n[r];t[r]=new Oo(a.x,a.y,a.z),o[r]=a.w}for(var i=[],v=0;v<e;++v){for(var c=t[v].clone(),s=1;s<=v;++s)c.sub(i[v-s].clone().multiplyScalar(rN(v,s)*o[s]));i[v]=c.divideScalar(o[0])}return i}(a)}var iN,vN,cN,sN=function(n){U(t,n);var e=k(t);function t(n,o,r,a,i){var v;g(this,t),(v=e.call(this)).degree=n,v.knots=o,v.controlPoints=[],v.startKnot=a||0,v.endKnot=i||v.knots.length-1;for(var c=0;c<r.length;++c){var s=r[c];v.controlPoints[c]=new To(s.x,s.y,s.z,s.w)}return v}return b(t,[{key:"getPoint",value:function(n,e){var t=e||new Oo,o=this.knots[this.startKnot]+n*(this.knots[this.endKnot]-this.knots[this.startKnot]),r=function(n,e,t,o){for(var r=tN(n,o,e),a=oN(r,o,n,e),i=new To(0,0,0,0),v=0;v<=n;++v){var c=t[r-n+v],s=a[v],l=c.w*s;i.x+=c.x*l,i.y+=c.y*l,i.z+=c.z*l,i.w+=c.w*s}return i}(this.degree,this.knots,this.controlPoints,o);return 1!=r.w&&r.divideScalar(r.w),t.set(r.x,r.y,r.z)}},{key:"getTangent",value:function(n,e){var t=e||new Oo,o=this.knots[0]+n*(this.knots[this.knots.length-1]-this.knots[0]),r=aN(this.degree,this.knots,this.controlPoints,o,1);return t.copy(r[1]).normalize(),t}}]),t}(Ys),lN=function(n){U(t,n);var e=k(t);function t(n){return g(this,t),e.call(this,n)}return b(t,[{key:"load",value:function(n,e,t,o){var r=this,a=""===r.path?Rf.extractUrlBase(n):r.path,i=new tf(this.manager);i.setPath(r.path),i.setResponseType("arraybuffer"),i.setRequestHeader(r.requestHeader),i.setWithCredentials(r.withCredentials),i.load(n,(function(t){try{e(r.parse(t,a))}catch(IN){o?o(IN):console.error(IN),r.manager.itemError(n)}}),t,o)}},{key:"parse",value:function(n,e){if(function(n){var e="Kaydara FBX Binary  \0";return n.byteLength>=e.length&&e===zN(n,0,e.length)}(n))iN=(new dN).parse(n);else{var t=zN(n);if(!function(n){var e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"],t=0;function o(e){var o=n[e-1];return n=n.slice(t+e),t++,o}for(var r=0;r<e.length;++r){if(o(1)===e[r])return!1}return!0}(t))throw new Error("THREE.FBXLoader: Unknown format.");if(gN(t)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+gN(t));iN=(new mN).parse(t)}var o=new sf(this.manager).setPath(this.resourcePath||e).setCrossOrigin(this.crossOrigin);return new uN(o,this.manager).parse(iN)}}]),t}($u),uN=function(){function n(e,t){g(this,n),this.textureLoader=e,this.manager=t}return b(n,[{key:"parse",value:function(){vN=this.parseConnections();var n=this.parseImages(),e=this.parseTextures(n),t=this.parseMaterials(e),o=this.parseDeformers(),r=(new fN).parse(o);return this.parseScene(o,r,t),cN}},{key:"parseConnections",value:function(){var n=new Map;"Connections"in iN&&iN.Connections.connections.forEach((function(e){var t=e[0],o=e[1],r=e[2];n.has(t)||n.set(t,{parents:[],children:[]});var a={ID:o,relationship:r};n.get(t).parents.push(a),n.has(o)||n.set(o,{parents:[],children:[]});var i={ID:t,relationship:r};n.get(o).children.push(i)}));return n}},{key:"parseImages",value:function(){var n={},e={};if("Video"in iN.Objects){var t=iN.Objects.Video;for(var o in t){var r=t[o];if(n[parseInt(o)]=r.RelativeFilename||r.Filename,"Content"in r){var a=r.Content instanceof ArrayBuffer&&r.Content.byteLength>0,i="string"===typeof r.Content&&""!==r.Content;if(a||i){var v=this.parseImage(t[o]);e[r.RelativeFilename||r.Filename]=v}}}}for(var c in n){var s=n[c];void 0!==e[s]?n[c]=e[s]:n[c]=n[c].split("\\").pop()}return n}},{key:"parseImage",value:function(n){var e,t=n.Content,o=n.RelativeFilename||n.Filename,r=o.slice(o.lastIndexOf(".")+1).toLowerCase();switch(r){case"bmp":e="image/bmp";break;case"jpg":case"jpeg":e="image/jpeg";break;case"png":e="image/png";break;case"tif":e="image/tiff";break;case"tga":null===this.manager.getHandler(".tga")&&console.warn("FBXLoader: TGA loader not found, skipping ",o),e="image/tga";break;default:return void console.warn('FBXLoader: Image type "'+r+'" is not supported.')}if("string"===typeof t)return"data:"+e+";base64,"+t;var a=new Uint8Array(t);return window.URL.createObjectURL(new Blob([a],{type:e}))}},{key:"parseTextures",value:function(n){var e=new Map;if("Texture"in iN.Objects){var t=iN.Objects.Texture;for(var o in t){var r=this.parseTexture(t[o],n);e.set(parseInt(o),r)}}return e}},{key:"parseTexture",value:function(n,e){var t=this.loadTexture(n,e);t.ID=n.id,t.name=n.attrName;var o=n.WrapModeU,r=n.WrapModeV,a=void 0!==o?o.value:0,i=void 0!==r?r.value:0;if(t.wrapS=0===a?Ln:Gn,t.wrapT=0===i?Ln:Gn,"Scaling"in n){var v=n.Scaling.value;t.repeat.x=v[0],t.repeat.y=v[1]}return t}},{key:"loadTexture",value:function(n,e){var t,o,r=this.textureLoader.path,a=vN.get(n.id).children;void 0!==a&&a.length>0&&void 0!==e[a[0].ID]&&(0!==(t=e[a[0].ID]).indexOf("blob:")&&0!==t.indexOf("data:")||this.textureLoader.setPath(void 0));var i=n.FileName.slice(-3).toLowerCase();if("tga"===i){var v=this.manager.getHandler(".tga");null===v?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",n.RelativeFilename),o=new Co):(v.setPath(this.textureLoader.path),o=v.load(t))}else"psd"===i?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",n.RelativeFilename),o=new Co):o=this.textureLoader.load(t);return this.textureLoader.setPath(r),o}},{key:"parseMaterials",value:function(n){var e=new Map;if("Material"in iN.Objects){var t=iN.Objects.Material;for(var o in t){var r=this.parseMaterial(t[o],n);null!==r&&e.set(parseInt(o),r)}}return e}},{key:"parseMaterial",value:function(n,e){var t=n.id,o=n.attrName,r=n.ShadingModel;if("object"===typeof r&&(r=r.value),!vN.has(t))return null;var a,i=this.parseParameters(n,e,t);switch(r.toLowerCase()){case"phong":a=new _u;break;case"lambert":a=new Mu;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',r),a=new _u}return a.setValues(i),a.name=o,a}},{key:"parseParameters",value:function(n,e,t){var o={};n.BumpFactor&&(o.bumpScale=n.BumpFactor.value),n.Diffuse?o.color=(new wo).fromArray(n.Diffuse.value):!n.DiffuseColor||"Color"!==n.DiffuseColor.type&&"ColorRGB"!==n.DiffuseColor.type||(o.color=(new wo).fromArray(n.DiffuseColor.value)),n.DisplacementFactor&&(o.displacementScale=n.DisplacementFactor.value),n.Emissive?o.emissive=(new wo).fromArray(n.Emissive.value):!n.EmissiveColor||"Color"!==n.EmissiveColor.type&&"ColorRGB"!==n.EmissiveColor.type||(o.emissive=(new wo).fromArray(n.EmissiveColor.value)),n.EmissiveFactor&&(o.emissiveIntensity=parseFloat(n.EmissiveFactor.value)),n.Opacity&&(o.opacity=parseFloat(n.Opacity.value)),o.opacity<1&&(o.transparent=!0),n.ReflectionFactor&&(o.reflectivity=n.ReflectionFactor.value),n.Shininess&&(o.shininess=n.Shininess.value),n.Specular?o.specular=(new wo).fromArray(n.Specular.value):n.SpecularColor&&"Color"===n.SpecularColor.type&&(o.specular=(new wo).fromArray(n.SpecularColor.value));var r=this;return vN.get(t).children.forEach((function(n){var t=n.relationship;switch(t){case"Bump":o.bumpMap=r.getTexture(e,n.ID);break;case"Maya|TEX_ao_map":o.aoMap=r.getTexture(e,n.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":o.map=r.getTexture(e,n.ID),void 0!==o.map&&("colorSpace"in o.map?o.map.colorSpace="srgb":o.map.encoding=3001);break;case"DisplacementColor":o.displacementMap=r.getTexture(e,n.ID);break;case"EmissiveColor":o.emissiveMap=r.getTexture(e,n.ID),void 0!==o.emissiveMap&&("colorSpace"in o.emissiveMap?o.emissiveMap.colorSpace="srgb":o.emissiveMap.encoding=3001);break;case"NormalMap":case"Maya|TEX_normal_map":o.normalMap=r.getTexture(e,n.ID);break;case"ReflectionColor":o.envMap=r.getTexture(e,n.ID),void 0!==o.envMap&&(o.envMap.mapping=En,"colorSpace"in o.envMap?o.envMap.colorSpace="srgb":o.envMap.encoding=3001);break;case"SpecularColor":o.specularMap=r.getTexture(e,n.ID),void 0!==o.specularMap&&("colorSpace"in o.specularMap?o.specularMap.colorSpace="srgb":o.specularMap.encoding=3001);break;case"TransparentColor":case"TransparencyFactor":o.alphaMap=r.getTexture(e,n.ID),o.transparent=!0;break;default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",t)}})),o}},{key:"getTexture",value:function(n,e){return"LayeredTexture"in iN.Objects&&e in iN.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),e=vN.get(e).children[0].ID),n.get(e)}},{key:"parseDeformers",value:function(){var n={},e={};if("Deformer"in iN.Objects){var t=iN.Objects.Deformer;for(var o in t){var r=t[o],a=vN.get(parseInt(o));if("Skin"===r.attrType){var i=this.parseSkeleton(a,t);i.ID=o,a.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),i.geometryID=a.parents[0].ID,n[o]=i}else if("BlendShape"===r.attrType){var v={id:o};v.rawTargets=this.parseMorphTargets(a,t),v.id=o,a.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),e[o]=v}}}return{skeletons:n,morphTargets:e}}},{key:"parseSkeleton",value:function(n,e){var t=[];return n.children.forEach((function(n){var o=e[n.ID];if("Cluster"===o.attrType){var r={ID:n.ID,indices:[],weights:[],transformLink:(new pr).fromArray(o.TransformLink.a)};"Indexes"in o&&(r.indices=o.Indexes.a,r.weights=o.Weights.a),t.push(r)}})),{rawBones:t,bones:[]}}},{key:"parseMorphTargets",value:function(n,e){for(var t=[],o=0;o<n.children.length;o++){var r=n.children[o],a=e[r.ID],i={name:a.attrName,initialWeight:a.DeformPercent,id:a.id,fullWeights:a.FullWeights.a};if("BlendShapeChannel"!==a.attrType)return;i.geoID=vN.get(parseInt(r.ID)).children.filter((function(n){return void 0===n.relationship}))[0].ID,t.push(i)}return t}},{key:"parseScene",value:function(n,e,t){cN=new kc;var o=this.parseModels(n.skeletons,e,t),r=iN.Objects.Model,a=this;o.forEach((function(n){var e=r[n.ID];a.setLookAtProperties(n,e),vN.get(n.ID).parents.forEach((function(e){var t=o.get(e.ID);void 0!==t&&t.add(n)})),null===n.parent&&cN.add(n)})),this.bindSkeleton(n.skeletons,e,o),this.createAmbientLight(),cN.traverse((function(n){if(n.userData.transformData){n.parent&&(n.userData.transformData.parentMatrix=n.parent.matrix,n.userData.transformData.parentMatrixWorld=n.parent.matrixWorld);var e=SN(n.userData.transformData);n.applyMatrix4(e),n.updateWorldMatrix()}}));var i=(new pN).parse();1===cN.children.length&&cN.children[0].isGroup&&(cN.children[0].animations=i,cN=cN.children[0]),cN.animations=i}},{key:"parseModels",value:function(n,e,t){var o=new Map,r=iN.Objects.Model;for(var a in r){var i=parseInt(a),v=r[a],c=vN.get(i),s=this.buildSkeleton(c,n,i,v.attrName);if(!s){switch(v.attrType){case"Camera":s=this.createCamera(c);break;case"Light":s=this.createLight(c);break;case"Mesh":s=this.createMesh(c,e,t);break;case"NurbsCurve":s=this.createCurve(c,e);break;case"LimbNode":case"Root":s=new ps;break;default:s=new kc}s.name=v.attrName?mp.sanitizeNodeName(v.attrName):"",s.ID=i}this.getTransformData(s,v),o.set(i,s)}return o}},{key:"buildSkeleton",value:function(n,e,t,o){var r=null;return n.parents.forEach((function(n){var a=function(a){var i=e[a];i.rawBones.forEach((function(e,a){if(e.ID===n.ID){var v=r;(r=new ps).matrixWorld.copy(e.transformLink),r.name=o?mp.sanitizeNodeName(o):"",r.ID=t,i.bones[a]=r,null!==v&&r.add(v)}}))};for(var i in e)a(i)})),r}},{key:"createCamera",value:function(n){var e,t;if(n.children.forEach((function(n){var e=iN.Objects.NodeAttribute[n.ID];void 0!==e&&(t=e)})),void 0===t)e=new Ar;else{var o=0;void 0!==t.CameraProjectionType&&1===t.CameraProjectionType.value&&(o=1);var r=1;void 0!==t.NearPlane&&(r=t.NearPlane.value/1e3);var a=1e3;void 0!==t.FarPlane&&(a=t.FarPlane.value/1e3);var i=window.innerWidth,v=window.innerHeight;void 0!==t.AspectWidth&&void 0!==t.AspectHeight&&(i=t.AspectWidth.value,v=t.AspectHeight.value);var c=i/v,s=45;void 0!==t.FieldOfView&&(s=t.FieldOfView.value);var l=t.FocalLength?t.FocalLength.value:null;switch(o){case 0:e=new Wa(s,c,r,a),null!==l&&e.setFocalLength(l);break;case 1:e=new di(-i/2,i/2,v/2,-v/2,r,a);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+o+"."),e=new Ar}}return e}},{key:"createLight",value:function(n){var e,t;if(n.children.forEach((function(n){var e=iN.Objects.NodeAttribute[n.ID];void 0!==e&&(t=e)})),void 0===t)e=new Ar;else{var o;o=void 0===t.LightType?0:t.LightType.value;var r=16777215;void 0!==t.Color&&(r=(new wo).fromArray(t.Color.value));var a=void 0===t.Intensity?1:t.Intensity.value/100;void 0!==t.CastLightOnObject&&0===t.CastLightOnObject.value&&(a=0);var i=0;void 0!==t.FarAttenuationEnd&&(i=void 0!==t.EnableFarAttenuation&&0===t.EnableFarAttenuation.value?0:t.FarAttenuationEnd.value);switch(o){case 0:e=new _f(r,a,i,1);break;case 1:e=new Sf(r,a);break;case 2:var v=Math.PI/3;void 0!==t.InnerAngle&&(v=ro.degToRad(t.InnerAngle.value));var c=0;void 0!==t.OuterAngle&&(c=ro.degToRad(t.OuterAngle.value),c=Math.max(c,1)),e=new xf(r,a,i,v,c,1);break;default:console.warn("THREE.FBXLoader: Unknown light type "+t.LightType.value+", defaulting to a PointLight."),e=new _f(r,a)}void 0!==t.CastShadows&&1===t.CastShadows.value&&(e.castShadow=!0)}return e}},{key:"createMesh",value:function(n,e,t){var o,r=null,a=null,i=[];return n.children.forEach((function(n){e.has(n.ID)&&(r=e.get(n.ID)),t.has(n.ID)&&i.push(t.get(n.ID))})),i.length>1?a=i:i.length>0?a=i[0]:(a=new _u({color:13421772}),i.push(a)),"color"in r.attributes&&i.forEach((function(n){n.vertexColors=!0})),r.FBX_Deformer?(o=new fs(r,a)).normalizeSkinWeights():o=new Oa(r,a),o}},{key:"createCurve",value:function(n,e){var t=n.children.reduce((function(n,t){return e.has(t.ID)&&(n=e.get(t.ID)),n}),null),o=new Ms({color:3342591,linewidth:1});return new Ds(t,o)}},{key:"getTransformData",value:function(n,e){var t={};"InheritType"in e&&(t.inheritType=parseInt(e.InheritType.value)),t.eulerOrder="RotationOrder"in e?MN(e.RotationOrder.value):"ZYX","Lcl_Translation"in e&&(t.translation=e.Lcl_Translation.value),"PreRotation"in e&&(t.preRotation=e.PreRotation.value),"Lcl_Rotation"in e&&(t.rotation=e.Lcl_Rotation.value),"PostRotation"in e&&(t.postRotation=e.PostRotation.value),"Lcl_Scaling"in e&&(t.scale=e.Lcl_Scaling.value),"ScalingOffset"in e&&(t.scalingOffset=e.ScalingOffset.value),"ScalingPivot"in e&&(t.scalingPivot=e.ScalingPivot.value),"RotationOffset"in e&&(t.rotationOffset=e.RotationOffset.value),"RotationPivot"in e&&(t.rotationPivot=e.RotationPivot.value),n.userData.transformData=t}},{key:"setLookAtProperties",value:function(n,e){"LookAtProperty"in e&&vN.get(n.ID).children.forEach((function(e){if("LookAtProperty"===e.relationship){var t=iN.Objects.Model[e.ID];if("Lcl_Translation"in t){var o=t.Lcl_Translation.value;void 0!==n.target?(n.target.position.fromArray(o),cN.add(n.target)):n.lookAt((new Oo).fromArray(o))}}}))}},{key:"bindSkeleton",value:function(n,e,t){var o=this.parsePoseNodes(),r=function(r){var a=n[r];vN.get(parseInt(a.ID)).parents.forEach((function(n){if(e.has(n.ID)){var r=n.ID;vN.get(r).parents.forEach((function(n){t.has(n.ID)&&t.get(n.ID).bind(new xs(a.bones),o[n.ID])}))}}))};for(var a in n)r(a)}},{key:"parsePoseNodes",value:function(){var n={};if("Pose"in iN.Objects){var e=iN.Objects.Pose;for(var t in e)if("BindPose"===e[t].attrType&&e[t].NbPoseNodes>0){var o=e[t].PoseNode;Array.isArray(o)?o.forEach((function(e){n[e.Node]=(new pr).fromArray(e.Matrix.a)})):n[o.Node]=(new pr).fromArray(o.Matrix.a)}}return n}},{key:"createAmbientLight",value:function(){if("GlobalSettings"in iN&&"AmbientColor"in iN.GlobalSettings){var n=iN.GlobalSettings.AmbientColor.value,e=n[0],t=n[1],o=n[2];if(0!==e||0!==t||0!==o){var r=new wo(e,t,o);cN.add(new Mf(r,1))}}}}]),n}(),fN=function(){function n(){g(this,n)}return b(n,[{key:"parse",value:function(n){var e=new Map;if("Geometry"in iN.Objects){var t=iN.Objects.Geometry;for(var o in t){var r=vN.get(parseInt(o)),a=this.parseGeometry(r,t[o],n);e.set(parseInt(o),a)}}return e}},{key:"parseGeometry",value:function(n,e,t){switch(e.attrType){case"Mesh":return this.parseMeshGeometry(n,e,t);case"NurbsCurve":return this.parseNurbsGeometry(e)}}},{key:"parseMeshGeometry",value:function(n,e,t){var o=t.skeletons,r=[],a=n.parents.map((function(n){return iN.Objects.Model[n.ID]}));if(0!==a.length){var i=n.children.reduce((function(n,e){return void 0!==o[e.ID]&&(n=o[e.ID]),n}),null);n.children.forEach((function(n){void 0!==t.morphTargets[n.ID]&&r.push(t.morphTargets[n.ID])}));var v=a[0],c={};"RotationOrder"in v&&(c.eulerOrder=MN(v.RotationOrder.value)),"InheritType"in v&&(c.inheritType=parseInt(v.InheritType.value)),"GeometricTranslation"in v&&(c.translation=v.GeometricTranslation.value),"GeometricRotation"in v&&(c.rotation=v.GeometricRotation.value),"GeometricScaling"in v&&(c.scale=v.GeometricScaling.value);var s=SN(c);return this.genGeometry(e,i,r,s)}}},{key:"genGeometry",value:function(n,e,t,o){var r=new ya;n.attrName&&(r.name=n.attrName);var a=this.parseGeoNode(n,e),i=this.genBuffers(a),v=new la(i.vertex,3);if(v.applyMatrix4(o),r.setAttribute("position",v),i.colors.length>0&&r.setAttribute("color",new la(i.colors,3)),e&&(r.setAttribute("skinIndex",new ia(i.weightsIndices,4)),r.setAttribute("skinWeight",new la(i.vertexWeights,4)),r.FBX_Deformer=e),i.normal.length>0){var c=(new io).getNormalMatrix(o),s=new la(i.normal,3);s.applyNormalMatrix(c),r.setAttribute("normal",s)}if(i.uvs.forEach((function(n,e){var t="uv"+(e+1).toString();0===e&&(t="uv"),r.setAttribute(t,new la(i.uvs[e],2))})),a.material&&"AllSame"!==a.material.mappingType){var l=i.materialIndex[0],u=0;if(i.materialIndex.forEach((function(n,e){n!==l&&(r.addGroup(u,e-u,l),l=n,u=e)})),r.groups.length>0){var f=r.groups[r.groups.length-1],p=f.start+f.count;p!==i.materialIndex.length&&r.addGroup(p,i.materialIndex.length-p,l)}0===r.groups.length&&r.addGroup(0,i.materialIndex.length,i.materialIndex[0])}return this.addMorphTargets(r,n,t,o),r}},{key:"parseGeoNode",value:function(n,e){var t={};if(t.vertexPositions=void 0!==n.Vertices?n.Vertices.a:[],t.vertexIndices=void 0!==n.PolygonVertexIndex?n.PolygonVertexIndex.a:[],n.LayerElementColor&&(t.color=this.parseVertexColors(n.LayerElementColor[0])),n.LayerElementMaterial&&(t.material=this.parseMaterialIndices(n.LayerElementMaterial[0])),n.LayerElementNormal&&(t.normal=this.parseNormals(n.LayerElementNormal[0])),n.LayerElementUV){t.uv=[];for(var o=0;n.LayerElementUV[o];)n.LayerElementUV[o].UV&&t.uv.push(this.parseUVs(n.LayerElementUV[o])),o++}return t.weightTable={},null!==e&&(t.skeleton=e,e.rawBones.forEach((function(n,e){n.indices.forEach((function(o,r){void 0===t.weightTable[o]&&(t.weightTable[o]=[]),t.weightTable[o].push({id:e,weight:n.weights[r]})}))}))),t}},{key:"genBuffers",value:function(n){var e={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]},t=0,o=0,r=!1,a=[],i=[],v=[],c=[],s=[],l=[],u=this;return n.vertexIndices.forEach((function(f,p){var m,d=!1;f<0&&(f^=-1,d=!0);var h=[],x=[];if(a.push(3*f,3*f+1,3*f+2),n.color){var g=UN(p,t,f,n.color);v.push(g[0],g[1],g[2])}if(n.skeleton){if(void 0!==n.weightTable[f]&&n.weightTable[f].forEach((function(n){x.push(n.weight),h.push(n.id)})),x.length>4){r||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),r=!0);var y=[0,0,0,0],b=[0,0,0,0];x.forEach((function(n,e){var t=n,o=h[e];b.forEach((function(n,e,r){if(t>n){r[e]=t,t=n;var a=y[e];y[e]=o,o=a}}))})),h=y,x=b}for(;x.length<4;)x.push(0),h.push(0);for(var U=0;U<4;++U)s.push(x[U]),l.push(h[U])}if(n.normal){var _=UN(p,t,f,n.normal);i.push(_[0],_[1],_[2])}n.material&&"AllSame"!==n.material.mappingType&&(m=UN(p,t,f,n.material)[0]),n.uv&&n.uv.forEach((function(n,e){var o=UN(p,t,f,n);void 0===c[e]&&(c[e]=[]),c[e].push(o[0]),c[e].push(o[1])})),o++,d&&(u.genFace(e,n,a,m,i,v,c,s,l,o),t++,o=0,a=[],i=[],v=[],c=[],s=[],l=[])})),e}},{key:"genFace",value:function(n,e,t,o,r,a,i,v,c,s){for(var l=function(s){n.vertex.push(e.vertexPositions[t[0]]),n.vertex.push(e.vertexPositions[t[1]]),n.vertex.push(e.vertexPositions[t[2]]),n.vertex.push(e.vertexPositions[t[3*(s-1)]]),n.vertex.push(e.vertexPositions[t[3*(s-1)+1]]),n.vertex.push(e.vertexPositions[t[3*(s-1)+2]]),n.vertex.push(e.vertexPositions[t[3*s]]),n.vertex.push(e.vertexPositions[t[3*s+1]]),n.vertex.push(e.vertexPositions[t[3*s+2]]),e.skeleton&&(n.vertexWeights.push(v[0]),n.vertexWeights.push(v[1]),n.vertexWeights.push(v[2]),n.vertexWeights.push(v[3]),n.vertexWeights.push(v[4*(s-1)]),n.vertexWeights.push(v[4*(s-1)+1]),n.vertexWeights.push(v[4*(s-1)+2]),n.vertexWeights.push(v[4*(s-1)+3]),n.vertexWeights.push(v[4*s]),n.vertexWeights.push(v[4*s+1]),n.vertexWeights.push(v[4*s+2]),n.vertexWeights.push(v[4*s+3]),n.weightsIndices.push(c[0]),n.weightsIndices.push(c[1]),n.weightsIndices.push(c[2]),n.weightsIndices.push(c[3]),n.weightsIndices.push(c[4*(s-1)]),n.weightsIndices.push(c[4*(s-1)+1]),n.weightsIndices.push(c[4*(s-1)+2]),n.weightsIndices.push(c[4*(s-1)+3]),n.weightsIndices.push(c[4*s]),n.weightsIndices.push(c[4*s+1]),n.weightsIndices.push(c[4*s+2]),n.weightsIndices.push(c[4*s+3])),e.color&&(n.colors.push(a[0]),n.colors.push(a[1]),n.colors.push(a[2]),n.colors.push(a[3*(s-1)]),n.colors.push(a[3*(s-1)+1]),n.colors.push(a[3*(s-1)+2]),n.colors.push(a[3*s]),n.colors.push(a[3*s+1]),n.colors.push(a[3*s+2])),e.material&&"AllSame"!==e.material.mappingType&&(n.materialIndex.push(o),n.materialIndex.push(o),n.materialIndex.push(o)),e.normal&&(n.normal.push(r[0]),n.normal.push(r[1]),n.normal.push(r[2]),n.normal.push(r[3*(s-1)]),n.normal.push(r[3*(s-1)+1]),n.normal.push(r[3*(s-1)+2]),n.normal.push(r[3*s]),n.normal.push(r[3*s+1]),n.normal.push(r[3*s+2])),e.uv&&e.uv.forEach((function(e,t){void 0===n.uvs[t]&&(n.uvs[t]=[]),n.uvs[t].push(i[t][0]),n.uvs[t].push(i[t][1]),n.uvs[t].push(i[t][2*(s-1)]),n.uvs[t].push(i[t][2*(s-1)+1]),n.uvs[t].push(i[t][2*s]),n.uvs[t].push(i[t][2*s+1])}))},u=2;u<s;u++)l(u)}},{key:"addMorphTargets",value:function(n,e,t,o){if(0!==t.length){n.morphTargetsRelative=!0,n.morphAttributes.position=[];var r=this;t.forEach((function(t){t.rawTargets.forEach((function(t){var a=iN.Objects.Geometry[t.geoID];void 0!==a&&r.genMorphGeometry(n,e,a,o,t.name)}))}))}}},{key:"genMorphGeometry",value:function(n,e,t,o,r){for(var a=void 0!==e.PolygonVertexIndex?e.PolygonVertexIndex.a:[],i=void 0!==t.Vertices?t.Vertices.a:[],v=void 0!==t.Indexes?t.Indexes.a:[],c=3*n.attributes.position.count,s=new Float32Array(c),l=0;l<v.length;l++){var u=3*v[l];s[u]=i[3*l],s[u+1]=i[3*l+1],s[u+2]=i[3*l+2]}var f={vertexIndices:a,vertexPositions:s},p=this.genBuffers(f),m=new la(p.vertex,3);m.name=r||t.attrName,m.applyMatrix4(o),n.morphAttributes.position.push(m)}},{key:"parseNormals",value:function(n){var e=n.MappingInformationType,t=n.ReferenceInformationType,o=n.Normals.a,r=[];return"IndexToDirect"===t&&("NormalIndex"in n?r=n.NormalIndex.a:"NormalsIndex"in n&&(r=n.NormalsIndex.a)),{dataSize:3,buffer:o,indices:r,mappingType:e,referenceType:t}}},{key:"parseUVs",value:function(n){var e=n.MappingInformationType,t=n.ReferenceInformationType,o=n.UV.a,r=[];return"IndexToDirect"===t&&(r=n.UVIndex.a),{dataSize:2,buffer:o,indices:r,mappingType:e,referenceType:t}}},{key:"parseVertexColors",value:function(n){var e=n.MappingInformationType,t=n.ReferenceInformationType,o=n.Colors.a,r=[];return"IndexToDirect"===t&&(r=n.ColorIndex.a),{dataSize:4,buffer:o,indices:r,mappingType:e,referenceType:t}}},{key:"parseMaterialIndices",value:function(n){var e=n.MappingInformationType,t=n.ReferenceInformationType;if("NoMappingInformation"===e)return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:t};for(var o=n.Materials.a,r=[],a=0;a<o.length;++a)r.push(a);return{dataSize:1,buffer:o,indices:r,mappingType:e,referenceType:t}}},{key:"parseNurbsGeometry",value:function(n){if(void 0===sN)return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),new ya;var e=parseInt(n.Order);if(isNaN(e))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",n.Order,n.id),new ya;for(var t,o,r=e-1,a=n.KnotVector.a,i=[],v=n.Points.a,c=0,s=v.length;c<s;c+=4)i.push((new To).fromArray(v,c));if("Closed"===n.Form)i.push(i[0]);else if("Periodic"===n.Form){t=r,o=a.length-1-t;for(var l=0;l<r;++l)i.push(i[l])}var u=new sN(r,a,i,t,o).getPoints(12*i.length);return(new ya).setFromPoints(u)}}]),n}(),pN=function(){function n(){g(this,n)}return b(n,[{key:"parse",value:function(){var n=[],e=this.parseClips();if(void 0!==e)for(var t in e){var o=e[t],r=this.addClip(o);n.push(r)}return n}},{key:"parseClips",value:function(){if(void 0!==iN.Objects.AnimationCurve){var n=this.parseAnimationCurveNodes();this.parseAnimationCurves(n);var e=this.parseAnimationLayers(n);return this.parseAnimStacks(e)}}},{key:"parseAnimationCurveNodes",value:function(){var n=iN.Objects.AnimationCurveNode,e=new Map;for(var t in n){var o=n[t];if(null!==o.attrName.match(/S|R|T|DeformPercent/)){var r={id:o.id,attr:o.attrName,curves:{}};e.set(r.id,r)}}return e}},{key:"parseAnimationCurves",value:function(n){var e=iN.Objects.AnimationCurve;for(var t in e){var o={id:e[t].id,times:e[t].KeyTime.a.map(yN),values:e[t].KeyValueFloat.a},r=vN.get(o.id);if(void 0!==r){var a=r.parents[0].ID,i=r.parents[0].relationship;i.match(/X/)?n.get(a).curves.x=o:i.match(/Y/)?n.get(a).curves.y=o:i.match(/Z/)?n.get(a).curves.z=o:i.match(/d|DeformPercent/)&&n.has(a)&&(n.get(a).curves.morph=o)}}}},{key:"parseAnimationLayers",value:function(n){var e=iN.Objects.AnimationLayer,t=new Map,o=function(e){var o=[],r=vN.get(parseInt(e));void 0!==r&&(r.children.forEach((function(e,t){if(n.has(e.ID)){var r=n.get(e.ID);if(void 0!==r.curves.x||void 0!==r.curves.y||void 0!==r.curves.z){if(void 0===o[t]){var a=vN.get(e.ID).parents.filter((function(n){return void 0!==n.relationship}))[0].ID;if(void 0!==a){var i=iN.Objects.Model[a.toString()];if(void 0===i)return void console.warn("THREE.FBXLoader: Encountered a unused curve.",e);var v={modelName:i.attrName?mp.sanitizeNodeName(i.attrName):"",ID:i.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};cN.traverse((function(n){n.ID===i.id&&(v.transform=n.matrix,n.userData.transformData&&(v.eulerOrder=n.userData.transformData.eulerOrder))})),v.transform||(v.transform=new pr),"PreRotation"in i&&(v.preRotation=i.PreRotation.value),"PostRotation"in i&&(v.postRotation=i.PostRotation.value),o[t]=v}}o[t]&&(o[t][r.attr]=r)}else if(void 0!==r.curves.morph){if(void 0===o[t]){var c=vN.get(e.ID).parents.filter((function(n){return void 0!==n.relationship}))[0].ID,s=vN.get(c).parents[0].ID,l=vN.get(s).parents[0].ID,u=vN.get(l).parents[0].ID,f=iN.Objects.Model[u],p={modelName:f.attrName?mp.sanitizeNodeName(f.attrName):"",morphName:iN.Objects.Deformer[c].attrName};o[t]=p}o[t][r.attr]=r}}})),t.set(parseInt(e),o))};for(var r in e)o(r);return t}},{key:"parseAnimStacks",value:function(n){var e=iN.Objects.AnimationStack,t={};for(var o in e){var r=vN.get(parseInt(o)).children;r.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");var a=n.get(r[0].ID);t[o]={name:e[o].attrName,layer:a}}return t}},{key:"addClip",value:function(n){var e=[],t=this;return n.layer.forEach((function(n){e=e.concat(t.generateTracks(n))})),new Xu(n.name,-1,e)}},{key:"generateTracks",value:function(n){var e=[],t=new Oo,o=new Eo,r=new Oo;if(n.transform&&n.transform.decompose(t,o,r),t=t.toArray(),o=(new wr).setFromQuaternion(o,n.eulerOrder).toArray(),r=r.toArray(),void 0!==n.T&&Object.keys(n.T.curves).length>0){var a=this.generateVectorTrack(n.modelName,n.T.curves,t,"position");void 0!==a&&e.push(a)}if(void 0!==n.R&&Object.keys(n.R.curves).length>0){var i=this.generateRotationTrack(n.modelName,n.R.curves,o,n.preRotation,n.postRotation,n.eulerOrder);void 0!==i&&e.push(i)}if(void 0!==n.S&&Object.keys(n.S.curves).length>0){var v=this.generateVectorTrack(n.modelName,n.S.curves,r,"scale");void 0!==v&&e.push(v)}if(void 0!==n.DeformPercent){var c=this.generateMorphTrack(n);void 0!==c&&e.push(c)}return e}},{key:"generateVectorTrack",value:function(n,e,t,o){var r=this.getTimesForAllAxes(e),a=this.getKeyframeTrackValues(r,e,t);return new Hu(n+"."+o,r,a)}},{key:"generateRotationTrack",value:function(n,e,t,o,r,a){void 0!==e.x&&(this.interpolateRotations(e.x),e.x.values=e.x.values.map(ro.degToRad)),void 0!==e.y&&(this.interpolateRotations(e.y),e.y.values=e.y.values.map(ro.degToRad)),void 0!==e.z&&(this.interpolateRotations(e.z),e.z.values=e.z.values.map(ro.degToRad));var i=this.getTimesForAllAxes(e),v=this.getKeyframeTrackValues(i,e,t);void 0!==o&&((o=o.map(ro.degToRad)).push(a),o=(new wr).fromArray(o),o=(new Eo).setFromEuler(o)),void 0!==r&&((r=r.map(ro.degToRad)).push(a),r=(new wr).fromArray(r),r=(new Eo).setFromEuler(r).invert());for(var c=new Eo,s=new wr,l=[],u=0;u<v.length;u+=3)s.set(v[u],v[u+1],v[u+2],a),c.setFromEuler(s),void 0!==o&&c.premultiply(o),void 0!==r&&c.multiply(r),c.toArray(l,u/3*4);return new Vu(n+".quaternion",i,l)}},{key:"generateMorphTrack",value:function(n){var e=n.DeformPercent.curves.morph,t=e.values.map((function(n){return n/100})),o=cN.getObjectByName(n.modelName).morphTargetDictionary[n.morphName];return new Bu(n.modelName+".morphTargetInfluences["+o+"]",e.times,t)}},{key:"getTimesForAllAxes",value:function(n){var e=[];if(void 0!==n.x&&(e=e.concat(n.x.times)),void 0!==n.y&&(e=e.concat(n.y.times)),void 0!==n.z&&(e=e.concat(n.z.times)),(e=e.sort((function(n,e){return n-e}))).length>1){for(var t=1,o=e[0],r=1;r<e.length;r++){var a=e[r];a!==o&&(e[t]=a,o=a,t++)}e=e.slice(0,t)}return e}},{key:"getKeyframeTrackValues",value:function(n,e,t){var o=t,r=[],a=-1,i=-1,v=-1;return n.forEach((function(n){if(e.x&&(a=e.x.times.indexOf(n)),e.y&&(i=e.y.times.indexOf(n)),e.z&&(v=e.z.times.indexOf(n)),-1!==a){var t=e.x.values[a];r.push(t),o[0]=t}else r.push(o[0]);if(-1!==i){var c=e.y.values[i];r.push(c),o[1]=c}else r.push(o[1]);if(-1!==v){var s=e.z.values[v];r.push(s),o[2]=s}else r.push(o[2])})),r}},{key:"interpolateRotations",value:function(n){for(var e=1;e<n.values.length;e++){var t=n.values[e-1],o=n.values[e]-t,r=Math.abs(o);if(r>=180){for(var a=r/180,i=o/a,v=t+i,c=n.times[e-1],s=(n.times[e]-c)/a,l=c+s,u=[],f=[];l<n.times[e];)u.push(l),l+=s,f.push(v),v+=i;n.times=CN(n.times,e,u),n.values=CN(n.values,e,f)}}}}]),n}(),mN=function(){function n(){g(this,n)}return b(n,[{key:"getPrevNode",value:function(){return this.nodeStack[this.currentIndent-2]}},{key:"getCurrentNode",value:function(){return this.nodeStack[this.currentIndent-1]}},{key:"getCurrentProp",value:function(){return this.currentProp}},{key:"pushStack",value:function(n){this.nodeStack.push(n),this.currentIndent+=1}},{key:"popStack",value:function(){this.nodeStack.pop(),this.currentIndent-=1}},{key:"setCurrentProp",value:function(n,e){this.currentProp=n,this.currentPropName=e}},{key:"parse",value:function(n){this.currentIndent=0,this.allNodes=new xN,this.nodeStack=[],this.currentProp=[],this.currentPropName="";var e=this,t=n.split(/[\r\n]+/);return t.forEach((function(n,o){var r=n.match(/^[\s\t]*;/),a=n.match(/^[\s\t]*$/);if(!r&&!a){var i=n.match("^\\t{"+e.currentIndent+"}(\\w+):(.*){",""),v=n.match("^\\t{"+e.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),c=n.match("^\\t{"+(e.currentIndent-1)+"}}");i?e.parseNodeBegin(n,i):v?e.parseNodeProperty(n,v,t[++o]):c?e.popStack():n.match(/^[^\s\t}]/)&&e.parseNodePropertyContinued(n)}})),this.allNodes}},{key:"parseNodeBegin",value:function(n,e){var t=e[1].trim().replace(/^"/,"").replace(/"$/,""),o=e[2].split(",").map((function(n){return n.trim().replace(/^"/,"").replace(/"$/,"")})),r={name:t},a=this.parseNodeAttr(o),i=this.getCurrentNode();0===this.currentIndent?this.allNodes.add(t,r):t in i?("PoseNode"===t?i.PoseNode.push(r):void 0!==i[t].id&&(i[t]={},i[t][i[t].id]=i[t]),""!==a.id&&(i[t][a.id]=r)):"number"===typeof a.id?(i[t]={},i[t][a.id]=r):"Properties70"!==t&&(i[t]="PoseNode"===t?[r]:r),"number"===typeof a.id&&(r.id=a.id),""!==a.name&&(r.attrName=a.name),""!==a.type&&(r.attrType=a.type),this.pushStack(r)}},{key:"parseNodeAttr",value:function(n){var e=n[0];""!==n[0]&&(e=parseInt(n[0]),isNaN(e)&&(e=n[0]));var t="",o="";return n.length>1&&(t=n[1].replace(/^(\w+)::/,""),o=n[2]),{id:e,name:t,type:o}}},{key:"parseNodeProperty",value:function(n,e,t){var o=e[1].replace(/^"/,"").replace(/"$/,"").trim(),r=e[2].replace(/^"/,"").replace(/"$/,"").trim();"Content"===o&&","===r&&(r=t.replace(/"/g,"").replace(/,$/,"").trim());var a=this.getCurrentNode();if("Properties70"!==a.name){if("C"===o){var i=r.split(",").slice(1),v=parseInt(i[0]),c=parseInt(i[1]),s=r.split(",").slice(3);o="connections",function(n,e){for(var t=0,o=n.length,r=e.length;t<r;t++,o++)n[o]=e[t]}(r=[v,c],s=s.map((function(n){return n.trim().replace(/^"/,"")}))),void 0===a[o]&&(a[o]=[])}"Node"===o&&(a.id=r),o in a&&Array.isArray(a[o])?a[o].push(r):"a"!==o?a[o]=r:a.a=r,this.setCurrentProp(a,o),"a"===o&&","!==r.slice(-1)&&(a.a=kN(r))}else this.parseNodeSpecialProperty(n,o,r)}},{key:"parseNodePropertyContinued",value:function(n){var e=this.getCurrentNode();e.a+=n,","!==n.slice(-1)&&(e.a=kN(e.a))}},{key:"parseNodeSpecialProperty",value:function(n,e,t){var o=t.split('",').map((function(n){return n.trim().replace(/^\"/,"").replace(/\s/,"_")})),r=o[0],a=o[1],i=o[2],v=o[3],c=o[4];switch(a){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":c=parseFloat(c);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":c=kN(c)}this.getPrevNode()[r]={type:a,type2:i,flag:v,value:c},this.setCurrentProp(this.getPrevNode(),r)}}]),n}(),dN=function(){function n(){g(this,n)}return b(n,[{key:"parse",value:function(n){var e=new hN(n);e.skip(23);var t=e.getUint32();if(t<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+t);for(var o=new xN;!this.endOfContent(e);){var r=this.parseNode(e,t);null!==r&&o.add(r.name,r)}return o}},{key:"endOfContent",value:function(n){return n.size()%16===0?(n.getOffset()+160+16&-16)>=n.size():n.getOffset()+160+16>=n.size()}},{key:"parseNode",value:function(n,e){var t={},o=e>=7500?n.getUint64():n.getUint32(),r=e>=7500?n.getUint64():n.getUint32();e>=7500?n.getUint64():n.getUint32();var a=n.getUint8(),i=n.getString(a);if(0===o)return null;for(var v=[],c=0;c<r;c++)v.push(this.parseProperty(n));var s=v.length>0?v[0]:"",l=v.length>1?v[1]:"",u=v.length>2?v[2]:"";for(t.singleProperty=1===r&&n.getOffset()===o;o>n.getOffset();){var f=this.parseNode(n,e);null!==f&&this.parseSubNode(i,t,f)}return t.propertyList=v,"number"===typeof s&&(t.id=s),""!==l&&(t.attrName=l),""!==u&&(t.attrType=u),""!==i&&(t.name=i),t}},{key:"parseSubNode",value:function(n,e,t){if(!0===t.singleProperty){var o=t.propertyList[0];Array.isArray(o)?(e[t.name]=t,t.a=o):e[t.name]=o}else if("Connections"===n&&"C"===t.name){var r=[];t.propertyList.forEach((function(n,e){0!==e&&r.push(n)})),void 0===e.connections&&(e.connections=[]),e.connections.push(r)}else if("Properties70"===t.name){Object.keys(t).forEach((function(n){e[n]=t[n]}))}else if("Properties70"===n&&"P"===t.name){var a,i=t.propertyList[0],v=t.propertyList[1],c=t.propertyList[2],s=t.propertyList[3];0===i.indexOf("Lcl ")&&(i=i.replace("Lcl ","Lcl_")),0===v.indexOf("Lcl ")&&(v=v.replace("Lcl ","Lcl_")),a="Color"===v||"ColorRGB"===v||"Vector"===v||"Vector3D"===v||0===v.indexOf("Lcl_")?[t.propertyList[4],t.propertyList[5],t.propertyList[6]]:t.propertyList[4],e[i]={type:v,type2:c,flag:s,value:a}}else void 0===e[t.name]?"number"===typeof t.id?(e[t.name]={},e[t.name][t.id]=t):e[t.name]=t:"PoseNode"===t.name?(Array.isArray(e[t.name])||(e[t.name]=[e[t.name]]),e[t.name].push(t)):void 0===e[t.name][t.id]&&(e[t.name][t.id]=t)}},{key:"parseProperty",value:function(n){var e,t=n.getString(1);switch(t){case"C":return n.getBoolean();case"D":return n.getFloat64();case"F":return n.getFloat32();case"I":return n.getInt32();case"L":return n.getInt64();case"R":return e=n.getUint32(),n.getArrayBuffer(e);case"S":return e=n.getUint32(),n.getString(e);case"Y":return n.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":var o=n.getUint32(),r=n.getUint32(),a=n.getUint32();if(0===r)switch(t){case"b":case"c":return n.getBooleanArray(o);case"d":return n.getFloat64Array(o);case"f":return n.getFloat32Array(o);case"i":return n.getInt32Array(o);case"l":return n.getInt64Array(o)}var i=nN(new Uint8Array(n.getArrayBuffer(a))),v=new hN(i.buffer);switch(t){case"b":case"c":return v.getBooleanArray(o);case"d":return v.getFloat64Array(o);case"f":return v.getFloat32Array(o);case"i":return v.getInt32Array(o);case"l":return v.getInt64Array(o)}default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}]),n}(),hN=function(){function n(e,t){g(this,n),this.dv=new DataView(e),this.offset=0,this.littleEndian=void 0===t||t}return b(n,[{key:"getOffset",value:function(){return this.offset}},{key:"size",value:function(){return this.dv.buffer.byteLength}},{key:"skip",value:function(n){this.offset+=n}},{key:"getBoolean",value:function(){return 1===(1&this.getUint8())}},{key:"getBooleanArray",value:function(n){for(var e=[],t=0;t<n;t++)e.push(this.getBoolean());return e}},{key:"getUint8",value:function(){var n=this.dv.getUint8(this.offset);return this.offset+=1,n}},{key:"getInt16",value:function(){var n=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,n}},{key:"getInt32",value:function(){var n=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,n}},{key:"getInt32Array",value:function(n){for(var e=[],t=0;t<n;t++)e.push(this.getInt32());return e}},{key:"getUint32",value:function(){var n=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,n}},{key:"getInt64",value:function(){var n,e;return this.littleEndian?(n=this.getUint32(),e=this.getUint32()):(e=this.getUint32(),n=this.getUint32()),2147483648&e?(e=4294967295&~e,4294967295===(n=4294967295&~n)&&(e=e+1&4294967295),-(4294967296*e+(n=n+1&4294967295))):4294967296*e+n}},{key:"getInt64Array",value:function(n){for(var e=[],t=0;t<n;t++)e.push(this.getInt64());return e}},{key:"getUint64",value:function(){var n,e;return this.littleEndian?(n=this.getUint32(),e=this.getUint32()):(e=this.getUint32(),n=this.getUint32()),4294967296*e+n}},{key:"getFloat32",value:function(){var n=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,n}},{key:"getFloat32Array",value:function(n){for(var e=[],t=0;t<n;t++)e.push(this.getFloat32());return e}},{key:"getFloat64",value:function(){var n=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,n}},{key:"getFloat64Array",value:function(n){for(var e=[],t=0;t<n;t++)e.push(this.getFloat64());return e}},{key:"getArrayBuffer",value:function(n){var e=this.dv.buffer.slice(this.offset,this.offset+n);return this.offset+=n,e}},{key:"getString",value:function(n){for(var e=[],t=0;t<n;t++)e[t]=this.getUint8();var o=e.indexOf(0);return o>=0&&(e=e.slice(0,o)),Rf.decodeText(new Uint8Array(e))}}]),n}(),xN=function(){function n(){g(this,n)}return b(n,[{key:"add",value:function(n,e){this[n]=e}}]),n}();function gN(n){var e=n.match(/FBXVersion: (\d+)/);if(e)return parseInt(e[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function yN(n){return n/46186158e3}var bN=[];function UN(n,e,t,o){var r;switch(o.mappingType){case"ByPolygonVertex":r=n;break;case"ByPolygon":r=e;break;case"ByVertice":r=t;break;case"AllSame":r=o.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+o.mappingType)}"IndexToDirect"===o.referenceType&&(r=o.indices[r]);var a=r*o.dataSize,i=a+o.dataSize;return function(n,e,t,o){for(var r=t,a=0;r<o;r++,a++)n[a]=e[r];return n}(bN,o.buffer,a,i)}var _N=new wr,wN=new Oo;function SN(n){var e=new pr,t=new pr,o=new pr,r=new pr,a=new pr,i=new pr,v=new pr,c=new pr,s=new pr,l=new pr,u=new pr,f=new pr,p=n.inheritType?n.inheritType:0;if(n.translation&&e.setPosition(wN.fromArray(n.translation)),n.preRotation){var m=n.preRotation.map(ro.degToRad);m.push(n.eulerOrder),t.makeRotationFromEuler(_N.fromArray(m))}if(n.rotation){var d=n.rotation.map(ro.degToRad);d.push(n.eulerOrder),o.makeRotationFromEuler(_N.fromArray(d))}if(n.postRotation){var h=n.postRotation.map(ro.degToRad);h.push(n.eulerOrder),r.makeRotationFromEuler(_N.fromArray(h)),r.invert()}n.scale&&a.scale(wN.fromArray(n.scale)),n.scalingOffset&&v.setPosition(wN.fromArray(n.scalingOffset)),n.scalingPivot&&i.setPosition(wN.fromArray(n.scalingPivot)),n.rotationOffset&&c.setPosition(wN.fromArray(n.rotationOffset)),n.rotationPivot&&s.setPosition(wN.fromArray(n.rotationPivot)),n.parentMatrixWorld&&(u.copy(n.parentMatrix),l.copy(n.parentMatrixWorld));var x=t.clone().multiply(o).multiply(r),g=new pr;g.extractRotation(l);var y=new pr;y.copyPosition(l);var b=y.clone().invert().multiply(l),U=g.clone().invert().multiply(b),_=a,w=new pr;if(0===p)w.copy(g).multiply(x).multiply(U).multiply(_);else if(1===p)w.copy(g).multiply(U).multiply(x).multiply(_);else{var S=(new pr).scale((new Oo).setFromMatrixScale(u)).clone().invert(),M=U.clone().multiply(S);w.copy(g).multiply(x).multiply(M).multiply(_)}var k=s.clone().invert(),z=i.clone().invert(),C=e.clone().multiply(c).multiply(s).multiply(t).multiply(o).multiply(r).multiply(k).multiply(v).multiply(i).multiply(a).multiply(z),T=(new pr).copyPosition(C),R=l.clone().multiply(T);return f.copyPosition(R),(C=f.clone().multiply(w)).premultiply(l.invert()),C}function MN(n){var e=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return 6===(n=n||0)?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),e[0]):e[n]}function kN(n){return n.split(",").map((function(n){return parseFloat(n)}))}function zN(n,e,t){return void 0===e&&(e=0),void 0===t&&(t=n.byteLength),Rf.decodeText(new Uint8Array(n,e,t))}function CN(n,e,t){return n.slice(0,e).concat(t).concat(n.slice(e))}function TN(n){return qd(lN,n)}TN.preload=function(n){return qd.preload(lN,n)},TN.clear=function(n){return qd.clear(lN,n)};var RN=function(n){return n===Object(n)&&!Array.isArray(n)&&"function"!==typeof n};function DN(n,e){var t=Gd((function(n){return n.gl})),o=qd(sf,RN(n)?Object.values(n):n);if((0,Am.useLayoutEffect)((function(){null==e||e(o)}),[e]),(0,Am.useEffect)((function(){(Array.isArray(o)?o:[o]).forEach(t.initTexture)}),[t,o]),RN(n)){var r=Object.keys(n),a={};return r.forEach((function(n){return Object.assign(a,s({},n,o[r.indexOf(n)]))})),a}return o}function PN(n){var e=TN("./Models/warehouse2/source/WareHouse.fbx"),t=DN("./Models/warehouse2/textures/Bake.jpg"),o=DN("./Models/warehouse2/textures/Tx.jpg");t.flipY=!0,o.flipY=!1;new Su;var r=new bu({map:t,aoMap:o});return(0,Wh.jsxs)("group",u(u({},n),{},{dispose:null,children:[(0,Wh.jsxs)("group",{position:[0,-27,80],children:[(0,Wh.jsx)("mesh",{geometry:e.children[0].children[1].geometry,material:r}),(0,Wh.jsx)("mesh",{geometry:e.children[0].children[0].children[1].geometry,material:r}),(0,Wh.jsx)("mesh",{geometry:e.children[0].children[0].children[0].children[0].geometry,material:r}),(0,Wh.jsx)("mesh",{geometry:e.children[1].geometry,material:r}),(0,Wh.jsx)("mesh",{geometry:e.children[2].geometry,material:r})]}),(0,Wh.jsx)("ambientLight",{intensity:.2}),(0,Wh.jsx)("rectAreaLight",{position:[0,0,-80],intensity:30})]}))}function FN(){var n=Nh((function(n){return n.songPlaying})),e=Nh((function(n){return n.getSongTime}));console.log(n);var t=(0,Am.useRef)(),o=(0,Am.useRef)();return(0,Am.useEffect)((function(){var r=Rd((function(){var r,a=0,i=e();!0===n&&(a=0),a=Date.now()-i,a/=1e3,t.current&&a>0&&a<=137&&(t.current.textContent=(r=a,Math.floor(r%3600/60).toString().padStart(2,"0")+":"+Math.floor(r%60).toString().padStart(2,"0")),o.current.style.width=a/137*100+"%")}),Fd);return function(){r()}}),[]),(0,Wh.jsx)(Wh.Fragment,{children:(0,Wh.jsxs)("div",{className:"interface",children:[(0,Wh.jsx)("div",{className:"song",children:"song: new adventure"}),(0,Wh.jsx)("div",{className:"artist",children:"artist: matrika "}),(0,Wh.jsx)("div",{id:"Progress_Status",children:(0,Wh.jsx)("div",{className:"progress",ref:o})}),(0,Wh.jsx)("div",{className:"time",ref:t,children:"00:00"})]})})}function jN(){var n=Nh((function(n){return n.currentShader})),e=Nh((function(n){return n.setCurrentShader})),t=Nh((function(n){return n.information})),o=Nh((function(n){return n.activateInformation})),r=Nh((function(n){return n.deactivateInformation}));document.addEventListener("wheel",(function(n){"number"===document.activeElement.type&&document.activeElement.blur()}));return(0,Wh.jsxs)(Wh.Fragment,{children:[(0,Wh.jsxs)("div",{className:"nav",children:[!t&&(0,Wh.jsx)("button",{className:"back",onClick:function(){n>1&&e(n-1)},children:"back"}),!t&&(0,Wh.jsx)("button",{className:"next",onClick:function(){n<646&&e(n+1)},children:"next"}),(0,Wh.jsx)("h1",{className:"current",children:n})]}),(0,Wh.jsxs)("form",{id:"myForm",className:"form",onSubmit:function(n){n.preventDefault();var t=n.target,o=new FormData(t),r=Object.fromEntries(o.entries()),a=parseInt(r.shader);!Number.isNaN(a)&&a>0&&a<=646&&e(a),document.getElementById("myForm").reset()},children:[!t&&(0,Wh.jsx)("input",{type:"number",name:"shader",placeholder:"Enter Shader Number",className:"input"}),!t&&(0,Wh.jsx)("input",{type:"submit",value:"Submit",className:"submit"})]}),(0,Wh.jsx)("div",{className:"icon",onClick:function(){!1===t&&(document.getElementsByClassName("webgl")[0].style.opacity="0.15",document.getElementsByClassName("nav")[0].style.opacity="0.025",document.getElementsByClassName("form")[0].style.opacity="0.025",document.getElementsByClassName("icon")[0].style.opacity="0.025",document.getElementsByClassName("random")[0].style.opacity="0.025",o())},children:(0,Wh.jsx)("i",{className:"fa-solid fa-info"})}),(0,Wh.jsx)("div",{className:"random",onClick:function(){e(Math.floor(646*Math.random())+1)},children:!t&&(0,Wh.jsx)("i",{className:"fa-solid fa-shuffle"})}),646===n&&(0,Wh.jsx)(FN,{}),console.log(n),t&&(0,Wh.jsxs)("div",{className:"container",children:[(0,Wh.jsx)("div",{className:"close",onClick:function(){document.getElementsByClassName("webgl")[0].style.opacity="1.0",document.getElementsByClassName("nav")[0].style.opacity="1.0",document.getElementsByClassName("form")[0].style.opacity="1.0",document.getElementsByClassName("icon")[0].style.opacity="1.0",document.getElementsByClassName("random")[0].style.opacity="1.0",r()},children:(0,Wh.jsx)("i",{className:"fa-solid fa-x"})}),(0,Wh.jsx)("h1",{className:"header",children:"Welcome to Shader Daily!"}),(0,Wh.jsxs)("p",{className:"text",children:["This website is a result of my personal journey towards learning the magic of Shaders. A shader is a computer program that uses a variety of specialized functions and algorithms to calculate the color value of each pixel in a rendered result using the graphics processing unit (GPU). Shaders are used in a variety of industries ranging from cinema to video games. The programming language used in shaders depends on the target environment. This target environment uses GLSL (Graphics Library Shader Language). This shader program requires a vertex shader and a fragment shader. The vertex shader is not manipulated in this website and kept standard for all results. The fragment shader is modified for each result. The rendering result and experience is achieved using Three.js and React-Three-Fiber. ",(0,Wh.jsx)("br",{})," ",(0,Wh.jsx)("br",{})," Thank you for visiting! ",(0,Wh.jsx)("br",{})," ",(0,Wh.jsx)("br",{}),"Nate Argaw"]}),(0,Wh.jsxs)("div",{className:"contact",children:[(0,Wh.jsxs)("div",{className:"mail",onClick:function(){var n="nateargaw@gmail.com";navigator.clipboard.writeText(n),alert("Copied email: "+n)},children:[(0,Wh.jsx)("a",{href:"mailto: nateargaw@gmail.com"}),(0,Wh.jsx)("i",{className:"fa-solid fa-envelope"})]}),(0,Wh.jsx)("div",{className:"twitter",children:(0,Wh.jsx)("a",{href:"https://twitter.com/nate_dev_",children:(0,Wh.jsx)("i",{className:"fa-brands fa-x-twitter"})})}),(0,Wh.jsx)("div",{className:"linkedin",children:(0,Wh.jsx)("a",{href:"https://www.linkedin.com/in/nateargaw/",children:(0,Wh.jsx)("i",{className:"fa-brands fa-linkedin-in"})})}),(0,Wh.jsx)("div",{className:"instagram",children:(0,Wh.jsx)("a",{href:"https://www.instagram.com/shaderdaily/",children:(0,Wh.jsx)("i",{className:"fa-brands fa-instagram"})})})]})]})]})}DN.preload=function(n){return qd.preload(sf,n)},DN.clear=function(n){return qd.clear(sf,n)},(0,jh.s)(document.querySelector("#root")).render((0,Wh.jsxs)(Am.StrictMode,{children:[(0,Wh.jsxs)(Fh,{className:"webgl",camera:{fov:50,aspect:window.innerWidth/window.innerHeight,near:.01,far:1e3,position:[0,0,5]},children:[(0,Wh.jsx)(MG,{}),(0,Wh.jsx)(PN,{})]}),(0,Wh.jsx)(jN,{})]}))}()}();
//# sourceMappingURL=main.d872fcd6.js.map